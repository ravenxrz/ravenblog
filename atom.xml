<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raven&#39;s Blog</title>
  
  <subtitle>zhang.xingrui@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ravenxrz.ink/"/>
  <updated>2020-10-12T09:38:21.450Z</updated>
  <id>https://www.ravenxrz.ink/</id>
  
  <author>
    <name>Raven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leveldb源码阅读记录-MemTableIterator</title>
    <link href="https://www.ravenxrz.ink/archives/51540516.html"/>
    <id>https://www.ravenxrz.ink/archives/51540516.html</id>
    <published>2020-10-12T10:36:12.000Z</published>
    <updated>2020-10-12T09:38:21.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MemTableIterator"><a href="#MemTableIterator" class="headerlink" title="MemTableIterator"></a>MemTableIterator</h2><p>读这篇文章前，请先阅读 skiplist实现和memtable两篇文章。</p><p>MemTableIteraotr是用来遍历MemTable的Iterator。</p><h2 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h2><p>下面是它的代码，代码很短：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTableIterator</span><span class="params">(MemTable::Table* table)</span> : <span class="title">iter_</span><span class="params">(table)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  MemTableIterator(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTableIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTableIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~MemTableIterator() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_.Valid(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> <span class="keyword">override</span> </span>&#123; iter_.Seek(EncodeKey(&amp;tmp_, k)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.SeekToFirst(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.SeekToLast(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.Next(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_.Prev(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    Slice key_slice = GetLengthPrefixedSlice(iter_.key());</span><br><span class="line">    <span class="keyword">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::OK(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemTable::Table::Iterator iter_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> tmp_;  <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，MemTableIterator是对MemTable::Table::Iterator的简单封装，也就是说，真正的iterator是MemTable::Table::Iterator，</p><p>MemTable::Table其实是SkipList的别名，所以最终就是对SkipList的Iterator的封装。所以要求对MemTable的SkipList实现有所了解。</p><p>虽然MemTableIterator只是对SkipList的Iter的薄薄封装，但这里有两个地方特殊，那就是key和value。</p><p>如果你之前阅读了本系列的ksiplist文章， 那应该知道skiplist中只有key没有value， key里面存放的东西就是本文开篇中给出的图。它既包含了key也包含了value。下图是iter中的key的布局：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><h2 id="2-key"><a href="#2-key" class="headerlink" title="2. key"></a>2. key</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = data;</span><br><span class="line">  p = GetVarint32Ptr(p, p + <span class="number">5</span>, &amp;len);  <span class="comment">// +5: we assume "p" is not corrupted</span></span><br><span class="line">  <span class="keyword">return</span> Slice(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取internal key 的长度，然后得到Internal key。</p><h2 id="3-value"><a href="#3-value" class="headerlink" title="3. value"></a>3. value</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  Slice key_slice = GetLengthPrefixedSlice(iter_.key());</span><br><span class="line">  <span class="keyword">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取internal key后，给第二个GetLengthPrefixedSlice传入的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_slice.data() + key_slice.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p>是value size字段的首地址，所以这里返回的是实际的value。</p><p><strong>到这里我们可以补充一条内容，MemTable中存放的key是整个MemTable key（包括internel key size 和 internal key), 但是对外部呈现的却是一个internal key。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MemTableIterator&quot;&gt;&lt;a href=&quot;#MemTableIterator&quot; class=&quot;headerlink&quot; title=&quot;MemTableIterator&quot;&gt;&lt;/a&gt;MemTableIterator&lt;/h2&gt;&lt;p&gt;读这篇文章前，请先阅读 sk
      
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Iterator-OverView</title>
    <link href="https://www.ravenxrz.ink/archives/2b8370d3.html"/>
    <id>https://www.ravenxrz.ink/archives/2b8370d3.html</id>
    <published>2020-10-12T10:31:40.000Z</published>
    <updated>2020-10-12T09:35:36.680Z</updated>
    
    <content type="html"><![CDATA[<p>通过之前对LevelDB的整体流程，数据存储以及元信息管理的介绍，我们已经基本完整的了解了LevelDB。从这篇文章开始，我们将重心转移到Iterator上，这是一种统一的访问底层数据的设计模式，用户不用关心底层数据是如何存储，只需使用Iterator提供的几种操作接口，即可访问。本文是leveldb众多iterator的一个总览，后文再对各个Iterator单独分析。</p><p>本文转载自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZmUyNGE3NzAwMmE=" title="https://www.jianshu.com/p/7fe24a77002a">https://www.jianshu.com/p/7fe24a77002a<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>正如<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>中介绍的，LevelDB各个组件用不同的格式进行数据存取。在LevelDB内部外部，各个不同阶段又不可避免的需要从不同的视角遍历这些数据。如果每一个层次的数据遍历都需要详细的关心全部数据存储格式，无疑将使得整个过程变得无比的冗余复杂。Iterator的出现正式为了解决这个问题，Iterator在各个层次上，向上层实现提供了：</p><p><strong>无须了解下层存储细节的情况下，通过统一接口对下层数据进行遍历的能力。</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>Iterator用确定的遍历接口将上层需求和下层实现解耦和。熟悉STL的同学一定不会陌生Iterator的使用方式，这里LevelDB的Iterator接口包括：</p><ul><li>Seek到某一位置：Seek，SeekToFirst，SeekToLast；</li><li>访问前驱后继：Next，Prev；</li><li>判断当前位置是否有效：Valid；</li><li>获取当前位置数据信息：key，value，status；</li><li>可以注册多个Cleanup方法，当Iterator析构前做一些清理操作。</li></ul><h3 id="Iterator虚基类定义"><a href="#Iterator虚基类定义" class="headerlink" title="Iterator虚基类定义"></a>Iterator虚基类定义</h3><p>下面给出，Iterator虚基类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Iterator();</span><br><span class="line"></span><br><span class="line">  Iterator(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Iterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~Iterator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An iterator is either positioned at a key/value pair, or</span></span><br><span class="line">  <span class="comment">// not valid.  This method returns true iff the iterator is valid.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first key in the source.  The iterator is Valid()</span></span><br><span class="line">  <span class="comment">// after this call iff the source is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the last key in the source.  The iterator is</span></span><br><span class="line">  <span class="comment">// Valid() after this call iff the source is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first key in the source that is at or past target.</span></span><br><span class="line">  <span class="comment">// The iterator is Valid() after this call iff the source contains</span></span><br><span class="line">  <span class="comment">// an entry that comes at or past target.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Moves to the next entry in the source.  After this call, Valid() is</span></span><br><span class="line">  <span class="comment">// true iff the iterator was not positioned at the last entry in the source.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Moves to the previous entry in the source.  After this call, Valid() is</span></span><br><span class="line">  <span class="comment">// true iff the iterator was not positioned at the first entry in source.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the key for the current entry.  The underlying storage for</span></span><br><span class="line">  <span class="comment">// the returned slice is valid only until the next modification of</span></span><br><span class="line">  <span class="comment">// the iterator.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the value for the current entry.  The underlying storage for</span></span><br><span class="line">  <span class="comment">// the returned slice is valid only until the next modification of</span></span><br><span class="line">  <span class="comment">// the iterator.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If an error has occurred, return it.  Else return an ok status.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clients are allowed to register function/arg1/arg2 triples that</span></span><br><span class="line">  <span class="comment">// will be invoked when this iterator is destroyed.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note that unlike all of the preceding methods, this method is</span></span><br><span class="line">  <span class="comment">// not abstract and therefore clients should not override it.</span></span><br><span class="line">  <span class="keyword">using</span> CleanupFunction = <span class="keyword">void</span> (*)(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterCleanup</span><span class="params">(CleanupFunction function, <span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Cleanup functions are stored in a single-linked list.</span></span><br><span class="line">  <span class="comment">// The list's head node is inlined in the iterator.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CleanupNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// True if the node is not used. Only head nodes might be unused.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> function == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="comment">// Invokes the cleanup function.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assert(function != <span class="literal">nullptr</span>);</span><br><span class="line">      (*function)(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The head node is used if the function pointer is not null.</span></span><br><span class="line">    CleanupFunction function;</span><br><span class="line">    <span class="keyword">void</span>* arg1;</span><br><span class="line">    <span class="keyword">void</span>* arg2;</span><br><span class="line">    CleanupNode* next;</span><br><span class="line">  &#125;;</span><br><span class="line">  CleanupNode cleanup_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到Iterator定义了一个迭代器的通用接口，同时还包含了一个cleanup链表，可以向iterator注册多个cleanup函数，这些cleanup函数会在iterator析构时被调用。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><p>LevelDB大量使用了各种Iterator，根据Iterator的实现和层次，我们将其分为三种类型：</p><ul><li>基本Iterator：最原子的Iterator，针对相应的数据结构实现Iterator接口；</li><li>组合Iterator：通过各种方式将多个基本Iterator组合起来，向上层提供一致的Iterator接口。</li><li>功能Iterator：某种或多种组合Iterator的联合使用，附加一些必要的信息，实现某个过程中的遍历操作。</li></ul><h2 id="基本Iterator"><a href="#基本Iterator" class="headerlink" title="基本Iterator"></a><strong>基本Iterator</strong></h2><p>LevelDB中包括三种基本Iterator，他们分别针对Memtable，Block以及Version中的文件索引格式，实现了最原子的Iterator：</p><h4 id="1，MemTableIterator"><a href="#1，MemTableIterator" class="headerlink" title="1，MemTableIterator"></a><strong>1，MemTableIterator</strong></h4><p>在Memtable Skiplist的格式上的Iterator实现。Memtable格式见<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>。</p><h4 id="2，Block-Iter"><a href="#2，Block-Iter" class="headerlink" title="2，Block::Iter"></a><strong>2，Block::Iter</strong></h4><p>针对SST文件Block存储格式的Iterator实现。遍历的过程中解析重启点，拼接key的共享部分和特有部分，获取对应的value值。Block详细格式见<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>。</p><h4 id="3，Version-LevelFileNumIterator"><a href="#3，Version-LevelFileNumIterator" class="headerlink" title="3，Version::LevelFileNumIterator"></a><strong>3，Version::LevelFileNumIterator</strong></h4><p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制<i class="fa fa-external-link"></i></span>中介绍了Version中记录了当前所有文件按层次划分的二维数组。其中Level1层之上的文件由于相互之间没有交集且有序，可以利用文件信息中的最大最小Key来进行二分查找。LevelFileNumIterator就是利用这个特点实现的对文件元信息进行遍历的Iterator。其中每个项记录了当前文件最大key到文件元信息的映射关系。这里的文件元信息包含文件号及文件长度。</p><h2 id="组合Iterator"><a href="#组合Iterator" class="headerlink" title="组合Iterator"></a><strong>组合Iterator</strong></h2><p>组合Iterator由上述多个基本Iterator或组合Iterator组合而成，LevelDB中包含两种组合Iterator</p><h4 id="1，TwoLevelIterator"><a href="#1，TwoLevelIterator" class="headerlink" title="1，TwoLevelIterator"></a><strong>1，TwoLevelIterator</strong></h4><p>TwoLevelIterator实现逻辑上有层次关系的数据的遍历操作。组合了<strong>index iterator</strong>和<strong>data iterator</strong>两层迭代器，其中index iterator记录从数据key值到data iterator的映射，而data iterator则负责真正数据key到value的映射。生成TwoLevelIterator时，需要提供index Iterator及BlockFunction函数，其中BlockFunction实现了index iterator value值的反序列化以及对应的data iterator的生成。</p><h4 id="2，MergingIterator"><a href="#2，MergingIterator" class="headerlink" title="2，MergingIterator"></a><strong>2，MergingIterator</strong></h4><p>通过MergingIterator可以实现多个有序数据集合的归并操作。其中包含多个<strong>child iterator</strong>组成的集合。对MergingIterator的遍历会有序的遍历其child iterator中的每个元素。</p><h2 id="功能Iterator"><a href="#功能Iterator" class="headerlink" title="功能Iterator"></a><strong>功能Iterator</strong></h2><p>为了实现不同场景下不同层次的数据遍历操作，可以联合一种或多种组合Iterator，这里称为功能Iterator，按其所负责的数据层次由下自上进行介绍：</p><h4 id="1，Table-Iterator"><a href="#1，Table-Iterator" class="headerlink" title="1，Table::Iterator"></a><strong>1，Table::Iterator</strong></h4><p>对SST文件的遍历，通过<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMTcvbGV2ZWxkYi1kYXRhLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/17/leveldb-data.html">庖丁解LevelDB之数据存储<i class="fa fa-external-link"></i></span>可知，这里有明显的层级关系，可以利用上面介绍的TwoLevelIterator，其<strong>index iterator</strong>为Index Block的Block::Iter，<strong>data iterator</strong>为Data Block的Block::Iter</p><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-6993a1249b141f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/415/format/webp" alt=""></p><p>Table::Iterator</p><h4 id="2，Compaction过程Iterator"><a href="#2，Compaction过程Iterator" class="headerlink" title="2，Compaction过程Iterator"></a><strong>2，Compaction过程Iterator</strong></h4><p>Compaction过程中需要对多个文件进行归并操作，并将结果输出到新的下层文件。LevelDB用MergingIterator来实现这个过程，其<strong>clild iterator</strong>包括<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制<i class="fa fa-external-link"></i></span>中提到的要Compaction的多个文件对应的Iterator：</p><ul><li><p>如果有Level0文件，则包含所有level0文件的Table::Iterator</p></li><li><p>其他Level文件，包含文件索引的TwoLevelIterator，由Version::LevelFileNumIterato作为index iterator，Table::Iterator作为data iterator</p></li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-2b69b6b6c162fa70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/998/format/webp" alt=""></p><p>Compaction过程Iterator</p><h4 id="3，NewInternalIterator"><a href="#3，NewInternalIterator" class="headerlink" title="3，NewInternalIterator"></a><strong>3，NewInternalIterator</strong></h4><p>LevelDB作为整体同样通过Iterator向外部用户提供遍历全部数据的能力。这里使用MergingIterator将Memtable，Immutable memtable及各层SST文件的Iterator归并起来，使得外部使用者不用关心具体的内部实现而有序的循环LevelDB内部的数据，LevelDB首先实现了NewInternalIterator：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/530927-cacadb66612c54d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p>在NewInternalIterator的基础上，LevelDB又封装了DBIter来处理快照，过滤已删除key。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p>Source Code：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9sZXZlbGRi" title="https://link.jianshu.com?t=https://github.com/google/leveldb">https://github.com/google/leveldb<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之概览: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMDcvbGV2ZWxkYi1zdW1tYXJ5Lmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/07/leveldb-summary.html">http://catkang.github.io/2017/01/07/leveldb-summary.html<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之数据管理: <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDEvMDcvbGV2ZWxkYi1zdW1tYXJ5Lmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/01/07/leveldb-summary.html">http://catkang.github.io/2017/01/07/leveldb-summary.html<i class="fa fa-external-link"></i></span></p><p>庖丁解LevelDB之版本控制：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmppYW5zaHUuY29tP3Q9aHR0cDovL2NhdGthbmcuZ2l0aHViLmlvLzIwMTcvMDIvMDMvbGV2ZWxkYi12ZXJzaW9uLmh0bWw=" title="https://link.jianshu.com?t=http://catkang.github.io/2017/02/03/leveldb-version.html">http://catkang.github.io/2017/02/03/leveldb-version.html<i class="fa fa-external-link"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过之前对LevelDB的整体流程，数据存储以及元信息管理的介绍，我们已经基本完整的了解了LevelDB。从这篇文章开始，我们将重心转移到Iterator上，这是一种统一的访问底层数据的设计模式，用户不用关心底层数据是如何存储，只需使用Iterator提供的几种操作接口，即可访问。本文是leveldb众多iterator的一个总览，后文再对各个Iterator单独分析。&lt;/p&gt;
&lt;p&gt;本文转载自：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83ZmUyNGE3NzAwMmE=&quot; title=&quot;https://www.jianshu.com/p/7fe24a77002a&quot;&gt;https://www.jianshu.com/p/7fe24a77002a&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Cache</title>
    <link href="https://www.ravenxrz.ink/archives/ce22f5e9.html"/>
    <id>https://www.ravenxrz.ink/archives/ce22f5e9.html</id>
    <published>2020-10-12T10:22:00.000Z</published>
    <updated>2020-10-12T09:30:53.621Z</updated>
    
    <content type="html"><![CDATA[<p>leveldb是一种对写优化的kv存储系统，读性能有所下降，为了充分利用局部性原理，提高读性能，leveldb自己也设计了一个Cache结构。内部采用LRU替换策略。</p><a id="more"></a><p>leveldb中的cache主要包含以下类：</p><ul><li>LRUHandle – 数据节点</li><li>HandleTable – HashTable</li><li>LRUCache</li><li>ShardedLRUCache</li></ul><p>事实上到了第三个数据结构LRUCache，LRU的缓存管理数据结构已经实现了，之所以引入第四个数据结构，就是因为减少竞争。因为多线程访问需要加锁，为了减少竞争，提升效率，ShardedLRUCache内部有<strong>16个LRUCach</strong>e，查找key的时候，先计算属于哪一个LRUCache，然后在相应的LRUCache中上锁查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;  </span><br><span class="line"> <span class="keyword">private</span>:  </span><br><span class="line">  LRUCache shard_[kNumShards];  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是什么高深的思路，这种减少竞争的策略非常常见。因此，读懂缓存管理策略的关键在前三个数据结构。</p><p>LevelDB的Cache管理，维护有2个双向链表和一个哈希表。哈希表是非常容易理解的。如何确定一个key值到底存不存在，如果存在如何快速获取key值对应的value值。我们都学过数据结构，这活，哈希表是比较适合的。</p><p>注意，我们都知道，hash表存在一个重要的问题，就是碰撞，有可能多个不同的键值hash之后值相同，解决碰撞的一个重要思路是链表，将hash之后计算的key相同的元素链入同一个表头对应的链表。</p><p>可是我们并不满意这种速度，LevelDB做了进一步的优化，即及时扩大hash桶的个数，尽可能地不会发生碰撞。因此LevelDB自己实现了一个hash表，即HandleTable数据结构。</p><p>说句题外话，我不太喜欢数据结构的命名方式，比如HandleTable，命名就是个HashTable，如果出现Hash会好理解很多。这个名字还自罢了，LRUHandle这个名字更是让人摸不到头脑，明明就是一个数据节点，如果名字中出现Node，整个代码都会好理解很多。好了吐槽结束，看下HandleTable的数据结构：</p><h2 id="1-HandleTable"><a href="#1-HandleTable" class="headerlink" title="1. HandleTable"></a>1. HandleTable</h2><p>HandleTable在本质上就是一个HashTable，只是leveldb做了优化，通过尽早的拓展桶，来达到减少碰撞的目的。</p><p>成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_;<span class="comment">// buckets个数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;  <span class="comment">// 当前插入的elem个数</span></span><br><span class="line">  LRUHandle** list_;<span class="comment">// 二级指针，每个一级指针指向一个桶</span></span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;<span class="comment">// 替换操作</span></span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;<span class="comment">// 尽可能保证一个bucket只有一个elem</span></span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      Resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert函数首先在当前hashtable中尝试找到与插入key具有相同key的entry，即旧entry。 如果存在旧entry，则将旧的覆盖为新的节点。如果不存在旧的entry，则添加一个新的节点。同时可能需要resize hash， resize的条件为“当前插入的节点数比hashtable 的 bucket数大”，这样做的目的是尽量保证每个bucket下只有一个entry，这样search时间能够保证在O(1)。</p><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;<span class="comment">// 保证新容量是4的整数倍</span></span><br><span class="line">   <span class="keyword">while</span> (new_length &lt; elems_) &#123;<span class="comment">// 2倍扩容</span></span><br><span class="line">     new_length *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 新hashtable</span></span><br><span class="line">   LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">   <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">   <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 移动旧hashtable中的元素到新hashtable</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">     LRUHandle* h = list_[i];</span><br><span class="line">     <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">       <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line"><span class="comment">// 下面3行代码的结果是，如果旧hashtable的一个bucket的多个node，都重新链接到了这个新hashtable的同一个bucket，则这些node将会反序连接</span></span><br><span class="line">       LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">       h-&gt;next_hash = *ptr;</span><br><span class="line">       *ptr = h;</span><br><span class="line">       h = next;</span><br><span class="line">       count++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   assert(elems_ == count);</span><br><span class="line">    <span class="comment">// 删除旧表</span></span><br><span class="line">   <span class="keyword">delete</span>[] list_;</span><br><span class="line">   list_ = new_list;</span><br><span class="line">   length_ = new_length;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 23 页.png" style="zoom:33%;" /><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(key, hash);</span><br><span class="line">  LRUHandle* result = *ptr;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *ptr = result-&gt;next_hash;<span class="comment">// remove掉当前节点，并指向下一个节点</span></span><br><span class="line">    --elems_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a pointer to slot that points to a cache entry that</span></span><br><span class="line"><span class="comment">// matches key/hash.  If there is no such cache entry, return a</span></span><br><span class="line"><span class="comment">// pointer to the trailing slot in the corresponding linked list.</span></span><br><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];<span class="comment">// 二级指针</span></span><br><span class="line">  <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里remove的entry并没有free掉。entry的free在后文的LRUCache中。</p><img data-src="https://pic.downk.cc/item/5f8421811cd1bbb86be7cd0d.png" style="zoom:33%;" /><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>leveldb的hashtable其实就是一个数组+链表的hashtable，只不过rehash操作做了优化，从而加快search的效率。</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 3 页.png" style="zoom:50%;" /><h2 id="2-LRUHandle"><a href="#2-LRUHandle" class="headerlink" title="2. LRUHandle"></a>2. LRUHandle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;<span class="comment">// 双链表的next</span></span><br><span class="line">  LRUHandle* prev;<span class="comment">// 双链表的prev</span></span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present. 引用计数</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key, ！！ 占位符，这里放在结构体的最后且只有一个字节是有目的的，后面说到</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    assert(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Slice(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRUHandle表示一个cache节点。其中next_hash字段用在hashtable中，表明相同bucekt下的下一个节点。</p><h2 id="3-LRUCache"><a href="#3-LRUCache" class="headerlink" title="3. LRUCache"></a>3. LRUCache</h2><h3 id="总layout："><a href="#总layout：" class="headerlink" title="总layout："></a>总layout：</h3><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 4 页.png" style="zoom:50%;" /><p>HandleTable是用来找到某个cache entry的。但是无法实现LRU算法，现在来说一下实际的LRUCache。在LRUCache的实现里维护了两个链表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy head of LRU list.</span></span><br><span class="line"><span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line"><span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;<span class="comment">// 冷数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy head of in-use list.</span></span><br><span class="line"><span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line"><span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;<span class="comment">// 热数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>; <span class="comment">// 之前讲过</span></span><br></pre></td></tr></table></figure><p>注意在lru_链表中， lru.prev代表最新entry，lru.next代表最旧entry。</p><p>一个cache entry在上述两条链中的其中一个，通过 Ref() and Unref()调用，一个cache entry在两条链表之间move。</p><h3 id="1-Ref"><a href="#1-Ref" class="headerlink" title="1. Ref"></a>1. Ref</h3><p>Ref将一个cache 节点，从lru_链表插入到in_user_链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    LRU_Append(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make "e" newest entry by inserting just before *list</span></span><br><span class="line">  <span class="comment">// 插入到最新位置,list head处</span></span><br><span class="line">  e-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">  e-&gt;prev = <span class="built_in">list</span>-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-UnRef"><a href="#2-UnRef" class="headerlink" title="2. UnRef"></a>2. UnRef</h3><p>如果client不再引用一条cache entry， 则会进行UnRef，当一个cache ref=0时，则删除这个entry，当cache ref = 1时，则从热链(in_user_)迁移到冷链(lru_)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  assert(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    assert(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;key(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);<span class="comment">// 这里free</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    LRU_Append(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Insert（evict）"><a href="#3-Insert（evict）" class="headerlink" title="3. Insert（evict）"></a>3. Insert（evict）</h3><p>cache是有容量大小限制的，当插入的cache entry达到一定数量时，需要根据LRU算法剔除旧cache。这部分实现的入口在Insert函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">void</span>* value))</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =<span class="comment">// !!! 这里解释了上面为什么申请了一个字节的 key_data并且放在最后</span></span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">  e-&gt;value = value;</span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line">  e-&gt;key_length = key.<span class="built_in">size</span>();</span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line">  e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">  e-&gt;refs = <span class="number">1</span>;  <span class="comment">// for the returned handle.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(e-&gt;key_data, key.data(), key.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache's reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    LRU_Append(&amp;in_use_, e);</span><br><span class="line">    usage_ += charge;</span><br><span class="line">    FinishErase(table_.Insert(e));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// don't cache. (capacity_==0 is supported and turns off caching.)</span></span><br><span class="line">    <span class="comment">// next is read by key() in an assert, so it must be initialized</span></span><br><span class="line">    e-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ！！！超过容量，需要剔除旧cache lru_.next存放的是最旧的cache entry</span></span><br><span class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<span class="comment">// 移除旧cache entry，直到当前usage 小于等于 capacity。 或者最旧的entry已经是lru_</span></span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line">    assert(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 从hashtable中移除，从cache中删除。</span></span><br><span class="line">    <span class="keyword">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      assert(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有3个地方需要说明：</p><ol><li><p>LRUHandler中为什么申请了一个字节的key_data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle* e =<span class="comment">// !!! 这里解释了上面为什么申请了一个字节的 key_data并且放在最后</span></span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件.png" style="zoom:33%;" /></li><li><p>新增一个cache entry到cache中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    e-&gt;refs++;  <span class="comment">// for the cache's reference.</span></span><br><span class="line">    e-&gt;in_cache = <span class="literal">true</span>;</span><br><span class="line">    LRU_Append(&amp;in_use_, e);<span class="comment">// 插入到热链中 in_user_</span></span><br><span class="line">    usage_ += charge;</span><br><span class="line">    FinishErase(table_.Insert(e));<span class="comment">// 如果是更新，需要删除旧entry</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      Resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Insert在Update的情况下，会返回旧的cache entry. 在FinishErase函数调用中决定该cache entry是删除还是移动到lru_链中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If e != nullptr, finish removing *e from the cache; it has already been</span></span><br><span class="line"><span class="comment">// removed from the hash table.  Return whether e != nullptr.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    assert(e-&gt;in_cache);</span><br><span class="line">    LRU_Remove(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    Unref(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LRU evict：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ！！！超过容量，需要剔除旧cache lru_.next存放的是最旧的cache entry</span></span><br><span class="line"><span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<span class="comment">// 移除旧cache entry，直到当前usage 小于等于 capacity。 或者最旧的entry已经是lru_头，即cache为空</span></span><br><span class="line">  LRUHandle* old = lru_.next;</span><br><span class="line">  assert(old-&gt;refs == <span class="number">1</span>);</span><br><span class="line">   <span class="comment">// 从hashtable中移除，从cache中删除。</span></span><br><span class="line">  <span class="keyword">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</span><br><span class="line">  <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">    assert(erased);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>LRU是如何体现的？</p><p>回到插入一个entry到lru_中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LRU_Append(&amp;lru_, e);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* <span class="built_in">list</span>, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make "e" newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">  e-&gt;prev = <span class="built_in">list</span>-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次插入都是向list head的前面插入一个新节点，作为最新节点。所以有：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 5 页.png)</p><h2 id="4-ShardedLRUCache"><a href="#4-ShardedLRUCache" class="headerlink" title="4. ShardedLRUCache"></a>4. ShardedLRUCache</h2><p>前面说了ShardedLRUCache是为了减少多线程的竞争延迟而设计的。在SharedLRUCache中有16个LRUCache。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Hash(s.data(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123; <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShardedLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> : <span class="title">last_id_</span><span class="params">(<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].SetCapacity(per_shard);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~ShardedLRUCache() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    <span class="keyword">return</span> shard_[Shard(hash)].Lookup(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</span><br><span class="line">    shard_[Shard(h-&gt;hash)].Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hash = HashSlice(key);</span><br><span class="line">    shard_[Shard(hash)].Erase(key, hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="title">Value</span><span class="params">(Handle* handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewId</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;id_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ++(last_id_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      shard_[s].Prune();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</span><br><span class="line">      total += shard_[s].TotalCharge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何做到减少竞争带来的延迟的？现在有多个cache，对于每个插入的key，做一次hash，然后取hash结果的高4位作为cache id，用于选择此次用哪个cache来缓存数据。这样就避免了只使用一个cache时，每次插入都要加锁。</p><h2 id="5-Cache应用1-TableCache"><a href="#5-Cache应用1-TableCache" class="headerlink" title="5. Cache应用1-TableCache"></a>5. Cache应用1-TableCache</h2><p>tablecache cache的是<strong>多个sstable（不包含data block)</strong>。其key和value对应关系如下：</p><p><img data-src="https://pic.downk.cc/item/5f82b2b81cd1bbb86b3919c9.png" alt=""></p><p>TableCache中的cache容量为990. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Number of open files that can be used by the DB.  You may need to</span></span><br><span class="line"><span class="comment">// increase this if your database has a large working set (budget</span></span><br><span class="line"><span class="comment">// one open file per 2MB of working set).</span></span><br><span class="line"><span class="keyword">int</span> max_open_files = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumNonTableCacheFiles = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TableCacheSize</span><span class="params">(<span class="keyword">const</span> Options&amp; sanitized_options)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve ten files or so for other uses and give the rest to TableCache.</span></span><br><span class="line">  <span class="keyword">return</span> sanitized_options.max_open_files - kNumNonTableCacheFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是整个TableCache:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  TableCache(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options&amp; options, <span class="keyword">int</span> entries);</span><br><span class="line">  ~TableCache();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator for the specified file number (the corresponding</span></span><br><span class="line">  <span class="comment">// file length must be exactly "file_size" bytes).  If "tableptr" is</span></span><br><span class="line">  <span class="comment">// non-null, also sets "*tableptr" to point to the Table object</span></span><br><span class="line">  <span class="comment">// underlying the returned iterator, or to nullptr if no Table object</span></span><br><span class="line">  <span class="comment">// underlies the returned iterator.  The returned "*tableptr" object is owned</span></span><br><span class="line">  <span class="comment">// by the cache and should not be deleted, and is valid for as long as the</span></span><br><span class="line">  <span class="comment">// returned iterator is live.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">uint64_t</span> file_size, Table** tableptr = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key "k" in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;, <span class="keyword">const</span> Slice&amp;))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evict any entry for the specified file number</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size, Cache::Handle**)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options&amp; options_;</span><br><span class="line">  Cache* cache_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-FindTable"><a href="#1-FindTable" class="headerlink" title="1. FindTable"></a>1. FindTable</h3><p>FindTable是在cache中根据指定filenumnber,lookup到相关cache的handle。如果找到了，直接返回该handle，如果没找到，则插入到cache中。</p><p><strong>此时的key是编码后的file_number. value是file_number对应的file指针以及打开后的sstable指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableCache::FindTable</span><span class="params">(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Cache::Handle** handle)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">(buf, <span class="keyword">sizeof</span>(buf))</span></span>;</span><br><span class="line">   <span class="comment">// 在cache寻找key对应的handle</span></span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;<span class="comment">// 找不到</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// 根据fname打开file</span></span><br><span class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;</span><br><span class="line">        s = Status::OK();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 根据file打开table</span></span><br><span class="line">      s = Table::Open(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      assert(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入到cache中</span></span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 7 页.png" style="zoom:67%;" /><h3 id="2-Get"><a href="#2-Get" class="headerlink" title="2. Get"></a>2. Get</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// If a seek to internal key "k" in specified file finds an entry,</span></span><br><span class="line">  <span class="comment">// call (*handle_result)(arg, found_key, found_value).</span></span><br><span class="line"><span class="function">Status <span class="title">TableCache::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 找到cache中的table</span></span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">      <span class="comment">// 在table内部寻找k，找到了对应data pair调用handle_result</span></span><br><span class="line">    s = t-&gt;InternalGet(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Table::InternalGet</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> Slice&amp;))</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">   <span class="comment">// 生成index迭代器</span></span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);</span><br><span class="line">  iiter-&gt;Seek(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;Valid()) &#123;</span><br><span class="line">      <span class="comment">// 找到相关data block</span></span><br><span class="line">    Slice handle_value = iiter-&gt;value();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br><span class="line">    <span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">        !filter-&gt;KeyMayMatch(handle.offset(), k)) &#123;<span class="comment">// 应用bloom filter检查给定key是否在这个data block中</span></span><br><span class="line">      <span class="comment">// Not found</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 可能在这个data block中</span></span><br><span class="line">       <span class="comment">// 将index的value转换为一个block iter</span></span><br><span class="line">      Iterator* block_iter = BlockReader(<span class="keyword">this</span>, options, iiter-&gt;value());</span><br><span class="line">      block_iter-&gt;Seek(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;Valid()) &#123;<span class="comment">// 确实在这个data block中，调用handle_result函数（这里的arg可以是一个saver，用来保存找到的key和vlaue）</span></span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;key(), block_iter-&gt;value());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = iiter-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第 8 页.png" style="zoom: 50%;" /><h3 id="3-Evict"><a href="#3-Evict" class="headerlink" title="3. Evict"></a>3. Evict</h3><p>这个相对简单，直接在cache_中Erase即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableCache::Evict</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  cache_-&gt;Erase(Slice(buf, <span class="keyword">sizeof</span>(buf)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-NewIterator"><a href="#4-NewIterator" class="headerlink" title="4.NewIterator"></a>4.NewIterator</h3><p>根据cache找到table，根据table返回iterator。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">TableCache::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Table** tableptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewErrorIterator(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">  Iterator* result = table-&gt;NewIterator(options);</span><br><span class="line">  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);</span><br><span class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *tableptr = table;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了TwoLevelIterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">Table::NewIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</span><br><span class="line">      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TwoLevelIterator</strong>用index_iter和data_iter来访问数据。</p><p><strong>index_iter为index_block的 Block::Iter。</strong></p><p><strong>data_iter为 data block的Block::Iter。</strong></p><h2 id="6-Cache应用2-BlockCache"><a href="#6-Cache应用2-BlockCache" class="headerlink" title="6. Cache应用2-BlockCache"></a>6. Cache应用2-BlockCache</h2><p>BlockCache用于cache sstable中的datablock。系统默认为8M. </p><p><strong>key为 cahceid+data block的位置信息(offset)。</strong></p><p><strong>value 为 data block的block封装（解压后）。</strong></p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 9 页 (1).png)</p><h3 id="1-BlockCache的初始化"><a href="#1-BlockCache的初始化" class="headerlink" title="1. BlockCache的初始化"></a>1. BlockCache的初始化</h3><p>blockcache的默认初始化在SanitizeOptions中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Options <span class="title">SanitizeOptions</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> InternalKeyComparator* icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> InternalFilterPolicy* ipolicy,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> Options&amp; src)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (result.block_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// block cache 的 capacity 为 8M</span></span><br><span class="line">    result.block_cache = NewLRUCache(<span class="number">8</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Block-Cache的读取与插入"><a href="#2-Block-Cache的读取与插入" class="headerlink" title="2. Block Cache的读取与插入"></a>2. Block Cache的读取与插入</h3><pre><code>目前仅在Table::BlockReader看到使用。所以以这个函数来讲解。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">Table::BlockReader</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice&amp; index_value)</span> </span>&#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">    <span class="comment">// 获取 block_cache</span></span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.DecodeFrom(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码较长，分开来看，核心在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      <span class="function">Slice <span class="title">key</span><span class="params">(cache_key_buffer, <span class="keyword">sizeof</span>(cache_key_buffer))</span></span>;</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;<span class="comment">// 在block cache中找到了block内容</span></span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 找不到block内容</span></span><br><span class="line">         <span class="comment">// 从table中读取block,注意此时blockcontents的内容已经是解压后的内容</span></span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果在block_cache中找到了相关的内容，则直接返回相应的Block。找不到，则从table中读取相应的Block并放入到block_cache中。可以看到，block cahce的key为一个16字节的buffer, 前8个字节存放的cache_id, 后8个字节存放的data block所在sstable中的offset。value为一个block（解压后）。</p><blockquote><p>cache id的作用：</p><p>// Return a new numeric id.  May be used by multiple clients who are</p><p>// sharing the same cache to partition the key space.  Typically the</p><p>// client will allocate a new id at startup and prepend the id to</p><p>// its cache keys.</p></blockquote><p>额外看一下Table是如何ReadBlock的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br></pre></td></tr></table></figure><h3 id="3-Table的ReadBlock"><a href="#3-Table的ReadBlock" class="headerlink" title="3. Table的ReadBlock"></a>3. Table的ReadBlock</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file, <span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> BlockHandle&amp; handle, BlockContents* result)</span> </span>&#123;</span><br><span class="line">  result-&gt;data = Slice();</span><br><span class="line">  result-&gt;cachable = <span class="literal">false</span>;</span><br><span class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取完整的data block</span></span><br><span class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></span><br><span class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></span><br><span class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</span><br><span class="line">  Slice contents;</span><br><span class="line">  Status s = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() != n + kBlockTrailerSize) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"truncated block read"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// crc校验</span></span><br><span class="line">  <span class="comment">// Check the crc of the type and the block contents</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.data();  <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::Unmask(DecodeFixed32(data + n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::Value(data, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      s = Status::Corruption(<span class="string">"block checksum mismatch"</span>);</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查看是否需要解压，如果需要解压，则解压数据</span></span><br><span class="line">  <span class="keyword">switch</span> (data[n]) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      <span class="keyword">if</span> (data != buf) &#123;</span><br><span class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></span><br><span class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></span><br><span class="line">        <span class="comment">// while the file is open.</span></span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        result-&gt;data = Slice(data, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = Slice(buf, n);</span><br><span class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">        result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ok</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (!port::Snappy_GetUncompressedLength(data, n, &amp;ulength)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</span><br><span class="line">      <span class="keyword">if</span> (!port::Snappy_Uncompress(data, n, ubuf)) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">        <span class="keyword">delete</span>[] ubuf;</span><br><span class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      result-&gt;data = Slice(ubuf, ulength);</span><br><span class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</span><br><span class="line">      result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">delete</span>[] buf;</span><br><span class="line">      <span class="keyword">return</span> Status::Corruption(<span class="string">"bad block type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leveldb是一种对写优化的kv存储系统，读性能有所下降，为了充分利用局部性原理，提高读性能，leveldb自己也设计了一个Cache结构。内部采用LRU替换策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Compaction</title>
    <link href="https://www.ravenxrz.ink/archives/1ba074b9.html"/>
    <id>https://www.ravenxrz.ink/archives/1ba074b9.html</id>
    <published>2020-10-12T10:00:00.000Z</published>
    <updated>2020-10-12T09:21:16.927Z</updated>
    
    <content type="html"><![CDATA[<p>截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。</p><a id="more"></a><h1 id="MemTable-到-SStable"><a href="#MemTable-到-SStable" class="headerlink" title="MemTable 到 SStable"></a>MemTable 到 SStable</h1><p>在leveldb中，compaction共有两种，分别叫 minor compaction 和major compaction。</p><ul><li>minor compaction，将immtable dump到SStable</li><li>major compaction，level之间的SSTable compaction。</li></ul><p>这里先来分析minor compaction。</p><p>我们主要关注以下问题：</p><ol><li>minor compaction是如何进行的？</li><li>minor compaction何时会进行？</li></ol><h1 id="1-minor-compaction如何进行？"><a href="#1-minor-compaction如何进行？" class="headerlink" title="1. minor compaction如何进行？"></a>1. minor compaction如何进行？</h1><p>compaction的入口是 <code>DBImpl::MaybeScheduleCompaction()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 env_-&gt;Schedule(&amp;DBImpl::BGWork, this);中，将BGWork放入线程池，由子线程来做:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="keyword">void</span>* db)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;BackgroundCall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">    <span class="comment">// 递归调用compaction，因为有可能这次compaction产生了过多的sst</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-调用流程图"><a href="#1-调用流程图" class="headerlink" title="1. 调用流程图"></a>1. 调用流程图</h2><p>这里的调用链比较清晰：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-minor_compaction过程1 (1).png" style="zoom: 33%;" /><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-compaction (1).png" style="zoom:33%;" /><p>需要注意的是，DBImpl::MaybeScheduleCompaction 是一个递归调用，递归结束的地方在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就说结束的条件是：</p><ol><li><p>当前immemtable为null</p></li><li><p>非手动compaction</p></li><li><p>versionset判定为不需要compaction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们曾在分析VersionEdit，VersionSet时，提到过compaction_score是如何计算的，这里提一下它的入口在 VersionSet::Finalize 。后面再做详细分析。</p></li></ol><h2 id="2-Minor-Compaction执行细节"><a href="#2-Minor-Compaction执行细节" class="headerlink" title="2. Minor Compaction执行细节"></a>2. Minor Compaction执行细节</h2><p>ok，说完宏观的调用链，现在来详细分一下leveldb是如何左minor compaction的，核心函数在：==BackgroundCompaction();==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;<span class="comment">// minor compaction的触发点</span></span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">   <span class="comment">// 将 数据写入到第0层（实际上不一定是第0层)</span></span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">      <span class="comment">// 应用生成的一个VersionEdit到当前VersionSet</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">     <span class="comment">// 减少计数，引用计数归0时会delete当前immemtable</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续看==WriteLevel0Table==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Version* base)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">      <span class="comment">//!! 1. 将memtable dump 到SSTable中</span></span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.SSTable 应该写入到哪个level？</span></span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 3. 生成VersionEdit，给后序Manifest做记录</span></span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 保存本次compaction所在level的 compaction状态</span></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-WriteLevel0Table-流程图"><a href="#1-WriteLevel0Table-流程图" class="headerlink" title="1 WriteLevel0Table 流程图"></a>1 WriteLevel0Table 流程图</h3><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-WriteLevel0Table.png" style="zoom:50%;" /><h4 id="3个函数的分析"><a href="#3个函数的分析" class="headerlink" title="3个函数的分析"></a>3个函数的分析</h4><p>现在来分别分析这3个函数：</p><h4 id="1-BuildTable-建立ssttable并持久化"><a href="#1-BuildTable-建立ssttable并持久化" class="headerlink" title="1. BuildTable (建立ssttable并持久化)"></a>1. BuildTable (建立ssttable并持久化)</h4><p>下面这些 .ldb的文件就是sstable，可以看到它们都是一些由数字组成的文件名，这些数字是哪里来的？我们可以从源码中获得答案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200925153434477.png" alt="image-20200925153434477"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  meta-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">  iter-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// meta number就是上图的数字来源， meta-&gt;number的赋值语句在DBImpl::WriteLevel0Table中的 `meta.number = versions_-&gt;NewFileNumber();`</span></span><br><span class="line">    <span class="comment">// 所以该数字由VersionSet分配</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname, meta-&gt;number);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;Valid()) &#123;</span><br><span class="line">    WritableFile* file;</span><br><span class="line">    s = env-&gt;NewWritableFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 新建sstable</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> TableBuilder(options, file);</span><br><span class="line">      <span class="comment">// 因为跳表是有序的，所以第一个key肯定是最小的</span></span><br><span class="line">    meta-&gt;smallest.DecodeFrom(iter-&gt;key());</span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) &#123;</span><br><span class="line">      key = iter-&gt;key();</span><br><span class="line">       <span class="comment">// 向sstable中添加key value。</span></span><br><span class="line">      builder-&gt;Add(key, iter-&gt;value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!key.empty()) &#123;</span><br><span class="line">        <span class="comment">// 同理，最后一个key是最大的</span></span><br><span class="line">      meta-&gt;largest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">      <span class="comment">// 写入sstable中的其他块，index block, meta block ,meta index block footer等</span></span><br><span class="line">    s = builder-&gt;Finish();</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      meta-&gt;file_size = builder-&gt;FileSize();</span><br><span class="line">      assert(meta-&gt;file_size &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for file errors</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 写入到硬件</span></span><br><span class="line">      s = file-&gt;Sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = file-&gt;Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">   xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Keep it</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env-&gt;RemoveFile(fname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作：</p><ol><li>新建SStable文件</li><li>根据memtable提供的Iterator，向SStable中添加所有数据</li><li>将SSTable写入到硬件设备中。</li></ol><h4 id="2-Version-PickLevelForMemTableOutput"><a href="#2-Version-PickLevelForMemTableOutput" class="headerlink" title="2. Version::PickLevelForMemTableOutput"></a>2. Version::PickLevelForMemTableOutput</h4><p>PickLevelForMemTableOutput决定新生成的sstable所在的level，原则上，从memtable dump出来sstable应该首先放到level0， 但是如果总是放到level 0，后序的compaction会耗费过多的io吞吐量，所以这个函数的意思是，尽量将新生成的sstable往更深的level放，但是又不能放的太深，因为如果这个sstable的访问频率较高，过深的level意味着读性能的降低。所以往下push得有个读。</p><p>leveldb定义了kMaxMemCompactLevel这个参数来限制新生成的sstable能够下推的层次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum level to which a new compacted memtable is pushed if it</span></span><br><span class="line"><span class="comment">// does not create overlap.  We try to push to level 2 to avoid the</span></span><br><span class="line"><span class="comment">// relatively expensive level 0=&gt;1 compactions and to avoid some</span></span><br><span class="line"><span class="comment">// expensive manifest file operations.  We do not push all the way to</span></span><br><span class="line"><span class="comment">// the largest level since that can generate a lot of wasted disk</span></span><br><span class="line"><span class="comment">// space if the same key space is being repeatedly overwritten.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxMemCompactLevel = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以，默认最高只能到level2.</p><p>现在来看看源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Version::PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> Slice&amp; largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果与level 0有重叠，直接return 0</span></span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    <span class="function">InternalKey <span class="title">limit</span><span class="params">(largest_user_key, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; <span class="built_in">config</span>::kMaxMemCompactLevel) &#123;<span class="comment">// 最高到kMaxMemCompactLevel</span></span><br><span class="line">       <span class="comment">// 与level+1有重叠</span></span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">         <span class="comment">// 与祖父level的重叠size过大，则直接break</span></span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用一张流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/PickLevelForMemTableOutput.png" alt="img"></p><h4 id="3-edit-gt-Addfile-（记录元sstable所在level等元数据）"><a href="#3-edit-gt-Addfile-（记录元sstable所在level等元数据）" class="headerlink" title="3. edit-&gt;Addfile （记录元sstable所在level等元数据）"></a>3. edit-&gt;Addfile （记录元sstable所在level等元数据）</h4><p>最后就是edit-&gt;Addfile。将生成的sstable的元数据（filemeta）加入到versionedit中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从edit-&gt;AddFile可知，一个SSTable对应有一个FileMeta存放在edit中，edit最终会存放在manifest，同时edit最终会演变成version，version又会加入到versioneset中。</p><h3 id="2-LogAndApply"><a href="#2-LogAndApply" class="headerlink" title="2. LogAndApply"></a>2. LogAndApply</h3><p>LogAndApply前面已经分析过了。 之前我们将所有filemeta存放在一个versionedit中，通过这个LogAndApply即可将versionedit应用到当前versionset中，并持久化到manifest。</p><h2 id="2-何时Tigger-Compaction？"><a href="#2-何时Tigger-Compaction？" class="headerlink" title="2. 何时Tigger Compaction？"></a>2. 何时Tigger Compaction？</h2><p>让我们回到MaybeScheduleCompaction</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，正常情况下只要满足一下3种条件中任何一个都会触发一次compaction：</p><ul><li>imm != null, memtable已经转化为immtable，需要及时dump到外存中。</li><li>manual_compaction， 手动compaction</li><li>versions-&gt;NeedCompaction()</li></ul><p>前两种都好说，重点看一下第3种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又分为了两种情况，根据compaction_score和根据 filte_compact。先说第一种：<code>v-&gt;compaction_score_</code></p><h3 id="1-compaction-score-amp-Finalize函数"><a href="#1-compaction-score-amp-Finalize函数" class="headerlink" title="1. compaction_score_  &amp; Finalize函数"></a>1. compaction_score_  &amp; Finalize函数</h3><p>==Finalize函数==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 最高level</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在leveldb的设计中，level0和其余level的compaction设计是不同的，level0基于文件数量，而其余层基于文件的总大小。</p><h4 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h4><p>level0为什么要要这样设计？根据注释：</p><ol><li>如果有更大的写buffer, 应该尽量避免多个level 0的compactions。</li><li>每次读，都会level0的file merge，应该如果level0的文件数量过多。（个人理解：因为读会衰减？）</li></ol><blockquote><p>引用博文：</p><p>注释说的很明白，level 0的文件之间，key可能是交叉重叠的，因此不希望level 0的文件数特别多。我们考虑write buffer 比较小的时候，如果使用size来限制，那么level 0的文件数可能太多。</p><p>另一个方面，如果write buffer过大，使用固定大小的size 来限制level 0的话，可能算出来的level 0的文件数又太少，触发 level 0 compaction的情况发生的又太频繁。</p></blockquote><p>所以，对于level0，其默认设计的文件数量不超过4:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h4 id="其他level"><a href="#其他level" class="headerlink" title="其他level"></a>其他level</h4><p>其他level则是根据当前文件大小与size limit的比值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">     score =</span><br><span class="line">         <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;<span class="comment">// 默认是10M</span></span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码说明，从level1开始，每相邻两层的level总大小，相差10.  level1=10M, level2=100M，以此类推。</p><p>同时这里也指明了leveldb的最高level为多少：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumLevels = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>所以最高到level6, 则各层大小分布为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level 1               10M </span><br><span class="line">level 2              100M</span><br><span class="line">level 3             1000M</span><br><span class="line">level 4            10000M</span><br><span class="line">level 5           100000M</span><br><span class="line">level 6          1000000M</span><br></pre></td></tr></table></figure><h4 id="选择得分最高的来做compaction"><a href="#选择得分最高的来做compaction" class="headerlink" title="选择得分最高的来做compaction"></a>选择得分最高的来做compaction</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">   best_level = level;</span><br><span class="line">   best_score = score;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>得分越高，越想compaction。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>所以根据compaction_score_ 来看，当level0的文件过多，或者其余level的总file size过大时，会触发compacton。</p><h3 id="2-file-to-compact-amp-Seek-Compaction"><a href="#2-file-to-compact-amp-Seek-Compaction" class="headerlink" title="2. file_to_compact_ &amp; Seek Compaction"></a>2. file_to_compact_ &amp; Seek Compaction</h3><p>除了上述情况外，leveldb还有用了基于seek的compactoin。</p><p>除了level 0以外，任何一个level的文件内部是有序的，文件之间也是有序的。但是level（n）和level （n＋1）中的两个文件的key可能存在交叉。正是因为这种交叉，查找某个key值的时候， level（n） 的查找无功而返，而不得不restart to level(n＋1)。</p><p>我们考虑寻找某一个key，如果找了曾经查找了level (n) ,但是没找到，然后去level (n+1)查找，结果找到了，那么对level (n)的某个文件而言，该文件就意味着有一次 未命中。</p><p>我们可以很容易想到，如果查找了多次，某个文件不得不查找，却总也找不到，总是去高一级的level，才能找到。这说明该层级的文件和上一级的文件，key的范围重叠的很严重，这是不合理的，会导致效率的下降。因此，需要对该level 发起一次Major compaction，减少 level 和level ＋ 1的重叠情况。</p><p>这就是所谓的 Seek Compaction。</p><p>我个人的理解是，查找一个key，根据manifest判定这个key可能在某个sstable中（manifest中存放了sstable的smallest和largest key）,但是实际上并不在，所以总是在更深层中去找。那查找本层的sstable就是对io的浪费，而且也说明了本层和更深层的key有比较严重的相互重叠。举个例子，如下图：</p><img data-src="../../../图库/leveldb源码阅读-copy-seek compaction.png" style="zoom:33%;" /><p>现在查找6， 对于level1的sstable来说，key的range在[1,9], 所以会查找这个sstable，显然6不在其中，于是向下层中找，level2的这个sstable的key range为[2,8]，在这里找到了。 这样level1的io就是浪费掉的， level1和level2的key overlap也比较严重，长此以往浪费io，所以需要compaction。</p><p>seek compaction在filemeta中用 <strong>allowed_seeks</strong> 来控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// !!!Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>==VersionSet::Builder::Apply==对其初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说的是， 根据估算，大概每25次seek的time cost = 1次compaction的。保守估计，1次seek相当于compaction16kb的数据。 所以==当seek的总耗时约等于一次compaction的耗时时，就触发一次compaction==。则允许seek的次数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// file_size/16KB</span></span><br></pre></td></tr></table></figure><h1 id="2-如何确定Compaction的输入源"><a href="#2-如何确定Compaction的输入源" class="headerlink" title="2. 如何确定Compaction的输入源"></a>2. 如何确定Compaction的输入源</h1><p>结合前面两种compaction来看，触发compaction的时机：</p><ol><li>size compaction :文件过多或文件过大</li><li>seek compaction: seek次数过多。</li></ol><p>现在回到==DBImpl::BackgroundCompaction:==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;<span class="built_in">begin</span>, m-&gt;<span class="built_in">end</span>);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;<span class="built_in">begin</span> ? m-&gt;<span class="built_in">begin</span>-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;<span class="built_in">end</span> ? m-&gt;<span class="built_in">end</span>-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 现在只看非manual的情况</span></span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-PickCompaction"><a href="#1-PickCompaction" class="headerlink" title="1. PickCompaction"></a>1. PickCompaction</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>PickCompaction流程图：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-PickCompaction.png" style="zoom: 33%;" /><p>转到==PickCompaction==函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line"><span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line"><span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line"><span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line"><span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 优先考虑 size_compaction, 再考虑seek_compaction.</span></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据函数签名注释，PickCompaction的作用是，找到level以及level对应的需要compaction的文件。现在来拆开代码看：</p><p>优先考虑 size_compaction, 再考虑seek_compaction.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line"><span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="1-Size-Compaction"><a href="#1-Size-Compaction" class="headerlink" title="1. Size Compaction"></a>1. Size Compaction</h3><h4 id="1-leve-n的sstable确定"><a href="#1-leve-n的sstable确定" class="headerlink" title="1. leve n的sstable确定"></a>1. leve n的sstable确定</h4><ol><li>得到  level[n]的输入源</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">   level = current_-&gt;compaction_level_;</span><br><span class="line">   assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">   assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">   c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">     FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">     <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">         icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">     <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">     c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>inputs_数组中存放的是输入源。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each compaction reads inputs from "level_" and "level_+1"</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; inputs_[<span class="number">2</span>];  <span class="comment">// The two sets of inputs</span></span><br></pre></td></tr></table></figure><p>接着看<code>size_compaction</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">level = current_-&gt;compaction_level_;</span><br><span class="line">assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个文件，其最大key比 compact_pointer_[level]的key大</span></span><br><span class="line"><span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">    <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">        icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果找不到这样的文件，从level头开始（round-robin)</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">    <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size_compation中<strong>只用确定一个要输入的 sstable文件。</strong> 接着看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level0由于存在overlap key，所以需要这些key加入。看注释有一点值得注意：</p><blockquote><p>在GetOverlappingInputs函数中，会discard我们之前加入的sstable filemeta, 但是后会replace一个overlap set，这个overlap set将会包含之前picked file。</p><p>是否还包含，这点还有待验证。</p></blockquote><h4 id="GetOverlappingInputs函数"><a href="#GetOverlappingInputs函数" class="headerlink" title="GetOverlappingInputs函数"></a>GetOverlappingInputs函数</h4><p>继续深追到GetOverlappingInputs:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::GetOverlappingInputs</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> InternalKey* <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs)</span> </span>&#123;</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">  inputs-&gt;<span class="built_in">clear</span>();<span class="comment">// 清空</span></span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = <span class="built_in">begin</span>-&gt;user_key();<span class="comment">// 确定begin</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = <span class="built_in">end</span>-&gt;user_key();<span class="comment">// 确定end</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;<span class="comment">// 对于level0，由于存在overlap key，所以可能会扩大begin和end的范围，一旦扩大，重新搜索整个files.</span></span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码的工作是，根据在PickCompaction() 中选定的文件，确定初步的key range[begin,end], 然后在level0中选择所有与该key range有重叠的sstable，<strong>同时每选择一个还会扩大key range，然后重新add。</strong></p><h4 id="举个例子（level0-compaction的sstable选择）"><a href="#举个例子（level0-compaction的sstable选择）" class="headerlink" title="举个例子（level0 compaction的sstable选择）"></a>举个例子（level0 compaction的sstable选择）</h4><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LWxldmVsMA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level0">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level0<i class="fa fa-external-link"></i></span> compaction.png)</p><p>假设在level 0中选择了<strong>8-14</strong> 这个sstable。现在从头开始遍历，查看是否有需要加入的其他sstable。</p><p>第一次，搜索3-6，因为3-6与8-14无重叠，所以无需加入。</p><p>第二次，搜索5-12，因为5-12与8-14有重叠，所以加入5-12。 同时由于现在是level0，5-12扩大了搜索域的下界，现在的搜索域改为 <strong>5-14</strong>, 清空所有已经加入的sstable，重头开始。</p><p>第三次，搜索3-6，因为3-6与5-14有重叠，所以加入3-6.</p><p>第四次，搜索5-12，因为5-12与5-14有重叠，所以5-12.</p><p>第五次，所有8-14，因为8-14与5-14有重叠，所以加入8-14.</p><p>最后加入的sstable，包括3-6，5-12，8-14.</p><p>==上面说的，都是如何level n的输入源，总结起来就是，除了level0，其余level只加入一个sstable，level0可能加入多个sstable==</p><h4 id="2-level-n-1的sstable确定"><a href="#2-level-n-1的sstable确定" class="headerlink" title="2. level n+1的sstable确定"></a>2. level n+1的sstable确定</h4><p>level n+1是在==SetupOtherInputs== 函数中确定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩展上边界 </span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">// 获取当前level n的range</span></span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">   <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">   <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line">  <span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log,</span><br><span class="line">            <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">            level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><p>核心在着几行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取当前level n的range</span></span><br><span class="line">GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"> <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                               &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">InternalKey all_start, all_limit;</span><br><span class="line"> <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure><h4 id="level-n新SStable的加入"><a href="#level-n新SStable的加入" class="headerlink" title="level n新SStable的加入"></a>level n新SStable的加入</h4><p>那下面还有一大段是做什么用的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">        ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">        InternalKey new_start, new_limit;</span><br><span class="line">        GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">        current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                       &amp;expanded1);</span><br><span class="line">        <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            Log(options_-&gt;info_log,</span><br><span class="line">                <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">                level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">            smallest = new_start;</span><br><span class="line">            largest = new_limit;</span><br><span class="line">            c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">            c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">            GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是，在选中level n+1层的sstable后，可能还可以加入一些level n的sstable。举个例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LWxldmVs" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-level<i class="fa fa-external-link"></i></span> n重新加入一些sstable.png)</p><p>假设现在在level n选择的是8-12这个sstable，则在level n+1 可以选择8-9，10-16着连个sstable。 这一切做完后，发现在level n中存在13-15这个sstable，加入13-15并不影响level n+1 sstable的选择。</p><p>上面那段代码就是做这个工作。举个不会加入新sstable的例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 16 页 (1).png)</p><p>在这样的情况下，13-18的重新加入，level n+1 需要重新加入17-20，所以不应该加入13-18.</p><p>但是再看下一个例子：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 17 页.png)</p><p>这个例子中，虽然新加入level 13-18，扩大了inputs_的范围，但是由于并没有造成level n+1的sstable重新选择，所以依然可以加入13-18.</p><p>ok，例子说了好几个，正式看代码。</p><ol><li>计算如果要在level n要重新加入sstable，那加入后的第level n层的compaction sstable的总大小为多少（即expanded0_size)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br></pre></td></tr></table></figure><ol start="2"><li>如果新加入后，level n和level n+1的总size小于一次compaction的总size，则考虑加入。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br></pre></td></tr></table></figure><p>一次compaction的总size：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes in all compacted files.  We avoid expanding</span></span><br><span class="line"><span class="comment">// the lower level file set of a compaction if it would make the</span></span><br><span class="line"><span class="comment">// total compaction cover more than this many bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">ExpandedCompactionByteSizeLimit</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">25</span> * TargetFileSize(options);<span class="comment">// 默认是50M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">TargetFileSize</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options-&gt;max_file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leveldb will write up to this amount of bytes to a file before</span></span><br><span class="line"><span class="comment">// switching to a new one.</span></span><br><span class="line"><span class="comment">// Most clients should leave this parameter alone.  However if your</span></span><br><span class="line"><span class="comment">// filesystem is more efficient with larger files, you could</span></span><br><span class="line"><span class="comment">// consider increasing the value.  The downside will be longer</span></span><br><span class="line"><span class="comment">// compactions and hence longer latency/performance hiccups.</span></span><br><span class="line"><span class="comment">// Another reason to increase this parameter might be when you are</span></span><br><span class="line"><span class="comment">// initially populating a large database.</span></span><br><span class="line"><span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>在level n中加入新sstable，但没有引起level n+1的sstable选择，则加入这个新sstable。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Log(options_-&gt;info_log,</span><br><span class="line">        <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">        level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">    smallest = new_start;</span><br><span class="line">    largest = new_limit;</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">    c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">    GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-记录下一轮的压缩起始文件"><a href="#3-记录下一轮的压缩起始文件" class="headerlink" title="3. 记录下一轮的压缩起始文件"></a>3. 记录下一轮的压缩起始文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line"><span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line"><span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line"><span class="comment">// key range next time.</span></span><br><span class="line">compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">c-&gt;edit_.SetCompactPointer(level, largest);</span><br></pre></td></tr></table></figure><h4 id="4-AddBoundaryInputs"><a href="#4-AddBoundaryInputs" class="headerlink" title="4. AddBoundaryInputs"></a>4. AddBoundaryInputs</h4><p>在前面的介绍中，我曾说过，除了level0， 其余level中 inputs数组的inputs[0]总是先只选择一个文件，然后通过<code>VersionSet::SetupOtherInputs</code>，确定inputs_[1],  当inputs_[1]确定后，会回退到input_[0]，尝试增加input_[0]的文件。其实除了这里会增加input[0]的选择外，还有一处可能增加Inputs[0]的选择。那就是AddBoundaryInputs函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// !! 这里</span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==AddBoundaryInputs==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Extracts the largest file b1 from |compaction_files| and then searches for a</span></span><br><span class="line"><span class="comment">// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a</span></span><br><span class="line"><span class="comment">// file b2 (known as a boundary file) it adds it to |compaction_files| and then</span></span><br><span class="line"><span class="comment">// searches again using this new upper bound.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and</span></span><br><span class="line"><span class="comment">// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a</span></span><br><span class="line"><span class="comment">// subsequent get operation will yield an incorrect result because it will</span></span><br><span class="line"><span class="comment">// return the record from b2 in level i rather than from b1 because it searches</span></span><br><span class="line"><span class="comment">// level by level for records matching the supplied user key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameters:</span></span><br><span class="line"><span class="comment">//   in     level_files:      List of files to search for boundary files.</span></span><br><span class="line"><span class="comment">//   in/out compaction_files: List of files to extend by adding boundary files.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span> </span>&#123;</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!FindLargestKey(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        FindSmallestBoundaryFile(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;push_back(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AddBoundaryInputs调用前，我们已经确定了inputs[0], 如果不考虑level0的话，对于其他level，inputs[0]为一个sstable。这个sstable存在一个key range[low,high], 我们都知道 sstable内部存的key是InternalKey, InternalKey内部封装了user key。如下图：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><p>因为只要internel key不相同，那么就可认为key是不重叠的。也就是说只要(key, sequence number,type)三个任一个不同，就可以认为key是不同。 那现在可能就存在这样一个情况， 相邻两个sstable的user key相同。如下图表示：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LUFkZEJvdW5kYXJ5SW5wdXRz" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-AddBoundaryInputs">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-AddBoundaryInputs<i class="fa fa-external-link"></i></span> (1).png)</p><p>sstable 1中的上届(upper)的user key 和 sstable 2的下届(lower)的user key相同，都为key2. 假设我们当前inputs[0]就是sstable 1。 那么AddBoundaryInputs函数的作用就是将sstable 2添加到inputs[0]中。 当然这是一个递归的过程，加完sstable 2，可能sstable 3的下届user key又和sstable 2的上届相同，所以继续添加。</p><p>为什么要这样加？因为若是不添加，sstable 1经过compaction陷入下层，而sstable 2还在上层。那么下一次Get操作时，leveldb将由上往下search，这样找到的key在sstable 2，而sstable 2中的key不是最新的，这显然是不对的。</p><h3 id="2-Seek-Compaction"><a href="#2-Seek-Compaction" class="headerlink" title="2. Seek Compaction"></a>2. Seek Compaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickCompaction函数中</span></span><br><span class="line">level = current_-&gt;file_to_compact_level_;</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br></pre></td></tr></table></figure><p>根据<code>file_to_compact_</code>指针和<code>file_to_compact_level_</code>即可得到 ==一个输入源文件==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure><h4 id="1-什么时候触发一次seek-compaction？"><a href="#1-什么时候触发一次seek-compaction？" class="headerlink" title="1. 什么时候触发一次seek compaction？"></a>1. 什么时候触发一次seek compaction？</h4><p>我们从<code>file_to_compact_</code>反追踪，可以发现 UpdateStats 函数中对file_to_compact_进行了赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Version::UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span> </span>&#123;</span><br><span class="line">  FileMetaData* f = stats.seek_file;</span><br><span class="line">  <span class="keyword">if</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    f-&gt;allowed_seeks--;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt;= <span class="number">0</span> &amp;&amp; file_to_compact_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      file_to_compact_ = f;</span><br><span class="line">      file_to_compact_level_ = stats.seek_file_level;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，当一个文件的allowed_seeks&lt;=0时，就可以对这个file进行compaction。</p><h4 id="2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析"><a href="#2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析" class="headerlink" title="2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析"></a>2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析</h4><p>继续反追踪 ，什么时候调用UpdateStats? <strong>在DBImpl::Get函数中</strong></p><p>==DBImpl::Get==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123; <span class="comment">// 1.首先在mem中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;<span class="comment">// 2.然后在imm中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);<span class="comment">// 3.再去sstable， ！！注意这里的status</span></span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123; <span class="comment">// 4.这里调用了UpdateStats</span></span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==Version::Get==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">      <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// ！！stats控制转移到State类</span></span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后走到了ForEachOverlapping，参数中传入了一个函数指针, State::Match, 后序在分析。先看ForEachOverlapping:</p><p>==ForEachOverlapping==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">   <span class="comment">// 加入第0层文件</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.reserve(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.push_back(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">      <span class="comment">// 按照新旧排序，由新到旧</span></span><br><span class="line">    <span class="built_in">std</span>::sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;<span class="comment">// 调用State::Match, 由于第0层无序，所以可能需要多次调用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 到这里，确定了 internal_key 一定是在 本file的key range中，即overlap</span></span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;<span class="comment">// 一个level，只会调用</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ForEachOverlapping函数中，首先搜索level0，在level 0中找到一些sstable，这些sstable的key range包含了user_key. 然后不断调用Match函数，直到找到相应file。 <strong>由于level0的无序性，所以Match函数可能被调用了多次。</strong></p><p>如果level0中找不到能够匹配的SStable，就逐层往下，因为level1–level6都是有序的，<strong>所以每层最多有一个sstable</strong>，满足其key range包含指定user_key， <strong>所以每层只用调用一次Match函数。</strong></p><p>最后，看看：</p><p>==Match==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 不再search</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> kNotFound:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">        <span class="keyword">case</span> kFound:</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kDeleted:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kCorrupt:</span><br><span class="line">            state-&gt;s =</span><br><span class="line">                Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个函数中也终于可以找到<code>seek_file</code>被赋值的地方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">    state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">    <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">    state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">    state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要进入这个分析，Match已经至少被执行了一次，所以现在记录的是上一次调用Match函数时所用到的file。这个file被访问了，但是却没有找到正确的key。所以它浪费了io，进而在后序的<code>UpdateStats</code>函数中，它的<strong>allowed_seeks会被–</strong>。</p><p><strong>不过感觉这里记录到第一个浪费了io的sstable，后序可能还会存在浪费io的sstable，可能是因为层别越低，访问频率越高，所以越需要快点将其allowed_seeks减小。</strong></p><p>ok，总结一下，花个流程图。</p><h4 id="seek-compaction的流程图（何时触发，如何触发）"><a href="#seek-compaction的流程图（何时触发，如何触发）" class="headerlink" title="seek_compaction的流程图（何时触发，如何触发）"></a>seek_compaction的流程图（何时触发，如何触发）</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-seek_compaction (2).png" style="zoom:50%;" /><h4 id="3-allowed-seeks–的时机-2-amp-DBIter"><a href="#3-allowed-seeks–的时机-2-amp-DBIter" class="headerlink" title="3.  allowed_seeks–的时机 (2) &amp; DBIter"></a>3.  allowed_seeks–的时机 (2) &amp; DBIter</h4><p>这部分请参考DBIter。</p><h2 id="3-Compaction的执行流程"><a href="#3-Compaction的执行流程" class="headerlink" title="3. Compaction的执行流程"></a>3. Compaction的执行流程</h2><p>选择了要执行的Compaction文件后，剩下的就是执行Compaction：</p><p>==DBImpl::BackgroundCompaction==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;<span class="comment">// trivial move: 下层没有本层的重叠key，修改元数据，移动到下层</span></span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;<span class="comment">// ！！实际compaction的代码</span></span><br><span class="line">   CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">   status = DoCompactionWork(compact);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   CleanupCompaction(compact);</span><br><span class="line">   c-&gt;ReleaseInputs();</span><br><span class="line">   RemoveObsoleteFiles();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure><p>上面的代码说明了：</p><ol><li><p>若没有选择的compaction file，则忽略。</p></li><li><p>IsTrivialMove，若选择的compaction文件，level n没有和level n+1重叠，并且level n的文件没有与过多的祖父level文件重叠，则直接修改元数据（verisonedit）即可，不必compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compaction::IsTrivialMove</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>否则，执行真正的<strong>compaction</strong>。</p></li></ol><h3 id="DoCompactionWork"><a href="#DoCompactionWork" class="headerlink" title="DoCompactionWork"></a>DoCompactionWork</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 创建迭代器, 内部同过mergeiterator对本次要compaction的文件做“排序”（没有排序，只不过通过iter依次访问数据，得到的结果就是排序后的结果）</span></span><br><span class="line">  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">  input-&gt;SeekToFirst();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">     <span class="comment">// 首先做immtable的dump</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CompactMemTable();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.SignalAll();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;key();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//检查当前输出文件是否与level+2层文件有过多冲突，如果是就要完成当前输出文件,并产生新的输出文件</span></span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这里是关键！！</span></span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 正常情况下走这里</span></span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||<span class="comment">// 已经有了user_key?</span></span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;<span class="comment">// 要分析的user_key是否和之前的user_key相同？</span></span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<span class="comment">//进入这个判断，一定时是出现了重复key. 如果前一个序列号都已经比当前smallest_snapshot小了， 现在key的序列号肯定更小，也肯定小于smallest_snapshot，所以直接drop</span></span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">      <span class="comment">// 前一个key的序列号时大于smallest_snapshot，而当前key的序列号小于smallest_snapshot,说名当前key是距离smallest_snapshot最近的key，</span></span><br><span class="line">          <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">          <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;<span class="comment">// 不需要删除，则写入到文件</span></span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = OpenCompactionOutputFile(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">      compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">        status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;Next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = input-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;<span class="comment">// 保存此次压缩结果的元数据 </span></span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的整体流程分3步：</p><ol><li>创建迭代器，内部对本次要compact的文件进行排序。</li><li>丢弃那些被删除的或者旧的文件。</li><li>写入新文件。</li></ol><h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;level() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">   <span class="comment">// !!! list中的每个iter，都指向了一个即将被compaction的sstable</span></span><br><span class="line">  Iterator** <span class="built_in">list</span> = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;level() + which == <span class="number">0</span>) &#123;<span class="comment">// 对第0层的files，通过table_cache创建iter</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="built_in">list</span>[num++] = table_cache_-&gt;NewIterator(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非第0层的fiels，使用TwoLevelIterator来迭代（index iter 和 data iter)</span></span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        <span class="built_in">list</span>[num++] = NewTwoLevelIterator(</span><br><span class="line">            <span class="keyword">new</span> Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(num &lt;= space);</span><br><span class="line">   <span class="comment">// 所有需要的compaction file都有一个iter，现在需要归并排序，这通过mergeiteraotr实现</span></span><br><span class="line">  Iterator* result = NewMergingIterator(&amp;icmp_, <span class="built_in">list</span>, num);</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于mergeiteraotr的具体实现，可参考 mergeitator。</p><h4 id="2-丢弃不需要的kv-pairs（待完善）"><a href="#2-丢弃不需要的kv-pairs（待完善）" class="headerlink" title="2. 丢弃不需要的kv pairs（待完善）"></a>2. 丢弃不需要的kv pairs（待完善）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||<span class="comment">// 已经有了user_key?</span></span><br><span class="line">         user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">             <span class="number">0</span>) &#123;<span class="comment">// 要分析的user_key是否和之前的user_key相同？</span></span><br><span class="line">       <span class="comment">// First occurrence of this user key</span></span><br><span class="line">       current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">       has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">         <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">       last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<span class="comment">//进入这个判断，一定时是出现了重复key. 如果前一个序列号都已经比当前smallest_snapshot小了， 现在key的序列号肯定更小，也肯定小于smallest_snapshot，所以直接drop</span></span><br><span class="line">       <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">       drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">     <span class="comment">// 前一个key的序列号大于smallest_snapshot，而当前key的序列号小于smallest_snapshot,说名当前key是距离smallest_snapshot最近的key，</span></span><br><span class="line">         <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">         <span class="comment">// For this user key:</span></span><br><span class="line">       <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">       <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">       <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">       <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">       <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">       <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">       drop = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     last_sequence_for_key = ikey.sequence;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这部分的第3个分支每看懂。后序补充。</p><h4 id="3-写入不需要drop的kv"><a href="#3-写入不需要drop的kv" class="headerlink" title="3. 写入不需要drop的kv"></a>3. 写入不需要drop的kv</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;<span class="comment">// builder为空，则打开</span></span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第一步：OpenCompactionOutputFile</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::OpenCompactionOutputFile</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> file_number;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    file_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      <span class="comment">// 注意这里的pending_outputs</span></span><br><span class="line">    pending_outputs_.insert(file_number);</span><br><span class="line">    CompactionState::Output out;</span><br><span class="line">    out.number = file_number;</span><br><span class="line">    out.smallest.Clear();</span><br><span class="line">    out.largest.Clear();</span><br><span class="line">     <span class="comment">// 加入到outputs</span></span><br><span class="line">    compact-&gt;outputs.push_back(out);</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the output file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">  Status s = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    compact-&gt;builder = <span class="keyword">new</span> TableBuilder(options_, compact-&gt;outfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个点要注意：</p><ol><li><p>pending_outputs_， 我们来看的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line"><span class="comment">// part of ongoing compactions.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure><p>它是为了避免tables files被误删除的而设计的。那在哪里会被误删除？在CompactMemTable中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="comment">// Commit to the new state</span></span><br><span class="line">  imm_-&gt;Unref();</span><br><span class="line">  imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    <span class="comment">// 这里会删除</span></span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  RecordBackgroundError(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoveObsoleteFiles中使用到了pending_outputs_，因为在合并过程中，刚生成的sstable还不是“live”的，通过<code>pending_outputs_</code>将它们当成 live 的就不会被删除了。</p></li><li><p>将需要保存的kv，放在compact-&gt;outputs中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到outputs</span></span><br><span class="line">compact-&gt;outputs.push_back(out);</span><br></pre></td></tr></table></figure></li></ol><p>第二步，记录最小key和最大key，同时并将要保存的kv加入到builder中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">    compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">  &#125;</span><br><span class="line">  compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">  compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br></pre></td></tr></table></figure><p>第三步，如果当前table已经过大，则输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close output file if it is big enough</span></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">    compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==FinishCompactionOutputFile==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::FinishCompactionOutputFile</span><span class="params">(CompactionState* compact,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Iterator* input)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;outfile != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> output_number = compact-&gt;current_output()-&gt;number;</span><br><span class="line">  assert(output_number != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for iterator errors</span></span><br><span class="line">  Status s = input-&gt;status();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_entries = compact-&gt;builder-&gt;NumEntries();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;/</span><br><span class="line">      <span class="comment">// 构建sstable</span></span><br><span class="line">    s = compact-&gt;builder-&gt;Finish();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;builder-&gt;Abandon();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 统计sstable的大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_bytes = compact-&gt;builder-&gt;FileSize();</span><br><span class="line">  compact-&gt;current_output()-&gt;file_size = current_bytes;</span><br><span class="line">  compact-&gt;total_bytes += current_bytes;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;builder;</span><br><span class="line">  compact-&gt;builder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish and check for file errors</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 写入sstable</span></span><br><span class="line">    s = compact-&gt;outfile-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;outfile;</span><br><span class="line">  compact-&gt;outfile = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; current_entries &gt; <span class="number">0</span>) &#123;<span class="comment">// 验证table是否有效</span></span><br><span class="line">    <span class="comment">// Verify that the table is usable</span></span><br><span class="line">    Iterator* iter =</span><br><span class="line">        table_cache_-&gt;NewIterator(ReadOptions(), output_number, current_bytes);</span><br><span class="line">    s = iter-&gt;status();</span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      Log(options_.info_log, <span class="string">"Generated table #%llu@%d: %lld keys, %lld bytes"</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)output_number, compact-&gt;compaction-&gt;level(),</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_entries,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FinishCompactionOutputFile主完成的工作就是将之前加入的有效kv落盘成一个新的sstable。</p><ol><li><code>compact-&gt;builder-&gt;Finish();</code> 构建sstable的所有块，data block, meta block meta index block, index block,footer.</li><li>记录本次形成的新sstable的大小</li><li>落盘，compact-&gt;outfile-&gt;Sync();</li><li>校验是否正确</li></ol><h4 id="4-元数据修改"><a href="#4-元数据修改" class="headerlink" title="4. 元数据修改"></a>4. 元数据修改</h4><p>经过前面几步，compaction过后的sstable已经持久化到设备上了，现在要做的是修改本次压缩过程中涉及到的sstable的元数据，删除用来compaction的数据，生成compaction后的sstable的元数据。这些都通过一次versionedit来表示，然后通过LogAndApply应用这个edit，生成新edit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>), compact-&gt;compaction-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());<span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);<span class="comment">// 结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);<span class="comment">// 应用edit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑比较简单，将本次操作过程中涉及的文件都加入一个edit中，然后通过LogAndApply应用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-SSTable</title>
    <link href="https://www.ravenxrz.ink/archives/b2082466.html"/>
    <id>https://www.ravenxrz.ink/archives/b2082466.html</id>
    <published>2020-10-12T09:00:00.000Z</published>
    <updated>2020-10-12T09:20:45.444Z</updated>
    
    <content type="html"><![CDATA[<p>上文中，我们介绍了Version和Manifest，这篇文章将介绍leveldb的核心–SStable。</p><h2 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h2><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9iZWFuLWxpLmdpdGh1Yi5pby9sZXZlbGRiLXNzdGFibGUv" title="https://bean-li.github.io/leveldb-sstable/">https://bean-li.github.io/leveldb-sstable/<i class="fa fa-external-link"></i></span></p></blockquote><p><strong>这部分在doc/table_format.md有介绍。</strong></p><p>SSTable文件是落在磁盘上的真正文件，leveldb存储路径中的.sst 类型的文件都是SSTable文件。 本文介绍该文件的格式，以及leveldb如何一条记录一条记录的增加到SSTable文件。</p><a id="more"></a><p>首先要注意，SSTable文件里面存放的是大量的key-value，因为leveldb就是一个key-value DB。我们都买过字典，如果把字典的每一个字当成key，对字的解释当成value，字典就是一个key-value DB。</p><p>在收录几千上万个字的字典中，如何快速寻找到茴香的茴字？</p><p>字典第一个思想是有序，按照一定的顺序收录，如果无序，杂乱无章地收录key-value就会给检索带来麻烦。</p><p>字典的第二个思想是目录，本质是索引，茴读作Hui，因此，在字典中有如下的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A                  ...............................................................页码</span><br><span class="line">B                  ...............................................................页码</span><br><span class="line">C                  ...............................................................页码</span><br><span class="line">D                  ...............................................................页码</span><br><span class="line">E                  ...............................................................页码</span><br><span class="line">F                  ...............................................................页码</span><br><span class="line">H</span><br><span class="line">|____ a             ...............................................................页码</span><br><span class="line">|____ ..            ...............................................................页码</span><br><span class="line">|____ u</span><br><span class="line">      |____ a       ...............................................................页码</span><br><span class="line">      |____ ..      ...............................................................页码</span><br><span class="line">      |____ i       ...............................................................页码</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这两种思想在leveldb中都有体现，但是leveldb的挑战要大于组织一个字典。首先字典的是死的，一旦字典组织好，字典不会发生变动，既不会增加新的内容，也不会删除某一个字，leveldb则不同，leveldb是动态变化的，你无法预测用户会插入多少笔key-value的记录，用户可能修改某条key-value对，也可能删除某条记录。</p><p>另外一个难点是字可以穷尽，但是key-value中的key无法穷举。</p><h2 id="2-SSTable的layout"><a href="#2-SSTable的layout" class="headerlink" title="2. SSTable的layout"></a>2. SSTable的layout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1]</span><br><span class="line">...</span><br><span class="line">[meta block K]</span><br><span class="line">[metaindex block]</span><br><span class="line">[index block]</span><br><span class="line">[Footer]        (fixed size; starts at file_size - sizeof(Footer))</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><p>即：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/sstable_format.png" alt="img"></p><p>首先SSTtable文件不是固定长度的，从上图中也可以看出，文件的内容要能够自解释，就需要有在固定位置有一定数据结构，顺藤摸瓜，理顺文件的内容。</p><h3 id="1-Footer"><a href="#1-Footer" class="headerlink" title="1.Footer"></a>1.Footer</h3><p>对于leveldb而言，Footer是线头，从Footer开始就可以找到该文件的其他组成部分如index block和metaindex block，进而解释整个文件的内容。</p><p>Footer的长度是固定的，因此对于SSTable文件的最后 sizeof(Footer)字节就是存放的Footer信息。 Footer固定48B，如下图所示：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/footer-format.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metaindex_handle: <span class="keyword">char</span>[p];      <span class="comment">// Block handle for metaindex</span></span><br><span class="line">index_handle:     <span class="keyword">char</span>[q];      <span class="comment">// Block handle for index</span></span><br><span class="line">padding:          <span class="keyword">char</span>[<span class="number">40</span>-p-q]; <span class="comment">// zeroed bytes to make fixed length</span></span><br><span class="line"><span class="comment">// (40==2*BlockHandle::kMaxEncodedLength)</span></span><br><span class="line">magic:            fixed64;      <span class="comment">// == 0xdb4775248b80fb57 (little-endian)</span></span><br></pre></td></tr></table></figure><p>其中最后的magic number是固定的长度的8字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const uint64_t kTableMagicNumber &#x3D; 0xdb4775248b80fb57ull;</span><br></pre></td></tr></table></figure><p>为了文件的自解释，内部必须要有指针指向文件的其他位置来表示某个section的开始和结束位置。负责记录这个的变量叫做BlockHandle，他有两个成员变量offset_ 和 size_，分别记录的某个数据块的起始位置和长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlockHandle is a pointer to the extent of a file that stores a data</span></span><br><span class="line"><span class="comment">// block or a meta block.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> offset_;</span><br><span class="line">  <span class="keyword">uint64_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个uint64整数经过varint64编码后最大占用10个字节，一个BlockHandle包含两个uint64类型(size和offset)，则一个BlockHandle最多占用20个字节，即BLockHandle::kMaxEncodedLength=20。metaindex_handle和index_handle最大占用字节为40个字节。magic number占用8个字节，是个固定数值，用于读取时校验是否跟填充时相同，不相同的话就表示此文件不是一个SSTable文件(bad magic number)。padding用于补齐为40字节。</p><p>sstable文件中footer中可以解码出在文件的结尾处距离footer最近的index block的BlockHandle，以及metaindex block的BlockHandle，从而确定这两个组成部分在文件中的位置。</p><p>事实上，在table/table_build.cc中的Status TableBuilder::Finish()函数，我们可以看出，当生成sstable文件的时候，各个组成部分的写入顺序：</p><h3 id="2-sst-layout的源码"><a href="#2-sst-layout的源码" class="headerlink" title="2.sst layout的源码"></a>2.sst layout的源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">   <span class="comment">// 写入data block</span></span><br><span class="line">  Flush();<span class="comment">// 写入还在buffer中的data block到文件中</span></span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入metablock</span></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">      key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.Add(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里按顺序写入了几种block:</p><ol><li>data block</li><li>meta block<ol><li>filter block （目前已经实现）</li><li>后面可选实现</li></ol></li><li>meta index block</li><li>inde block</li><li>footer</li></ol><h2 id="3-Data-Block"><a href="#3-Data-Block" class="headerlink" title="3. Data Block"></a>3. Data Block</h2><p>data block里面存放的东西很简单，就是一个个的key/value 数据对。</p><h3 id="1-向SST中写入一个datablock的过程"><a href="#1-向SST中写入一个datablock的过程" class="headerlink" title="1. 向SST中写入一个datablock的过程"></a>1. 向SST中写入一个datablock的过程</h3><h4 id="处理流程图"><a href="#处理流程图" class="headerlink" title="处理流程图"></a>处理流程图</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/写入一个datablock的流程-1600853106778.png" style="zoom:25%;" /><p>通过TableBuilder::Add函数，可以将一个pair加入到TableBuilder中，至于是否写入到sst中，则需要满足一定条件：</p><p>==TableBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">...</span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当当前data_block的size超过options中的block_size阈值时，将当前的block_size写入到sst中（通过Flush函数）。这也说明，<strong>data_block size不是定长的，但一定是超过4k的（应该是会除了最后一个）。</strong></p><p>options.block_size = 4k</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>==TableBuilder::Flush==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">    <span class="comment">// 实际写入</span></span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 写入成功与否状态</span></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 应用 filter（根据源码来看，目前应该只支持bloom filter)</span></span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作:</p><ol><li>写入数据块</li><li>应用filter</li></ol><p>再稍微的深追一下：</p><p>在Flush中又会调用==TableBuilder::WriteBlock==，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// File format contains a sequence of blocks where each block has:</span></span><br><span class="line">  <span class="comment">//    block_data: uint8[n]</span></span><br><span class="line">  <span class="comment">//    type: uint8</span></span><br><span class="line">  <span class="comment">//    crc: uint32</span></span><br><span class="line">  assert(ok());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;Finish();</span><br><span class="line"></span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type = r-&gt;options.compression;</span><br><span class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line">   <span class="comment">// 压缩</span></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> kNoCompression:</span><br><span class="line">      block_contents = raw;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">      <span class="keyword">if</span> (port::Snappy_Compress(raw.data(), raw.<span class="built_in">size</span>(), compressed) &amp;&amp;</span><br><span class="line">          compressed-&gt;<span class="built_in">size</span>() &lt; raw.<span class="built_in">size</span>() - (raw.<span class="built_in">size</span>() / <span class="number">8u</span>)) &#123;</span><br><span class="line">        block_contents = *compressed;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">        <span class="comment">// store uncompressed form</span></span><br><span class="line">        block_contents = raw;</span><br><span class="line">        type = kNoCompression;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WriteRawBlock(block_contents, type, handle);</span><br><span class="line">  r-&gt;compressed_output.<span class="built_in">clear</span>();</span><br><span class="line">  block-&gt;Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是决定了是否对数据进行压缩，然后将处理后的数据交给==WriteRawBlock==处理，同时从这里我们也可以知道，写入一个key value pair，还会附带两个元数据，type和crc。下图给出实际写入一个datablock的数据格式。</p><h4 id="Record的layout"><a href="#Record的layout" class="headerlink" title="Record的layout"></a>Record的layout</h4><p>data N bytes &lt;= 4k(图少写个=)</p><img data-src="../../../图库/datablock格式.png" style="zoom: 33%;" /><p>最后，调用==TableBuilder::WriteRawBlock==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 写入key value pairs</span></span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::Value(block_contents.data(), block_contents.<span class="built_in">size</span>());</span><br><span class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">      <span class="comment">// 写入元数据 type + crc</span></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.<span class="built_in">size</span>() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-DataBlock是如何达到阈值，然后才写入到sst的？"><a href="#2-DataBlock是如何达到阈值，然后才写入到sst的？" class="headerlink" title="2. DataBlock是如何达到阈值，然后才写入到sst的？"></a>2. DataBlock是如何达到阈值，然后才写入到sst的？</h3><p>回到==TableBuilder::Add==函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>r-&gt;data_block.Add(key, value);</code>为核心：</p><h4 id="前缀压缩机制"><a href="#前缀压缩机制" class="headerlink" title="前缀压缩机制"></a>前缀压缩机制</h4><p>由于在一个data block中存在多个key value paris，且它们相互之间是相互有序的，leveldb为了能够减少冗余存储，使用了key的 前缀压缩机制。假设现在要存储两个key， key1 =”the dog”, key2 = “the world”, 会发现key1和key的前4个字符”the “都是相同的，采用前缀压缩机制，key1继续存储”the dog”,key2只用存储”world”即可。</p><p>除此之外，leveldb在每16次共享后，会取消当前的前缀共享机制，重新存储当前完整的key。</p><p>16次来自：options::block_restart_interval</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of keys between restart points for delta encoding of keys.</span></span><br><span class="line"><span class="comment">// This parameter can be changed dynamically.  Most clients should</span></span><br><span class="line"><span class="comment">// leave this parameter alone.</span></span><br><span class="line"><span class="keyword">int</span> block_restart_interval = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><h4 id="datablock的layout"><a href="#datablock的layout" class="headerlink" title="datablock的layout"></a>datablock的layout</h4><p>所以一个datablock内部是长这样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/data_block_of_sstable.png" alt="img"></p><p>现在来看看<code>data_block_Add(key,value)</code>里面到底是怎么做的：</p><p>==BlockBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  assert(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<span class="comment">// 是否达到16次？</span></span><br><span class="line">      <span class="comment">// 找到与上一个key (last_key_piece)之间共享了多少个字节</span></span><br><span class="line">    <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">      shared++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 达到block_restart_interval，设置restart_point</span></span><br><span class="line">    <span class="comment">// Restart compression</span></span><br><span class="line">    restarts_.push_back(buffer_.<span class="built_in">size</span>());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 剩下的都是非共享的</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.<span class="built_in">size</span>() - shared;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></span><br><span class="line">    <span class="comment">// 写入元数据</span></span><br><span class="line">  PutVarint32(&amp;buffer_, shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">  PutVarint32(&amp;buffer_, value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">  buffer_.append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">    <span class="comment">// 把当前key作为下一个用于比较的key</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码相对简单，首先确定当前要add的key与之前最后一个加入的key的共享长度，非共享长度，然后写入这些元数据(<shared><non_shared><value_size>)， 接着再写入数据（数据只用写非共享长度即可）。<strong>最后将当前key作为下一次add key的比较对象。</strong></p><p>==前缀压缩的时候当前key主要参照的是他/它前面的一个key，而不是起始点的key。==</p><h4 id="key-value-pair的layout"><a href="#key-value-pair的layout" class="headerlink" title="key value pair的layout"></a>key value pair的layout</h4><p>从上面的代码中，我们可以知道datablock里面一个key value pair的数据格式为：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcva2V5" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/key">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/key<i class="fa fa-external-link"></i></span> value pair的数据格式-1600852877733.png)</p><h2 id="4-Index-Block"><a href="#4-Index-Block" class="headerlink" title="4. Index Block"></a>4. Index Block</h2><p>我们在前面说明了如何存放data block，既然可以存放，那自然可以取出来，问题是应该如何存储，注意到sstable内的datablock是有序的，自然会想到采用二分查找的方法来做搜索。leveldb是如何实现data block的搜索的？答案就在这个index block中。</p><p>index block中存放的是data block的索引。看看index block的类型：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200923192147959.png" alt="image-20200923192147959"></p><p>可以看到index block和data_block都是BlockBuilder类型，意味着index_block和data_block的存储格式是相同的。那index_block中一个entry中的key value分别是什么？</p><p>这里先给出答案，假设index block索引到的块为data_block1, data_block1的key=”key1”, 与data_block1相邻的是data_block2, data_block2的key=’key3’, 则 index block entry的key是处于[“key1”,”key3”]之间的key，这里可以取”key2”, 也即:<br>$$<br>index\  entry 索引的data block 的key &lt;= index\  entry的key &lt;= index\ entry索引的data\ block的下一个data\ block的key<br>$$<br>那index entry的value是什么？既然index entry要能索引一个data block， 这个value就是用来存放这个data block的位置信息的， 也即该data block的(offset,size).</p><h3 id="1-Index-Block中一个Index-entry的数据格式"><a href="#1-Index-Block中一个Index-entry的数据格式" class="headerlink" title="1. Index Block中一个Index entry的数据格式"></a>1. Index Block中一个Index entry的数据格式</h3><p>ok，画个图来说明一下:</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读 (2).png" style="zoom:50%;" /><h3 id="2-什么时候会生成一个Index-entry"><a href="#2-什么时候会生成一个Index-entry" class="headerlink" title="2. 什么时候会生成一个Index entry?"></a>2. 什么时候会生成一个Index entry?</h3><p>下面结合源码看一下</p><p>==TableBuilder::Add==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">     <span class="comment">// 添加index entry</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">      <span class="comment">// 计算index entry key</span></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      <span class="comment">// 编码data block的位置信息</span></span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      <span class="comment">// 添加一个index entry</span></span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      <span class="comment">// 生成添加一个index entry后，设置为false,等待下一个data block被Flush</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，是否添加一个index entry, 由pending_index_entry控制。看下它的源码定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We do not emit the index entry for a block until we have seen the</span></span><br><span class="line"><span class="comment">// first key for the next data block.  This allows us to use shorter</span></span><br><span class="line"><span class="comment">// keys in the index block.  For example, consider a block boundary</span></span><br><span class="line"><span class="comment">// between the keys "the quick brown fox" and "the who".  We can use</span></span><br><span class="line"><span class="comment">// "the r" as the key for the index block entry since it is &gt;= all</span></span><br><span class="line"><span class="comment">// entries in the first block and &lt; all entries in subsequent</span></span><br><span class="line"><span class="comment">// blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span></span><br><span class="line"><span class="keyword">bool</span> pending_index_entry;</span><br></pre></td></tr></table></figure><p>上面的意思是说，只有当下一个block的第一个key Add进来时，pending_index_entry会被设置为true.  那什么时候添加一个index entry就很明朗了，==当当前data block被Flush到SST, 且下一个block的第一个key被添加时，会写入一个index entry，用于索引刚才被Flush的block==。</p><p>我们来看看pending_index_entry在源码中是什么时候被设置为true的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">   <span class="comment">// 注意这里的pending_handle, 保存了这个data block的位置信息。</span></span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">      <span class="comment">// 这里被设置为true</span></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数说明了两个点：</p><ol><li><p>解释了pending_index_entry在一个block被flush时才被设置为true.</p></li><li><p>解释了index entry的value，即指向的data block的位置信息是什么时候生成的。 这里在深追一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">    <span class="comment">// 在这里设置</span></span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.<span class="built_in">size</span>());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-index-entry的key是如何计算的？"><a href="#3-index-entry的key是如何计算的？" class="headerlink" title="3. index entry的key是如何计算的？"></a>3. index entry的key是如何计算的？</h3><p>前面说了 index entry key 是介于两个block的key之间的。那它是如何计算的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line">      <span class="comment">// 将计算后的key放在r-&gt;last_key中。</span></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在==FindShortestSeparator==函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* start,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice&amp; limit)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// diff_index指向 start串和limit串的第一个不同点。 或者其中一个是另一个的子串</span></span><br><span class="line">    <span class="comment">// Find length of common prefix</span></span><br><span class="line">  <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::<span class="built_in">min</span>(start-&gt;<span class="built_in">size</span>(), limit.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">size_t</span> diff_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;</span><br><span class="line">         ((*start)[diff_index] == limit[diff_index])) &#123;</span><br><span class="line">    diff_index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diff_index &gt;= min_length) &#123;<span class="comment">// 如果其中一个是另一个的子串， 直接用start串作为entry的key</span></span><br><span class="line">    <span class="comment">// Do not shorten if one string is a prefix of the other</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则</span></span><br><span class="line">    <span class="keyword">uint8_t</span> diff_byte = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">    <span class="keyword">if</span> (diff_byte &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">        diff_byte + <span class="number">1</span> &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(limit[diff_index])) &#123;</span><br><span class="line">      (*start)[diff_index]++;<span class="comment">// 不同的地方+1，使得生成的key 处于 [上一个block key， 下一个block key]</span></span><br><span class="line">      start-&gt;resize(diff_index + <span class="number">1</span>);<span class="comment">// 生成最终key</span></span><br><span class="line">      assert(Compare(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下上面的代码：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-index entry key计算方式.png" style="zoom:50%;" /><p>这里分别说两点：</p><ol><li><p>为什么start可以直接作为entry的key，不是要求entry key要 &lt;=limit吗？ 万一start大于limit了呢？</p><p>这里limit是新block的新key，一定是比旧block的key大的。</p></li><li><p>后半段代码分析</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> diff_byte = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">     <span class="keyword">if</span> (diff_byte &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">         diff_byte + <span class="number">1</span> &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(limit[diff_index])) &#123;</span><br><span class="line">       (*start)[diff_index]++;<span class="comment">// 不同的地方+1，使得生成的key 处于 [上一个block key， 下一个block key]</span></span><br><span class="line">       start-&gt;resize(diff_index + <span class="number">1</span>);<span class="comment">// 生成最终key</span></span><br><span class="line">       assert(Compare(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ol><li><p>取出第一个不同的字节，要求这个字节所对应的 uint8 value &lt;255 并且 该值+1 后的值也小于 Limit对应位置的value。</p></li><li><p>首个不同字节的位置的值+1</p></li></ol><p>这里我描述的不好，所以举个例子：</p><p>==情况1: start不是limit的子串==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*start:    helloleveldb        上一个data block的最后一个key</span><br><span class="line">limit:     helloworld          下一个data block的第一个key</span><br></pre></td></tr></table></figure><p>那么调用FindShortestSeparator后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start变成： hellom (保留前缀，第一个不相同的字符+1)</span><br><span class="line">即l+1 &#x3D; m</span><br></pre></td></tr></table></figure><p>==情况2: start是limit的子串==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*start:    hello               上一个data block的最后一个key</span><br><span class="line">limit:     helloworld          下一个data block的第一个key</span><br></pre></td></tr></table></figure><p>那么调用FindShortestSeparator后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start变成：</span><br><span class="line"> hello</span><br></pre></td></tr></table></figure><h3 id="4-index-block如何持久化到硬件上？"><a href="#4-index-block如何持久化到硬件上？" class="headerlink" title="4. index block如何持久化到硬件上？"></a>4. index block如何持久化到硬件上？</h3><p>上面所做的Add操作，只是将生成的index entry放在内存的index block，如何将index block持久化？</p><p>==TableBuilder::Finish==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write index block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">      r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 持久化index block,并记录index block的位置信息到index_block_handle</span></span><br><span class="line">    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">     <span class="comment">// 记录index block handle的位置信息到footer中</span></span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点都用注释表示了。</p><p>现在再想想如何索引一个key？ 首先找到固定的footer，通过footer找到index block,通过index block找到data block, 在通过data block就可以找到key了。</p><h3 id="5-什么时候持久化index-block"><a href="#5-什么时候持久化index-block" class="headerlink" title="5. 什么时候持久化index block?"></a>5. 什么时候持久化index block?</h3><p>目前有3个地方都调用了 ==TableBuilder::Finish==</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200923203705354.png" alt="image-20200923203705354"></p><p>只有持久化SSTable时，才会持久化index block. 从SSTable的layout也可以看出来，因为一个SSTable只有一个index block。</p><h2 id="5-Meta-Block-amp-Meta-Index-Block"><a href="#5-Meta-Block-amp-Meta-Index-Block" class="headerlink" title="5. Meta Block &amp; Meta Index Block"></a>5. Meta Block &amp; Meta Index Block</h2><p>前面介绍了 footer, data block 和 index block, 似乎已经可以完成数据的存与取，但是这样会带来一个问题，search性能过低的问题。如果每次都从footer-&gt;index block-&gt;data  block-&gt;key / value pair, search性能明显不行。 所以leveldb使用了bloom filter来做优化。</p><p>bloom filter是什么，参数的设定，可参考：</p><p>Onenote中笔记，后序添加。</p><p>这里先给出bloom filter的几个参数：</p><ol><li>m: bloom filter的比特位数</li><li>n: 预计的key的个数</li><li>k: 使用的hash function的个数</li></ol><h3 id="1-BloomFilterPolicy："><a href="#1-BloomFilterPolicy：" class="headerlink" title="1. BloomFilterPolicy："></a>1. BloomFilterPolicy：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterPolicy</span> :</span> <span class="keyword">public</span> FilterPolicy &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">    k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">    <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">"leveldb.BuiltinBloomFilter2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">    <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">    <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">    dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">    dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">      <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">      <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">        <span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">        h += delta;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the encoded k so that we can read filters generated by</span></span><br><span class="line">    <span class="comment">// bloom filters created using different parameters.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</span><br><span class="line">      <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></span><br><span class="line">      <span class="comment">// Consider it a match.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> bits_per_key_;<span class="comment">// m/n</span></span><br><span class="line">  <span class="keyword">size_t</span> k_;<span class="comment">// hash function 个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BloomFilterPolicy</span><span class="params">(<span class="keyword">int</span> bits_per_key)</span> : <span class="title">bits_per_key_</span><span class="params">(bits_per_key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></span><br><span class="line">  k_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></span><br><span class="line">  <span class="keyword">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bloom filter的初始化只用到了bits_per_key, hash function个数可以通过计算得到:<br>$$<br>k = bits_per_key \times log2<br>$$</p><h4 id="2-CreateFilter"><a href="#2-CreateFilter" class="headerlink" title="2. CreateFilter"></a>2. CreateFilter</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.得到bloom filter用的bit数</span></span><br><span class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></span><br><span class="line">  <span class="keyword">size_t</span> bits = n * bits_per_key_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></span><br><span class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></span><br><span class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">  bits = bytes * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;<span class="built_in">size</span>();</span><br><span class="line">  dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</span><br><span class="line">  dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></span><br><span class="line">  <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">// 外循环计算每个key，n代表key的个数</span></span><br><span class="line">    <span class="comment">// Use double-hashing to generate a sequence of hash values.</span></span><br><span class="line">    <span class="comment">// See analysis in [Kirsch,Mitzenmacher 2006].</span></span><br><span class="line">    <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123; <span class="comment">// 内循环计算多个hash</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">      <span class="built_in">array</span>[bitpos / <span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</span><br><span class="line">      h += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一说的是，在代码末尾计算多个hash时，并不是真的用了多个hash函数（多hash计算浪费计算资源），而是采用了<code>[Kirsch,Mitzenmacher 2006]</code>中的方法，一个hash函数，然后移位的方法来替代多次hash。</p><blockquote><p>Leveldb使用了double hashing来模拟多个hash函数，当然这里不是用来解决冲突的。</p><p>和线性再探测（linearprobing）一样，Double hashing从一个hash值开始，重复向前迭代，直到解决冲突或者搜索完hash表。不同的是，double hashing使用的是另外一个hash函数，而不是固定的步长。</p><p>给定两个独立的hash函数h1和h2，对于hash表T和值k，第i次迭代计算出的位置就是：h(i, k) = (h1(k) + i*h2(k)) mod |T|。</p><p>对此，Leveldb选择的hash函数是：</p><p>Gi(x)=H1(x)+iH2(x)</p><p>H2(x)=(H1(x)&gt;&gt;17) | (H1(x)&lt;&lt;15)</p><p>H1是一个基本的hash函数，H2是由H1循环右移得到的，Gi(x)就是第i次循环得到的hash值。【理论分析可参考论文Kirsch,Mitzenmacher2006】</p></blockquote><blockquote><p>注意，因为sstable中key的个数可能很多，当攒了足够多个key值，就会计算一批位图，再攒一批key，又计算一批位图，那么这么多bloom filter的位图，必需分隔开，否则就混了。</p><p>也就说，位图与位图的边界必需清晰，否则就乱了。</p></blockquote><p>==FilterBlockBuilder::GenerateFilter==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// tmp_keys中存放本轮要进行计算的keys</span></span><br><span class="line">  <span class="comment">// Make list of keys from flattened key structure</span></span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// Simplify length computation</span></span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">      <span class="comment">// keys_中存放了所有key，通过偏移量start[i]和length (start[i+1] - start[i]) 得到一个key</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];</span><br><span class="line">    tmp_keys_[i] = Slice(base, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一轮计算的结果</span></span><br><span class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 计算本轮keys的filter 位图，并将结果放入到result_中</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空本轮涉及的所有keys</span></span><br><span class="line">  tmp_keys_.<span class="built_in">clear</span>();</span><br><span class="line">  keys_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start_和keys是如何生成的？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  Slice k = key;</span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());<span class="comment">// 记录当前已经存入的keys的size，可以在后面用这些size来分割出每个key的长度</span></span><br><span class="line">  keys_.append(k.data(), k.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数在<code>TableBuilder::Add</code>中被调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">   xxx</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// !!</span></span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br></pre></td></tr></table></figure><p>result_是一个长字节数组（string表示）。里面存放了多论filter位图的计算结果。每次计算都在result_后面apped.</p><h4 id="3-FilterBlockBuilder结构"><a href="#3-FilterBlockBuilder结构" class="headerlink" title="3. FilterBlockBuilder结构"></a>3. FilterBlockBuilder结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FilterBlockBuilder is used to construct all of the filters for a</span></span><br><span class="line"><span class="comment">// particular Table.  It generates a single string which is stored as</span></span><br><span class="line"><span class="comment">// a special block in the Table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The sequence of calls to FilterBlockBuilder must match the regexp:</span></span><br><span class="line"><span class="comment">//      (StartBlock AddKey*)* Finish</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*注意本轮keys产生的位图计算完毕后，会将keys_, start_ ,还有tmp_keys_ 清空*/</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;              <span class="comment">// 暂时存放本轮所有keys，追加往后写入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;     <span class="comment">// 记录本轮key与key之间的边界的位置，便于分割成多个key</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;            <span class="comment">// 计算出来的位图，多轮计算则往后追加写入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   <span class="comment">// 将本轮的所有key，存入该vector，其实并无存在的必要，用临时变量即可</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_; <span class="comment">//计算出来的多个位图的边界位置，用于分隔多轮keys产生的位图</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-when-amp-how-to-得到filter-和-filter-offset？"><a href="#4-when-amp-how-to-得到filter-和-filter-offset？" class="headerlink" title="4. when &amp; how to 得到filter 和 filter offset？"></a>4. when &amp; how to 得到filter 和 filter offset？</h4><p>==FilterBlockBuilder::StartBlock==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See doc/table_format.md for an explanation of the filter block format.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate new filter every 2KB of data</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg;</span><br><span class="line"></span><br><span class="line">FilterBlockBuilder::FilterBlockBuilder(<span class="keyword">const</span> FilterPolicy* policy)</span><br><span class="line">    : policy_(policy) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  assert(filter_index &gt;= filter_offsets_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码注释上来看，每2kb的data就会生成一个filter。但真的是这样吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);<span class="comment">// 计算当前offset所在位置的数据的filter index，入 block_offset=3k,则filter_indx=1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　filter_offsets_.size() 返回的是当前整个sstable的filter 个数</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-how"><a href="#1-how" class="headerlink" title="1. how"></a>1. how</h5><p>假设（注意我说的是假设）GenerateFilter一次处理2kb数据，filter_offsets_.size() 会+1，则上面的代码即将data按照2kb分一个filter来处理。但是实际上==GenerateFilter==的处理方式并不是按2kbf分块处理为，但可确定是，GenerateFilter函数内部，每进行一轮计算，filter_offsets_.size()会+1.</p><p>下面看看GenerateFilter的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据前面说所，可推得start_.size()为当前Add进来的key的个数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过start_和key_将 所有添加的key加入到tmp_keys_中。</span></span><br><span class="line">  <span class="comment">// Make list of keys from flattened key structure</span></span><br><span class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// Simplify length computation</span></span><br><span class="line">  tmp_keys_.resize(num_keys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];</span><br><span class="line">    tmp_keys_[i] = Slice(base, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 为所有添加进来的 keys 生成一个 Filter，并将结果 append到 result_中</span></span><br><span class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// ！filter_offsets_.size() +1</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br><span class="line"></span><br><span class="line">  tmp_keys_.<span class="built_in">clear</span>();</span><br><span class="line">  keys_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取上面的代码，我们可以知道，在一次==GenerateFilter==中，就处理完了之前所有Add进来的keys，此时 filter_offsets_的size只+1，所以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个循环，仍在继续。而后序的调用会进入到这个分支：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据前面说所，可推得start_.size()为当前Add进来的key的个数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_keys = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 只增加filter_offsets_的size，没有生成新的filter</span></span><br><span class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外还有没有说的是，filter_offsets_存放的就是各个filter的位置信息（偏移量）。所以除了第一次调用GenerateFilter会生成一个filter，后序的都是空filter。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>假设当前已经插入的data block大小达到6kb，则GenerateFilter会调用三次。下面给出filter block的图解：</p><p>第一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 为所有添加进来的 keys 生成一个 Filter，并将结果 append到 result_中</span></span><br><span class="line"><span class="comment">// Generate filter for current set of keys and append to result_.</span></span><br><span class="line">filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// ！filter_offsets_.size() +1</span></span><br><span class="line">policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block插入流程1 (1).png" style="zoom: 33%;" /><p>第二次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// 此时第一次调用已经使得result_ size增加, 假设这里增加了9</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://pic.downk.cc/item/5f7184db160a154a670fe620.png" style="zoom: 33%;" /><p>第三次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Fast path if there are no keys for this filter</span></span><br><span class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());<span class="comment">// 此时result未发生变化，size依然等于9</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block插入流程3.png" style="zoom:33%;" /><p>这看起来似乎有点奇怪， 注释中说的是一个filter对应2kb的data block, 一个filter offset应该对应一个filter才对，但是这里多个filter offset对应到了一个filter。留个悬念，下面的 <code>KeyMayMatch</code>中会进行讲解。</p><h5 id="2-when"><a href="#2-when" class="headerlink" title="2. when"></a>2. when</h5><p>现在，回到问题，什么时候发起一轮位图计算（即生成一个filter）。</p><p>答案：Flush函数。</p><p>==TableBuilder::Flush==调用==FilterBlockBuilder::StartBlock==:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// !! </span></span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候Flush?</p><p>当前 data_block超过阈值4kb时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-生成filter的调用流程图"><a href="#5-生成filter的调用流程图" class="headerlink" title="5. 生成filter的调用流程图"></a>5. 生成filter的调用流程图</h4><p>![leveldb源码阅读-copy-第 3 页](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第<i class="fa fa-external-link"></i></span> 3 页.png)</p><h4 id="6-KeyMayMatch"><a href="#6-KeyMayMatch" class="headerlink" title="6. KeyMayMatch"></a>6. KeyMayMatch</h4><p>前面说了何时以及如何生成filter和filter offset，有了这两样，我们应该如何使用filter？</p><p><strong>==传入 data_block 的 block_offset==</strong>, 计算给定key是否在这个data block中。</p><p>传入 data_block 的 block_offset</p><p>传入 data_block 的 block_offset。</p><p>重要的事情说3遍。<strong>传入的的参数是一个block的起始offset，而不是一个key所在data block的offset。</strong></p><p>先看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FilterBlockReader::KeyMayMatch</span><span class="params">(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> index = block_offset &gt;&gt; base_lg_;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; num_) &#123;</span><br><span class="line">      <span class="comment">// 启始偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> start = DecodeFixed32(offset_ + index * <span class="number">4</span>);</span><br><span class="line">     <span class="comment">// 结尾偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> limit = DecodeFixed32(offset_ + index * <span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(offset_ - data_)) &#123;<span class="comment">// 考虑一下，什么时候start会=limit</span></span><br><span class="line">        <span class="comment">// 得到filter</span></span><br><span class="line">      Slice filter = Slice(data_ + start, limit - start);</span><br><span class="line">        <span class="comment">// 正式匹配</span></span><br><span class="line">      <span class="keyword">return</span> policy_-&gt;KeyMayMatch(key, filter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;</span><br><span class="line">      <span class="comment">// Empty filters do not match any keys</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Errors are treated as potential matches</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 return policy_-&gt;KeyMayMatch(key, filter);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"> xxx</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// bloom filter 的hash index判断，只要有一个0，则返回false，都为1，返回true</span></span><br><span class="line">  <span class="keyword">uint32_t</span> h = BloomHash(key);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos / <span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    h += delta;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设之前写入了两个data block，一个6kb，一个4kb，则对应的data block和 filter block如下:</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 12 页 (5).png" style="zoom:33%;" /><p>现在判定一个key是否在data block1, 只用传入data block1起始地址0， 计算得到 index = 0, 则start= 0，limit=9， 所以得到filter的地址未0-9.</p><p>判定一个key是否在data block2， 传入data block2起始地址6k，计算得到index=3，则start=9,limit=15。</p><p>这回答了一个问题，中间 filter offset 1, filter offset 2虽然指向了同一个filter，但是实际上，filter offset2从不会被访问，所以并不影响。==<strong>那为什么要这样设计呢？</strong>==</p><p>想想如何没有这 ”2kb分块“的设计，我们是无法快速的 通过一个block_offset就定位到一个filter offset，进而定位到filter。所以这样的设计还是很巧妙的。</p><p>==<strong>另外，还有个问题</strong>==</p><p>什么时候:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start == limit</span><br></pre></td></tr></table></figure><p>filter 为空时。 </p><h3 id="2-Meta-Block-在SSTable中的布局"><a href="#2-Meta-Block-在SSTable中的布局" class="headerlink" title="2. Meta Block 在SSTable中的布局"></a>2. Meta Block 在SSTable中的布局</h3><h4 id="1-什么时候写入Meta-Block（持久化-filter-block"><a href="#1-什么时候写入Meta-Block（持久化-filter-block" class="headerlink" title="1. 什么时候写入Meta Block（持久化 filter block)"></a>1. 什么时候写入Meta Block（持久化 filter block)</h4><p>==TableBuilder::Finish==中:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="comment">// ！！这里写入filter_block！！</span></span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">      key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      meta_index_block.Add(key, handle_encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">FilterBlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append array of per-filter offsets</span></span><br><span class="line">    <span class="comment">// result_.size()是总filter的长度，也是 filter_offsets的起始偏移量</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PutFixed32(&amp;result_, array_offset);</span><br><span class="line">    <span class="comment">// filter编码参数</span></span><br><span class="line">  result_.push_back(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result</span></span><br><span class="line">  <span class="keyword">return</span> Slice(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Meta-Block（filter-block）-amp-Meta-Index-Block的布局"><a href="#2-Meta-Block（filter-block）-amp-Meta-Index-Block的布局" class="headerlink" title="2. Meta Block（filter block）&amp; Meta Index Block的布局"></a>2. Meta Block（filter block）&amp; Meta Index Block的布局</h4><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-filter block的layout (1).png" style="zoom:50%;" /><h4 id="3-meta-index-block的写入"><a href="#3-meta-index-block的写入" class="headerlink" title="3. meta index block的写入"></a>3. meta index block的写入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write metaindex block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">    key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    meta_index_block.Add(key, handle_encoding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">  WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta index block和 data block以及index block一样，都是BlockBuilder类型。</p><p>key: meta index block的key是 <strong>filter.Name</strong>, 其中，Name来自 filter_policy-&gt;Name()调用。</p><p>value:  value是filter_block_handle,也就是 filter_block的位置信息。 还记得位置信息是在哪里生成的吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Write filter block</span></span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="comment">// !! 这里生成的 filter_block_handle信息s</span></span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write metaindex block</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文中，我们介绍了Version和Manifest，这篇文章将介绍leveldb的核心–SStable。&lt;/p&gt;
&lt;h2 id=&quot;SSTable&quot;&gt;&lt;a href=&quot;#SSTable&quot; class=&quot;headerlink&quot; title=&quot;SSTable&quot;&gt;&lt;/a&gt;SSTable&lt;/h2&gt;&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iZWFuLWxpLmdpdGh1Yi5pby9sZXZlbGRiLXNzdGFibGUv&quot; title=&quot;https://bean-li.github.io/leveldb-sstable/&quot;&gt;https://bean-li.github.io/leveldb-sstable/&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这部分在doc/table_format.md有介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSTable文件是落在磁盘上的真正文件，leveldb存储路径中的.sst 类型的文件都是SSTable文件。 本文介绍该文件的格式，以及leveldb如何一条记录一条记录的增加到SSTable文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Version数据结构及MANIFEST文件</title>
    <link href="https://www.ravenxrz.ink/archives/90a4812e.html"/>
    <id>https://www.ravenxrz.ink/archives/90a4812e.html</id>
    <published>2020-10-12T03:19:43.000Z</published>
    <updated>2020-10-12T08:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>文本要介绍一个在leveldb中相当重要的数据结构 - Version及其相关的VersionEdit和VersionSet。理解了这些内容后，我们会提到leveldb系统中MANIFEST文件。</p><a id="more"></a><h1 id="1-Version"><a href="#1-Version" class="headerlink" title="1. Version"></a>1. Version</h1><p>为什么要用version控制？</p><p>对于同一笔记录，如果读和写同一时间发生，reader可能读到不一致的数据或者是修改了一半的数据。对于这种情况，有三种常见的解决方法：</p><ul><li>悲观锁  ，最简单的处理方式，就是加锁保护，写的时候不许读，读的时候不许写。效率低。 </li><li>乐观锁   它假设多用户并发的事物在处理时不会彼此互相影响，各事务能够在不产生锁的的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。 果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生死锁， 但如果数据竞争的概率较高，效率也会受影响 。</li><li>MVCC，MVCC是一个数据库常用的概念。Multiversion concurrency control多版本并发控制。每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到;当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本, 此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</li></ul><p>leveldb中的version就是MVCC思想的体现。</p><h2 id="1-VersionEdit结构"><a href="#1-VersionEdit结构" class="headerlink" title="1. VersionEdit结构"></a>1. VersionEdit结构</h2><p>前面说了整个version相关的数据结构是用来实现MVCC的，这也意味这系统中存在多个版本，那我们是如何从上一个历史版本走到这个版本的？这就是通过VersionEdit来实现的。</p><p>VersionEdit是LevelDB两个Version之间的差量，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Versoin0 + VersoinEdit &#x3D; Version1</span><br></pre></td></tr></table></figure><p>差量包括本次操作，新增的文件和删除的文件。</p><p>看看VersionEdit的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"> <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"> <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line"> SequenceNumber last_sequence_;</span><br><span class="line"> <span class="keyword">bool</span> has_comparator_;</span><br><span class="line"> <span class="keyword">bool</span> has_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"> <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;<span class="comment">// 存放这个version的压缩指针，pair.first对应哪一个level， pair.second 对应哪一个key开始compaction</span></span><br><span class="line"> DeletedFileSet deleted_files_;<span class="comment">// 本次操作要删除的文件</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;<span class="comment">// 本次操作新增的文件</span></span><br></pre></td></tr></table></figure><p>关注最后3个， compacton_pointers暂时不管，<strong>delted_files_, new_files_是这次版本修改的差量。</strong></p><p><strong>关注new_files_中的FileMetaData，因为一次版本修改新增的文件是这个类的集合，</strong></p><h2 id="2-FileMetaData"><a href="#2-FileMetaData" class="headerlink" title="2. FileMetaData"></a>2. FileMetaData</h2><p>FileMetaData是每个Version内部维持的文件，每层中都有多个FileMetaData， 一个FileMetaData用于描述一个sstable的相关信息，是sstable的元数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// Seeks allowed until compaction，用于基于seek compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;<span class="comment">// 这个number用来唯一标识一个sstable，还记得文件命名中的编号吗？</span></span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes 文件大小</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table 最小key</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table 最大key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各字段都在注释中解释，我们可以得到一个信息，在SSTable中存放的是key是InternalKey， 对应了 <a href="https://www.ravenxrz.ink/archives/aba77258.html">MemTable</a> 文章中说的Key类型。</p><h2 id="3-Version结构"><a href="#3-Version结构" class="headerlink" title="3. Version结构"></a>3. Version结构</h2><p>来看看Version的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里看出leveldb在系统中维护的version组成一个链表，且系统中可能存在多个VersionSet。每个Set维护一（多）组Version</span></span><br><span class="line"> VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line"> Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line"> Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"> <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version  // 引用计数，估计和回收Version相关</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 每层的files, 每个file都是FileMetadata</span></span><br><span class="line"> <span class="comment">// List of files per level</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[<span class="built_in">config</span>::kNumLevels];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line"> FileMetaData* file_to_compact_;<span class="comment">// compaction过程会用到</span></span><br><span class="line"> <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// compaction相关，根据compactoin_score_决定是否需要compaction</span></span><br><span class="line"> <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"> <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line"> <span class="comment">// are initialized by Finalize().</span></span><br><span class="line"> <span class="keyword">double</span> compaction_score_;</span><br><span class="line"> <span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure><p>next_和prev_指针，表明version之间组成一个双链表。</p><p>files_表示了这个版本下整个系统的所有sstable的元数据。</p><p>下面是和compaction相关的结构。</p><h2 id="4-VersionSet结构"><a href="#4-VersionSet结构" class="headerlink" title="4. VersionSet结构"></a>4. VersionSet结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscname, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs, InternalKey* smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="function"><span class="params">InternalKey* smallest, InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save current contents to *log</span></span><br><span class="line"><span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(<span class="built_in">log</span>::Writer* <span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">Env* <span class="keyword">const</span> env_;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line"><span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">TableCache* <span class="keyword">const</span> table_cache_;<span class="comment">// cache相关</span></span><br><span class="line"><span class="keyword">const</span> InternalKeyComparator icmp_;<span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;<span class="comment">// !!!前面文件编号文章中重点想说的就是这个变量</span></span><br><span class="line"><span class="keyword">uint64_t</span> manifest_file_number_;<span class="comment">// 当前manifest文件</span></span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence_;<span class="comment">// 这个序列号是用来表示Internal key中的序列号</span></span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;<span class="comment">// log文件序列号</span></span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Opened lazily</span></span><br><span class="line">WritableFile* descriptor_file_;</span><br><span class="line"><span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.链表head</span></span><br><span class="line">Version* current_;        <span class="comment">// == dummy_versions_.prev_ 当前version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次compaction时，每层compaction的开始key</span></span><br><span class="line"><span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line"><span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[<span class="built_in">config</span>::kNumLevels];</span><br></pre></td></tr></table></figure><p>VersionSet维护了所有有效的version，内部采用双链表的结构来维护。</p><p>下图展示了这几个数据结构之间的关系，引用自：<span class="exturl" data-url="aHR0cHM6Ly9iZWFuLWxpLmdpdGh1Yi5pby9sZXZlbGRiLXZlcnNpb24v" title="https://bean-li.github.io/leveldb-version/">https://bean-li.github.io/leveldb-version/<i class="fa fa-external-link"></i></span></p><p><img data-src="https://bean-li.github.io/assets/LevelDB/version_versionset.png" alt="img"></p><p>一个version维护整个系统中的所有sstable文件的元数据，versionset维护多个version，显然我们不可能无限增加version个数。那如何清理version？</p><p>LevelDB会触发Compaction，能对一些文件进行清理操作，让数据更加有序，清理后的数据放到新的版本里面，而老的数据作为原始的素材，最终是要清理掉的，但是如果有读事务位于旧的文件，那么暂时就不能删除。因此利用引用计数，只要一个Verison还活着，就不允许删除该Verison管理的所有文件。当一个Version生命周期结束，它管理的所有文件的引用计数减1.</p><p>当一个version被销毁时，每个和它想关联的file的引用计数都会-1，当引用计数小于=0时，file被删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-如何应用VersionEdit-Version-New-Version"><a href="#2-如何应用VersionEdit-Version-New-Version" class="headerlink" title="2. 如何应用VersionEdit+Version = New Version"></a>2. 如何应用VersionEdit+Version = New Version</h1><p>前面说到， Version + VersionEdit = new Version，如何应用这个增量呢？</p><p>具体的操作是在VersionSet中的Builder中的。</p><p>首先可以看到，Builder是在 LogAndApply和Recover中被调用的：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210900575.png" alt="image-20200917210900575" style="zoom:50%;" /><p>重点看一下LogAndApply</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200917210931871.png" alt="image-20200917210931871" style="zoom:50%;" /><p>可以看到，一共有4个函数调用了LogAndApply，DB打开时，其余3个都是和Compaction相关。</p><h2 id="1-VersionEdit记录一次操作中涉及的文件过程"><a href="#1-VersionEdit记录一次操作中涉及的文件过程" class="headerlink" title="1. VersionEdit记录一次操作中涉及的文件过程"></a>1. VersionEdit记录一次操作中涉及的文件过程</h2><blockquote><p>因为和Compaction过程相关，所以初次看不懂没关系，只用记住VersionEdit是用来保存一次操作过程涉及的文件的差量的。</p></blockquote><p>说LogAndApply之前，先说一下VersionEdit是如何保存一次操作过程中的涉及的文件的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet; <span class="comment">// level和filenumber的pair</span></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;<span class="comment">// level和filemetadata</span></span><br></pre></td></tr></table></figure><p>先看==<strong>deleted_files_</strong>:==</p><p>只在RemoveFile函数调用中，增加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete the specified "file" from the specified "level".</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>&#123;</span><br><span class="line">  deleted_files_.insert(<span class="built_in">std</span>::make_pair(level, file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RemoveFile函数调用，有两个函数caller:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194127291.png" alt="image-20201006194127291"></p><p>AddInputDeletions， 在常规compaction中，加入所有选中了的compaction文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compaction::AddInputDeletions</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs_[which].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// !!!</span></span><br><span class="line">      edit-&gt;RemoveFile(level_ + which, inputs_[which][i]-&gt;number);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BackgroundCompaction，只看上层与下层不重叠的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// !!!!</span></span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再看==<strong>new_files_</strong>==</p><p>new_files_在==<strong>AddFile</strong>==中增加：‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddFile被下图中的3各函数call：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201006194516231.png" alt="image-20201006194516231"></p><p>WriteLevel0Table中是memtable dump 到level0所生成的新文件。</p><p>BackgroundCompaction是上层与下层不重叠的情况，紧接着是InstallCompactionResults：</p><p>InstallCompactionResults：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">     <span class="comment">// 在level+1中生成新文件的结果</span></span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-LogAndApply"><a href="#2-LogAndApply" class="headerlink" title="2. LogAndApply"></a>2. LogAndApply</h2><p>有了VersionEdit，自然就要分析下如何应用这个Edit了。</p><p>看一下LogAndApply的工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 为edit绑定log_number</span></span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!应用edit到当前版本</span></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 通过本次version，计算下一次compaction相关变量，（compaction level和compaction score)</span></span><br><span class="line">  Finalize(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面和Manifest文件相关</span></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">     <span class="comment">// new_manifest_file为当前manifest文件路径</span></span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">     <span class="comment">// 创建文件</span></span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 创建manifest写者</span></span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">        <span class="comment">// edit内容编码到record !!, 可以看一下是怎么编码的，这样就知道manifest文件中保存的内容布局了</span></span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">       <span class="comment">// 写入manifest文件</span></span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          <span class="comment">// 刷新到设备上</span></span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新Current指针</span></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 插入当前version到VersionSet中</span></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">     <span class="comment">// 插入version，更新current</span></span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作：</p><ol><li>执行 old version + version_edit = new version</li><li>编码versionedit，并将其写入到manifest中，同时修改 CURRENT 指针</li><li>将新生成的version插入到versionset中</li></ol><p>current_版本的更替时机一定要注意到，LogAndApply生成新版本之后，同时将VersionEdit记录到MANIFEST文件之后，不然系统一旦crash，虽然数据不会丢失，但是系统后续启动时的性能会降低。（这段话不理解也没关系，等待后面对会专门出文章分析系统是如何启动的）。</p><h3 id="1-Builder"><a href="#1-Builder" class="headerlink" title="1.Builder"></a>1.Builder</h3><p>接下来需要重点分析下面三行代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// !!!应用edit到当前版本</span></span><br><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">  builder.Apply(edit);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以builder自然是重点分析对象：</p><p>builder的内部数据域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">  FileSet* added_files;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VersionSet* vset_;</span><br><span class="line">Version* base_;</span><br><span class="line">LevelState levels_[<span class="built_in">config</span>::kNumLevels];<span class="comment">// 本次操作造成每层的数据变化</span></span><br></pre></td></tr></table></figure><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><p>==Builder的构造函数：==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"> <span class="comment">// Initialize a builder with the files from *base and other info from *vset</span></span><br><span class="line"> Builder(VersionSet* vset, Version* base) : vset_(vset), base_(base) &#123;</span><br><span class="line">   base_-&gt;Ref();</span><br><span class="line">   BySmallestKey cmp;</span><br><span class="line">   cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">     levels_[level].added_files = <span class="keyword">new</span> FileSet(cmp);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里只是完成了一些初始化工作。 这里使用了一个BySmallestKey比较器，简单看下实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BySmallestKey</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData* f1, FileMetaData* f2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);<span class="comment">// 按照smallest key比较</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (r &lt; <span class="number">0</span>);<span class="comment">// 按照最小key升序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Break ties by file number</span></span><br><span class="line">      <span class="keyword">return</span> (f1-&gt;number &lt; f2-&gt;number);<span class="comment">// 按照文件序列升序，由于文件序列号越小，文件越旧，所以这里是按照文件从旧到新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Apply"><a href="#2-Apply" class="headerlink" title="2. Apply"></a>2. Apply</h4><p><strong>将edit中的更改保存在builder中。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;<span class="comment">// first为 level</span></span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString(); <span class="comment">// second 为 这一level开始compaction的key</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files 删除文件保存在builder中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);<span class="comment">// delete 的 file用number表示</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略compaction相关代码</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);<span class="comment">// 这里非常奇怪，将再SaveTo函数里面谈一点个人的理解</span></span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码注释说明了逻辑：</p><ol><li>更新compaction指针</li><li>保存操作中删除了的文件</li><li>保存操作中新增的文件</li></ol><p><strong>注意，added_files添加完元素后，内部是按照smallest key排序（如果smallest key相同则按照文件旧-&gt;新排序）的，这一点很重要，不然不好理解下面的SaveTo函数</strong></p><h4 id="3-SaveTo"><a href="#3-SaveTo" class="headerlink" title="3. SaveTo"></a>3. SaveTo</h4><p>builder中经过Apply已经保存了这次操作的增量，通过SaveTo将这个增量融合到Version中去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">    BySmallestKey cmp;<span class="comment">// 按照smallestkey比较，如果key相同，按照file number比较。</span></span><br><span class="line">    cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;<span class="comment">// 一层层的合并</span></span><br><span class="line">      <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">      <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">      v-&gt;files_[level].reserve(base_files.<span class="built_in">size</span>() + added_files-&gt;<span class="built_in">size</span>());</span><br><span class="line">      <span class="comment">// 小于added_files的key 的 当前版本中的文件，全部加入新版本中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">        <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                 <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">             base_iter != bpos; ++base_iter) &#123;</span><br><span class="line"></span><br><span class="line">          MaybeAddFile(v, level, *base_iter);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 加入 added_file</span></span><br><span class="line">        MaybeAddFile(v, level, added_file);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩余文件整合</span></span><br><span class="line">      <span class="comment">// Add remaining base files</span></span><br><span class="line">      <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 下面是检查level&gt;0是否有overlap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">          <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">          <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                         prev_end.DebugString().c_str(),</span><br><span class="line">                         this_begin.DebugString().c_str());</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>base_存放的是当前系统版本，我们的目标是使用当前versionedit+base_得到一个新的version。这里的工作就是将builder中的文件+base_中的文件融合后加入到version中。核心逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">                <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">            base_iter != bpos; ++base_iter) &#123;</span><br><span class="line"></span><br><span class="line">         MaybeAddFile(v, level, *base_iter);</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="comment">// 加入 added_file</span></span><br><span class="line">       MaybeAddFile(v, level, added_file);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>引用Api文档中对std中的upper_bound的作用的解释：</p><blockquote><p>函数签名：</p><p>template&lt; class ForwardIt, class T, class Compare &gt;<br>ForwardIt upper_bound( ForwardIt first, ForwardIt last, const T&amp; value, Compare comp );</p><p>解释：</p><p>Returns an iterator pointing to the first element in the range <code>[first, last)</code> that is <em>greater</em> than <code>value</code>, or <code>last</code> if no such element is found.</p></blockquote><p>具体例子，假设有<code>[1,3,7,8]</code>, 现在value设置为5， 则upper_bound返回的iterator指向 7.</p><p>有了对upper_bound的理解+ added_files内部是有序的前提，就不难理解这个循环了。画个图：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-第 29 页.png" style="zoom:33%;" /><p>第一次循环：added_file=2，bpos指向7，所以base_iter只能添加1，接着添加added_file=2.</p><p>第二次循环，added_file=3,bpos指向7，因为base_iter已经指向7，所以不从base_添加，只加入3</p><p>第三次循环, added_file=11, bpos指向15，从base_中添加7和10，再添加added_file=11</p><p>第四次循环，added_file=16，bpos指向<code>last</code>，从base_中添加15，再添加added_file=16</p><p>最终可得如图所示结果。</p><p>不过这一切都建立在added_files中的所有文件都会添加到最终version，但实际上却不一定，所以用了<code>MaybeAddFile</code> 可能添加File：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// File is deleted: do nothing  // 在删除列表中，文件将被删除，不用添加</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">// </span></span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">     <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;<span class="comment">// 考虑level&gt;0, 要求key不能overlap</span></span><br><span class="line">       <span class="comment">// Must not overlap</span></span><br><span class="line">       assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                   f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     f-&gt;refs++;<span class="comment">//  当前新版本v 对file有引用，所以refs++</span></span><br><span class="line">     files-&gt;push_back(f); <span class="comment">// 实际压入到新版本</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过 deleted_files来判定是否需要添加这个文件,如果deleted_files中没有该file number，则可以添加，否则不能添加。现在联系前面留下的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">levels_[level].deleted_files.erase(f-&gt;number);<span class="comment">// 这里非常奇怪，将再SaveTo函数里面谈一点个人的理解</span></span><br><span class="line">levels_[level].added_files-&gt;insert(f);</span><br></pre></td></tr></table></figure><p>这两行代码会觉得非常奇怪，为什么前期加上了要删除的文件，这里却又要删除了？以下只是我个人的看法，<strong>经过我个人的测试，正常情况和系统crash的情况下，<code>levels_[level].deleted_files.erase(f-&gt;number);</code>这句话是完全不起作用的，永远不会擦除到元素。那是否这行代码就没用？我也不知道，希望后来人能告诉我。</strong></p><p>目前我将这行代码改为了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">assert(n==<span class="number">0</span>);</span><br><span class="line">levels_[level].added_files-&gt;insert(f);</span><br></pre></td></tr></table></figure><p>但还没出现过assert失败过。后期测试中一旦出现，再补上。</p><h3 id="2-Finalize"><a href="#2-Finalize" class="headerlink" title="2. Finalize"></a>2. Finalize</h3><p>生成新版本后，需要更新这个新版本的compaction辅助变量，用于下次compaction，这个工作由Finalize函数完成。这里只用知道这个有这个功能即可，具体再Compaction章节再说。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// level0 单独处理，文件数量 超过kL0_CompactionTrigger时，就trigger compaction</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);<span class="comment">// static const int kL0_CompactionTrigger = 4;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其余level 用文件size来比较</span></span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>level0:  根据文件数量决定。</p><p>其余：根据该层的文件大小决定。</p><h2 id="3-Manifest"><a href="#3-Manifest" class="headerlink" title="3. Manifest"></a>3. Manifest</h2><h3 id="1-向manifest中””写入VersionEdit”"><a href="#1-向manifest中””写入VersionEdit”" class="headerlink" title="1. 向manifest中””写入VersionEdit”"></a>1. 向manifest中””写入VersionEdit”</h3><p>在VersionSet::LogAndApply中的后半段就是与Manifest相关的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 下面和Manifest文件相关</span></span><br><span class="line"> <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line"> <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line"> Status s;</span><br><span class="line"><span class="comment">// 创建manifest writer</span></span><br><span class="line"> <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;<span class="comment">// 首次进入，创建manifest writer</span></span><br><span class="line">   <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">   <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">   assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// new_manifest_file为当前manifest文件路径</span></span><br><span class="line">   new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">   edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">   s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">   <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">       <span class="comment">// 创建manifest写者，从本质上来看，manifest和log文件的布局完全相同</span></span><br><span class="line">     descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">       <span class="comment">// 保存一次当前系统的快照内容到manifest中</span></span><br><span class="line">     s = WriteSnapshot(descriptor_log_);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line"> &#123;</span><br><span class="line">   mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前edit内容编码成一条recored，添加到manifest中</span></span><br><span class="line">   <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">   <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">       <span class="comment">// edit内容编码到record !!, 可以看一下是怎么编码的，这样就知道manifest文件中保存的内容布局了</span></span><br><span class="line">     edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      <span class="comment">// 写入manifest文件</span></span><br><span class="line">     s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">     <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">         <span class="comment">// 刷新到设备上</span></span><br><span class="line">       s = descriptor_file_-&gt;Sync();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">       Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Current指针</span></span><br><span class="line">   <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">   <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">   <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">     s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mu-&gt;Lock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>工作:</p><ol><li><p>如果是首次进入，此时还没有manifest的writer，则新建一个writer，并保存一次当前系统版本的快照到manifest中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br></pre></td></tr></table></figure><p>根据这行代码来看，manifest和log文件的布局是完全相同的。</p></li><li><p>将本次edit中的内容转换成一条记录并Add到manifest中。</p></li></ol><h3 id="2-manifest中保存的内容"><a href="#2-manifest中保存的内容" class="headerlink" title="2. manifest中保存的内容"></a>2. manifest中保存的内容</h3><p>那manifest中到底存放了些什么？这就需要看看<code>EncodeTo</code>函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionEdit::EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</span><br><span class="line">    PutVarint32(dst, kComparator);</span><br><span class="line">    PutLengthPrefixedSlice(dst, comparator_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kLogNumber);</span><br><span class="line">    PutVarint64(dst, log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kPrevLogNumber);</span><br><span class="line">    PutVarint64(dst, prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</span><br><span class="line">    PutVarint32(dst, kNextFileNumber);</span><br><span class="line">    PutVarint64(dst, next_file_number_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</span><br><span class="line">    PutVarint32(dst, kLastSequence);</span><br><span class="line">    PutVarint64(dst, last_sequence_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    PutVarint32(dst, kCompactPointer);</span><br><span class="line">    PutVarint32(dst, compact_pointers_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_kvp : deleted_files_) &#123;</span><br><span class="line">    PutVarint32(dst, kDeletedFile);</span><br><span class="line">    PutVarint32(dst, deleted_file_kvp.first);   <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, deleted_file_kvp.second);  <span class="comment">// file number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</span><br><span class="line">    PutVarint32(dst, kNewFile);</span><br><span class="line">    PutVarint32(dst, new_files_[i].first);  <span class="comment">// level</span></span><br><span class="line">    PutVarint64(dst, f.number);</span><br><span class="line">    PutVarint64(dst, f.file_size);</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.smallest.Encode());</span><br><span class="line">    PutLengthPrefixedSlice(dst, f.largest.Encode());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是保存这些字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tag numbers for serialized VersionEdit.  These numbers are written to</span></span><br><span class="line"><span class="comment">// disk and should not be changed.</span></span><br><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应VersionEdit中的成员</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">SequenceNumber last_sequence_;</span><br><span class="line"><span class="keyword">bool</span> has_comparator_;</span><br><span class="line"><span class="keyword">bool</span> has_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line"><span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line"><span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img data-src="https://bean-li.github.io/assets/LevelDB/write_a_manifest.png" alt="img"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本文中，我们介绍了leveldb中的重要数据结构，Version，VersionEdit和VersionSet。特别是VersionEdit，它表示了一次leveldb操作过程产生的文件增删的差量。 详细剖析了如何从一个旧版本，通过应用VersionEdit，产生一个新版本。最后，我们还讲解了Manifest文件，它是用来表述sstable的元数据的文件，其内容来自VersionEdit。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本要介绍一个在leveldb中相当重要的数据结构 - Version及其相关的VersionEdit和VersionSet。理解了这些内容后，我们会提到leveldb系统中MANIFEST文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Memtable</title>
    <link href="https://www.ravenxrz.ink/archives/aba77258.html"/>
    <id>https://www.ravenxrz.ink/archives/aba77258.html</id>
    <published>2020-10-12T03:12:58.000Z</published>
    <updated>2020-10-12T03:20:08.903Z</updated>
    
    <content type="html"><![CDATA[<p>上文我们介绍了Skiplist，它是leveldbMemtable的底层数据结构，这篇文章，我们一起来分析MemTable。</p><a id="more"></a><h2 id="1-MemTable定义"><a href="#1-MemTable定义" class="headerlink" title="1. MemTable定义"></a>1. MemTable定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> </span>&#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --refs_;</span><br><span class="line">    assert(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.&#123;h,cc&#125; module.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; c)</span> : <span class="title">comparator</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意skiplist存放的key是 const char *类型</span></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~MemTable();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;</span><br><span class="line">  <span class="keyword">int</span> refs_;</span><br><span class="line">  Arena arena_;</span><br><span class="line">  Table table_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MemTable里面有3个重要的数据结构：</p><ol><li>KeyComparator ，比较器，在Get操作中会用到。</li><li>Arena，内存分配器，在Add操作中用到。</li><li>SkipList，核心数据结构，管理数据。 <strong>注意key就是一个char *， 内部比较器采用的是InternalKeyComparator.</strong></li></ol><h2 id="2-Key类型分类"><a href="#2-Key类型分类" class="headerlink" title="2. Key类型分类"></a>2. Key类型分类</h2><p>在说memtable的get和add操作前，我们先了解一下 <strong>leveldb 中</strong>的几种key类型。</p><p>在leveldb中做search操作时，search的过程大概是:</p><p>memtable-&gt;immutable memtable -&gt; sstable</p><p>这里涉及到2个search用到的key，一个在memtable中用，一个在sstable中用的key。</p><p>其实还有1个key，那就是用户自己输入的key，user-key。</p><p>总结起来就3种key，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memtable: 逻辑上称为memtable_key</span><br><span class="line"></span><br><span class="line">sstalbe: 逻辑上称为internal_key</span><br><span class="line"></span><br><span class="line">key: 用户提供的key，我们称之为user_key</span><br></pre></td></tr></table></figure><p>leveldb是如何表示这3种key的？看下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb_key.png" alt="img"></p><p>leveldb用一种类LookupKey包含了这3种key，我们要用的memtable_key其实就是Lookupkey。这一点，也可以从MemTable类的成员函数中可以看出，如Get操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-Add-操作"><a href="#3-Add-操作" class="headerlink" title="3. Add 操作"></a>3. Add 操作</h2><p>对key分类有了初步的认识后 ，我们就来看MemTable是如何将一个user key封装成一个memtable_key，然后将key value插入到skiplist中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line"><span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line"><span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><p>上面是Add的函数签名，注意到函数参数中有一个ValueType类型，我们知道leveldb中删除一个key并不会inplace update,而是插入一个带有删除标记的key。ValueType就是表示当前插入的是一个正常key还是一个删除key:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value types encoded as the last component of internal keys.</span></span><br><span class="line"><span class="comment">// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span></span><br><span class="line"><span class="comment">// data structures.</span></span><br><span class="line"><span class="keyword">enum</span> ValueType &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure><p>好了，现在来正式看看Add函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = EncodeVarint32(p, val_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很短，基本就是申请一个buf，然后填充数据,最后将buf插入到skiplist中。具体填充的字段如下：</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcvbGV2ZWxkYua6kOeggemYheivuy1jb3B5LW1lbXRhYmxl5o+S5YWl5LiA5LiqZW50cnk=" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-memtable插入一个entry<i class="fa fa-external-link"></i></span> (1).png)</p><h2 id="4-Get操作"><a href="#4-Get操作" class="headerlink" title="4. Get操作"></a>4. Get操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line"><span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line"><span class="comment">// in *status and return true.</span></span><br><span class="line"><span class="comment">// Else, return false.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MemTable::Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span> </span>&#123;</span><br><span class="line">  Slice memkey = key.memtable_key();</span><br><span class="line">  <span class="function">Table::Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">    <span class="comment">// 在skip中找到相应的memkey对应的node</span></span><br><span class="line">  iter.Seek(memkey.data());</span><br><span class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">      <span class="comment">// 提取memtable key。包括 klength + userkey + tag 字段</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line">            Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;<span class="comment">// 如果找到的key和需要get的key相同</span></span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">        <span class="comment">// 获取序列号+type字段</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;<span class="comment">// &amp; 0xff 取最后1个字节</span></span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;<span class="comment">// 有value</span></span><br><span class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">          value-&gt;assign(v.data(), v.<span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:<span class="comment">// deletion 操作</span></span><br><span class="line">          *s = Status::NotFound(Slice());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get的流程：</p><ol><li>根据传入key，到skiplist中找到相应的node</li><li>提取 node中的 memtable_key, 进一步从memtable_key中提取 user_key, 比较这个user_key和用户传入的user_key是否相同</li><li>提取 memtable_key中的tag(包括序列号和type)</li><li>查看type是哪种类型：<ol><li>正常有value，保存value</li><li>是删除的key，在Status s中保存NotFound的结果。</li></ol></li></ol><h2 id="5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？"><a href="#5-在skiplist如何进行key的比较-amp-如果key相同，新旧数据如何确定？" class="headerlink" title="5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？"></a>5. 在skiplist如何进行key的比较 &amp; 如果key相同，新旧数据如何确定？</h2><p>通过InternalKeyComparator::Compare来确定。</p><p>规则：</p><ol><li>按照key的升序</li><li>key相同，按照序列号降序</li><li>序列号相同，按照type降序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InternalKeyComparator::Compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.<span class="built_in">size</span>() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同时，seq number越大，代表数据越新。</strong></p><h2 id="6-迭代器Iterator"><a href="#6-迭代器Iterator" class="headerlink" title="6. 迭代器Iterator"></a>6. 迭代器Iterator</h2><p>这部分请看 MemTableIterator 。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuMWZlbmcubWUvMjAxNi8wOS8xMC9sZXZlbGRiLXJlYWQv" title="http://blog.1feng.me/2016/09/10/leveldb-read/">Leveldb源码笔记之读操作<i class="fa fa-external-link"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上文我们介绍了Skiplist，它是leveldbMemtable的底层数据结构，这篇文章，我们一起来分析MemTable。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Memtable基础-Skiplist</title>
    <link href="https://www.ravenxrz.ink/archives/931e70da.html"/>
    <id>https://www.ravenxrz.ink/archives/931e70da.html</id>
    <published>2020-10-12T03:11:33.000Z</published>
    <updated>2020-10-12T03:20:08.905Z</updated>
    
    <content type="html"><![CDATA[<p>在leveldb中，memtable的实现是采用skiplist的，所以本篇文章，我们就来分析以下leveldb的skiplist。</p><p>对于不了解skiplist，建议先学习以下skiplist的基本概念，最好能跟着实现一个skiplist。</p><a id="more"></a><h2 id="1-skiplist的定义"><a href="#1-skiplist的定义" class="headerlink" title="1. skiplist的定义"></a>1. skiplist的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use "cmp" for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using "*arena".  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; kMaxHeight = <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总体来看，这个skiplist只提供了, <code>Insert</code>和<code>Contains</code>两个接口。一个用于插入key，一个用于判断skiplist中是否存在具有和传入key相同的key的entry。为什么不提供delete接口？因为在leveldb中，一个删除操作就是一个插入一个具有“删除标记”的节点。所以删除即插入。</p><h2 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2. Insert"></a>2. Insert</h2><p>insert插入一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">   <span class="comment">// prev存放搜索路径</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">    <span class="comment">// 设置搜索路径</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许出现相同节点</span></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 采用随机height确定新节点能插入的最高高度</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 更新最高高度</span></span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(<span class="built_in">height</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">  x = NewNode(key, <span class="built_in">height</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点逻辑很清晰, 主要就是三个工作：</p><ol><li>通过<code>FindGreaterOrEqual</code>函数确定搜索路径, 保存在 <code>prev</code>中</li><li>生成本次插入节点的高度</li><li>插入新节点</li></ol><h3 id="1-FindGreaterOrEqual"><a href="#1-FindGreaterOrEqual" class="headerlink" title="1. FindGreaterOrEqual"></a>1. FindGreaterOrEqual</h3><p>说一下<code>FindGreaterOrEqual</code>函数的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;<span class="comment">// 保存路径到prev中</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200909215139172.png" alt=""></p><p>现在一共有4层，level0,1,2,3. 最下面为level0. , 则prev数组的有效长度为4(实际上都为kmaxHeight),假设要插入87, 图中红色虚线为要插入时所经过的路线，prev数组的作用就是保存这些路线。 比如 prev[0] 代表的是level0层的86， prev[1]代表的是level1层的71,以此类推。</p><h3 id="2-RandomHeight"><a href="#2-RandomHeight" class="headerlink" title="2.RandomHeight"></a>2.RandomHeight</h3><p>紧接上面的例子，现在找到了要插入的地点（86的后一个节点），思考一个问题， skiplist的上层节点是怎么生成的？如果只在level0中插入87，那如何生成上层的87？ 这部分就是通过RandomHeight来实现的，每次找到要插入的节点的位置时，就为这个节点生成一个高度，从0到这个高度都要插入这个节点，而高度是随机生成的，我们看看这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">height</span> &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">height</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(<span class="built_in">height</span> &gt; <span class="number">0</span>);</span><br><span class="line">  assert(<span class="built_in">height</span> &lt;= kMaxHeight);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rnd_是一个随机对象，leveldb作者自己实现的随机数生成器，这部分我们不管，从这段代码来看， height是随机递增且不能超过预设的最大高度。</p><h2 id="3-Contains"><a href="#3-Contains" class="headerlink" title="3. Contains"></a>3. Contains</h2><p>这个函数没什么好说的，在skiplist中找到节点，如果存在这个节点，且key相同，则返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; Equal(key, x-&gt;key)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Iterator"><a href="#4-Iterator" class="headerlink" title="4. Iterator"></a>4. Iterator</h2><p>前面说了skiplist的两个接口，但是skiplist还提供了一个重要的功能，那就是迭代器，迭代器是用来遍历skiplist的内部节点的。我们一起来分析以下：</p><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">  <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the next position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advances to the previous position.</span></span><br><span class="line">  <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">  <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">  Node* node_;</span><br><span class="line">  <span class="comment">// Intentionally copyable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，这个迭代器提供的接口和普通迭代器基本一样，<strong>但没有value</strong>，内部私有成员包含一个skiplist和一个node，毕竟是要遍历skiplist，所以这也很好理解。</p><h3 id="2-Seek"><a href="#2-Seek" class="headerlink" title="2.Seek"></a>2.Seek</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Seek(<span class="keyword">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seek内部直接调用了skiplist的FindGreaterOrEqual函数，FindGreaterOrEqual除了保存搜索路径外，最终还会返回找到的节点，正好可以用来做seek，并将结果保存在node_</p><h3 id="3-Next"><a href="#3-Next" class="headerlink" title="3. Next"></a>3. Next</h3><p>Next函数很简单，移动到下一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Next() &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Prev"><a href="#4-Prev" class="headerlink" title="4. Prev"></a>4. Prev</h3><p>prev内部调用了FindLessThan，它和FindGreaterOrEqual类似。其实可以双链表优化，但是双链表会多占用一个prev指针，这里应该算是时间换空间吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::Prev() &#123;</span><br><span class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></span><br><span class="line">  <span class="comment">// last node that falls before key.</span></span><br><span class="line">  assert(Valid());</span><br><span class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</span><br><span class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</span><br><span class="line">    node_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-key"><a href="#5-key" class="headerlink" title="5. key"></a>5. key</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">const</span> <span class="title">Key</span>&amp; <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Iterator::key() <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  <span class="keyword">return</span> node_-&gt;key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就说完skiplist了，有了skiplist的基础，下文我们将介绍memtable。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在leveldb中，memtable的实现是采用skiplist的，所以本篇文章，我们就来分析以下leveldb的skiplist。&lt;/p&gt;
&lt;p&gt;对于不了解skiplist，建议先学习以下skiplist的基本概念，最好能跟着实现一个skiplist。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-log文件</title>
    <link href="https://www.ravenxrz.ink/archives/8ea77a40.html"/>
    <id>https://www.ravenxrz.ink/archives/8ea77a40.html</id>
    <published>2020-10-12T03:02:12.000Z</published>
    <updated>2020-10-12T03:20:08.908Z</updated>
    
    <content type="html"><![CDATA[<p>log文件是用来保证写入的持久性的。当用户向系统发出write请求，首先就会将数据写入一份到log文件中，然后再写入到memtable，这是为了防止系统crash而出现数据loss。</p><a id="more"></a><h2 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="1. 结构分析"></a>1. 结构分析</h2><p>关于log的结构在levedb源码的 doc/log_format.md中有介绍。</p><p>leveldb在内存中的数据结构是memtable，显然memtable是无法保证数据的持久性，因为系统一旦掉电，数据就丢失了，所以leveldb使用了log file来保证数据的持久性。log file具有only append的特点，写入速度快。</p><p>我们曾在<a href="https://www.ravenxrz.ink/archives/1a545f48.html">整体架构</a>中提到过log的结构，这里再说一下：</p><p>leveldb存放的是key-value对，因为键值和value值的长度是可变的，因此，每一笔记录都必须有个<strong>length</strong>字段来表明当前记录的长度。 当然了，leveldb为了校验数据的一致性，同时会计算<strong>checksum</strong>，作为记录的一个字段.</p><p>还有另外一个字段，即<strong>type</strong>。注意，Log文件是分block存放的，每个block的大小为32KB，这就会存在一个问题，如某个key－value对过大，无法存放在单个block中，可能存放在多个不同的block中,因此引入了另一个字段RecordType, 用于标识当前物理快与逻辑块之间的关系。</p><p>RecordType字段主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p><ul><li><p>如果 一个Record的size在一个block内，则type=FULL</p></li><li><p>否则Record将会跨越多个block，则可能出现上图中的情况，分别对应FIRST/MIDDLE/LAST</p></li></ul><p>下图展示的 log 文件由 3 个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="https://img-blog.csdnimg.cn/20190314203727797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R1d2VucWkyMDEz,size_16,color_FFFFFF,t_70" alt="img"></p><p>一个Record的逻辑结构如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/log-record%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.jpg" alt=""></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>与log相关的代码文件存放在：</p><ul><li>db/log_format.h</li><li>db/log_reader.h</li><li>db/log_reader.cc</li><li>db/log_writer.h</li><li>db/log_writer.cc</li></ul><h3 id="1-leveldb-log命名空间"><a href="#1-leveldb-log命名空间" class="headerlink" title="1. leveldb::log命名空间"></a>1. leveldb::log命名空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RecordType &#123;</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;<span class="comment">// 1个block 32kb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h3 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h3><p>log wirter类，对log写入的封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableFile</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must be initially empty.</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must have initial length "dest_length".</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Writer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="keyword">int</span> block_offset_;  <span class="comment">// Curr </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算的crc</span></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><h4 id="核心-AddRecord-函数"><a href="#核心-AddRecord-函数" class="headerlink" title="核心-AddRecord 函数"></a>核心-AddRecord 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();<span class="comment">// left表示剩余多少size未写</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">begin</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">// 当前32kb的块的剩余量</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;<span class="comment">// 剩余量 &lt; 一个record的header size</span></span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="keyword">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));<span class="comment">// 填充本块最后的空间</span></span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>; <span class="comment">// 更换新块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<span class="comment">// 剩余可用给数据的空间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) &#123;<span class="comment">// 开始和结束都在本块，整条record都可放置</span></span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) &#123;<span class="comment">// 只有开始在，结束不在，说明是第一条</span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) &#123;<span class="comment">// 结束在，开始不在，说明是最后一条</span></span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 其余就是中间条目</span></span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将本条Record写入到物理设备上</span></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    <span class="built_in">begin</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/AddRecord%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B%E5%9B%BE-1600848090666.jpg" alt=""></p><h4 id="EmitPhysicalRecord函数"><a href="#EmitPhysicalRecord函数" class="headerlink" title="EmitPhysicalRecord函数"></a>EmitPhysicalRecord函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  assert(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes 一个块最多写32kb，即2^15，至少需要15个bit，所以需要2个字节（解释了为什么要用0xffff)</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">   <span class="comment">// 初始化header， 4-5为数据的length， 6 为类型</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::Mask(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">    <span class="comment">// crc校验</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));<span class="comment">// 加入heder</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, length));<span class="comment">// 加如实际数据</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数相对简单：</p><ol><li>检查写入数据的length是否符合条件。满足在2个字节以内。</li><li>填充record的元数据， length + type + crc校验码</li><li>写入到dest_中。</li></ol><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文介绍了leveldb中用来保证持久性的log文件，重点介绍了它的逻辑布局和物理布局，同时介绍了一次log写入操作是如何执行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;log文件是用来保证写入的持久性的。当用户向系统发出write请求，首先就会将数据写入一份到log文件中，然后再写入到memtable，这是为了防止系统crash而出现数据loss。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-leveldbutil工具</title>
    <link href="https://www.ravenxrz.ink/archives/2938ff32.html"/>
    <id>https://www.ravenxrz.ink/archives/2938ff32.html</id>
    <published>2020-10-12T01:52:34.000Z</published>
    <updated>2020-10-12T01:59:20.333Z</updated>
    
    <content type="html"><![CDATA[<p>从本文之后，我们将正式分析leveldb内部组件，如memtable,sstable, log, manifest等。</p><a id="more"></a><p> 如果你已经搭建了leveldb的源码debug环境并做过简单测试，你会发现leveldb中存在以下几类文件：</p><ul><li>sstable文件，sst或ldb结尾</li><li>log文件，保证写入的持久性</li><li>MANIFEST, 记录每次修改操作的增量，记录sstable的元数据</li><li>CURRENT， 指向当前该使用哪个MANIFEST</li><li>LOCK 锁相关</li><li>LOG.old 日志</li></ul><p>一般情况下，除了CURRENT和LOG.old文件可以双击查看，其它文件都是没办法查看的，因为它们都不是txt文件，而是经过leveldb按照自身设计而存储的。但是有没有办法查看这些文件的内容呢？有，leveldb为我们提供了一个工具—<strong>leveldb/db/leveldbutil.cc</strong></p><p>我们将它编译成可执行文件后，执行 ./levelutil dump [要查看的文件] 即可打印相关文件的信息，如，我要查看log文件：</p><p><img data-src="https://pic.downk.cc/item/5f81b4da1cd1bbb86b526c02.jpg" alt=""></p><p>知道了这个工具，在后续查看文件布局时就会比较方便了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了查看 log、sstable、manifest等文件的工具–leveldbutil. 文本是”前置知识“的最后一篇，从下文开始，我们将分析leveldb中log文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文之后，我们将正式分析leveldb内部组件，如memtable,sstable, log, manifest等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-文件命名规则</title>
    <link href="https://www.ravenxrz.ink/archives/f38b067b.html"/>
    <id>https://www.ravenxrz.ink/archives/f38b067b.html</id>
    <published>2020-10-12T01:50:34.000Z</published>
    <updated>2020-10-12T03:01:46.348Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章我们说一说leveldb中的文件命名规则。</p><blockquote><p>这篇文章虽然放在前置知识，但是内部原理牵涉到leveldb中的Version相关类，所以看不懂没关系，只用知道一个结论：leveldb的所有带编号的文件共用一套编号系统，也就是说任何带编号的文件不可能有重复的编号。如不会出现 000001.ldb和000001.log文件这种情况。</p></blockquote><a id="more"></a><p>运行leveldb程序一段时间后，我们会发现在系统给中，存在很多由数字编号的文件：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201009111936923.png" alt="image-20201009111936923"></p><p>这篇文章从整体上谈一谈leveldb的文件命令和文件编号的来源。</p><h2 id="1-文件命名"><a href="#1-文件命名" class="headerlink" title="1. 文件命名"></a>1. 文件命名</h2><p>在leveldb中和文件命名相关的代码在：</p><ul><li>leveldb/db/filename.cc</li><li>leveldb/db/filename.h</li></ul><p>其核心为MakeFileName函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">MakeFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span>* suffix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/%06llu.%s"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number), suffix);</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到文件名时由 dbname + 6位number + 后缀组成的。 比如dbname = testdb, 则一个sstable的文件名可以为： testdb/000132.ldb. (ldb和sst都是sstable的有效后缀)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">TableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"ldb"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">SSTTableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"sst"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，manifest文件没有调用MakeFileName，而是自己单独的函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DescriptorFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/MANIFEST-%06llu"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-文件编号"><a href="#2-文件编号" class="headerlink" title="2. 文件编号"></a>2. 文件编号</h2><h3 id="1-sstable-log和manifest的number"><a href="#1-sstable-log和manifest的number" class="headerlink" title="1. sstable, log和manifest的number"></a>1. sstable, log和manifest的number</h3><p>dbname和后缀容易理解。那number是在哪儿来的？</p><p>实际上在leveldb中所有和编号有关的文件名的编码都有versonset来维护：</p><p>如log file的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">WritableFile* lfile;</span><br><span class="line">s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                 &amp;lfile);</span><br></pre></td></tr></table></figure><p>又如sstable的number:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file_number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the output file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br></pre></td></tr></table></figure><p>看看NewFileNumber：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br></pre></td></tr></table></figure><p>所以log和sst文件的编号都是由versionset中的next_file_number_来维护的。注意在versionset的构造函数中，next_file_number被初始化为2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),<span class="comment">// !! 这里被初始化为2的</span></span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件编号1在哪儿？"><a href="#文件编号1在哪儿？" class="headerlink" title="文件编号1在哪儿？"></a>文件编号1在哪儿？</h4><p>那谁在用1呢？<code>manifest_file_number_</code>在用。注意到在<code>versionset</code>的构造函数中<code>manifest_file_number_</code>初始化为0. 如果系统是首次使用，则会在NewDB中重新对<code>manifest_file_number_</code>赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);<span class="comment">// !! 记住这里的next file number = 2</span></span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !! 这里设置了manifest的number = 1</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 设置CURRENT 指向</span></span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般来说，除非你修改了options，否则你在运行leveldb时，看到的最小的manifest文件应该是，MANIFEST-000002. 这是为什么？这是因为在DBImpl::Open函数中调用NewDB函数后，紧接着调用了Recover.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::Recover</span><span class="params">(<span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略掉的... 中做工作就是中 CURRENT 所指向的manifest文件读取内容， 先前在NewDB中CURRENT指向 manifest000001</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">        next_file = edit.next_file_number_;<span class="comment">// 此时next_file = 2, 因为在NewDB中 next_file_number_ 被设置为2</span></span><br><span class="line">        have_next_file = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">        last_sequence = edit.last_sequence_;</span><br><span class="line">        have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">    <span class="comment">// Install recovered version</span></span><br><span class="line">    Finalize(v);</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    manifest_file_number_ = next_file;<span class="comment">// ！！ 这里manifest_file_number_ = 2</span></span><br><span class="line"> ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就解释了 manifest_file_number_ = 2是如何来的， 那manifest_file_number_ = 1是如何消失的？在DBImpl::Open的下半部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  impl-&gt;RemoveObsoleteFiles();<span class="comment">// 其中移除了manifest_file_number = 1时的文件</span></span><br><span class="line">  impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要意识到，这只是系统第一次使用启动时manifest_file_number的指定过程。 在后序的使用过程中，manifest_file_number的初始化是从<code>VersionSet::Recover</code>中开始，这其中 manifest_file_number仍然由next_file_number_指定，另外还要考虑是否Reuse旧manifest文件，如果复用，manifest_file_number将等于旧manifest的number。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>总结起来一句话，sstable, log, manifest的编号都是由versoinset的next_file_number_来指定。</strong></p><h3 id="2-VersoinSet中的LogNumber和PrevLogNumber"><a href="#2-VersoinSet中的LogNumber和PrevLogNumber" class="headerlink" title="2. VersoinSet中的LogNumber和PrevLogNumber"></a>2. VersoinSet中的LogNumber和PrevLogNumber</h3><p>PrevLogNumber已不再使用。</p><p>LogNumber存放的是当前系统有效的log file 的number。用于写log、recover系统时判定是否有newer log没有转化为sstable等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本片文章我们说一说leveldb中的文件命名规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章虽然放在前置知识，但是内部原理牵涉到leveldb中的Version相关类，所以看不懂没关系，只用知道一个结论：leveldb的所有带编号的文件共用一套编号系统，也就是说任何带编号的文件不可能有重复的编号。如不会出现 000001.ldb和000001.log文件这种情况。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-编码</title>
    <link href="https://www.ravenxrz.ink/archives/8f115521.html"/>
    <id>https://www.ravenxrz.ink/archives/8f115521.html</id>
    <published>2020-10-12T01:46:54.000Z</published>
    <updated>2020-10-12T01:59:20.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>在阅读本篇文章前，你应该能先了解什么是字节序，什么是小端序，什么是大端序。 </p><a id="more"></a><h2 id="1-正文"><a href="#1-正文" class="headerlink" title="1. 正文"></a>1. 正文</h2><p>leveldb中与编码相关的内容都在coding.h，coding.cc文件中。leveldb的编码都是采用小端序，编码一共分为固定长度编码和变长编码，且都分为32位和64位版本，我们先说固定长度编码。</p><h2 id="2-固定长度编码"><a href="#2-固定长度编码" class="headerlink" title="2. 固定长度编码"></a>2. 固定长度编码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">40</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">48</span>);</span><br><span class="line">  <span class="built_in">buffer</span>[<span class="number">7</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话总结，低位字节放在低位内存，高位字节放在高位内存，也即小端序。</p><p>解码过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Get... that read directly from a character buffer</span></span><br><span class="line"><span class="comment">// without any bounds checking.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">DecodeFixed64</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> <span class="built_in">buffer</span> = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / ldr instruction.</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">0</span>])) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">4</span>]) &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">5</span>]) &lt;&lt; <span class="number">40</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">6</span>]) &lt;&lt; <span class="number">48</span>) |</span><br><span class="line">         (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">buffer</span>[<span class="number">7</span>]) &lt;&lt; <span class="number">56</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按字节取即可。</p><h2 id="3-变长编码"><a href="#3-变长编码" class="headerlink" title="3. 变长编码"></a>3. 变长编码</h2><p>为什么需要变长编码？ 考虑一个场景，假设现在我们只用在存放一个int类型的1， 这么简单的一个数字，我们却需要4个字节（一般情况下），要是可以压缩就好了。变长编码就是用来解决这个问题的，使用变长编码后，只用一个字节就可以保存这个1. </p><p>leveldb的变长编码也是采用小端序，同时在一个字节中，低7位表示的是实际数据，最高的1位用来表示，这个字节后序是否还有字节用来表示数字。举个例子：</p><p>假设要表示数字1000。 其二进制是111 1101000。 </p><p>首先取出低7位：1101000， 高位先补0凑成一个字节， 0110 1000。</p><p>取出高3位： 111， 高位补0凑成一个字节， 0000 0111.</p><p>采用小端序存储这个数字： 0110 1000 0000 0111。</p><p>因为这里用到了两个字节表示一个数字，所以在第一个字节的最高位需要设置成1，表示第二个字节也是用来表示“1000（一千）”这个数字的。最终编码结果为：</p><p><strong>1110 1000 0000 0111.</strong></p><p>解码过程：</p><p>首先，读取第一个字节， 1110 1000， 最高位为1，表示后续还有字节表示这个数字，还原最高位位1后（0110 1000），再取一个字节（0000 0111）， 因为0000 0111最高不为1，所以取字节结束。现在得到两个字节：</p><p>01110 1000 0000 0111</p><p>按照小端序还原：</p><p><strong>0000 0111 0110 1000（二进制） ==&gt; 1000（十进制）</strong></p><p>知道了原理，来看代码吧。</p><p>变长编码函数签名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// and return a pointer just past the last byte written.</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span></span>;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照前面讲的例子，这段代码不难理解，变量B用来设置一个字节的最高位，表示后续是否还有字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位是32位的循环版本，两个代码表示同一个意思。</p><p>解码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Standard Get... routines parse a value from the beginning of a Slice</span></span><br><span class="line"><span class="comment">// and advance the slice past the parsed value.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, <span class="keyword">uint64_t</span>* value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------最终会走到下面这个函数---------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">byte</span> = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">byte</span> &amp; <span class="number">128</span>) &#123;<span class="comment">// 后续还有字节</span></span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((<span class="keyword">byte</span> &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 后续无字节，到了最后的字节</span></span><br><span class="line">      result |= (<span class="keyword">byte</span> &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便用户使用，leveldb还封住了一个Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</span><br><span class="line">  dst-&gt;append(buf, ptr - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先申请了一个5字节的buf，用来存储编码后的结果。为什么是5个字节？因为当32位的数值过大，比如 0xffffffff， 那么变长编码肯定需要5个字节才能表示。后面就很简单那了，执行编码，将编码结果保存在dst中。</p><h2 id="4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice"><a href="#4-PutLengthPrefixedSlice-amp-GetLengthPrefixedSlice" class="headerlink" title="4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice"></a>4. PutLengthPrefixedSlice &amp; GetLengthPrefixedSlice</h2><p>Put函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  PutVarint32(dst, value.<span class="built_in">size</span>());</span><br><span class="line">  dst-&gt;append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个字符串，这里首先将它的长度放到dst中，然后再将数值放入。 </p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhdmVueHJ6L1BpY0JlZC9pbWcv57uY5Zu+5paH5Lu2LeesrA==" title="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第">https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/绘图文件-第<i class="fa fa-external-link"></i></span> 20 页.png)</p><p>Get函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp; input-&gt;<span class="built_in">size</span>() &gt;= len) &#123;</span><br><span class="line">    *result = Slice(input-&gt;data(), len);</span><br><span class="line">    input-&gt;remove_prefix(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思相当于将编码后的string中的长度信息去除，提出出原始string。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文分析了leveldb中与编码相关的知识，包含了固定长度编码与变长编码的原理与实现。这些内容虽然看似与leveldb无关，但是leveldb内部存储中却无时无刻不用到这些编码，所以我们现在都是在为后续看懂leveldb做铺垫。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;在阅读本篇文章前，你应该能先了解什么是字节序，什么是小端序，什么是大端序。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-Env类</title>
    <link href="https://www.ravenxrz.ink/archives/c451920b.html"/>
    <id>https://www.ravenxrz.ink/archives/c451920b.html</id>
    <published>2020-10-12T01:30:40.000Z</published>
    <updated>2020-10-12T02:38:34.245Z</updated>
    
    <content type="html"><![CDATA[<p>本系列的前几篇文章并不准备深入到leveldb中的”核心“，而是分析一些leveldb中用到的”杂项“内容，如本文要说的Env类，后面要提到的编码、文件命名方式等。</p><a id="more"></a><h2 id="Env"><a href="#Env" class="headerlink" title="Env"></a>Env</h2><p>Env代表Environment，环境类，在其内部封装了leveldb所有的文件操作和线程调度操作。Env是一个虚基类，具体操作由子类实现，看一下它的继承关系：</p><img data-src="https://pic.downk.cc/item/5f83a9d71cd1bbb86b971527.png" alt="image-20201012085159807" style="zoom: 50%;" /><p>EnvWrapper类主要是供用户自定义一些操作，一般不管，主要看Windows平台和PosixEnv（linux属于这个范围），因为我都是在linux平台上看的，所以这里只用关注PosixEnv。</p><h3 id="构造env"><a href="#构造env" class="headerlink" title="构造env"></a>构造env</h3><p>默认情况下，Env由<code>Env::Default()</code>函数调用创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leveldb/util/env_posix.cc</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PosixDefaultEnv = SingletonEnv&lt;PosixEnv&gt;;</span><br><span class="line"><span class="function">Env* <span class="title">Env::Default</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PosixDefaultEnv env_container;</span><br><span class="line">  <span class="keyword">return</span> env_container.env();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Env* <span class="title">env</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Env*&gt;(&amp;env_storage_); &#125;</span><br></pre></td></tr></table></figure><p>Evn.Default调用<code>env_container.env();</code>,  env_container是PosixDefaultEnv类型（PosixDefaultEnv是SingletonEnv<PosixEnv>的别名), env返回<code>env_storage</code>.</p><p>关于env_storage，这个变量在SingletonEnv类中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于字节对齐，这里表示env_storage_按照EnvType的大小对齐，同时自身的大小也是env_storage_</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span>(EnvType), <span class="keyword">alignof</span>(EnvType)&gt;::type</span><br><span class="line">      env_storage_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// env_storage_在PosixDefaultEnv的构造函数中被初始化：</span></span><br><span class="line"><span class="keyword">new</span> (&amp;env_storage_) EnvType();<span class="comment">// 这句话的意思是，按照EvnType的大小申请一个对象，然后将这个对象填充到env_storage_的地址空间中去。</span></span><br></pre></td></tr></table></figure><p>最后的默认环境为 <strong>PosixEnv类</strong>, 看一下它的类图：</p><img data-src="https://pic.downk.cc/item/5f633eec160a154a67e8687e.png" alt="image-20200916170716873" style="zoom: 50%;" /><p>可以看到都是一些辅助函数，包括文件创建，监测，线程管理（同步）等。文件的相关操作比较简单，我们说一下线程池的实现：</p><h3 id="线程池、队列"><a href="#线程池、队列" class="headerlink" title="线程池、队列"></a>线程池、队列</h3><p>线程池的实现中有一个工作队列，队列中放的都是需要被线程执行的任务。工作队列由<code>background_work_queue_</code>表示，任务则由<code>BackgroundWorkItem</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;BackgroundWorkItem&gt; background_work_queue_</span><br><span class="line">      GUARDED_BY(background_work_mutex_);</span><br><span class="line">      </span><br><span class="line"><span class="comment">// work item</span></span><br><span class="line"><span class="comment">// Stores the work item data in a Schedule() call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Instances are constructed on the thread calling Schedule() and used on the</span></span><br><span class="line"><span class="comment">// background thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This structure is thread-safe beacuse it is immutable.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BackgroundWorkItem</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BackgroundWorkItem</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>* arg), <span class="keyword">void</span>* arg)</span></span></span><br><span class="line">        : function(function), arg(arg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">const</span> function)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">const</span> arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何调度一个线程？看Schedule函数，<em>目前看来线程池中只有一个线程</em>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* background_work_arg)</span> </span>&#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;<span class="comment">// 首次执行，开启线程</span></span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.<span class="built_in">detach</span>();<span class="comment">// detach模式，由内核去回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看下唤醒消费者的代码，注意这里Signal后，消费者的线程虽然被唤醒，但是依然处于阻塞状态，只有当前线程，调用 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>后，消费者线程才能正常执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line"><span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">background_work_cv_.Signal();</span><br><span class="line">&#125;</span><br><span class="line">background_work_queue_.emplace(background_work_function, background_work_arg);<span class="comment">// 插入一个任务</span></span><br><span class="line">background_work_mutex_.Unlock();</span><br></pre></td></tr></table></figure><p>所以只有当真正插入一个任务后，线程才正式执行。</p><p>如果第一次调度，则首先启动线程, 线程执行的函数为<code>BackgroundThreadEntryPoint:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BackgroundThreadEntryPoint</span><span class="params">(PosixEnv* env)</span> </span>&#123;</span><br><span class="line">    env-&gt;BackgroundThreadMain();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PosixEnv::BackgroundThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 取出任务</span></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行</span></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥量Mutex和条件变量CondVar"><a href="#互斥量Mutex和条件变量CondVar" class="headerlink" title="互斥量Mutex和条件变量CondVar"></a>互斥量Mutex和条件变量CondVar</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOCKABLE</span> <span class="title">Mutex</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Mutex() = <span class="keyword">default</span>;</span><br><span class="line">  ~Mutex() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  Mutex(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Lock</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.lock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unlock</span><span class="params">()</span> <span class="title">UNLOCK_FUNCTION</span><span class="params">()</span> </span>&#123; mu_.unlock(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssertHeld</span><span class="params">()</span> <span class="title">ASSERT_EXCLUSIVE_LOCK</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CondVar</span>;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Mutex就是对标准mutex的封装，同时用了些宏来修饰，这些宏是clang用于 语法分析（猜想） 的宏，如这里的 ASSERT_EXCLUSIVE_LOCK， 表示调用AssertHeld函数时，表示必须是在获取独占lock的情况下，才能执行之后的代码。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Recover</span><span class="params">(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br></pre></td></tr></table></figure><p>DBImpl::Recover函数的第一行代码就是表示该函数必须在本线程获取独占锁的情况下执行。</p><p>下面再看看条件变量，CondVar：</p><p>条件变量只是对std::condition_variable的浅封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thinly wraps std::condition_variable.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondVar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">CondVar</span><span class="params">(Mutex* mu)</span> : <span class="title">mu_</span><span class="params">(mu)</span> </span>&#123; assert(mu != <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  ~CondVar() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  CondVar(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  CondVar&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CondVar&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mu_-&gt;mu_, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    cv_.wait(lock);</span><br><span class="line">    lock.<span class="built_in">release</span>();<span class="comment">// 断开lock和mutex的关联，不释放mutex</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span> </span>&#123; cv_.notify_one(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SignalAll</span><span class="params">()</span> </span>&#123; cv_.notify_all(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line">  Mutex* <span class="keyword">const</span> mu_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文解释了leveldb中Env类的作用，并分析了内部线程池的实现，下文我们将说一下leveldb内的编码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列的前几篇文章并不准备深入到leveldb中的”核心“，而是分析一些leveldb中用到的”杂项“内容，如本文要说的Env类，后面要提到的编码、文件命名方式等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>leveldb源码阅读记录-整体架构</title>
    <link href="https://www.ravenxrz.ink/archives/1a545f48.html"/>
    <id>https://www.ravenxrz.ink/archives/1a545f48.html</id>
    <published>2020-10-12T01:00:06.000Z</published>
    <updated>2020-10-12T02:36:35.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>本系列文章是对leveldb源码分析的笔记，基本会包含leveldb中的方方面面。阅读过程中，参照网上各博客并加上了个人的理解，所以难免有错，如有错误还请告知。</p><p>如果你是刚开始看leveldb，我希望你对LSM有一定的概念。为了避免过度陷入代码细节，本文将解释leveldb的整体设计架构，各个组件的宏观设计，这样能在心里对leveldb有个轮廓，也能指导我们从哪里入手代码。</p><p>本文非写者编辑，转载自：<span class="exturl" data-url="aHR0cDovL2NpZ2hhby5jb20vMjAxNi8wOC8xNC9sZXZlbGRiLXNvdXJjZS1hbmFseXNpcy0wMi1zdHJ1Y3R1cmUv" title="http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/">http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/<i class="fa fa-external-link"></i></span></p><a id="more"></a><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h2><p>LevelDB 作为存储系统，数据记录的存储介质包括内存以及磁盘文件，当 LevelDB 运行了一段时间，此时我们给 LevelDB 进行透视拍照，会看到如下一番景象，这也就是 LevelDB 的结构图。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-01.png" alt="LevelDB结构"></p><p>从图中可以看出，构成 LevelDB 静态结构的包括六个主要部分：内存中的 <strong>MemTable</strong> 和 <strong>Immutable MemTable</strong> 以及磁盘上的几种主要文件：<strong>Current文件</strong>，<strong>Manifest文件</strong>，<strong>log文件</strong>以及 <strong>SSTable 文件</strong>。当然，LevelDB 除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是 LevelDB 的主体构成元素。</p><p>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高。</p><p>SSTable 中的文件(后缀为.sst)是 key 有序的，就是说在文件中小 key 记录排在大 key 记录之前，除了 level 0，各个 level 的 SSTable 都是如此。</p><h2 id="2-manifest文件"><a href="#2-manifest文件" class="headerlink" title="2. manifest文件"></a>2. manifest文件</h2><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。<strong>manifest</strong> 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。下图是 manifest 所存储内容的示意：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-02.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p><h2 id="3-current-文件"><a href="#3-current-文件" class="headerlink" title="3. current 文件"></a>3. current 文件</h2><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest文件。</p><h2 id="4-log-文件"><a href="#4-log-文件" class="headerlink" title="4. log 文件"></a>4. log 文件</h2><p>log 文件在 LevelDB 中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的 memtable 之前，会先写入 log 文件，这样即使系统发生故障，memtable 中的数据没有来得及 dump 到磁盘的 SSTable 文件，LevelDB 也可以根据 log 文件恢复内存的 Memtable 数据结构内容，不会造成系统丢失数据。</p><p>LevelDB 对于一个 log 文件，会把它切割成以 32K 为单位的物理 Block，每次读取以一个 Block 作为基本读取单位，下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-03.png" alt="log文件布局"></p><p>log 文件中的数据是以 block 为单位组织，写日志时，处于一致性考虑并没有按 block 单位写，每次更新均对 log 文件进行 IO，每次更新写入作为一个 record，每条 record 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-04.png" alt="记录结构"></p><p><code>checksum</code> 记录的是 “type” 和 “data” 字段的CRC校验，为了避免处理不完整或者是被破坏的数据，当 LevelDB 读取记录数据时候会对数据进行校验，如果发现和存储的 checksum 相同，说明数据完整无破坏，可以继续后续流程。</p><p><code>length</code> 记录的是 record 内保存的 data 长度(小端对齐)。</p><p><code>data</code> 记录的是 Key:Value 数值对.</p><p><code>type</code> 字段则指出了每条记录的逻辑结构和 log 文件物理分块结构之间的关系，具体而言，主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code>。如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p><p>假设目前存在三条记录，Record A，Record B 和 Record C，其中 Record A 大小为10K，Record B 大小为80K，Record C大小为12K，那么其在 log 文件中的逻辑布局会如上面的图所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDB一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><h2 id="5-SSTable-文件"><a href="#5-SSTable-文件" class="headerlink" title="5. SSTable 文件"></a>5. SSTable 文件</h2><p>LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征），所有 .sst 文件内部布局都是一样的。上节介绍 log 文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：log文件中的记录是 Key 无序的，即先后记录的 key 大小没有明确大小关系，而 .sst 文件内部则是根据记录的 Key 由小到大排列的。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-05.png" alt=".sst文件的分块结构"></p><p>上图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块，每个 Block 分为三个部分：<strong>数据存储区</strong>，<strong>Type 区</strong>用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩），<strong>CRC校验</strong>则是数据校验码，用于判别数据在生成和传输中是否出错。</p><p>以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。下图展示了.sst文件的内部逻辑解释。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-06.png" alt="逻辑布局"></p><p>从上图可以看出，从大的方面，可以将 .sst文 件划分为<strong>数据存储区</strong>和<strong>数据管理区</strong>，数据存储区存放实际的 key-value 数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储 KV 数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：<strong>Meta Block</strong>，<strong>MetaBlock 索引</strong>和<strong>数据索引块</strong>以及一个<strong>文件尾部块</strong>。</p><p><code>data_block</code>：实际存储的 KV 数据。<br><code>meta_block</code>：每个 data_block 对应一个 meta_block，保存 data_block 中的 key size/value size/kv counts 之类的统计信息，当前版本未实现。<br><code>metaindex_block</code>：保存 meta_block 的索引信息，当前版本未实现。<br><code>index_block</code>：保存每个 data_block 的 last_key 及其在 SSTable 文件中的索引。block 中 entry 的 key 即是 last_key(依赖于FindShortestSeparator()/FindShortSuccessor()的实现)，value即是该data_block的BlockHandler（offset/size）。<br><code>footer</code>：文件末尾固定长度的数据。保存着 metaindex_block 和 index_block 的索引信息(BlockHandler)，为达到固定的长度，添加 padding_bytes。最后有8个字节的 magic 校验。</p><p>footer 的结构如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-07.png" alt="Footer"></p><p><code>metaindex_block_handle</code> 指出了 metaindex block 的起始位置和大小；<code>index_block_handle</code> 指出了 index Block 的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的；为达到固定的长度，添加 <code>padding_bytes</code>。最后有8个字节的 <code>magic</code> 校验。</p><p>下图是数据索引块的内部结构示意图：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-08.png" alt="数据索引"></p><p>Data Block 内的 KV 记录是按照 key 由小到大排列的，数据索引区的每条记录是对某个 Data Block 建立的索引信息，每条索引信息包含三个内容。以上图所示的数据块 i 的索引 index i 来说：</p><p><strong>第一个字段</strong>：记录大于等于数据块i中最大的 key 值的那个 key。在索引里保存的这个 key 值未必一定是某条记录的 key，以上的例子来说，假设数据块i的最小key=“samecity”，最大key=“the best”；数据块i+1的最小key=“the fox”，最大key=“zoo”，那么对于数据块i的索引 index i 来说，其第一个字段记载大于等于数据块i的最大Key(“the best”) 同时要小于数据块i+1的最小Key(“the fox”)，所以例子中 index i 的第一个字段是 “the c”，这个是满足要求的；而 index i+1 的第一个字段则是 “zoo”，即数据块i+1的最大 key。</p><p><strong>第二个字段</strong>：指出数据块 i 在 .sst 文件中的起始位置。</p><p><strong>第三个字段</strong>：指出 Data Block i 的大小（有时候是有数据压缩的）。</p><p>上面主要介绍的是数据管理区的内部结构，下图是数据区的一个 Block 的数据部分布局。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-09.png" alt=""></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个 KV 记录，其顺序是根据 key 值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point），其实是一些指针，指出 Block 内容中的一些记录位置。</p><p>“重启点”是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p>其中记录的格式如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-10.png" alt="记录格式"></p><p>每个记录包含5个字段：</p><p><strong>key共享长度</strong>：比如上面的 “olor” 记录， 其 key 和上一条记录共享的 key 部分长度是 “the c” 的长度，即5；</p><p><strong>key非共享长度</strong>：对于“olor”来说，是4；</p><p><strong>value长度</strong>：指出 key-value 中 value 的长度，在后面的 value 内容字段中存储实际的 value 值；</p><p><strong>key非共享内容</strong>：指实际存储 “olor” 这个 key 字符串；</p><p><strong>value内容</strong>：存储实际的 value 值。</p><h2 id="6-Memtable"><a href="#6-Memtable" class="headerlink" title="6. Memtable"></a>6. Memtable</h2><p>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p><p>LevelDB 的 MemTable 提供了将 KV 数据写入，删除以及读取 KV 记录的操作接口，但是事实上 Memtable 并不存在真正的删除操作,删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。</p><p>需要注意的是，LevelDB 的 Memtable 中KV对是根据key大小有序存储的，在系统插入新的KV时，LevelDB 要把这个KV插到合适的位置上以保持这种 Key 有序性。其实，LevelDB 的 Memtable 类只是一个接口类，真正的操作是通过背后的 SkipList 来做的，包括插入操作和读取操作等，所以 Memtable 的核心数据结构是一个 SkipList。</p><p>SkipList是由 William Pugh 发明。他在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。关于SkipList的详细介绍可以参考这篇文章：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS94dXFpYW5nL2FyY2hpdmUvMjAxMS8wNS8yMi8yMDUzNTE2Lmh0bWzjgII=" title="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。<i class="fa fa-external-link"></i></span></p><h2 id="7-读记录"><a href="#7-读记录" class="headerlink" title="7. 读记录"></a>7. 读记录</h2><p>因为写入操作比较简单就不介绍了，LevelDB 的读取流程如下所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-11.png" alt="LevelDB读取记录流程"></p><p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p><p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p><p>因为SSTable数量较多，而且分成多个level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于 level 0 的文件中查找，如果找到则返回对应的value值，如果没有找到那么到 level 1 中的文件中去找，如此循环往复，直到在某层 SSTable 文件中找到这个 key 对应的 value 为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>如果给定一个要查询的 key 和某个 key range 包含这个key的 SSTable 文件，那么 LevelDB 是如何进行具体查找过程的呢？LevelDB 一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后 LevelDB 根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的 SSTable 文件并不包含这个key，所以到下一级别的 SSTable 中去查找。</p><h2 id="8-Compaction"><a href="#8-Compaction" class="headerlink" title="8. Compaction"></a>8. Compaction</h2><p>LevelDB 包含其中两种 compaction 模式：minor 和 major。所谓 <strong>minor Compaction</strong>，就是把 memtable 中的数据导出到 SSTable 文件中；<strong>major compaction</strong> 就是合并不同层级的 SSTable 文件。</p><p><strong>minor Compaction</strong></p><p>Minor compaction 的目的是当内存中的 memtable 大小到了一定值时，将内容保存到磁盘文件中。其机理如下图所示：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-12.png" alt="Minor compaction"></p><p>当 memtable 数量到了一定程度会转换为 immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable 其实是一个多层级队列SkipList，其中的记录是根据 key 有序排列的。所以这个 minor compaction 实现起来也很简单，就是按照 immutable memtable 中记录由小到大遍历，并依次写入一个 level 0 的新建 SSTable 文件中，写完后建立文件的 index 数据，这样就完成了一次minor compaction。</p><p>从上图中也可以看出，对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。</p><p><strong>major compaction</strong></p><p>当某个 level 下的 SSTable 文件数目超过一定设置值后，levelDB 会从这个 level 的 SSTable 中选择一个文件（level&gt;0），将其和高一层级的 level+1 的 SSTable 文件合并，这就是 major compaction。</p><p>在大于 0 的层级中，每个 SSTable 文件内的key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。level 0 的 SSTable 文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为 level 0 的文件是通过 minor compaction 直接生成的，所以任意两个 level 0下的两个 SSTable 文件可能再key范围上有重叠。所以在做 major compaction 的时候，对于大于 level 0 的层级，选择其中一个文件就行，但是对于 level 0 来说，指定某个文件后，本 level 中很可能有其他 SSTable 文件的 key 范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和 level 1 的文件进行合并，即 level 0 在进行文件选择的时候，可能会有多个文件参与 major compaction。</p><p>LevelDB 在选定某个 level 进行 compaction 后，还要选择是具体哪个文件要进行 compaction，LevelDB 在这里有个小技巧， 就是说轮流来，比如这次是文件A进行 compaction，那么下次就是在 key range 上紧挨着文件A的文件B进行 compaction，这样每个文件都会有机会轮流和高层的 level 文件进行合并。</p><p>如果选好了 level i 的文件A和 level i+1 层的文件进行合并，那么问题又来了，应该选择 level i+1 哪些文件进行合并？LevelDB 选择 i+1 层中和文件A在 key range 上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了 level i 的文件A，之后在 level i+1 中找到了所有需要合并的文件B,C,D… 等等。剩下的问题就是具体是如何进行 major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的 KV 数据。</p><p>下图所示的是合并过程：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-13.png" alt="SSTable compaction"></p><p>major compaction 的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 level i+1 层中新生成的一个 SSTable 文件中。就这样对KV数据一一处理，形成了一系列新的 i+1 层数据文件，之前的 i 层文件和 i+1 层参与 compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了 i 层和 i+1 层文件记录的合并过程。</p><p>那么在 major compaction 过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于 i 层中存在这个key，那么这个KV在major compaction 过程中可以抛掉。因为，对于层级低于 i 的文件中如果存在同一 key 的记录，那么说明对于 key 来说，有更新鲜的 value 存在，那么过去的 value 就等于没有意义了，所以可以删除。</p><h2 id="9-Cache"><a href="#9-Cache" class="headerlink" title="9. Cache"></a>9. Cache</h2><p>读取操作如果没有在内存的 memtable 中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在 level 0 中最新的文件中找到了这个 key，那么也需要读取2次磁盘，一次是将 SSTable 的文件中的 index 部分读入内存，这样根据这个 index 可以确定 key 是在哪个 block 中存储；第二次是读入这个 block 的内容，然后在内存中查找 key 对应的 value。</p><p>LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。</p><p>下图是 table cache 的结构：</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-14.png" alt="SSTable compaction"></p><p>在 Cache 中，key值是 SSTable 的文件名称，value 部分包含两部分，一个是指向磁盘打开的 SSTable 文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个 SSTable 文件对应的 Table 结构指针，table结构在内存中，保存了 SSTable 的 index 内容以及用来指示 block cache 用的 cache_id ，当然除此外还有其它一些内容。</p><p>比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据 index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面，去 index 里面定位哪个 block 包含这个 key 。如果确定了文件哪个 block 包含这个 key，那么需要读入 block 内容，这是第二次读取。</p><p><img data-src="http://cighao.com/img/articles/leveldb/leveldb-02-15.png" alt="SSTable compaction"></p><p>Block Cache是为了加快这个过程的。上图是block cache 的结构。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><h2 id="10-Version"><a href="#10-Version" class="headerlink" title="10. Version"></a>10. Version</h2><p><strong>Version</strong> 保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。</p><p>当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p><strong>VersionSet</strong> 是所有 Version的集合，管理着所有存活的 Version。</p><p><strong>VersionEdit</strong> 表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。他们之间的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version0 +VersionEdit--&gt;Version1</span><br></pre></td></tr></table></figure><p>VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。</p><p>这其实是一种MVCC思想的实现。后续</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;本系列文章是对leveldb源码分析的笔记，基本会包含leveldb中的方方面面。阅读过程中，参照网上各博客并加上了个人的理解，所以难免有错，如有错误还请告知。&lt;/p&gt;
&lt;p&gt;如果你是刚开始看leveldb，我希望你对LSM有一定的概念。为了避免过度陷入代码细节，本文将解释leveldb的整体设计架构，各个组件的宏观设计，这样能在心里对leveldb有个轮廓，也能指导我们从哪里入手代码。&lt;/p&gt;
&lt;p&gt;本文非写者编辑，转载自：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2NpZ2hhby5jb20vMjAxNi8wOC8xNC9sZXZlbGRiLXNvdXJjZS1hbmFseXNpcy0wMi1zdHJ1Y3R1cmUv&quot; title=&quot;http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/&quot;&gt;http://cighao.com/2016/08/14/leveldb-source-analysis-02-structure/&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leveldb" scheme="https://www.ravenxrz.ink/categories/leveldb/"/>
    
    
  </entry>
  
  <entry>
    <title>Tarjan算法详解</title>
    <link href="https://www.ravenxrz.ink/archives/ed32a852.html"/>
    <id>https://www.ravenxrz.ink/archives/ed32a852.html</id>
    <published>2020-09-20T04:23:12.000Z</published>
    <updated>2020-09-20T04:30:23.840Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说说tarjan算法，一种用于求解连通图的关键点算法。</p><a id="more"></a><h2 id="1-什么是关节点？"><a href="#1-什么是关节点？" class="headerlink" title="1.什么是关节点？"></a>1.什么是关节点？</h2><p>假设现在有一个连通图，在去掉这个图中的某个节点后，连通分量增加，那么这个节点就是关节点。如下图的3去掉后，整个图拆分为了4个连通分量{1,2,4,5}</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111152803.png" alt="image-20200920111152803" style="zoom: 67%;" /><h2 id="2-求解关键点"><a href="#2-求解关键点" class="headerlink" title="2.求解关键点"></a>2.求解关键点</h2><h3 id="1-暴力法"><a href="#1-暴力法" class="headerlink" title="1. 暴力法"></a>1. 暴力法</h3><p>如果在没有学习过tarjan算法前，求解一个图的关键点最直观的方法就是暴力求解。可以分别在原连通图中去掉一点，然后用dfs或bfs遍历，若在去掉某个的点后，整个图的连通度有所增加，则该点一定是个关键点。伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;node1,node2...noden&#125;</span><br><span class="line">去掉nodei</span><br><span class="line">求解当前图的连通度</span><br><span class="line">if 连通度增加</span><br><span class="line">nodei 是关键点</span><br><span class="line">复原nodei</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>显然，包利发虽然简单，但是复杂度较高。下面我们来看tarjan算法。</p><h3 id="2-tarjan算法"><a href="#2-tarjan算法" class="headerlink" title="2. tarjan算法"></a>2. tarjan算法</h3><p><strong>回边概念</strong></p><p>为了说明方便，我们以下图为例：</p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920111908187.png" alt="image-20200920111908187" style="zoom:67%;" /><p>现在，我们从0开始对这个图做一个dfs<strong>先序</strong>遍历，可以得到<strong>深度优先搜索树</strong>如下：</p><img data-src="https://pic.downk.cc/item/5f674a36160a154a67fe2e78.png" alt="image-20200920112158018" style="zoom:50%;" /><p>这个图和上个图唯一的区别在于将1-3的边改为了红色，因为实际遍历过程中，不会经过这条边，我们把这种在dfs遍历中不会经过的边但又实际存在图中的边称为<strong>“回边“</strong>。</p><p>ok，有了回边的概念，现在说明我们应该如何确定连通图中的关键点：</p><blockquote><p>以下摘自: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p></blockquote><p>假设DFS中我们从顶点U访问到了顶点V（此时顶点V还未被访问过），那么我们称顶点U为顶点V的父顶点，V为U的孩子顶点。在顶点U之前被访问过的顶点，我们就称之为U的祖先顶点。</p><p>显然如果顶点U的<strong>所有孩子顶点</strong>可以不通过父顶点U而访问到U的祖先顶点，那么说明此时去掉顶点U不影响图的连通性，U就不是割点。相反，如果顶点U<strong>至少存在一个孩子顶点</strong>，必须通过父顶点U才能访问到U的祖先顶点，那么去掉顶点U后，顶点U的祖先顶点和孩子顶点就不连通了，说明U是一个割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a53160a154a67fe3be6.png" alt="image-20200920112749317"></p><p>上图中的箭头表示DFS访问的顺序（而不表示有向图），对于顶点D而言，D的孩子顶点可以通过连通区域1红色的边回到D的祖先顶点C（此时C已被访问过），所以此时D不是割点。</p><p><img data-src="https://pic.downk.cc/item/5f674a76160a154a67fe4a72.png" alt="image-20200920112807700"></p><p>上图中的连通区域2中的顶点，必须通过D才能访问到D的祖先顶点，所以说此时D为割点。再次强调一遍，箭头仅仅表示DFS的访问顺序，而不是表示该图是有向图。</p><p>除了上述情况，我们还应该考虑一个特殊情况，那就是DFS的根节点，因为根节点没有祖先节点。其实根顶点是不是割点也很好判断，如果从根顶点出发，一次DFS就能访问到所有的顶点，那么根顶点就不是割点。反之，如果回溯到根顶点后，还有未访问过的顶点，需要在邻接顶点上再次进行DFS，根顶点就是割点。</p><p>所以，tarjan算法的核心可以总结如如下两条规则：</p><ol><li>对于dfs生成树的根节点，如果根节点存在两颗或者两颗以上的子树，则该该节点必为关键点。</li><li>对于非叶子节点v，若v的子树中的所有节点均无指向v的祖先节点的回边，则v为关键点。</li></ol><p>对于规则1,非常好判断。所以主要说一下规则2：</p><p>要实现规则2，我们需要三个辅助数组：</p><ol><li>dfn[n]数组</li></ol><p>dfn数组的下标表示图中定点的编号，数组中的值表示dfs中的遍历顺序（访问时间戳）。每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。子顶点的dfn值一定比父顶点的dfn值大（但不一定恰好大1，比如父顶点有两个及两个以上分支的情况）。在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。</p><ol start="2"><li>low数组</li></ol><p>low数组的下标表示顶点的编号，数组中的值表示DFS中该顶点<strong>不通过父顶点</strong>能访问到的祖先顶点中最小的顺序值（或者说时间戳）。</p><blockquote><p>想一下，为什么不能通过父顶点来访问父顶点的祖先顶点？</p><p>因为我们是要判断父节点是不是关键点，如果以父节点做中间访问点就没有意义了。</p></blockquote><p>请好好理解low数组，因为它是tarjan算法的核心。</p><ol start="3"><li>parent数组</li></ol><p>parent数组的下标标识顶点的编号，数组中的值表示该顶点的父节点编号。主要用于辅助low数组的计算，再次说明low数组的含义是节点不通过其父节点能够访问的最小祖先节点的时间戳。</p><h3 id="3-看一个例子"><a href="#3-看一个例子" class="headerlink" title="3. 看一个例子"></a>3. 看一个例子</h3><p>图片摘自：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">https://www.cnblogs.com/nullzx/p/7968110.html<i class="fa fa-external-link"></i></span></p><p>可见，最难计算的是low数组。下面以一个具体的例子来说明如何计算dfn和low数组：</p><p>下图中蓝色实线箭头表示已访问过的路径，无箭头虚线表示未访问路径。已访问过的顶点用黄色标记，未访问的顶点用白色标记，DFS当前正在处理的顶点用绿色表示。带箭头的蓝色虚线表示DFS回溯时的返回路径。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114204133.png" alt="image-20200920114204133"></p><p>假设从A点出发，当前遍历到I节点，注意dfn数组是如何计算的，只要dfs前进一步，dfn就会+1. low数组的初始值和dfn相同。</p><p>当前节点为I，I想继续往前，但是发现D已经被遍历过了，于是（I，D）形成一个回边，且D不是I的父亲节点。所以我们可以更新I的low值，具体更新规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &gt; dfn[D] )</span><br><span class="line"></span><br><span class="line">  low[I] &#x3D; dfn[D]</span><br></pre></td></tr></table></figure><p>所以现在I的low值为4，</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200920114503369.png" alt="image-20200920114503369"></p><p>现在I没有其他连接点，所以回退到H，H发现可以通过I到达D，且D不是H的父亲节点。于是可以更新H的low值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(low[I] &lt; dfn[H] &amp;&amp; low[I] !&#x3D; dfn[parent[D]])</span><br><span class="line"> low[H] &#x3D; low[I]</span><br></pre></td></tr></table></figure><p><img data-src="https://pic.downk.cc/item/5f674a8b160a154a67fe53eb.png" alt="image-20200920115233737"></p><p>现在H继续向前到J：</p><p><img data-src="https://pic.downk.cc/item/5f674aa4160a154a67fe5edb.png" alt="image-20200920115330764"></p><p><img data-src="https://pic.downk.cc/item/5f674acc160a154a67fe71ab.png" alt="image-20200920115344808"></p><p>同理，由DFS访问顶点B，dfn[J] &gt; dfn[B]，B为祖先顶点，顶点J不经过父顶点H能访问到的最早时间戳就是dfn[B]，即low[J] = 2</p><p><img data-src="https://pic.downk.cc/item/5f674ae1160a154a67fe7b26.png" alt="image-20200920115401233"></p><p>我们从顶点J回溯到顶点H，显然到目前为止顶点H能访问到的最早时间戳就更新为2（因为我们到现在为止知道了能从H访问到J），所以low[H] = 2。</p><p>ok，后面重新回溯到G-&gt;F-&gt;E, 剩下的过程（访问K和L）和上面类似，不再赘述。</p><h3 id="4-tarjan-C-实现"><a href="#4-tarjan-C-实现" class="headerlink" title="4. tarjan C++实现"></a>4. tarjan C++实现</h3><p>既然核心的部分已经理解了，代码写起来就相对容易了。</p><p>1.首先声明几个辅助数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;      <span class="comment">/* 保存关节点 */</span></span><br></pre></td></tr></table></figure><ol start="2"><li>初始化图</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create graph from the input file */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input1.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：tarjan_input1.txt文件如下:</p><p>首行代表节点个数，其余行代表从一个链链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">0: 1</span><br><span class="line">1: 0 2 3</span><br><span class="line">2: 1 3</span><br><span class="line">3: 1 2 4 5</span><br><span class="line">4: 3</span><br><span class="line">5: 3</span><br></pre></td></tr></table></figure><p>这里采用邻接链表的方式保存图， 原图如下：</p><img data-src="https://pic.downk.cc/item/5f674af8160a154a67fe8508.png" alt="image-20200920120055167" style="zoom:67%;" /><ol start="3"><li>tarjan算法</li></ol><p>显然tarjan算法和dfs算法有联系：我们把dfs的框架搭起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> cur_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;</span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connaected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在这个框架上改：</p><ol><li><p>low,parent,dfn数组的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回边情况</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dfs 从深节点回溯到浅节点的情况</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;vecotr&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"><span class="keyword">if</span>(!visited[cur_node]) &#123;<span class="comment">/* 第一部分：这个作用域暂时不修改 */</span></span><br><span class="line">         visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">         parent[cur_node] = from_node;</span><br><span class="line">         dfn[cur_node] = ++counter;</span><br><span class="line">         low[cur_node] = dfn[cur_node];<span class="comment">/* 第一部分：low初始值和dfn相同 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> connected_node : graph[cur_node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(connected_node == from_node) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            dfs(graph,connected_node);</span><br><span class="line">            <span class="comment">/* 第三部分：从dfs中回溯回来 */</span></span><br><span class="line">            <span class="keyword">if</span>(low[connected_node] != dfn[parent[cur_node]] &amp;&amp;<span class="comment">/* 第三部分：子树的回边节点时间戳不是本节点的父节点的时间戳 */</span></span><br><span class="line">              low[connected_node] &lt; dfn[cur_node])&#123;<span class="comment">/*  第三部分：子树的回边节点时间戳小于当前节点的时间戳 */</span></span><br><span class="line">                 low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);<span class="comment">/*第三部分：min函数是为了保证在cur_node的多个子树中选择最小的那个*/</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low[connected_node] &gt; dfn[cur_node])&#123;<span class="comment">/* 第三部分： 子树中存在节点必须经过cur_node才能回到上层 */</span></span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">/* 第二部分：cur_node 已经是访问过的点，说明(from_node, to_node)这条边是回边，可能需要更新low数组 */</span></span><br><span class="line">        <span class="keyword">if</span>(to_node != parent[cur_node] &amp;&amp; low[from_node] &gt; dfn[to_node])&#123;</span><br><span class="line">             low[cur_node] = dfn[to_node];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>root节点单独处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* root node单独处理 */</span></span><br><span class="line"><span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">        child_num++;</span><br><span class="line">        dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        joint_node.insert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>完整代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by raven on 2020/9/20.</span></span><br><span class="line"><span class="comment"> * 求解连通图的关键点</span></span><br><span class="line"><span class="comment"> * 书上讲解得不好</span></span><br><span class="line"><span class="comment"> * 讲解参考：https://www.cnblogs.com/nullzx/p/7968110.html</span></span><br><span class="line"><span class="comment"> * 输入： tarjan_input.txt 采用邻接链表表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;         <span class="comment">/*第一次访问到第idx个节点时的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;         <span class="comment">/*第idx个节点及其子树能够回溯到的最小节点处的时间戳*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;      <span class="comment">/*第idx个节点的父亲节点*/</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; joint_node;     <span class="comment">/* 关节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link_graph</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; link_graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" connect to "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; link_graph[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; link_graph[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">create_link_graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">path</span><span class="params">(<span class="string">"/home/raven/Projects/Clion/MyLeetCode/0.数据结构/6.图/tarjan_input3.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fin.is_open()) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> node_num;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    fin &gt;&gt; node_num;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">link_graph</span><span class="params">(node_num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(fin, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="built_in">line</span>.find_first_of(<span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> num_str = <span class="built_in">line</span>.substr(<span class="number">0</span>, i); <span class="comment">/* 序号 */</span></span><br><span class="line">        <span class="built_in">string</span> connect_node = <span class="built_in">line</span>.substr(i + <span class="number">1</span>, <span class="built_in">line</span>.<span class="built_in">size</span>() - i);   <span class="comment">/* 想连接的点 */</span></span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream1</span><span class="params">(num_str)</span></span>;</span><br><span class="line">        sstream1 &gt;&gt; i;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">sstream2</span><span class="params">(connect_node)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化与 i 相连的node */</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (sstream2 &gt;&gt; temp) &#123;</span><br><span class="line">            link_graph[i].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> link_graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;link_graph, <span class="keyword">int</span> from_node, <span class="keyword">int</span> to_node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;       <span class="comment">/* 时间戳 */</span></span><br><span class="line">    <span class="keyword">int</span> cur_node = to_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visited[cur_node]) &#123;     <span class="comment">/* 深入到子树 */</span></span><br><span class="line">        visited[cur_node] = <span class="literal">true</span>;</span><br><span class="line">        dfn[cur_node] = ++counter;</span><br><span class="line">        low[cur_node] = dfn[cur_node];</span><br><span class="line">        parent[cur_node] = from_node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* dfs from "cur_node" */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node: link_graph[cur_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connected_node == parent[cur_node]) <span class="keyword">continue</span>;    <span class="comment">/* 去掉直接相邻parent回边 */</span></span><br><span class="line"></span><br><span class="line">            dfs(link_graph, cur_node, connected_node);</span><br><span class="line">            <span class="comment">/* 从dfs回来后，已经求解到子树能够回溯到的最小节点 */</span></span><br><span class="line">            <span class="keyword">if</span> (low[connected_node] &lt; dfn[cur_node] &amp;&amp;           <span class="comment">/* 子树回边到的最小节点在本节点之上 */</span></span><br><span class="line">                low[connected_node] != dfn[parent[cur_node]]) &#123;  <span class="comment">/* 保证子树回边到的最小节点不是本节点的parent节点 */</span></span><br><span class="line">                low[cur_node] = <span class="built_in">min</span>(low[cur_node],low[connected_node]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (low[connected_node] &gt; dfn[cur_node]) &#123;</span><br><span class="line">                joint_node.insert(cur_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;          <span class="comment">/* 回边 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_node != parent[from_node] &amp;&amp; dfn[cur_node] &lt; low[from_node]) &#123;</span><br><span class="line">            low[from_node] = dfn[cur_node];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* create graph from the input file */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;&amp;link_graph = create_link_graph();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print result */</span></span><br><span class="line">    print_link_graph(link_graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize global vars */</span></span><br><span class="line">    visited.resize(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    dfn.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    low.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line">    parent.reserve(link_graph.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tarjan algorithm */</span></span><br><span class="line">    <span class="comment">/* start from node 0 */</span></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dfn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    low[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root node单独处理 */</span></span><br><span class="line">    <span class="keyword">int</span> child_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> connected_node : link_graph[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[connected_node])&#123;</span><br><span class="line">            child_num++;</span><br><span class="line">            dfs(link_graph, <span class="number">0</span>, connected_node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child_num&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            joint_node.insert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print answer */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : joint_node)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"joint node "</span> &lt;&lt; node &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnVsbHp4L3AvNzk2ODExMC5odG1s" title="https://www.cnblogs.com/nullzx/p/7968110.html">Tarjan算法：求解图的割点与桥（割边）<i class="fa fa-external-link"></i></span></li><li><a href="">数据结构(C语言版本)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说说tarjan算法，一种用于求解连通图的关键点算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://www.ravenxrz.ink/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Proxylab题解</title>
    <link href="https://www.ravenxrz.ink/archives/5d2f135a.html"/>
    <id>https://www.ravenxrz.ink/archives/5d2f135a.html</id>
    <published>2020-09-06T04:27:25.000Z</published>
    <updated>2020-09-06T07:50:50.929Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab Proxylab。 也是csapp的最后一个lab。</p><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><p>proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。</p><p>再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。</p><a id="more"></a><h2 id="2-个人实现"><a href="#2-个人实现" class="headerlink" title="2.个人实现"></a>2.个人实现</h2><p>下面是整个处理流程图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906094312362.png" alt="image-20200906094312362"></p><p>client向proxy请求数据，proxy将请求放入到一个任务队列中，交由子线程处理。线程负责参数解析，首先看cache中是否有满足的数据，有则直接返回给client，没有则向server请求，server返回数据后，线程将数据插入到cache中，并返回给client。</p><p>ok，整个处理流程知道后就可以开始写代码了。</p><p><strong>下文不会给出所有代码，具体代码已贴github:</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVuLWJvb2tzLXNvdXJjZS1jb2Rlcy9jc2FwcF9sYWIvYmxvYi9tYXN0ZXIvcHJveHlsYWIvcHJveHlsYWItaGFuZG91dC9wcm94eS5j" title="https://github.com/raven-books-source-codes/csapp_lab/blob/master/proxylab/proxylab-handout/proxy.c">proxy.c<i class="fa fa-external-link"></i></span></p><h3 id="1-主线程工作"><a href="#1-主线程工作" class="headerlink" title="1. 主线程工作"></a>1. 主线程工作</h3><p>先看看主线程做的工作，主线程的工作相对简单，除了一些必要的初始化工作外，只需要开启socket监听，一旦有新连接就将该连接的文件描述符(fd)放入到任务队列中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> proxy_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> client_hostname[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> client_port[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    log_set_level(LOG_INFO);</span><br><span class="line">    sbuf_init(&amp;sbuf, WORKER_NUM * <span class="number">3</span>);</span><br><span class="line">    cache_init(&amp;mycache);</span><br><span class="line">    create_thread_workers(WORKER_NUM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse port from cmd */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        log_error(<span class="string">"need specify proxy port\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(proxy_port, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* start listen */</span></span><br><span class="line">    listenfd = Open_listenfd(proxy_port);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, BUF_SIZE,</span><br><span class="line">                    client_port, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        log_info(<span class="string">"Accepted connection from (%s, %s)\n"</span>, client_hostname,</span><br><span class="line">                 client_port);</span><br><span class="line">        <span class="comment">/* put task into task queue */</span></span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource  */</span></span><br><span class="line">    cache_deinit(&amp;mycache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-子线程工作"><a href="#2-子线程工作" class="headerlink" title="2. 子线程工作"></a>2. 子线程工作</h3><p>子线程从任务队列中获取一个“任务“，然后doit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_routinue</span><span class="params">(<span class="keyword">void</span> *vargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doit就复杂些了，因为基本包含了所有工作：</p><ol><li>负责获取client请求</li><li>解析client请求</li><li>转换成可以发送给server的请求</li><li>获取数据，可能从cache中获取，也可能从server中获取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src_uri[BUF_SIZE], dest_uri[BUF_SIZE], src_version[BUF_SIZE],</span><br><span class="line">            dest_version[BUF_SIZE], src_headers[BUF_SIZE], dest_headers[BUF_SIZE],</span><br><span class="line">            hostname[BUF_SIZE], server_port[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">char</span> *request_to_server = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (!buf || !request_to_server) &#123;</span><br><span class="line">        log_error(</span><br><span class="line">                <span class="string">"allocate memory for request which is sending to server faild\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* init */</span></span><br><span class="line">    <span class="built_in">memset</span>(src_uri, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_version, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(src_headers, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(hostname, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(request_to_server, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(server_port, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* parse request from client */</span></span><br><span class="line">    <span class="keyword">if</span> (parse_client_request(fd, src_uri, src_version, src_headers, hostname,</span><br><span class="line">                             server_port)) &#123;</span><br><span class="line">        log_error(<span class="string">"parse client request error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"request: %s\n"</span>, src_uri);</span><br><span class="line">    log_info(<span class="string">"http version: %s\n"</span>, src_version);</span><br><span class="line">    log_info(<span class="string">"headers: %s\n"</span>, src_headers);</span><br><span class="line">    log_info(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* convert uri , headers, version to the uri headers version that will be</span></span><br><span class="line"><span class="comment">     * send to server */</span></span><br><span class="line">    <span class="comment">/* append HOSTNAME first */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"Host: %s\r\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">strcat</span>(src_headers, buf);</span><br><span class="line">    <span class="keyword">if</span> (convert_request(src_uri, src_headers, src_version, dest_uri,</span><br><span class="line">                        dest_headers, dest_version)) &#123;</span><br><span class="line">        log_error(<span class="string">"convert request failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* constrcut request sending to server */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"GET %s %s\r\n"</span>, dest_uri, dest_version);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, buf);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, dest_headers);</span><br><span class="line">    <span class="built_in">strcat</span>(request_to_server, <span class="string">"\r\n"</span>); <span class="comment">/* end of requst */</span></span><br><span class="line">    log_info(<span class="string">"coneverted request to server:\n%s\n"</span>, request_to_server);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fetch data  */</span></span><br><span class="line">    <span class="comment">/* is data in cache? */</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    ci = cache_get(&amp;mycache, dest_uri);</span><br><span class="line">    <span class="keyword">int</span> read_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ci == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* fetch from server*/</span></span><br><span class="line">        <span class="keyword">if</span> ((read_len = fetch_data_from_server(request_to_server,</span><br><span class="line">                                               <span class="built_in">strlen</span>(request_to_server) + <span class="number">1</span>,</span><br><span class="line">                                               hostname, server_port, buf)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            log_error(<span class="string">"fetch data from server failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log_info(<span class="string">"fetch data from server sucess %d\n"</span>, read_len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save to cache */</span></span><br><span class="line">        log_debug(<span class="string">"put data into cache\n"</span>);</span><br><span class="line">        cache_put(&amp;mycache, dest_uri, buf, read_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fetch from cache */</span></span><br><span class="line">        log_debug(<span class="string">"fetch data from cache\n"</span>);</span><br><span class="line">        read_len = ci-&gt;effect_size;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, ci-&gt;data, read_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* send data to client */</span></span><br><span class="line">    <span class="keyword">int</span> write_len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((write_len = send_data_to_client(fd, buf, read_len)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        log_error(<span class="string">"send data to client failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">"send data to client sucess %d\n"</span>, write_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* free resource */</span></span><br><span class="line">    <span class="built_in">free</span>(request_to_server);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程就是这样，处理起来不算来。下面我们主要看看整个流程中设计到的一些互斥资源。</p><ol><li>sbuf，互斥队列，这个是csapp提供了，我们可以直接用，内部采用“生产者-消费者”的思想+信号量的实现。</li><li>cache，典型的”读写锁“实现，个人这里采用的是写优先的读写锁信号量实现。</li></ol><h3 id="3-cache的实现"><a href="#3-cache的实现" class="headerlink" title="3. cache的实现"></a>3. cache的实现</h3><p>那下面就说一下cache的实现吧。</p><p>文中定义了cache的最大size和一个object的最大size。为了简单起见，我们按照max object size来分块，然后采用LRU算法来替换cache block。</p><p>首先看看用到的数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">char</span> key[<span class="number">100</span>] ;     <span class="comment">/* use request uri as key */</span></span><br><span class="line">   <span class="keyword">char</span> data[MAX_OBJECT_SIZE];</span><br><span class="line">   <span class="keyword">size_t</span> effect_size;      <span class="comment">/* effect size */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age;      <span class="comment">/* use to implement LRU */</span></span><br><span class="line">&#125;cache_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    cache_item *ci;</span><br><span class="line">    <span class="keyword">size_t</span> ci_num;     <span class="comment">/* cache item pair_num */</span></span><br><span class="line">&#125;cache;</span><br></pre></td></tr></table></figure><p>cache_item定义了一个cache block的数据及元数据。</p><p>cache则由多个cache_item组成了。</p><p>然后是要用到的一些函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span>;</span><br><span class="line"><span class="comment">/* cache_put */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="comment">/* cache_get */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span>;</span><br></pre></td></tr></table></figure><p>接口很简单，就get、put。</p><p>先看看简单的init和deinit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cache init</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return 0 sucess</span></span><br><span class="line"><span class="comment"> *         -1 failed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_init</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* cache_get cache item pair_num */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci_num = MAX_CACHE_SIZE / MAX_OBJECT_SIZE;</span><br><span class="line">    cp-&gt;ci = (cache_item *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_item) * ci_num);</span><br><span class="line">    cp-&gt;ci_num = ci_num;</span><br><span class="line">    <span class="comment">/* init every cache block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        cp-&gt;ci[i].effect_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* semaphore init */</span></span><br><span class="line">    sem_init(&amp;rcounter_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;res_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;w_mutex, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * deinit</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_deinit</span><span class="params">(cache *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cp) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(&amp;cp-&gt;ci[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说get和put之前，先说说读写锁-写优先的操作。</p><ol><li>写-写互斥</li><li>写-读互斥</li><li>读-读共享</li><li>读加锁时，后续有读线程又有写线程时，写线程优先。</li></ol><p>看PV实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_counter = <span class="number">0</span>;<span class="comment">// 记录读者数</span></span><br><span class="line"><span class="keyword">sem_t</span> rc_mutex;<span class="comment">// 读者数的操作锁</span></span><br><span class="line"><span class="keyword">sem_t</span> res_mutex;<span class="comment">// 互斥资源锁</span></span><br><span class="line"><span class="keyword">sem_t</span> w_mutex;<span class="comment">// 实现写优先</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写者</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);<span class="comment">// 占用w_mutex, 阻塞读者</span></span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">write</span></span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读着</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;w_mutex);</span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter++;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">1</span>)</span><br><span class="line">P(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">V(&amp;w_mutex);</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">read</span></span><br><span class="line">P(&amp;rc_mutex);</span><br><span class="line">read_counter--;</span><br><span class="line"><span class="keyword">if</span>(read_counter == <span class="number">0</span>)</span><br><span class="line">V(&amp;res_mutex);</span><br><span class="line">V(&amp;rc_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 有了以上基础知识，写cache_get和cache_put就会很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put data into cache</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> * @param size</span></span><br><span class="line"><span class="comment"> * @return  0 sucess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cache_put</span><span class="params">(cache *cp, <span class="keyword">char</span> *key, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> age_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_block_idx = <span class="number">-1</span>;</span><br><span class="line">    cache_item *ci;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write start */</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;res_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* increment age counter */</span></span><br><span class="line">    age_counter++;</span><br><span class="line">    <span class="comment">/* first try to find an empty block */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size == <span class="number">0</span>) &#123;</span><br><span class="line">            empty_block_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* need evict ?*/</span></span><br><span class="line">    <span class="keyword">if</span> (empty_block_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        empty_block_idx = evict(cp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ci = &amp;cp-&gt;ci[empty_block_idx];</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;key, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">memcpy</span>(ci-&gt;data, data, <span class="built_in">size</span>);</span><br><span class="line">    ci-&gt;effect_size = <span class="built_in">size</span>;</span><br><span class="line">    ci-&gt;age = age_counter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* write end*/</span></span><br><span class="line">    V(&amp;res_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get data from cache in terms of key</span></span><br><span class="line"><span class="comment"> * @param cp</span></span><br><span class="line"><span class="comment"> * @param key</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> *         NULL not found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">cache_item *<span class="title">cache_get</span><span class="params">(cache *cp, <span class="keyword">char</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cache_item *ci = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* read start*/</span></span><br><span class="line">    P(&amp;w_mutex);</span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter++;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">1</span>)</span><br><span class="line">        P(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    V(&amp;w_mutex);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cp-&gt;ci_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cp-&gt;ci[i].effect_size != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(cp-&gt;ci[i].key, key)) &#123;</span><br><span class="line">            ci = &amp;cp-&gt;ci[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    P(&amp;rcounter_mutex);</span><br><span class="line">    rcounter--;</span><br><span class="line">    <span class="keyword">if</span> (rcounter == <span class="number">0</span>)</span><br><span class="line">        V(&amp;res_mutex);</span><br><span class="line">    V(&amp;rcounter_mutex);</span><br><span class="line">    <span class="keyword">return</span> ci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-cache实现的额外想法"><a href="#4-cache实现的额外想法" class="headerlink" title="4. cache实现的额外想法"></a>4. cache实现的额外想法</h3><p>其实cache最开始我是准备用Log-Strucutre的实现，但是发现实现起来很复杂，而且csapp的测试跑不了太久，Log-Sturcutre的优点没法充分利用。下面简单说一下思路。Log-Strucutre的特点就是Only-Append. 题目的要求是缓存从server返回的数据，而这些数据的大小不一，如果按照上文的实现，<strong>必然会导致很多内部碎片</strong>。而采用only-append的思想，则不存在内部碎片的问题，如下图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200906101718082.png" alt="image-20200906101718082"></p><p>但是这样又会存在一个新问题，那就是cache空间是有限的，我们最后总会evict掉某些块，<strong>那就很容产生外部碎片问题，</strong>这该怎么解决呢？开启一个compact线程就好了，compact线程可以周期性的对整个内存空间做压缩处理，去掉外部碎片问题。compact的触发点可以有两个：</p><ol><li>周期性触发</li><li>当前cache已满</li></ol><p>但是每次compact可能也会成为cache的读写性能瓶颈。 所以现在又该怎么办？</p><p>可以考虑<strong>“分页思想”，</strong>操作系统里面最经典的知识之一，要想提高系统的内存利用率，降低外部碎片和内部碎片，那就将内存分页，将每个取回的file进行分页,然后插入到“虚拟内存页”，不过这样需要维护页表了。实现难度较大，所以我也没做了，实在没时间继续耗在csapp上，不过还是想将这个思路写在这里，说不定未来我就回来写了呢。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这个实验涉及的知识较多，网络编程（c语言的socket一言难尽啊，特别写过python和java后。。。），多线程并发，同步信号量，cache替换策略，每一个都是重要的知识点。所以也还是挺有收获的。</p><p>当然了，这也是csapp的最后一个lab，也就意味着我的csapp之旅告一段落了，但是csapp这本书是真的值得每个程序员多看几遍的，里面的每个知识点都相当重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab Proxylab。 也是csapp的最后一个lab。&lt;/p&gt;
&lt;h2 id=&quot;1-实验目的&quot;&gt;&lt;a href=&quot;#1-实验目的&quot; class=&quot;headerlink&quot; title=&quot;1.实验目的&quot;&gt;&lt;/a&gt;1.实验目的&lt;/h2&gt;&lt;p&gt;proxylab, 从最终目的来看，我们实现的是一个代理服务器。proxy接收来client的请求，转发给server，并从server中取得数据后，返回给client。另外，proxy从server中取回数据后还需要做cache，这样，当另一个client请求相同的数据时，就不用从server端请求数据，降低了server的压力。&lt;/p&gt;
&lt;p&gt;再看看一些细节的要求，要求支持多线程请求，多线程涉及一些同步的问题，所以做的时候一定要考虑哪些是互斥资源，用什么方式同步等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="proxylab" scheme="https://www.ravenxrz.ink/tags/proxylab/"/>
    
  </entry>
  
  <entry>
    <title>Csapp-Malloclab题解</title>
    <link href="https://www.ravenxrz.ink/archives/36920455.html"/>
    <id>https://www.ravenxrz.ink/archives/36920455.html</id>
    <published>2020-08-26T08:45:31.000Z</published>
    <updated>2020-09-06T07:37:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab，malloclab，自己手写一个内存分配器。</p><a id="more"></a><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h2><p>malloclab，简单明了的说就是实现一个自己的 malloc,free,realloc函数。做完这个实验你能够加深对指针的理解，掌握一些内存分配中的核心概念，如：如何组织heap，如何找到可用free block，采用first-fit, next-fit,best-fit?  如何在吞吐量和内存利用率之间做trade-off等。</p><p>就我个人的感受来说，malloclab的基础知识不算难，但是代码中充斥了大量的指针运算，为了避免硬编码指针运算，会定义一些宏，而定义宏来操作则会加大debug的难度（当然了，诸如linus这样的大神会觉得，代码写好了，为什么还用debug？），debug基本只能靠gdb和print，所以整体还是有难度了。</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><p>这里简单说一下要做这个实验需要哪些背景知识。</p><p>首先，为了写一个alloctor,需要解决哪些问题。csapp本章的ppt中列出了一些关键问题：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/clip_image001.png" alt="Implementation Issues  How do we know how much memory to free given just a  pointer?  How do we keep track of the free blocks?  What do we do with the extra space when allocating a  structure that is smaller than the free block it is placed in?  How do we pick a block to use for allocation — many  might fit?  How do we reinsert freed block? "></p><p>第一个问题，free(ptr)这样的routine是如何知道本次释放的block的大小的？</p><p>很显然我们需要一些额外的信息来存放block的元信息。之类的具体做法是在block的前面添加一个word，存放分配的size和是否已分配状态。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170802474.png" alt="image-20200826170802474"></p><p><strong>注意：这里只是给出了最简单的情况，实际操作中，额外的元数据不仅只有这些</strong></p><p>第二个问题，如何追踪free blocks?</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826170901374.png" alt="image-20200826170901374"></p><p>csapp一共给出了4种方案。其中implicit list在书上给出了源码，我个人实现了implicit list和explicit list。segregated free list感觉利用OO思想，把explicit list封装一下也是能够实现的，红黑树同理。</p><p>第三个问题，拆分策略（详见代码的place函数）</p><p>第四个问题，一般来说有 first-fit, next-fit和best-fit策略，我这里采用了最简单的first-fit策略。（这其实是一个trade-off的问题，看你是想要吞吐量高还是内存利用率高了）</p><p>ok，下面就来看看implicit list(书上有）和explicit list两种方案是如何实现的。</p><h2 id="3-Implicit-list"><a href="#3-Implicit-list" class="headerlink" title="3. Implicit list"></a>3. Implicit list</h2><p>下面是一个implicit list的组织方式和一个block的具体情况，一个block采用了双边tag，保证可以前向和后向索引。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826171525409.png" alt="image-20200826171525409"></p><p>这种方案的优点：实现简单。缺点：寻找free block的开销过大。</p><p>现在说说lab中给的一些代码把：</p><ol><li>memlib，这个文件中，给出了heap扩展的方法，除此之外，我们还可以获取当前可用heap的第一个字节，最后一个字节，heap size等。具体实现是通过一个sbrk指针来操作的。</li><li>mdriver, 这个文件不用看，只用它编译出来的可执行文件即可，用于测试我们写的allocator是否正确。</li><li>mm.c， 这个就是我们要操作的文件了，主要实现三个函数 mm_malloc,mm_free,mm_realloc，我们再额外定义自己需要的函数。</li></ol><p>好的，下面再说说具体代码，因为代码中涉及到很多指针操作，我们对这些操作做一个峰装，用宏定义来操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))           </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) </span></span><br></pre></td></tr></table></figure><p>注释给出了每个宏的意义。</p><p>一些额外的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *free_list_head = <span class="literal">NULL</span>; <span class="comment">// 整个list的头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;<span class="comment">// heap 不够分配时，用于扩展heap大小</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;<span class="comment">// free block时，可能存在一些前后也是free block的情况，这时需要做合并，不允许一条list上，同时存在两个连续的free block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">// 在list上找到可满足本次malloc请求的block</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 放置当前块，如果size &lt; 本次block size - MIN_BLOCK ，则需要做split操作</span></span><br></pre></td></tr></table></figure><h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数对mm做初始化，工作包括：</p><ol><li>分配4个字，第0个字为pad，为了后续分配的块payload首地址能够是8字节对齐。</li><li>第1-2个字为序言块，free_list_head指向这里，相当于给list一个定义，不然我们从哪里开始search呢？</li><li>第3个字，结尾块，主要用于确定尾边界。</li><li>extend_heap, 分配一大块heap，用于后续malloc请求时分配。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Create the inital empty heap</span></span><br><span class="line">    <span class="keyword">if</span>( (free_list_head = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(free_list_head, <span class="number">0</span>);</span><br><span class="line">    PUT(free_list_head + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(free_list_head + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    free_list_head += (<span class="number">2</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>工作：</p><ol><li>size更新，保证size为偶数个word</li><li>为当前分配的block添加元数据，即header和footer信息</li><li>更新尾边界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化free block的header/footer和epilogue header</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Coalesce if the previous block was free</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>mm_malloc也比较简单，首先更改请求size，满足8字节对齐+元数据的开销要求。接着尝试找到当前可用heap中是否有能够满足本次请求的block，有则直接place，无则需要扩展当前可用heap的大小，扩展后再place。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">// Amount to extend heap if no fit</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ajust block size to include overhea and alignment reqs;</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE); <span class="comment">// 超过8字节，加上header/footer块开销，向上取整保证是8的倍数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the free list for a fit</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No fit found. Get more memory and place the block</span></span><br><span class="line">        extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit"><a href="#find-fit" class="headerlink" title="find_fit"></a>find_fit</h3><p>遍历整个list，找到还未分配且满足当前请求大小的block，然后返回该block的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp ;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place"><a href="#place" class="headerlink" title="place"></a>place</h3><p>place的工作也很简单：</p><ol><li>最小块大小（2*DSIZE) &lt;= 当前块的大小-当前请求的块大小 ，则对当前block做split</li><li>否则，直接place即可。</li></ol><p>现在继续看看free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span>(remain_size &gt;= <span class="number">2</span>*DSIZE)  <span class="comment">// 剩下的块，最少需要一个double word (header/footer占用一个double word, pyaload不为空，再加上对齐要求)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不足一个双字，保留内部碎片</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free"><a href="#mm-free" class="headerlink" title="mm_free"></a>mm_free</h3><p>可以看到，free也是相当简单的，将当前block的分配状态从1更新到0即可。然后做<strong>coalesce操作:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    print_allocated_info();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h3><p>free block后要考虑前后是否也有free block, 如果存在free block需要进行合并.下面给出了4种情况:</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205642747.png" alt="image-20200826205642747"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205653451.png" alt="image-20200826205653451"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205703127.png" alt="image-20200826205703127"></p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200826205708948.png" alt="image-20200826205708948"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于存在序言块和尾块，避免了一些边界检查。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pre_alloc &amp;&amp; next_alloc)&#123;    <span class="comment">// case1: 前后都分配</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre_alloc &amp;&amp; !next_alloc)&#123;  <span class="comment">// case 2： 前分配，后free</span></span><br><span class="line">        <span class="keyword">void</span> *next_block = NEXT_BLKP(bp);</span><br><span class="line">        size += GET_SIZE(HDRP(next_block));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(next_block), PACK(size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 其余两个tag不用清空？ 正常情况确实不用清空。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!pre_alloc &amp;&amp; next_alloc)&#123;  <span class="comment">// case 3: 前free，后分配</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 前后两个都是free</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h3><p>realloc函数实现也很简单, 重新分配size大小的块,然后将旧块内容复制到新块内容上. 注意这里也考虑了block变小的情况.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *oldptr = ptr;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line">    <span class="keyword">size_t</span> copySize;</span><br><span class="line">    </span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copySize = GET_SIZE(HDRP(oldptr));</span><br><span class="line">    <span class="keyword">if</span> (size &lt; copySize)</span><br><span class="line">      copySize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, oldptr, copySize);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 以上就是implicit list的所有内容, 下面我们开始讲解explicit list的实现.</p><h2 id="4-explicit-list"><a href="#4-explicit-list" class="headerlink" title="4. explicit list"></a>4. explicit list</h2><p>explicit list和implicit list的区别在于前者在 <strong>逻辑空间</strong> 中维护一个free list, 里面只保存free的blocks, 而后者则是在 <strong>虚拟地址空间</strong>中维护整个list,里面即包含了free blocks也包含了allocated blocks. 当然了, explicit list底层也是虚拟地址空间.下面这张图给出了explicit list的上层结构:</p><p><img data-src="https://pic.downk.cc/item/5f465f2f160a154a67918a70.png" alt="image-20200826210834218"></p><p>下面给出implicit和explicit的每一块的具体结构对比:</p><p><img data-src="https://pic.downk.cc/item/5f465f75160a154a6791b829.png" alt="image-20200826211059458"></p><p>可以看到,explicit比较implicit,每一个块只是多了两个字段,用于保存下一个free block的地址(next)和上一个free block的地址(prev).</p><p>想一下,explict的优点: 大大提高搜索free block的效率. 但是实现复杂度比implicit难,因为多一个逻辑空间的操作.</p><p>首先第一个问题,next和prev占用多大空间? 对于32位的os来说,地址空间的编址大小的32位(4字节), 64位的os则位64位(8字节). 为了简单起见,本文中只考虑32位的情况(gcc编译时加上-m32的参数,默认的makefile已经给出).</p><p>好的现在确定了next和prev的大小,再来确定一个最小块的大小,最小块应该包含header+footer+next+prev+payload,其中payload最小为1个字节, 同时最小块应该保证8字节对齐要求,综合以上所述,一个最小块为:<br>$$<br>4+4+4+1+4=17,向上取8字节对齐,则\<br>MIN_BLOCK = 24<br>$$<br>ok,现在再说明代码中做的一些规定:</p><ol><li>find策略,采用first-fit策略</li><li>对于free后的block应该如何重新插入free list, 本文采用LIFO策略</li><li>对齐约定, 8字节对齐</li></ol><p>有了以上的说明, 差不多就可以写代码了,先从定义的宏出发:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4             <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (unsigned int)(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-3 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - 4 * WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算：计算当前block的“NEXT&quot;指针域</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_PTR(bp) ((char *)(bp)-2 * WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_PTR(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// free block运算： 计算下一个free block的payload首地址</span></span><br><span class="line"><span class="comment">// bp:当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_FREE_BLKP(bp) ((char *)(*(unsigned int *)(NEXT_PTR(bp))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_FREE_BLKP(bp) ((char *)(*(unsigned int *)(PREV_PTR(bp))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual address计算：计算下一个block的payload首地址</span></span><br><span class="line"><span class="comment">// bp: 当前block的payload首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(HDRP(bp) - WSIZE))</span></span><br></pre></td></tr></table></figure><p>可以看到, 基本上和implicit的宏差不多, 只是多了NEXT_FREE_BLKP这类宏, 由于调整了每个block的具体layout(多了next和prev), 所以一些运算,如HDRP等需要对应调整.</p><p>然后就是各个函数:</p><blockquote><p>NOTE: 再次注意存在逻辑空间和虚拟地址空间两个空间.</p></blockquote><h3 id="mm-init-1"><a href="#mm-init-1" class="headerlink" title="mm_init"></a>mm_init</h3><p>这个函数的主要工作包括:</p><ol><li>分配 一个word+ MIN_BLOCK</li><li>第一个word是做pad用,用于保证后续分配的block能够8字节对齐,和implicit一样.</li><li>后面的MIN_BLOCK用于作为free_list_head, 和impilicit的序言块作用相同</li><li>最后分配一个CHUNK,分配函数的内部会将这个chunk块插入到free list 中.</li></ol><p>整体来说,explicit的mm_init和implicit的mm_init作用相同,但是组织方式发生了一些变化.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个块，用于存放root指针</span></span><br><span class="line">    <span class="keyword">char</span> *init_block_p;</span><br><span class="line">    <span class="keyword">if</span> ((init_block_p = mem_sbrk(MIN_BLOCK + WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_block_p = (<span class="keyword">char</span> *)(init_block_p) + WSIZE; <span class="comment">// 跳过首个对齐块</span></span><br><span class="line"></span><br><span class="line">    free_list_head = init_block_p + <span class="number">3</span> * WSIZE;</span><br><span class="line">    PUT(PREV_PTR(free_list_head), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_PTR(free_list_head), <span class="literal">NULL</span>); <span class="comment">// 初始化root指针为NULL（0）</span></span><br><span class="line">    PUT(HDRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line">    PUT(FTRP(free_list_head), PACK(MIN_BLOCK, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extend the empty heap with a free block of CHUNKSIZE bytes</span></span><br><span class="line">    <span class="keyword">if</span> ((allocate_from_chunk(CHUNKSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="allocate-from-heap"><a href="#allocate-from-heap" class="headerlink" title="allocate_from_heap"></a>allocate_from_heap</h3><p>allocate_from_heap做的工作很简单, 扩展heap大小, 然后将扩展出来的block插入到free_lilst中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展heap,并分配满足当前需求的块到free_list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size  需求size 字节为单位</span></span><br><span class="line"><span class="comment"> * @return void*  成功：当前能够分配的块的首地址</span></span><br><span class="line"><span class="comment"> *                失败： NULL， 一般只在run out out memory时才会NULL </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">allocate_from_heap</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *cur_bp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> extend_size = MAX(size, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((cur_bp = extend_heap(extend_size / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到free list中</span></span><br><span class="line">    insert_to_free_list(cur_bp);</span><br><span class="line">    <span class="keyword">return</span> cur_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extend-heap-1"><a href="#extend-heap-1" class="headerlink" title="extend_heap"></a>extend_heap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 扩展当前heap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param words  需要扩展的words, 字为单位</span></span><br><span class="line"><span class="comment"> * @return void* 当前可用块的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = (<span class="keyword">char</span> *)(bp) + <span class="number">3</span> * WSIZE; <span class="comment">// point to payload</span></span><br><span class="line">    <span class="comment">// set 本块信息</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-to-free-list"><a href="#insert-to-free-list" class="headerlink" title="insert_to_free_list"></a>insert_to_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp free block的payload的首个地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_to_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *head = free_list_head;</span><br><span class="line">    <span class="keyword">void</span> *p = NEXT_FREE_BLKP(head); <span class="comment">// 当前首个有效节点 或者 NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新当前要插入的节点</span></span><br><span class="line">        PUT(NEXT_PTR(bp), p);</span><br><span class="line">        PUT(PREV_PTR(bp), head);</span><br><span class="line">        <span class="comment">// 更新head</span></span><br><span class="line">        PUT(NEXT_PTR(head), bp);</span><br><span class="line">        <span class="comment">// 更新p节点(原首有效节点)</span></span><br><span class="line">        PUT(PREV_PTR(p), bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用LIFO策略,将bp所指向的block插入到free_list中.</p><h3 id="mm-malloc-1"><a href="#mm-malloc-1" class="headerlink" title="mm_malloc"></a>mm_malloc</h3><p>注释中说了本函数的工作. 首先从free_list中看有没有适合的块, 否则从heap中分配.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc, 根据 size 返回一个指针，该指针指向这个block的payload首地址</span></span><br><span class="line"><span class="comment"> * 主要工作：</span></span><br><span class="line"><span class="comment"> * 1. size的round操作，满足最小块需求以及对齐限制</span></span><br><span class="line"><span class="comment"> * 2. 首先检查当前free list中是否有可以满足 asize(adjusted size) ，有则place，（place可能需要split),无则第3步</span></span><br><span class="line"><span class="comment"> * 3. 从当前heap中分配新的free block， 插入到free list中，然后place</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">// Adjusted block size</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: round size 满足最小块和对齐限制</span></span><br><span class="line">    asize = ALIGN(<span class="number">2</span> * DSIZE + size); <span class="comment">// 2*DSIZE = header+ footer + next + prev</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: 从free list 中找free block</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="comment">//free list中找不到</span></span><br><span class="line">        <span class="comment">// step3: 从当前heap中分配</span></span><br><span class="line">        <span class="keyword">if</span> ((bp = allocate_from_heap(asize)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-fit-1"><a href="#find-fit-1" class="headerlink" title="find_fit"></a>find_fit</h3><p>从free list中找到第一个满足需求size的free block并返回该block的payload首地址.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用first-fit policy</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @return void* 成功，返回可用块的首地址</span></span><br><span class="line"><span class="comment"> *               失败，返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span> &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">0</span> &amp;&amp; size &lt;= GET_SIZE(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="place-1"><a href="#place-1" class="headerlink" title="place"></a>place</h3><p>本函数实现,将bp所指向的free block在可能的情况下做split.具体来说,是当当前free block的size &gt;= 请求size+最小block时会做split.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief place block</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> origin_size;</span><br><span class="line">    <span class="keyword">size_t</span> remain_size;</span><br><span class="line"></span><br><span class="line">    origin_size = GET_SIZE(HDRP(bp));</span><br><span class="line">    remain_size = origin_size - size;</span><br><span class="line">    <span class="keyword">if</span> (remain_size &gt;= MIN_BLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可拆分</span></span><br><span class="line">        <span class="comment">// 设置拆分后剩下的块的size和allocate情况</span></span><br><span class="line">        <span class="keyword">char</span> *remain_blockp = (<span class="keyword">char</span> *)(bp) + size;</span><br><span class="line">        PUT(HDRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(remain_blockp), PACK(remain_size, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 更新指针，将剩下块加入到free list中</span></span><br><span class="line">        <span class="keyword">char</span> *prev_blockp = PREV_FREE_BLKP(bp);</span><br><span class="line">        <span class="keyword">char</span> *next_blockp = NEXT_FREE_BLKP(bp);</span><br><span class="line">        PUT(NEXT_PTR(remain_blockp), next_blockp);</span><br><span class="line">        PUT(PREV_PTR(remain_blockp), prev_blockp);</span><br><span class="line">        PUT(NEXT_PTR(prev_blockp), remain_blockp);</span><br><span class="line">        <span class="keyword">if</span> (next_blockp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PUT(PREV_PTR(next_blockp), remain_blockp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分配的块</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 断开原block与free list的连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可拆分</span></span><br><span class="line">        <span class="comment">// 更新header和footer</span></span><br><span class="line">        PUT(HDRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(origin_size, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 移除free block from free list</span></span><br><span class="line">        delete_from_free_list(bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="delete-from-free-list"><a href="#delete-from-free-list" class="headerlink" title="delete_from_free_list"></a>delete_from_free_list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从free list中删除 bp 所在节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_from_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_free_block = PREV_FREE_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *next_free_block = NEXT_FREE_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_free_block == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_block), next_free_block);</span><br><span class="line">        PUT(PREV_PTR(next_free_block), prev_free_block);</span><br><span class="line">        <span class="comment">// 断开连接</span></span><br><span class="line">        PUT(NEXT_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">        PUT(PREV_PTR(bp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mm-free-1"><a href="#mm-free-1" class="headerlink" title="mm_free"></a>mm_free</h3><p>这里的free函数和implicit list的free函数一致,重点在coalesce函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">    debug();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coalesce-1"><a href="#coalesce-1" class="headerlink" title="coalesce"></a>coalesce</h3><p>coalesce是每种分配器的重点,需要考虑如何合并在虚拟地址空间中的相邻blocks之间的关系, 和implicit一样,explicit也有4种情况:</p><p><img data-src="https://pic.downk.cc/item/5f466750160a154a6795783c.png" alt="image-20200826214359077"></p><p><img data-src="https://pic.downk.cc/item/5f46675f160a154a67957e67.png" alt="image-20200826214409356"></p><p><img data-src="https://pic.downk.cc/item/5f466771160a154a6795847c.png" alt="image-20200826214415780"></p><p><img data-src="https://pic.downk.cc/item/5f46677a160a154a679586f3.png" alt="image-20200826214426686"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 合并地址空间，并将可用free block插入到free list中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前block的payload首地址</span></span><br><span class="line"><span class="comment"> *           </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = (<span class="keyword">char</span> *)mem_heap_hi() + <span class="number">1</span>; <span class="comment">// heap的上边界</span></span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_blockp &gt;= mem_max_addr)</span><br><span class="line">    &#123; <span class="comment">// next_block超过heap的上边界，只用考虑prev_blockp</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_alloc)</span><br><span class="line">        &#123;</span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        next_alloc = GET_ALLOC(HDRP(next_blockp));</span><br><span class="line">        <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 1: 前后都已经分配</span></span><br><span class="line">            case1(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        &#123; <span class="comment">//case 3: 前未分配，后分配</span></span><br><span class="line">            case3(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">        &#123; <span class="comment">// case 2: 前分配，后未分配</span></span><br><span class="line">            case2(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// case 4: 前后都未分配</span></span><br><span class="line">            case4(bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case1</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前分配后未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case2</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="keyword">void</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(next_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前后free block指针</span></span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief case 3 前一个block未分配，后一个块已分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp 当前块的payload首地址</span></span><br><span class="line"><span class="comment"> * @return void* 合并后的payload首地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case3</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    <span class="keyword">char</span> *prev_free_blockp;</span><br><span class="line">    <span class="keyword">char</span> *next_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(prev_blockp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新块大小</span></span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前后free块并更新</span></span><br><span class="line">    next_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    prev_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">if</span> (next_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev_free_blockp), next_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next_free_blockp), prev_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LIFO策略，插入到free list的头部</span></span><br><span class="line">    insert_to_free_list(prev_blockp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="case4"><a href="#case4" class="headerlink" title="case4"></a>case4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 前后都未分配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param bp </span></span><br><span class="line"><span class="comment"> * @return void* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">case4</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *prev_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next1_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next_blockp;</span><br><span class="line">    <span class="keyword">void</span> *prev2_free_blockp;</span><br><span class="line">    <span class="keyword">void</span> *next2_free_blockp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    prev_blockp = PREV_BLKP(bp);</span><br><span class="line">    next_blockp = NEXT_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新size</span></span><br><span class="line">    <span class="keyword">size_t</span> size1 = GET_SIZE(HDRP(prev_blockp));</span><br><span class="line">    <span class="keyword">size_t</span> size2 = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">size_t</span> size3 = GET_SIZE(HDRP(next_blockp));</span><br><span class="line">    size = size1 + size2 + size3;</span><br><span class="line">    PUT(HDRP(prev_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(next_blockp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    bp = prev_blockp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新前半部 free block指针</span></span><br><span class="line">    prev1_free_blockp = PREV_FREE_BLKP(prev_blockp);</span><br><span class="line">    next1_free_blockp = NEXT_FREE_BLKP(prev_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next1_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev1_free_blockp), next1_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next1_free_blockp), prev1_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新后半部 free block指针</span></span><br><span class="line">    prev2_free_blockp = PREV_FREE_BLKP(next_blockp);</span><br><span class="line">    next2_free_blockp = NEXT_FREE_BLKP(next_blockp);</span><br><span class="line">    <span class="keyword">if</span> (next2_free_blockp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_PTR(prev2_free_blockp), next2_free_blockp);</span><br><span class="line">        PUT(PREV_PTR(next2_free_blockp), prev2_free_blockp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LIFO策略插入free list</span></span><br><span class="line">    insert_to_free_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其余debug用的函数"><a href="#其余debug用的函数" class="headerlink" title="其余debug用的函数"></a>其余debug用的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_allocated_info();</span><br><span class="line">    print_free_blocks_info();</span><br><span class="line">    consistent_check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  打印分配情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_allocated_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_addr = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============start allocated info===========\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt; mem_max_addr &amp;&amp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;block%d range %p  %p size=%d, payload %p  %p block size=%d\n&quot;</span>, idx, HDRP(bp), FTRP(bp) + WSIZE, FTRP(bp) - HDRP(bp) + WSIZE, (<span class="keyword">char</span> *)bp, FTRP(bp), FTRP(bp) - (<span class="keyword">char</span> *)(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=============end allocated info===========\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consistent_check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查free list中的所有block都为free</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">char</span> *mem_max_heap = mem_heap_hi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_FREE_BLKP(free_list_head); bp != <span class="literal">NULL</span>; bp = NEXT_FREE_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_ALLOC(HDRP(bp)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d free list中存在块已分配\n&quot;</span>, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否所有free block都在free list中</span></span><br><span class="line">    <span class="keyword">for</span> (bp = NEXT_BLKP(free_list_head); bp &lt;= mem_max_heap; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; !is_in_free_list(bp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 存在free block %p 不在free list中\n&quot;</span>, __LINE__, bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_in_free_list</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p = NEXT_FREE_BLKP(free_list_head); p != <span class="literal">NULL</span>; p = NEXT_FREE_BLKP(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == bp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是整个explicit list的实现了. 最终实现的效果是,跑完所有trace file,得分 83/100. 算是个良水平吧. 要想实现优秀水平,可以考虑做做segregated list或者red block tree list.</p><p>再谈一些优化:</p><ol><li>空间优化,对于分配的block, 可以不存储NEXT和PREV指针, 从而扩大payload空间,提高空间利用率.</li><li>封装整个free list, 然后改用segregated list.</li><li>现在search策略是从头search到尾部, ,比较慢,可以针对每个free block建立index, index数据结构选择rbtree, 应该可以大大提高分配吞吐量.</li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>嗯, 个人觉得这个lab仅次于cachelab, 但是它的难点不在于思路,而在于如何调试,毕竟像我这样的菜鸡,不debug是不可能,这辈子都不可能不debug的, 而这次lab有很多macros, 就很难在gdb中调试,gdb中也只能通过exam命令查看连续的地址内存空间, 但是当trace file中给定的malloc size过大时, exam命令也很难快速查看, 所以个人在做的时候, 将trace file的malloc size手动改小了(当然后面还是改回去了的),然后debug就会相对轻松一些. </p><p>再谈谈收获, 总算清晰的知道了什么是虚拟内存,页表,TLB,为什么要设计它们,它们有什么好处. 也知道了malloc的基本工作原理, 现在想想这些技术也不是离我们那么遥远, 继续加油吧, 下一个lab是网络相关的了, 不过下一次lab又得暂停一阵子了, 项目的事情让人心累…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab，malloclab，自己手写一个内存分配器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
  </entry>
  
  <entry>
    <title>Csapp-Shlab题解</title>
    <link href="https://www.ravenxrz.ink/archives/cf3e2591.html"/>
    <id>https://www.ravenxrz.ink/archives/cf3e2591.html</id>
    <published>2020-08-15T11:36:25.000Z</published>
    <updated>2020-09-06T07:37:36.751Z</updated>
    
    <content type="html"><![CDATA[<p>本次lab, shlab. 即编写一个简单的shell。</p><h2 id="0-背景知识"><a href="#0-背景知识" class="headerlink" title="0. 背景知识"></a>0. 背景知识</h2><p>shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。</p><blockquote><p>书籍对应 异常控制流 章节</p></blockquote><ol><li>理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。</li><li>理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 <strong>Async-Signal-Safety问题及解决方案（也是本次实验的难点）</strong> ，掌握async-signal-safety的guideline.</li></ol><a id="more"></a><h2 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1. 题目要求"></a>1. 题目要求</h2><p>题目的要求主要看shlab的writeup的 《The tsh Specification》小节：</p><p>Your tsh shell should have the following features:</p><ol><li><p>The prompt should be the string “tsh&gt; ”.</p></li><li><p>The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If name is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that name is the path of an executable file, which it loads and runs in the context of an initial child process (In this context, the term <em>job</em> refers to this initial child process).</p></li><li><p>tsh need not support pipes (|) or I/O redirection (&lt; and &gt;).</p></li><li><p>Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p></li><li><p>If the command line ends with an ampersand &amp;, then tsh should run the job in the background. Otherwise, it should run the job in the foreground.</p></li><li><p>Each job can be identified by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the prefix ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.)</p></li><li><p>tsh should support the following built-in commands:<br>– The quit command terminates the shell.<br>– The jobs command lists all background jobs.<br>– The bg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it inthe background. The <job> argument can be either a PID or a JID.<br>– The fg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the foreground. The <job> argument can be either a PID or a JID.</p></li><li><p>tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p></li></ol><p>上述是整个shell的功能要求，但是我们不必从0写整个代码，整体代码的框架是已经搭建好了的，只用完成tsh.c文件中的以下几个函数：</p><ol><li>eval: Main routine that parses and interprets the command line. [70 lines]</li><li>builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</li><li>do bgfg: Implements the bg and fg built-in commands. [50 lines]</li><li>waitfg: Waits for a foreground job to complete. [20 lines]</li><li>sigchld handler: Catches SIGCHILD signals. 80 lines]</li><li>sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</li><li>sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</li></ol><p>一共7个函数，每个函数也给出了建议的行数。</p><p>再看下如何验证lab。 shlab提供了tshref，用于参考。同时给出了16个trace file以及一个driver，具体验证过程为， trace file指导driver运行制定shell，查看我们写的shell是否和tshref输出一致。举个例子，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt, 在tsh（我们写的shell）下执行trace01.txt中的命令，然后tsh会给出一些输出。此时再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make rtest01</span><br></pre></td></tr></table></figure><p>driver会读取trace01.txt 在tshref(参考的shell)下执行trace01.txt中的命令，然后tshref会给出一些输出。对比两次输出，即可知道自己写的shell是否正确了。</p><p>当然了，一共16个trace file,每次都make，相当麻烦，所以lab中还给出了 tshref.out文件，这里面给出了所有tshref的输出结果。</p><h2 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2. 题目分析"></a>2. 题目分析</h2><p>稍微思考下，可以分析出，其实shell就两种命令，一种buildin命令(fg,bg,quit,jobs)，需要立即在shell中执行，一种外部命令，需要fork出新进程来执行，只不过这里需要考虑是前台进程和后台进程。</p><p>那先说说<strong>buildin命令</strong>，其中 jobs 已经有默认实现了，quit也相对简单，剩下的就是fg和bg。</p><p>那fg和bg做了什么事情呢? 其实代码中已经给出了答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>fg命令，无法是将后台（Running 或 Stopped）转换到前台来。</p><p>bg命令，将后台Stopped的进程转换为后台Running。</p><p>额外的一些工作就是fg和bg的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fg%jid</span><br><span class="line">或</span><br><span class="line">fg pid</span><br></pre></td></tr></table></figure><p>自己通过是否有%来解析就好。</p><p>再来看看<strong>外部命令</strong> ， 在parseline函数执行时，会返回当前的命令是前台进程还是后台进程。所以这部分不用我们操心。我们唯一需要做得，就是对前台进程和后台进程”分别处理“。</p><p><strong>这里会用到几个知识点：</strong></p><ol><li><p>子进程在terminate或stop时，内核会发送SIGCHLD给父进程</p></li><li><p>父进程需要通过wait族函数回收子进程，否则子进程变为zombie进程，耗费系统资源。</p></li></ol><p>ok，有了两个知识点，思考一下如何对待前台进程和后台进程：</p><ol><li>前台进程：最为直接的想法就是父进程调用wait系统调用，等待前台进程结束。但请注意刚才提到的知识点1，前台进程结束后，wait系统调用的确返回了，但同时，父进程会收到SIGCHLD信号，sigchld_handler会被调用。这会带来什么问题？接着看后台进程如何处理。</li><li>后台进程：后台进程意味不能阻塞tsh进程，也就意味着我们不能在tsh中调用wait系统调用，那唯一能回收后台进程（除非强制kill）就是当后台进程结束后，父进程会收到SIGHLD信号，通过sigchld_handler来回收，也就意味着我们的sigchld_handler中会有wait系统调用的存在。<strong>ok，结合目前前台进程的处理，就会存在一个严重的问题。</strong></li></ol><p><strong>前台进程，在tsh.c 中出现了两次wait操作。一次在最开始fork出前台进程时，一次出现在sigchld_handler中。</strong>所以这种情况需要处理，大体思路有两种：</p><ol><li>前台进程，fork后立即wait保持不变，在sigchld_handler中过滤掉前台进程的terminate，避免重复wait。</li><li>前台进程，fork后的wait变为”伪wait”, 前后台进程统一在sigchld_handler中回收处理。那什么是”伪wait“，我们要之前前台进程的意思是什么，作用是什么，作用就是阻塞住当前的tsh，不允许输入新命令，除此之外，前后台进程都是一样的。ok，既然这样，我们只用让tsh阻塞住即可，采用什么方法则看个人实现了。</li></ol><p>显然，第二种统一处理更容易理解，维护。当然，writeup其实给出了一种解决方案：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133536133.png" alt="image-20200805133536133"></p><p>另外一个问题就是，<strong>信号的转发</strong>。</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200805133902911.png" alt="image-20200805133902911"></p><p>这里要解决的是，后台进程不应该接收到Ctrl-C所引发的信号。</p><p>还有一个问题就是<strong>保持和tshref的输出相同</strong>，那需要在恰当的位置，打印出相应的信息，这部分不难，但其实挺磨人的。</p><p>最后就是非tsh需求的逻辑部分了，那就是<strong>如何编写 async-signal-safety 的代码</strong>。如果你是看了csapp课程或书籍的话， 那应该可以意识这里会有一些async-signal-safety问题。ppt中其实基本上给出所有我们会遇到的问题，以及一些常用的guideline。这部分需要仔细阅读，理解清楚，必然很可能出现一些莫名的bug。</p><p>下面贴出我个人的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="keyword">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="keyword">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="keyword">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="keyword">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span></span></span><br><span class="line"><span class="class">&#123;</span>                          <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="keyword">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="keyword">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:            <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read command line */</span></span><br><span class="line">        <span class="keyword">if</span> (emit_prompt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">            app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">        &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bg;                               <span class="comment">// 是否是后台程序</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];                    <span class="comment">// cmd copy</span></span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS];                  <span class="comment">// 解析后的命令</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;                       <span class="comment">// 子进程id</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, pre_one; <span class="comment">// 用于同步</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式执行命令</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 外部命令</span></span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">0</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能够运行的外部命令</span></span><br><span class="line">        <span class="comment">// Parent: 在fork前，block SIGCHLD 信号，避免在addjob之前Child结束，触发sigchld_handler,从而deltejob比addjob先执行</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">        &#123;                  <span class="comment">// Child</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 改变组id，避免信号的自动传送(write up中有更相似的描述)</span></span><br><span class="line">            <span class="comment">// 执行exec之前，解除从Parent中继承过来的block_mask</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                unix_error(<span class="string">&quot;execve child process error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// Parent</span></span><br><span class="line">            <span class="comment">// addjob, block所有信号，避免竞争问题</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">            addjob(jobs, pid,</span><br><span class="line">                   bg ? BG : FG,</span><br><span class="line">                   buf);</span><br><span class="line">            <span class="comment">// 还原信号</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent: 前台进程处理</span></span><br><span class="line">        <span class="keyword">if</span> (!bg)</span><br><span class="line">        &#123;</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 在这里输出，耦合了addjob函数(内部对nextjid++)，如何优化？</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s &amp;\n&quot;</span>, nextjid - <span class="number">1</span>, pid, argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="keyword">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="keyword">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *cmd = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!cmd || !<span class="built_in">strlen</span>(cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cmmond not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判定4种内置命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;quit&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 考虑当前还有后台进程，需要kill</span></span><br><span class="line">        <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 先kill 所有子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (jobs[i].pid)</span><br><span class="line">            &#123;</span><br><span class="line">                kill(jobs[i].pid, SIGKILL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clearjob(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;jobs&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, cmd) || !<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span>本函数假设argv[0] 只能 = fg 或者 = bg</span></span><br><span class="line">    <span class="keyword">char</span> *arg = argv[<span class="number">1</span>]; <span class="comment">// 命令参数</span></span><br><span class="line">    <span class="keyword">int</span> jid = <span class="number">-1</span>, pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令是否有效？</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数后续是否全是数字</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (*arg != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(*arg))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arg++;</span><br><span class="line">    &#125;</span><br><span class="line">    arg = argv[<span class="number">1</span>]; <span class="comment">// 还原</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取job</span></span><br><span class="line">    <span class="keyword">if</span> (arg[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// jid mod</span></span><br><span class="line">        jid = atoi(arg + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// pid mod</span></span><br><span class="line">        pid = atoi(arg);</span><br><span class="line">        jid = pid2jid(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobjid(jobs, jid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg[<span class="number">0</span>] != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;fg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// fg mode</span></span><br><span class="line">        <span class="comment">// 后台进程转前台</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state == FG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process is foreground already\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;state == ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ST -&gt; RUNNING</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 测试后发现，发送SIGCONT后，也会触发一次SIGCHLD,目前原因未知</span></span><br><span class="line">            kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;bg&quot;</span>, argv[<span class="number">0</span>]))</span><br><span class="line">    &#123; <span class="comment">// bg mode</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="comment">// 后台stop进程转running进程</span></span><br><span class="line">        <span class="keyword">if</span> (job-&gt;state != ST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process isn&#x27;t stoped\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kill(job-&gt;pid, SIGCONT);</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 这里的printf后面没有加\n，因为cmdline自带\n</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Note: 因为前台进程结束后，会自动调用chld_handler,所以回收工作交给chld_handler处理</span></span><br><span class="line">    <span class="comment">// 这里只用保证tsh被阻塞即可。</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="comment">// 初始化blocking mask</span></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 从全局变量jobs中读取 fg pid，避免jobs的竞争</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">        <span class="keyword">if</span> (!fgpid(jobs))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有前台进程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, pre_one;</span><br><span class="line">    <span class="keyword">int</span> pid, wstate;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span> <span class="comment">// 触发本次sigchld_handler的job</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;wstate, WNOHANG | WUNTRACED);</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid调用返回有两种情况：</span></span><br><span class="line">    <span class="comment">// 1. 子进程terminate</span></span><br><span class="line">    <span class="comment">// 2. 通过信号，被stop了，如用户键入 ctrl+z</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;mask_all, &amp;pre_one);</span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(wstate))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// stoped，更新状态即可</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGTSTP);</span><br><span class="line">        job-&gt;state = ST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// terminate，需要deletejob</span></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstate))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 不应该在handler中出现printf这类async-unsafe, 替换为safe-library即可</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, job-&gt;pid, SIGINT);</span><br><span class="line">        &#125;</span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;pre_one, <span class="literal">NULL</span>);</span><br><span class="line">    errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    <span class="comment">// 注意传递INT信号可能会造成死循环：具体参考https://blog.csdn.net/guozhiyingguo/article/details/53837424</span></span><br><span class="line">    <span class="comment">// 同时注意，这里kill需要发送给整个进程组</span></span><br><span class="line">    kill(-job-&gt;pid, SIGINT);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (!job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有前台进程, forward to it， 后续处理交给chld_handler</span></span><br><span class="line">    kill(job-&gt;pid, SIGTSTP);</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">            max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            jobs[i].pid = pid;</span><br><span class="line">            jobs[i].state = state;</span><br><span class="line">            jobs[i].jid = nextjid++;</span><br><span class="line">            <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">                nextjid = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">            <span class="keyword">if</span> (verbose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            clearjob(&amp;jobs[i]);</span><br><span class="line">            nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fgpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">            <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="function">struct <span class="keyword">job_t</span> *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">            <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">            <span class="keyword">switch</span> (jobs[i].state)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> BG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FG:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ST:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                       i, jobs[i].state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次lab, shlab. 即编写一个简单的shell。&lt;/p&gt;
&lt;h2 id=&quot;0-背景知识&quot;&gt;&lt;a href=&quot;#0-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0. 背景知识&quot;&gt;&lt;/a&gt;0. 背景知识&lt;/h2&gt;&lt;p&gt;shlab相对其它lab要简单一些，但是其中牵涉出来的一些概念是相当难的。简单说一下这次lab依赖的背景知识吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍对应 异常控制流 章节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;理解进程的概念，linux如何创建新进程，进程的状态转换，回收等过程。&lt;/li&gt;
&lt;li&gt;理解linux中的signal概念，掌握如何发送、接收、处理signal事件，理解signal handler中的 &lt;strong&gt;Async-Signal-Safety问题及解决方案（也是本次实验的难点）&lt;/strong&gt; ，掌握async-signal-safety的guideline.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Csapp" scheme="https://www.ravenxrz.ink/categories/Csapp/"/>
    
    
      <category term="shlab" scheme="https://www.ravenxrz.ink/tags/shlab/"/>
    
  </entry>
  
  <entry>
    <title>linux下rime输入法无法在qt中输入的解决办法</title>
    <link href="https://www.ravenxrz.ink/archives/167d6ba3.html"/>
    <id>https://www.ravenxrz.ink/archives/167d6ba3.html</id>
    <published>2020-08-11T11:33:51.000Z</published>
    <updated>2020-09-06T07:37:36.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>继续看arch的wiki，搜索fcitx qt等关键词后，发现现在arch都使用的fcitx5了，fcitx5有qt的插件，能够完美解决这些这些问题，具体来说，卸载以前的旧版本fcitx，安装以下包：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f22402714195aa594ef0f0e.png" alt="image-20200730113135729"></p><p>参照arch的wiki，安装这些包后，还需要配置环境变量：</p><p>vim ~/.pam_environment </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INPUT_METHOD  DEFAULT=fcitx5</span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx5</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx5</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx5</span><br></pre></td></tr></table></figure><p>要开机自启动fcitx，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/applications/fcitx5.desktop ~/.config/autostart</span><br></pre></td></tr></table></figure><p>注销后重新登录，打开fcitx5配置GUI：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/5f224cc914195aa594f584e9.png" alt="image-20200730113337696"></p><p>rime的配置文件路径也变了，具体路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;.local&#x2F;share&#x2F;fcitx5&#x2F;rime</span><br></pre></td></tr></table></figure><p>最后一个问题，<strong>修改候选框的字体大小</strong>，这个我找了很久：</p><p><img data-src="https://pic.downk.cc/item/5f22404814195aa594ef2114.png" alt="image-20200730113538459"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天在manjaro下做qt开发时，发现fcitx-rime输入法无法在qtcreator中输入，google了一波，发现应该是差了某个动态库，网上的发行版大多以debian系列为主，apt安装个包就完了，arch系列不是这样解决的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="输入法" scheme="https://www.ravenxrz.ink/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Qt 配置+fakevim自定义</title>
    <link href="https://www.ravenxrz.ink/archives/afbe8180.html"/>
    <id>https://www.ravenxrz.ink/archives/afbe8180.html</id>
    <published>2020-08-10T11:29:53.000Z</published>
    <updated>2020-09-06T07:37:36.758Z</updated>
    
    <content type="html"><![CDATA[<p>项目原因，要写点qt代码。记录下个人配置：</p><a id="more"></a><ol><li>高分屏下字体过小问题</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a50e514195aa594c27812.jpg"></p><ol start="2"><li>上下文帮助菜单（即快捷键F1）字体过小问题：</li></ol><p>目前在manjaro-gnome上通过更改字体大小无效，只能更改渲染引擎，然后再更改字体大小，才能生效。</p><p><img data-src="https://pic.downk.cc/item/5f1a512214195aa594c29044.jpg"></p><ol start="3"><li>fakevim配置</li></ol><p><img data-src="https://pic.downk.cc/item/5f1a524414195aa594c3099c.jpg"></p><p>注意右边有个传递Control按键，开启这个选项后，能够使系统自带的一些快捷键（如Ctrl+R,Ctrl+O)和vim的一些特性共同使用。 但是就我个人而言，这样会失去一些vim的快捷键，所以未开启。</p><p>如果不开启传递Control， 那么Ctrl+R，Ctrl+F等常用qtcreator的快捷键又无法使用，好在fakevim支持vimrc，也支持定义ex command，所以可以自行配置vimrc来做键位mapping。下面以 “Run“命令为例，讲解如何配置vimrc。</p><p>打开Fakevim的ex command mapping:</p><p><img data-src="https://pic.downk.cc/item/5f1a535914195aa594c3663f.jpg"></p><p>然后打开你的vimrc，（个人为qt新建了一个配置文件，放在~/.qtvimrc下）</p><p>写上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>这样，就将 “ ;r “ 快捷键绑定为 Run命令了。</p><p>其余命令同理，现在fake vim中的ex command命令中写上mapping命令，然后在vimrc中mapping键位。</p><p>下面是我个人的全部qtvimrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&quot; 显示当前模式</span><br><span class="line">set showmode</span><br><span class="line">&quot; 共享系统粘贴板</span><br><span class="line">set clipborad&#x3D;unamed</span><br><span class="line">&quot; 打开行号</span><br><span class="line">set number</span><br><span class="line">&quot; 打开相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line">&quot; 设置命令历史记录条数</span><br><span class="line">set history&#x3D;2000</span><br><span class="line">&quot; 关闭兼容vi</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 开启语法高亮功能</span><br><span class="line">syntax enable</span><br><span class="line">&quot; 允许用指定语法高亮配色方案替换默认方案</span><br><span class="line">syntax on</span><br><span class="line">&quot; 模式搜索实时预览,增量搜索</span><br><span class="line">set incsearch</span><br><span class="line">&quot; 设置搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 忽略大小写 (该命令配合smartcase使用较好，否则不要开启)</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 模式查找时智能忽略大小写</span><br><span class="line">set smartcase</span><br><span class="line">&quot; vim自身命令行模式智能补全</span><br><span class="line">set wildmenu</span><br><span class="line">&quot; 总是显示状态栏</span><br><span class="line">set laststatus&#x3D;2</span><br><span class="line">&quot; 显示光标当前位置</span><br><span class="line">set ruler</span><br><span class="line">&quot; 高亮显示当前行&#x2F;列</span><br><span class="line">set cursorline</span><br><span class="line">&quot;set cursorcolumn</span><br><span class="line">&quot; 禁止折行</span><br><span class="line">set nowrap</span><br><span class="line">&quot; 将制表符扩展为空格</span><br><span class="line">set expandtab</span><br><span class="line">&quot; 设置编辑时制表符占用空格数</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line">&quot; 设置格式化时制表符占用空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line">&quot; 让 vim 把连续数量的空格视为一个制表符</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line">&quot; 基于缩进或语法进行代码折叠</span><br><span class="line">set foldmethod&#x3D;indent</span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line">&quot; 启动 vim 时关闭折叠代码</span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置前导键</span><br><span class="line">&quot; let mapleader&#x3D;&quot;;&quot;</span><br><span class="line">&quot; 暂时取消搜索高亮快捷键</span><br><span class="line">nnoremap &lt;silent&gt; ;l :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</span><br><span class="line"></span><br><span class="line">&quot; 移动相关</span><br><span class="line">&quot; 前一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; [b :w&lt;CR&gt;:bprevious&lt;CR&gt;</span><br><span class="line">&quot; 后一个缓冲区</span><br><span class="line">nnoremap &lt;silent&gt; ]b :w&lt;CR&gt;:bnext&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键到行首和行尾</span><br><span class="line">map H ^</span><br><span class="line">map L $</span><br><span class="line">&quot; 定义快速跳转</span><br><span class="line">nmap ;t &lt;C-]&gt;</span><br><span class="line">&quot; 定义快速跳转回退</span><br><span class="line">nmap ;T &lt;C-t&gt;</span><br><span class="line">&quot; 标签页后退 ---标签页前进是gt</span><br><span class="line">nmap gn gt</span><br><span class="line">nmap gp gT</span><br><span class="line"></span><br><span class="line">&quot; 文件操作相关</span><br><span class="line">&quot; 定义快捷键关闭当前分割窗口</span><br><span class="line">nmap ;q :q&lt;CR&gt;</span><br><span class="line">&quot; 定义快捷键保存当前窗口内容</span><br><span class="line">nmap ;w :w&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; 窗口操作相关</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line"></span><br><span class="line">&quot; 使用 qt内部功能</span><br><span class="line">&quot; run operation</span><br><span class="line">map ;r :run&lt;CR&gt;</span><br><span class="line">&quot; copy operation</span><br><span class="line">map ;c :copy&lt;CR&gt;</span><br><span class="line">&quot; paste operation</span><br><span class="line">map ;v :paste&lt;CR&gt;</span><br><span class="line">&quot; cut operation</span><br><span class="line">map ;x :cut&lt;CR&gt;</span><br><span class="line">&quot; Select All</span><br><span class="line">map ;a :selectall&lt;CR&gt;</span><br><span class="line">&quot; reformat code</span><br><span class="line">map ;f :reformatcode&lt;CR&gt;</span><br><span class="line">&quot; 找到usage</span><br><span class="line">map ;u :findusages&lt;CR&gt;</span><br><span class="line">&quot; 调用idea的replace操作</span><br><span class="line">map ;; :replace&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>基本上是从以前的vimrc配置中copy过来的，所以有些设置在qt中是无效的，但是不影响使用。 关键在 “使用qt内部功能”项下的映射。有些可惜的是fakevim不支持leader键位，所以只能在每处mapping中都硬编码为；  。</p><p>4.反缩进问题</p><p>qtcreator有个反人类的地方在于，写代码换行，会自动缩进，但是退格却又需要退几次才能回到上一行，可以改为：</p><p><img data-src="https://pic.downk.cc/item/5f1a556014195aa594c428c1.jpg"></p><p>剩下的就看个人配置了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目原因，要写点qt代码。记录下个人配置：&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂文" scheme="https://www.ravenxrz.ink/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="vim" scheme="https://www.ravenxrz.ink/tags/vim/"/>
    
  </entry>
  
</feed>
