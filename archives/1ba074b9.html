<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.ravenxrz.ink","root":"/","scheme":"Mist","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。">
<meta property="og:type" content="article">
<meta property="og:title" content="leveldb源码阅读记录-Compaction">
<meta property="og:url" content="https://www.ravenxrz.ink/archives/1ba074b9.html">
<meta property="og:site_name" content="Raven&#39;s Blog">
<meta property="og:description" content="截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.downk.cc/item/5f84430d1cd1bbb86b056b74.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84432b1cd1bbb86b0582d0.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84433d1cd1bbb86b058e5b.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200925153434477.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/PickLevelForMemTableOutput.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f844aeb1cd1bbb86b0a9343.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-copy-PickCompaction.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84436e1cd1bbb86b05b42f.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84437a1cd1bbb86b05bbf2.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f8443831cd1bbb86b05c1ea.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84438c1cd1bbb86b05c90f.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f8442441cd1bbb86b04da1b.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f84439f1cd1bbb86b05d684.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f8443b11cd1bbb86b05e0f2.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f88ed491cd1bbb86b4e4e55.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f88ec9c1cd1bbb86b4e2c8e.png">
<meta property="og:image" content="https://pic.downk.cc/item/5f88ec471cd1bbb86b4e1cc7.png">
<meta property="article:published_time" content="2020-10-12T10:00:00.000Z">
<meta property="article:modified_time" content="2020-10-16T00:47:08.355Z">
<meta property="article:author" content="Raven">
<meta property="article:tag" content="IT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.downk.cc/item/5f84430d1cd1bbb86b056b74.png">

<link rel="canonical" href="https://www.ravenxrz.ink/archives/1ba074b9.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leveldb源码阅读记录-Compaction | Raven's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Raven's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Raven's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">zhang.xingrui@foxmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-fa fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-fa fa-archive"></i>归档<span class="badge">146</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-fa fa-th"></i>分类<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-fa fa-tags"></i>标签<span class="badge">114</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-fa fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ravenxrz.ink/archives/1ba074b9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic.downk.cc/item/5e907515504f4bcb04b6f798.jpg">
      <meta itemprop="name" content="Raven">
      <meta itemprop="description" content="分享技术，记录生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Raven's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leveldb源码阅读记录-Compaction
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-12 18:00:00" itemprop="dateCreated datePublished" datetime="2020-10-12T18:00:00+08:00">2020-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-16 08:47:08" itemprop="dateModified" datetime="2020-10-16T08:47:08+08:00">2020-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leveldb/" itemprop="url" rel="index"><span itemprop="name">leveldb</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>截至到上文，我们已经将levedb中几个重要的组件都分析了，包括log、manifest、memtable和sstable。今天将介绍leveldb中最重要的内部操作–Compaction。</p>
<a id="more"></a>

<h1 id="MemTable-到-SStable"><a href="#MemTable-到-SStable" class="headerlink" title="MemTable 到 SStable"></a>MemTable 到 SStable</h1><p>在leveldb中，compaction共有两种，分别叫 minor compaction 和major compaction。</p>
<ul>
<li>minor compaction，将immtable dump到SStable</li>
<li>major compaction，level之间的SSTable compaction。</li>
</ul>
<p>这里先来分析minor compaction。</p>
<p>我们主要关注以下问题：</p>
<ol>
<li>minor compaction是如何进行的？</li>
<li>minor compaction何时会进行？</li>
</ol>
<h1 id="1-minor-compaction如何进行？"><a href="#1-minor-compaction如何进行？" class="headerlink" title="1. minor compaction如何进行？"></a>1. minor compaction如何进行？</h1><p>compaction的入口是 <code>DBImpl::MaybeScheduleCompaction()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 env_-&gt;Schedule(&amp;DBImpl::BGWork, this);中，将BGWork放入线程池，由子线程来做:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="keyword">void</span>* db)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;BackgroundCall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">    <span class="comment">// 递归调用compaction，因为有可能这次compaction产生了过多的sst</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-调用流程图"><a href="#1-调用流程图" class="headerlink" title="1. 调用流程图"></a>1. 调用流程图</h2><p>这里的调用链比较清晰：</p>
<img data-src="https://pic.downk.cc/item/5f84430d1cd1bbb86b056b74.png" style="zoom: 33%;" />

<img data-src="https://pic.downk.cc/item/5f84432b1cd1bbb86b0582d0.png" style="zoom:33%;" />

<p>需要注意的是，DBImpl::MaybeScheduleCompaction 是一个递归调用，递归结束的地方在：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>也就说结束的条件是：</p>
<ol>
<li><p>当前immemtable为null</p>
</li>
<li><p>非手动compaction</p>
</li>
<li><p>versionset判定为不需要compaction</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们曾在分析VersionEdit，VersionSet时，提到过compaction_score是如何计算的，这里提一下它的入口在 VersionSet::Finalize 。后面再做详细分析。</p>
</li>
</ol>
<h2 id="2-Minor-Compaction执行细节"><a href="#2-Minor-Compaction执行细节" class="headerlink" title="2. Minor Compaction执行细节"></a>2. Minor Compaction执行细节</h2><p>ok，说完宏观的调用链，现在来详细分一下leveldb是如何左minor compaction的，核心函数在：==BackgroundCompaction();==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;	<span class="comment">// minor compaction的触发点</span></span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">   <span class="comment">// 将 数据写入到第0层（实际上不一定是第0层)</span></span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">      <span class="comment">// 应用生成的一个VersionEdit到当前VersionSet</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">     <span class="comment">// 减少计数，引用计数归0时会delete当前immemtable</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续看==WriteLevel0Table==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Version* base)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">      <span class="comment">//!! 1. 将memtable dump 到SSTable中</span></span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.SSTable 应该写入到哪个level？</span></span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 3. 生成VersionEdit，给后序Manifest做记录</span></span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 保存本次compaction所在level的 compaction状态</span></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-WriteLevel0Table-流程图"><a href="#1-WriteLevel0Table-流程图" class="headerlink" title="1 WriteLevel0Table 流程图"></a>1 WriteLevel0Table 流程图</h3><img data-src="https://pic.downk.cc/item/5f84433d1cd1bbb86b058e5b.png" style="zoom:50%;" />

<h4 id="3个函数的分析"><a href="#3个函数的分析" class="headerlink" title="3个函数的分析"></a>3个函数的分析</h4><p>现在来分别分析这3个函数：</p>
<h4 id="1-BuildTable-建立ssttable并持久化"><a href="#1-BuildTable-建立ssttable并持久化" class="headerlink" title="1. BuildTable (建立ssttable并持久化)"></a>1. BuildTable (建立ssttable并持久化)</h4><p>下面这些 .ldb的文件就是sstable，可以看到它们都是一些由数字组成的文件名，这些数字是哪里来的？我们可以从源码中获得答案：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200925153434477.png" alt="image-20200925153434477"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  meta-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">  iter-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// meta number就是上图的数字来源， meta-&gt;number的赋值语句在DBImpl::WriteLevel0Table中的 `meta.number = versions_-&gt;NewFileNumber();`</span></span><br><span class="line">    <span class="comment">// 所以该数字由VersionSet分配</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname, meta-&gt;number);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;Valid()) &#123;</span><br><span class="line">    WritableFile* file;</span><br><span class="line">    s = env-&gt;NewWritableFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 新建sstable</span></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> TableBuilder(options, file);</span><br><span class="line">      <span class="comment">// 因为跳表是有序的，所以第一个key肯定是最小的</span></span><br><span class="line">    meta-&gt;smallest.DecodeFrom(iter-&gt;key());</span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) &#123;</span><br><span class="line">      key = iter-&gt;key();</span><br><span class="line">       <span class="comment">// 向sstable中添加key value。</span></span><br><span class="line">      builder-&gt;Add(key, iter-&gt;value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!key.empty()) &#123;</span><br><span class="line">        <span class="comment">// 同理，最后一个key是最大的</span></span><br><span class="line">      meta-&gt;largest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">      <span class="comment">// 写入sstable中的其他块，index block, meta block ,meta index block footer等</span></span><br><span class="line">    s = builder-&gt;Finish();</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      meta-&gt;file_size = builder-&gt;FileSize();</span><br><span class="line">      assert(meta-&gt;file_size &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for file errors</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        <span class="comment">// 写入到硬件</span></span><br><span class="line">      s = file-&gt;Sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = file-&gt;Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">   xxx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Keep it</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env-&gt;RemoveFile(fname);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作：</p>
<ol>
<li>新建SStable文件</li>
<li>根据memtable提供的Iterator，向SStable中添加所有数据</li>
<li>将SSTable写入到硬件设备中。</li>
</ol>
<h4 id="2-Version-PickLevelForMemTableOutput"><a href="#2-Version-PickLevelForMemTableOutput" class="headerlink" title="2. Version::PickLevelForMemTableOutput"></a>2. Version::PickLevelForMemTableOutput</h4><p>PickLevelForMemTableOutput决定新生成的sstable所在的level，原则上，从memtable dump出来sstable应该首先放到level0， 但是如果总是放到level 0，后序的compaction会耗费过多的io吞吐量，所以这个函数的意思是，尽量将新生成的sstable往更深的level放，但是又不能放的太深，因为如果这个sstable的访问频率较高，过深的level意味着读性能的降低。所以往下push得有个读。</p>
<p>leveldb定义了kMaxMemCompactLevel这个参数来限制新生成的sstable能够下推的层次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum level to which a new compacted memtable is pushed if it</span></span><br><span class="line"><span class="comment">// does not create overlap.  We try to push to level 2 to avoid the</span></span><br><span class="line"><span class="comment">// relatively expensive level 0=&gt;1 compactions and to avoid some</span></span><br><span class="line"><span class="comment">// expensive manifest file operations.  We do not push all the way to</span></span><br><span class="line"><span class="comment">// the largest level since that can generate a lot of wasted disk</span></span><br><span class="line"><span class="comment">// space if the same key space is being repeatedly overwritten.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxMemCompactLevel = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>所以，默认最高只能到level2.</p>
<p>现在来看看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Version::PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> Slice&amp; largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果与level 0有重叠，直接return 0</span></span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    <span class="function">InternalKey <span class="title">limit</span><span class="params">(largest_user_key, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; <span class="built_in">config</span>::kMaxMemCompactLevel) &#123;	<span class="comment">// 最高到kMaxMemCompactLevel</span></span><br><span class="line">       <span class="comment">// 与level+1有重叠</span></span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">         <span class="comment">// 与祖父level的重叠size过大，则直接break</span></span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用一张流程图：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/PickLevelForMemTableOutput.png" alt="img"></p>
<h4 id="3-edit-gt-Addfile-（记录元sstable所在level等元数据）"><a href="#3-edit-gt-Addfile-（记录元sstable所在level等元数据）" class="headerlink" title="3. edit-&gt;Addfile （记录元sstable所在level等元数据）"></a>3. edit-&gt;Addfile （记录元sstable所在level等元数据）</h4><p>最后就是edit-&gt;Addfile。将生成的sstable的元数据（filemeta）加入到versionedit中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>&#123;</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从edit-&gt;AddFile可知，一个SSTable对应有一个FileMeta存放在edit中，edit最终会存放在manifest，同时edit最终会演变成version，version又会加入到versioneset中。</p>
<h3 id="2-LogAndApply"><a href="#2-LogAndApply" class="headerlink" title="2. LogAndApply"></a>2. LogAndApply</h3><p>LogAndApply前面已经分析过了。 之前我们将所有filemeta存放在一个versionedit中，通过这个LogAndApply即可将versionedit应用到当前versionset中，并持久化到manifest。</p>
<h2 id="2-何时Tigger-Compaction？"><a href="#2-何时Tigger-Compaction？" class="headerlink" title="2. 何时Tigger Compaction？"></a>2. 何时Tigger Compaction？</h2><p>让我们回到MaybeScheduleCompaction</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">      <span class="comment">// 递归结束点，防止无限递归</span></span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，正常情况下只要满足一下3种条件中任何一个都会触发一次compaction：</p>
<ul>
<li>imm != null, memtable已经转化为immtable，需要及时dump到外存中。</li>
<li>manual_compaction， 手动compaction</li>
<li>versions-&gt;NeedCompaction()</li>
</ul>
<p>前两种都好说，重点看一下第3种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又分为了两种情况，根据compaction_score和根据 filte_compact。先说第一种：<code>v-&gt;compaction_score_</code></p>
<h3 id="1-compaction-score-amp-Finalize函数"><a href="#1-compaction-score-amp-Finalize函数" class="headerlink" title="1. compaction_score_  &amp; Finalize函数"></a>1. compaction_score_  &amp; Finalize函数</h3><p>==Finalize函数==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line">						<span class="comment">// 最高level</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在leveldb的设计中，level0和其余level的compaction设计是不同的，level0基于文件数量，而其余层基于文件的总大小。</p>
<h4 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h4><p>level0为什么要要这样设计？根据注释：</p>
<ol>
<li>如果有更大的写buffer, 应该尽量避免多个level 0的compactions。</li>
<li>每次读，都会level0的file merge，应该如果level0的文件数量过多。（个人理解：因为读会衰减？）</li>
</ol>
<blockquote>
<p>引用博文：</p>
<p>注释说的很明白，level 0的文件之间，key可能是交叉重叠的，因此不希望level 0的文件数特别多。我们考虑write buffer 比较小的时候，如果使用size来限制，那么level 0的文件数可能太多。</p>
<p>另一个方面，如果write buffer过大，使用固定大小的size 来限制level 0的话，可能算出来的level 0的文件数又太少，触发 level 0 compaction的情况发生的又太频繁。</p>
</blockquote>
<p>所以，对于level0，其默认设计的文件数量不超过4:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h4 id="其他level"><a href="#其他level" class="headerlink" title="其他level"></a>其他level</h4><p>其他level则是根据当前文件大小与size limit的比值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">     score =</span><br><span class="line">         <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;	<span class="comment">// 默认是10M</span></span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码说明，从level1开始，每相邻两层的level总大小，相差10.  level1=10M, level2=100M，以此类推。</p>
<p>同时这里也指明了leveldb的最高level为多少：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumLevels = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>所以最高到level6, 则各层大小分布为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level 1               10M </span><br><span class="line">level 2              100M</span><br><span class="line">level 3             1000M</span><br><span class="line">level 4            10000M</span><br><span class="line">level 5           100000M</span><br><span class="line">level 6          1000000M</span><br></pre></td></tr></table></figure>

<h4 id="选择得分最高的来做compaction"><a href="#选择得分最高的来做compaction" class="headerlink" title="选择得分最高的来做compaction"></a>选择得分最高的来做compaction</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">   best_level = level;</span><br><span class="line">   best_score = score;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>得分越高，越想compaction。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>所以根据compaction_score_ 来看，当level0的文件过多，或者其余level的总file size过大时，会触发compacton。</p>
<h3 id="2-file-to-compact-amp-Seek-Compaction"><a href="#2-file-to-compact-amp-Seek-Compaction" class="headerlink" title="2. file_to_compact_ &amp; Seek Compaction"></a>2. file_to_compact_ &amp; Seek Compaction</h3><p>除了上述情况外，leveldb还有用了基于seek的compactoin。</p>
<p>除了level 0以外，任何一个level的文件内部是有序的，文件之间也是有序的。但是level（n）和level （n＋1）中的两个文件的key可能存在交叉。正是因为这种交叉，查找某个key值的时候， level（n） 的查找无功而返，而不得不restart to level(n＋1)。</p>
<p>我们考虑寻找某一个key，如果找了曾经查找了level (n) ,但是没找到，然后去level (n+1)查找，结果找到了，那么对level (n)的某个文件而言，该文件就意味着有一次 未命中。</p>
<p>我们可以很容易想到，如果查找了多次，某个文件不得不查找，却总也找不到，总是去高一级的level，才能找到。这说明该层级的文件和上一级的文件，key的范围重叠的很严重，这是不合理的，会导致效率的下降。因此，需要对该level 发起一次Major compaction，减少 level 和level ＋ 1的重叠情况。</p>
<p>这就是所谓的 Seek Compaction。</p>
<p>我个人的理解是，查找一个key，根据manifest判定这个key可能在某个sstable中（manifest中存放了sstable的smallest和largest key）,但是实际上并不在，所以总是在更深层中去找。那查找本层的sstable就是对io的浪费，而且也说明了本层和更深层的key有比较严重的相互重叠。举个例子，如下图：</p>
<img data-src="https://pic.downk.cc/item/5f844aeb1cd1bbb86b0a9343.png" style="zoom:33%;" />

<p>现在查找6， 对于level1的sstable来说，key的range在[1,9], 所以会查找这个sstable，显然6不在其中，于是向下层中找，level2的这个sstable的key range为[2,8]，在这里找到了。 这样level1的io就是浪费掉的， level1和level2的key overlap也比较严重，长此以往浪费io，所以需要compaction。</p>
<p>seek compaction在filemeta中用 <strong>allowed_seeks</strong> 来控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;  <span class="comment">// !!!Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;    <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;  <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;   <span class="comment">// Largest internal key served by table</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==VersionSet::Builder::Apply==对其初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We arrange to automatically compact this file after</span></span><br><span class="line">    <span class="comment">// a certain number of seeks.  Let's assume:</span></span><br><span class="line">    <span class="comment">//   (1) One seek costs 10ms</span></span><br><span class="line">    <span class="comment">//   (2) Writing or reading 1MB costs 10ms (100MB/s)</span></span><br><span class="line">    <span class="comment">//   (3) A compaction of 1MB does 25MB of IO:</span></span><br><span class="line">    <span class="comment">//         1MB read from this level</span></span><br><span class="line">    <span class="comment">//         10-12MB read from next level (boundaries may be misaligned)</span></span><br><span class="line">    <span class="comment">//         10-12MB written to next level</span></span><br><span class="line">    <span class="comment">// This implies that 25 seeks cost the same as the compaction</span></span><br><span class="line">    <span class="comment">// of 1MB of data.  I.e., one seek costs approximately the</span></span><br><span class="line">    <span class="comment">// same as the compaction of 40KB of data.  We are a little</span></span><br><span class="line">    <span class="comment">// conservative and allow approximately one seek for every 16KB</span></span><br><span class="line">    <span class="comment">// of data before triggering a compaction.</span></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>));</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说的是， 根据估算，大概每25次seek的time cost = 1次compaction的。保守估计，1次seek相当于compaction16kb的数据。 所以==当seek的总耗时约等于一次compaction的耗时时，就触发一次compaction==。则允许seek的次数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// file_size/16KB</span></span><br></pre></td></tr></table></figure>

<h1 id="2-如何确定Compaction的输入源"><a href="#2-如何确定Compaction的输入源" class="headerlink" title="2. 如何确定Compaction的输入源"></a>2. 如何确定Compaction的输入源</h1><p>结合前面两种compaction来看，触发compaction的时机：</p>
<ol>
<li>size compaction :文件过多或文件过大</li>
<li>seek compaction: seek次数过多。</li>
</ol>
<p>现在回到==DBImpl::BackgroundCompaction:==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;<span class="built_in">begin</span>, m-&gt;<span class="built_in">end</span>);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;<span class="built_in">begin</span> ? m-&gt;<span class="built_in">begin</span>-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;<span class="built_in">end</span> ? m-&gt;<span class="built_in">end</span>-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 现在只看非manual的情况</span></span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-PickCompaction"><a href="#1-PickCompaction" class="headerlink" title="1. PickCompaction"></a>1. PickCompaction</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>PickCompaction流程图：</p>
<img data-src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/leveldb源码阅读-copy-PickCompaction.png" style="zoom: 33%;" />

<p>转到==PickCompaction==函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line"><span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line"><span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line"><span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line"><span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 优先考虑 size_compaction, 再考虑seek_compaction.</span></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数签名注释，PickCompaction的作用是，找到level以及level对应的需要compaction的文件。现在来拆开代码看：</p>
<p>优先考虑 size_compaction, 再考虑seek_compaction.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line"><span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-Size-Compaction"><a href="#1-Size-Compaction" class="headerlink" title="1. Size Compaction"></a>1. Size Compaction</h3><h4 id="1-leve-n的sstable确定"><a href="#1-leve-n的sstable确定" class="headerlink" title="1. leve n的sstable确定"></a>1. leve n的sstable确定</h4><ol>
<li>得到  level[n]的输入源</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_compaction) &#123;	</span><br><span class="line">   level = current_-&gt;compaction_level_;</span><br><span class="line">   assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">   assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">   c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">     FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">     <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">         icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">     <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">     c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>inputs_数组中存放的是输入源。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each compaction reads inputs from "level_" and "level_+1"</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; inputs_[<span class="number">2</span>];  <span class="comment">// The two sets of inputs</span></span><br></pre></td></tr></table></figure>

<p>接着看<code>size_compaction</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">level = current_-&gt;compaction_level_;</span><br><span class="line">assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个文件，其最大key比 compact_pointer_[level]的key大</span></span><br><span class="line"><span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">    <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">        icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果找不到这样的文件，从level头开始（round-robin)</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">    <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size_compation中<strong>只用确定一个要输入的 sstable文件。</strong> 接着看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>level0由于存在overlap key，所以需要这些key加入。看注释有一点值得注意：</p>
<blockquote>
<p>在GetOverlappingInputs函数中，会discard我们之前加入的sstable filemeta, 但是后会replace一个overlap set，这个overlap set将会包含之前picked file。</p>
<p>是否还包含，这点还有待验证。</p>
</blockquote>
<h4 id="GetOverlappingInputs函数"><a href="#GetOverlappingInputs函数" class="headerlink" title="GetOverlappingInputs函数"></a>GetOverlappingInputs函数</h4><p>继续深追到GetOverlappingInputs:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::GetOverlappingInputs</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> InternalKey* <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs)</span> </span>&#123;</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">  inputs-&gt;<span class="built_in">clear</span>();		<span class="comment">// 清空</span></span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = <span class="built_in">begin</span>-&gt;user_key();		<span class="comment">// 确定begin</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = <span class="built_in">end</span>-&gt;user_key();			<span class="comment">// 确定end</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;		<span class="comment">// 对于level0，由于存在overlap key，所以可能会扩大begin和end的范围，一旦扩大，重新搜索整个files.</span></span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span> != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;<span class="built_in">clear</span>();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码的工作是，根据在PickCompaction() 中选定的文件，确定初步的key range[begin,end], 然后在level0中选择所有与该key range有重叠的sstable，<strong>同时每选择一个还会扩大key range，然后重新add。</strong></p>
<h4 id="举个例子（level0-compaction的sstable选择）"><a href="#举个例子（level0-compaction的sstable选择）" class="headerlink" title="举个例子（level0 compaction的sstable选择）"></a>举个例子（level0 compaction的sstable选择）</h4><p><img data-src="https://pic.downk.cc/item/5f84436e1cd1bbb86b05b42f.png" alt=""></p>
<p>假设在level 0中选择了<strong>8-14</strong> 这个sstable。现在从头开始遍历，查看是否有需要加入的其他sstable。</p>
<p>第一次，搜索3-6，因为3-6与8-14无重叠，所以无需加入。</p>
<p>第二次，搜索5-12，因为5-12与8-14有重叠，所以加入5-12。 同时由于现在是level0，5-12扩大了搜索域的下界，现在的搜索域改为 <strong>5-14</strong>, 清空所有已经加入的sstable，重头开始。</p>
<p>第三次，搜索3-6，因为3-6与5-14有重叠，所以加入3-6.</p>
<p>第四次，搜索5-12，因为5-12与5-14有重叠，所以5-12.</p>
<p>第五次，所有8-14，因为8-14与5-14有重叠，所以加入8-14.</p>
<p>最后加入的sstable，包括3-6，5-12，8-14.</p>
<p>==上面说的，都是如何level n的输入源，总结起来就是，除了level0，其余level只加入一个sstable，level0可能加入多个sstable==</p>
<h4 id="2-level-n-1的sstable确定"><a href="#2-level-n-1的sstable确定" class="headerlink" title="2. level n+1的sstable确定"></a>2. level n+1的sstable确定</h4><p>level n+1是在==SetupOtherInputs== 函数中确定的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩展上边界 </span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">// 获取当前level n的range</span></span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">   <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">   <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line">  <span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log,</span><br><span class="line">            <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">            level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">            <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><p>核心在着几行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取当前level n的range</span></span><br><span class="line">GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"> <span class="comment">// 获取level n+1中与 level n的range重叠的sstable，将这些sstable存放在c-&gt;inputs_[1]中</span></span><br><span class="line">current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                               &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">InternalKey all_start, all_limit;</span><br><span class="line"> <span class="comment">// 计算leveln level n+1的range</span></span><br><span class="line">GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure>

<h4 id="level-n新SStable的加入"><a href="#level-n新SStable的加入" class="headerlink" title="level n新SStable的加入"></a>level n新SStable的加入</h4><p>那下面还有一大段是做什么用的？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">        ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">        InternalKey new_start, new_limit;</span><br><span class="line">        GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">        current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                       &amp;expanded1);</span><br><span class="line">        <span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">            Log(options_-&gt;info_log,</span><br><span class="line">                <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">                level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">                <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">            smallest = new_start;</span><br><span class="line">            largest = new_limit;</span><br><span class="line">            c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">            c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">            GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的意思是，在选中level n+1层的sstable后，可能还可以加入一些level n的sstable。举个例子：</p>
<p><img data-src="https://pic.downk.cc/item/5f84437a1cd1bbb86b05bbf2.png" alt=""></p>
<p>假设现在在level n选择的是8-12这个sstable，则在level n+1 可以选择8-9，10-16着连个sstable。 这一切做完后，发现在level n中存在13-15这个sstable，加入13-15并不影响level n+1 sstable的选择。</p>
<p>上面那段代码就是做这个工作。举个不会加入新sstable的例子：</p>
<p><img data-src="https://pic.downk.cc/item/5f8443831cd1bbb86b05c1ea.png" alt=""></p>
<p>在这样的情况下，13-18的重新加入，level n+1 需要重新加入17-20，所以不应该加入13-18.</p>
<p>但是再看下一个例子：</p>
<p><img data-src="https://pic.downk.cc/item/5f84438c1cd1bbb86b05c90f.png" alt=""></p>
<p>这个例子中，虽然新加入level 13-18，扩大了inputs_的范围，但是由于并没有造成level n+1的sstable重新选择，所以依然可以加入13-18.</p>
<p>ok，例子说了好几个，正式看代码。</p>
<ol>
<li>计算如果要在level n要重新加入sstable，那加入后的第level n层的compaction sstable的总大小为多少（即expanded0_size)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果新加入后，level n和level n+1的总size小于一次compaction的总size，则考虑加入。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br></pre></td></tr></table></figure>

<p>一次compaction的总size：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of bytes in all compacted files.  We avoid expanding</span></span><br><span class="line"><span class="comment">// the lower level file set of a compaction if it would make the</span></span><br><span class="line"><span class="comment">// total compaction cover more than this many bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">ExpandedCompactionByteSizeLimit</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">25</span> * TargetFileSize(options);			<span class="comment">// 默认是50M</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">TargetFileSize</span><span class="params">(<span class="keyword">const</span> Options* options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> options-&gt;max_file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leveldb will write up to this amount of bytes to a file before</span></span><br><span class="line"><span class="comment">// switching to a new one.</span></span><br><span class="line"><span class="comment">// Most clients should leave this parameter alone.  However if your</span></span><br><span class="line"><span class="comment">// filesystem is more efficient with larger files, you could</span></span><br><span class="line"><span class="comment">// consider increasing the value.  The downside will be longer</span></span><br><span class="line"><span class="comment">// compactions and hence longer latency/performance hiccups.</span></span><br><span class="line"><span class="comment">// Another reason to increase this parameter might be when you are</span></span><br><span class="line"><span class="comment">// initially populating a large database.</span></span><br><span class="line"><span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在level n中加入新sstable，但没有引起level n+1的sstable选择，则加入这个新sstable。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Log(options_-&gt;info_log,</span><br><span class="line">        <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">        level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">        <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">    smallest = new_start;</span><br><span class="line">    largest = new_limit;</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">    c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">    GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-记录下一轮的压缩起始文件"><a href="#3-记录下一轮的压缩起始文件" class="headerlink" title="3. 记录下一轮的压缩起始文件"></a>3. 记录下一轮的压缩起始文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line"><span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line"><span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line"><span class="comment">// key range next time.</span></span><br><span class="line">compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">c-&gt;edit_.SetCompactPointer(level, largest);</span><br></pre></td></tr></table></figure>

<h4 id="4-AddBoundaryInputs"><a href="#4-AddBoundaryInputs" class="headerlink" title="4. AddBoundaryInputs"></a>4. AddBoundaryInputs</h4><p>在前面的介绍中，我曾说过，除了level0， 其余level中 inputs数组的inputs[0]总是先只选择一个文件，然后通过<code>VersionSet::SetupOtherInputs</code>，确定inputs_[1],  当inputs_[1]确定后，会回退到input_[0]，尝试增加input_[0]的文件。其实除了这里会增加input[0]的选择外，还有一处可能增加Inputs[0]的选择。那就是AddBoundaryInputs函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// !! 这里</span></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==AddBoundaryInputs==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Extracts the largest file b1 from |compaction_files| and then searches for a</span></span><br><span class="line"><span class="comment">// b2 in |level_files| for which user_key(u1) = user_key(l2). If it finds such a</span></span><br><span class="line"><span class="comment">// file b2 (known as a boundary file) it adds it to |compaction_files| and then</span></span><br><span class="line"><span class="comment">// searches again using this new upper bound.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are two blocks, b1=(l1, u1) and b2=(l2, u2) and</span></span><br><span class="line"><span class="comment">// user_key(u1) = user_key(l2), and if we compact b1 but not b2 then a</span></span><br><span class="line"><span class="comment">// subsequent get operation will yield an incorrect result because it will</span></span><br><span class="line"><span class="comment">// return the record from b2 in level i rather than from b1 because it searches</span></span><br><span class="line"><span class="comment">// level by level for records matching the supplied user key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// parameters:</span></span><br><span class="line"><span class="comment">//   in     level_files:      List of files to search for boundary files.</span></span><br><span class="line"><span class="comment">//   in/out compaction_files: List of files to extend by adding boundary files.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span> </span>&#123;</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!FindLargestKey(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        FindSmallestBoundaryFile(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;push_back(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AddBoundaryInputs调用前，我们已经确定了inputs[0], 如果不考虑level0的话，对于其他level，inputs[0]为一个sstable。这个sstable存在一个key range[low,high], 我们都知道 sstable内部存的key是InternalKey, InternalKey内部封装了user key。如下图：</p>
<p><img data-src="https://pic.downk.cc/item/5f8442441cd1bbb86b04da1b.png" alt=""></p>
<p>因为只要internel key不相同，那么就可认为key是不重叠的。也就是说只要(key, sequence number,type)三个任一个不同，就可以认为key是不同。 那现在可能就存在这样一个情况， 相邻两个sstable的user key相同。如下图表示：</p>
<p><img data-src="https://pic.downk.cc/item/5f84439f1cd1bbb86b05d684.png" alt=""></p>
<p>sstable 1中的上届(upper)的user key 和 sstable 2的下届(lower)的user key相同，都为key2. 假设我们当前inputs[0]就是sstable 1。 那么AddBoundaryInputs函数的作用就是将sstable 2添加到inputs[0]中。 当然这是一个递归的过程，加完sstable 2，可能sstable 3的下届user key又和sstable 2的上届相同，所以继续添加。</p>
<p>为什么要这样加？因为若是不添加，sstable 1经过compaction陷入下层，而sstable 2还在上层。那么下一次Get操作时，leveldb将由上往下search，这样找到的key在sstable 2，而sstable 2中的key不是最新的，这显然是不对的。</p>
<h3 id="2-Seek-Compaction"><a href="#2-Seek-Compaction" class="headerlink" title="2. Seek Compaction"></a>2. Seek Compaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickCompaction函数中</span></span><br><span class="line">level = current_-&gt;file_to_compact_level_;</span><br><span class="line">c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br></pre></td></tr></table></figure>

<p>根据<code>file_to_compact_</code>指针和<code>file_to_compact_level_</code>即可得到 ==一个输入源文件==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure>

<h4 id="1-什么时候触发一次seek-compaction？"><a href="#1-什么时候触发一次seek-compaction？" class="headerlink" title="1. 什么时候触发一次seek compaction？"></a>1. 什么时候触发一次seek compaction？</h4><p>我们从<code>file_to_compact_</code>反追踪，可以发现 UpdateStats 函数中对file_to_compact_进行了赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Version::UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span> </span>&#123;</span><br><span class="line">  FileMetaData* f = stats.seek_file;</span><br><span class="line">  <span class="keyword">if</span> (f != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    f-&gt;allowed_seeks--;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt;= <span class="number">0</span> &amp;&amp; file_to_compact_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      file_to_compact_ = f;</span><br><span class="line">      file_to_compact_level_ = stats.seek_file_level;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，当一个文件的allowed_seeks&lt;=0时，就可以对这个file进行compaction。</p>
<h4 id="2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析"><a href="#2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析" class="headerlink" title="2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析"></a>2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析</h4><p>继续反追踪 ，什么时候调用UpdateStats? <strong>在DBImpl::Get函数中</strong></p>
<p>==DBImpl::Get==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123; <span class="comment">// 1.首先在mem中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;	<span class="comment">// 2.然后在imm中</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);		<span class="comment">// 3.再去sstable， ！！注意这里的status</span></span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123; <span class="comment">// 4.这里调用了UpdateStats</span></span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==Version::Get==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line">		</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">      <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// ！！stats控制转移到State类</span></span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后走到了ForEachOverlapping，参数中传入了一个函数指针, State::Match, 后序在分析。先看ForEachOverlapping:</p>
<p>==ForEachOverlapping==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">   <span class="comment">// 加入第0层文件</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.reserve(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.push_back(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">      <span class="comment">// 按照新旧排序，由新到旧</span></span><br><span class="line">    <span class="built_in">std</span>::sort(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;	<span class="comment">// 调用State::Match, 由于第0层无序，所以可能需要多次调用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;										<span class="comment">// 到这里，确定了 internal_key 一定是在 本file的key range中，即overlap</span></span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;				<span class="comment">// 一个level，只会调用</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ForEachOverlapping函数中，首先搜索level0，在level 0中找到一些sstable，这些sstable的key range包含了user_key. 然后不断调用Match函数，直到找到相应file。 <strong>由于level0的无序性，所以Match函数可能被调用了多次。</strong></p>
<p>如果level0中找不到能够匹配的SStable，就逐层往下，因为level1–level6都是有序的，<strong>所以每层最多有一个sstable</strong>，满足其key range包含指定user_key， <strong>所以每层只用调用一次Match函数。</strong></p>
<p>最后，看看：</p>
<p>==Match==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;			<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 不再search</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> kNotFound:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">        <span class="keyword">case</span> kFound:</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kDeleted:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不再search</span></span><br><span class="line">        <span class="keyword">case</span> kCorrupt:</span><br><span class="line">            state-&gt;s =</span><br><span class="line">                Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">            state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个函数中也终于可以找到<code>seek_file</code>被赋值的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">    state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;			<span class="comment">// 走到这个分支，说明Match函数至少已经被调用过一次，也就是说至少浪费了一次io</span></span><br><span class="line">    <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">    state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">    state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过要进入这个分析，Match已经至少被执行了一次，所以现在记录的是上一次调用Match函数时所用到的file。这个file被访问了，但是却没有找到正确的key。所以它浪费了io，进而在后序的<code>UpdateStats</code>函数中，它的<strong>allowed_seeks会被–</strong>。</p>
<p><strong>不过感觉这里记录到第一个浪费了io的sstable，后序可能还会存在浪费io的sstable，可能是因为层别越低，访问频率越高，所以越需要快点将其allowed_seeks减小。</strong></p>
<p>ok，总结一下，花个流程图。</p>
<h4 id="seek-compaction的流程图（何时触发，如何触发）"><a href="#seek-compaction的流程图（何时触发，如何触发）" class="headerlink" title="seek_compaction的流程图（何时触发，如何触发）"></a>seek_compaction的流程图（何时触发，如何触发）</h4><img data-src="https://pic.downk.cc/item/5f8443b11cd1bbb86b05e0f2.png" style="zoom:50%;" />

<h4 id="3-allowed-seeks–的时机-2-amp-DBIter"><a href="#3-allowed-seeks–的时机-2-amp-DBIter" class="headerlink" title="3.  allowed_seeks–的时机 (2) &amp; DBIter"></a>3.  allowed_seeks–的时机 (2) &amp; DBIter</h4><p>这部分请参考DBIter。</p>
<h2 id="3-Compaction的执行流程"><a href="#3-Compaction的执行流程" class="headerlink" title="3. Compaction的执行流程"></a>3. Compaction的执行流程</h2><p>选择了要执行的Compaction文件后，剩下的就是执行Compaction：</p>
<p>==DBImpl::BackgroundCompaction==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"> <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="comment">// Nothing to do</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;	<span class="comment">// trivial move: 下层没有本层的重叠key，修改元数据，移动到下层</span></span><br><span class="line">   <span class="comment">// Move file to next level</span></span><br><span class="line">   assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">   FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">   c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                      f-&gt;largest);</span><br><span class="line">   status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">   Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">       <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">       status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;					<span class="comment">// ！！实际compaction的代码</span></span><br><span class="line">   CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">   status = DoCompactionWork(compact);</span><br><span class="line">   <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">     RecordBackgroundError(status);</span><br><span class="line">   &#125;</span><br><span class="line">   CleanupCompaction(compact);</span><br><span class="line">   c-&gt;ReleaseInputs();</span><br><span class="line">   RemoveObsoleteFiles();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure>

<p>上面的代码说明了：</p>
<ol>
<li><p>若没有选择的compaction file，则忽略。</p>
</li>
<li><p>IsTrivialMove，若选择的compaction文件，level n没有和level n+1重叠，并且level n的文件没有与过多的祖父level文件重叠，则直接修改元数据（verisonedit）即可，不必compaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compaction::IsTrivialMove</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>否则，执行真正的<strong>compaction</strong>。</p>
</li>
</ol>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>ok，知道了这些，现在一起来看看Snapshot是怎么实现与使用的。</p>
<p>SnapshotList是一个双链表。 这和Cache的链表是完全相同的。</p>
<p><img data-src="https://pic.downk.cc/item/5f88ed491cd1bbb86b4e4e55.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotList</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SnapshotList() : head_(<span class="number">0</span>) &#123;</span><br><span class="line">    head_.prev_ = &amp;head_;</span><br><span class="line">    head_.next_ = &amp;head_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> head_.next_ == &amp;head_; &#125;</span><br><span class="line">  <span class="function">SnapshotImpl* <span class="title">oldest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    <span class="keyword">return</span> head_.next_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">SnapshotImpl* <span class="title">newest</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    <span class="keyword">return</span> head_.prev_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates a SnapshotImpl and appends it to the end of the list.</span></span><br><span class="line">  <span class="function">SnapshotImpl* <span class="title">New</span><span class="params">(SequenceNumber sequence_number)</span> </span>&#123;</span><br><span class="line">    assert(empty() || newest()-&gt;sequence_number_ &lt;= sequence_number);</span><br><span class="line"></span><br><span class="line">    SnapshotImpl* snapshot = <span class="keyword">new</span> SnapshotImpl(sequence_number);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">    snapshot-&gt;list_ = <span class="keyword">this</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">    snapshot-&gt;next_ = &amp;head_;</span><br><span class="line">    snapshot-&gt;prev_ = head_.prev_;</span><br><span class="line">    snapshot-&gt;prev_-&gt;next_ = snapshot;</span><br><span class="line">    snapshot-&gt;next_-&gt;prev_ = snapshot;</span><br><span class="line">    <span class="keyword">return</span> snapshot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removes a SnapshotImpl from this list.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The snapshot must have been created by calling New() on this list.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The snapshot pointer should not be const, because its memory is</span></span><br><span class="line">  <span class="comment">// deallocated. However, that would force us to change DB::ReleaseSnapshot(),</span></span><br><span class="line">  <span class="comment">// which is in the API, and currently takes a const Snapshot.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> SnapshotImpl* snapshot)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(NDEBUG)</span></span><br><span class="line">    assert(snapshot-&gt;list_ == <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(NDEBUG)</span></span></span><br><span class="line">    snapshot-&gt;prev_-&gt;next_ = snapshot-&gt;next_;</span><br><span class="line">    snapshot-&gt;next_-&gt;prev_ = snapshot-&gt;prev_;</span><br><span class="line">    <span class="keyword">delete</span> snapshot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Dummy head of doubly-linked list of snapshots</span></span><br><span class="line">  SnapshotImpl head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好了，有了Snapshot的铺垫，我们来看看DoCompactionWork函数。</p>
<h3 id="DoCompactionWork"><a href="#DoCompactionWork" class="headerlink" title="DoCompactionWork"></a>DoCompactionWork</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">// 记录最老快照，只能删除比最老快照还老的数据，如何表示最老？用序列号，序列号越小代表数据越旧。</span></span><br><span class="line">  <span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 创建迭代器, 内部通过mergeiterator对本次要compaction的文件做“排序”（没有排序，只不过通过iter依次访问数据，得到的结果就是排序后的结果）</span></span><br><span class="line">  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">  input-&gt;SeekToFirst();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">     <span class="comment">// 首先做immtable的dump</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CompactMemTable();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.SignalAll();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slice key = input-&gt;key();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//检查当前输出文件是否与level+2层文件有过多冲突，如果是就要完成当前输出文件,并产生新的输出文件</span></span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 下面这里是关键！！</span></span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 正常情况下走这里</span></span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||		</span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=	</span><br><span class="line">              <span class="number">0</span>) &#123;		<span class="comment">// 某个user_key第一次出现</span></span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;	<span class="comment">// 前一个key的序列号都小了，本key肯定更小，直接抛弃</span></span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;		<span class="comment">// 前一个key还在snaphost内，本key虽然是离snapshot最近的key，但是本key是删除节点	</span></span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;	<span class="comment">// 在是删除节点的同时，还必须保证本key一定是"最底层"的key（也就是更底层没有该key），否则删除这个key，更底层的key将被重新激活</span></span><br><span class="line">          <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">          <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 不需要drop的文件直接写入</span></span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;		<span class="comment">// 不需要删除，则写入到文件</span></span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = OpenCompactionOutputFile(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">      compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">        status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;Next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = input-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;	<span class="comment">// 保存此次压缩结果的元数据 </span></span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的整体流程分3步：</p>
<ol>
<li>创建迭代器，内部对本次要compact的文件进行排序。</li>
<li>丢弃那些被删除的或者旧的文件。</li>
<li>写入新文件。</li>
</ol>
<h4 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">VersionSet::MakeInputIterator</span><span class="params">(Compaction* c)</span> </span>&#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;level() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">   <span class="comment">// !!! list中的每个iter，都指向了一个即将被compaction的sstable</span></span><br><span class="line">  Iterator** <span class="built_in">list</span> = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;level() + which == <span class="number">0</span>) &#123;	<span class="comment">// 对第0层的files，通过table_cache创建iter</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="built_in">list</span>[num++] = table_cache_-&gt;NewIterator(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 非第0层的fiels，使用TwoLevelIterator来迭代（index iter 和 data iter)</span></span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        <span class="built_in">list</span>[num++] = NewTwoLevelIterator(</span><br><span class="line">            <span class="keyword">new</span> Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(num &lt;= space);</span><br><span class="line">   <span class="comment">// 所有需要的compaction file都有一个iter，现在需要归并排序，这通过mergeiteraotr实现</span></span><br><span class="line">  Iterator* result = NewMergingIterator(&amp;icmp_, <span class="built_in">list</span>, num);</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于mergeiteraotr的具体实现，可参考 mergeitator。</p>
<h4 id="2-丢弃不需要的kv-pairs"><a href="#2-丢弃不需要的kv-pairs" class="headerlink" title="2. 丢弃不需要的kv pairs"></a>2. 丢弃不需要的kv pairs</h4><p>最核心也是最难的代码在下面这一段，先看代码，后面将通过例子来说明这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这里是关键！！</span></span><br><span class="line"><span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;		<span class="comment">// 正常情况下走这里</span></span><br><span class="line">  <span class="keyword">if</span> (!has_current_user_key ||		</span><br><span class="line">      user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=	</span><br><span class="line">          <span class="number">0</span>) &#123;		<span class="comment">// 某个user_key第一次出现</span></span><br><span class="line">    <span class="comment">// First occurrence of this user key</span></span><br><span class="line">    current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">    has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">    last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;	<span class="comment">// 前一个key的序列号都小了，本key肯定更小，直接抛弃</span></span><br><span class="line">    <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">    drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;		<span class="comment">// 前一个key还在snaphost内，本key虽然是离snapshot最近的key，但是本key是删除节点	</span></span><br><span class="line">             ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">             compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;	<span class="comment">// 在是删除节点的同时，还必须保证本key一定是"最底层"的key（也就是更底层没有该key），否则删除这个key，更底层的key将被重新激活</span></span><br><span class="line">      <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">      <span class="comment">// For this user key:</span></span><br><span class="line">    <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">    <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">    <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">    <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">    <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">    <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">    drop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_sequence_for_key = ikey.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解释这个函数，看看下面这个图：</p>
<p><img data-src="https://pic.downk.cc/item/5f88ec9c1cd1bbb86b4e2c8e.png" alt=""></p>
<p>每个上下箭头符号代表一个snapshot，前面说了我们不管比snapshot更新(newer)的数据，因为他们可能把snapshot内的数据给删除了。所以，这次compaction操作中，我们只能删除比snapshot更旧(older)的数据。上面的图从左到右数据从新到旧。 我们将以“最旧的snapshot”为分界线，比该snapshot更旧（右边）的数据才有可能被删除。所以id=3的key不能删除（因为它比snapshot新），id=2的kye不能删除，虽然它比snapshot旧，但是它是最旧里面最新的一个，我们需要保存这个key，id=1的key可以被删除。</p>
<p>知道了这些，就可以慢慢分析代码了。</p>
<p>第一次循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||		</span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=	</span><br><span class="line">              <span class="number">0</span>) &#123;		<span class="comment">// 某个user_key第一次出现</span></span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>假设第一次运行，则current_user_key指向id=3的key，last_sequence_for_key=一个最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;	<span class="comment">// 前一个key的序列号都小了，本key肯定更小，直接抛弃</span></span><br><span class="line">       <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">       drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>这个if条件不满足。</p>
<p>last_sequence_for_key 为id=3的key的序列号。</p>
<p>第二次循环：</p>
<p>由于id=2和id=3的key相同，所以直接进入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;	<span class="comment">// 前一个key的序列号都小了，本key肯定更小，直接抛弃</span></span><br><span class="line">       <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">       drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>由于此时的last_sequence_for_key是id=3的序列号，这个判断依然不满足。last_sequence_for_key 为id=2的key的序列号。</p>
<p>第三次循环：</p>
<p>由于id=1和id=3的key相同,last_sequence_for_key 为id=2的key的序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;	<span class="comment">// 前一个key的序列号都小了，本key肯定更小，直接抛弃</span></span><br><span class="line">       <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">       drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>此时满足，丢弃id=1的key。</p>
<p>ok，到这里，相信你应该可以看到前两个判断了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.<span class="built_in">clear</span>();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;		<span class="comment">// 正常情况下走这里</span></span><br><span class="line">  <span class="keyword">if</span> (!has_current_user_key ||		</span><br><span class="line">      user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=	</span><br><span class="line">          <span class="number">0</span>) &#123;		<span class="comment">// 某个user_key第一次出现</span></span><br><span class="line">    <span class="comment">// First occurrence of this user key</span></span><br><span class="line">    current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">    has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 第一次出现的user_key不允许删除</span></span><br><span class="line">    last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那还剩下一个判断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;		<span class="comment">// 前一个key还在snaphost内，本key虽然是离snapshot最近的key，但是本key是删除节点	</span></span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;	<span class="comment">// 在是删除节点的同时，还必须保证本key一定是"最底层"的key（也就是更底层没有该key），否则删除这个key，更底层的key将被重新激活</span></span><br><span class="line">          <span class="comment">// !!!!!! 待完善</span></span><br><span class="line">          <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>还是用图来解释：</p>
<p><img data-src="https://pic.downk.cc/item/5f88ec471cd1bbb86b4e1cc7.png" alt=""></p>
<p>如果现在比最旧的snapshot还旧的第一个key(id=2)是一个删除操作。那这个是不是也该丢弃？（后面的key也该丢弃）。所以有了这个判断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ikey.type == kTypeDeletion &amp;&amp; </span><br><span class="line">     ikey.sequence &lt;= compact-&gt;smallest_snapshot</span><br></pre></td></tr></table></figure>

<p>那这个判断是在做什么工作?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)</span><br></pre></td></tr></table></figure>

<p>IsBaseLevelForKey函数保证更低层没有这个user_key, 也就是这个key在这个level已经是全局最旧的了。可以思考一下如果没有这个判断，我们旧把delete操作的节点删除了，那更低层的key是不是又复活了？显然我们不能让这个key重新复活。所以加了这个key。</p>
<h4 id="3-写入不需要drop的kv"><a href="#3-写入不需要drop的kv" class="headerlink" title="3. 写入不需要drop的kv"></a>3. 写入不需要drop的kv</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;	<span class="comment">// builder为空，则打开</span></span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第一步：OpenCompactionOutputFile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::OpenCompactionOutputFile</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> file_number;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    file_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      <span class="comment">// 注意这里的pending_outputs</span></span><br><span class="line">    pending_outputs_.insert(file_number);</span><br><span class="line">    CompactionState::Output out;</span><br><span class="line">    out.number = file_number;</span><br><span class="line">    out.smallest.Clear();</span><br><span class="line">    out.largest.Clear();</span><br><span class="line">     <span class="comment">// 加入到outputs</span></span><br><span class="line">    compact-&gt;outputs.push_back(out);</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the output file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">  Status s = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    compact-&gt;builder = <span class="keyword">new</span> TableBuilder(options_, compact-&gt;outfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个点要注意：</p>
<ol>
<li><p>pending_outputs_， 我们来看的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set of table files to protect from deletion because they are</span></span><br><span class="line"><span class="comment">// part of ongoing compactions.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; pending_outputs_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它是为了避免tables files被误删除的而设计的。那在哪里会被误删除？在CompactMemTable中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="comment">// Commit to the new state</span></span><br><span class="line">  imm_-&gt;Unref();</span><br><span class="line">  imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    <span class="comment">// 这里会删除</span></span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  RecordBackgroundError(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RemoveObsoleteFiles中使用到了pending_outputs_，因为在合并过程中，刚生成的sstable还不是“live”的，通过<code>pending_outputs_</code>将它们当成 live 的就不会被删除了。</p>
</li>
<li><p>将需要保存的kv，放在compact-&gt;outputs中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入到outputs</span></span><br><span class="line">compact-&gt;outputs.push_back(out);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第二步，记录最小key和最大key，同时并将要保存的kv加入到builder中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">    compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">  &#125;</span><br><span class="line">  compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">  compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br></pre></td></tr></table></figure>

<p>第三步，如果当前table已经过大，则输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close output file if it is big enough</span></span><br><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">    compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==FinishCompactionOutputFile==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::FinishCompactionOutputFile</span><span class="params">(CompactionState* compact,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Iterator* input)</span> </span>&#123;</span><br><span class="line">  assert(compact != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;outfile != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;builder != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> output_number = compact-&gt;current_output()-&gt;number;</span><br><span class="line">  assert(output_number != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for iterator errors</span></span><br><span class="line">  Status s = input-&gt;status();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_entries = compact-&gt;builder-&gt;NumEntries();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;/</span><br><span class="line">      <span class="comment">// 构建sstable</span></span><br><span class="line">    s = compact-&gt;builder-&gt;Finish();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;builder-&gt;Abandon();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 统计sstable的大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> current_bytes = compact-&gt;builder-&gt;FileSize();</span><br><span class="line">  compact-&gt;current_output()-&gt;file_size = current_bytes;</span><br><span class="line">  compact-&gt;total_bytes += current_bytes;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;builder;</span><br><span class="line">  compact-&gt;builder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finish and check for file errors</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 写入sstable</span></span><br><span class="line">    s = compact-&gt;outfile-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = compact-&gt;outfile-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> compact-&gt;outfile;</span><br><span class="line">  compact-&gt;outfile = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; current_entries &gt; <span class="number">0</span>) &#123;	<span class="comment">// 验证table是否有效</span></span><br><span class="line">    <span class="comment">// Verify that the table is usable</span></span><br><span class="line">    Iterator* iter =</span><br><span class="line">        table_cache_-&gt;NewIterator(ReadOptions(), output_number, current_bytes);</span><br><span class="line">    s = iter-&gt;status();</span><br><span class="line">    <span class="keyword">delete</span> iter;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      Log(options_.info_log, <span class="string">"Generated table #%llu@%d: %lld keys, %lld bytes"</span>,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)output_number, compact-&gt;compaction-&gt;level(),</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_entries,</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)current_bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FinishCompactionOutputFile主完成的工作就是将之前加入的有效kv落盘成一个新的sstable。</p>
<ol>
<li><code>compact-&gt;builder-&gt;Finish();</code> 构建sstable的所有块，data block, meta block meta index block, index block,footer.</li>
<li>记录本次形成的新sstable的大小</li>
<li>落盘，compact-&gt;outfile-&gt;Sync();</li>
<li>校验是否正确</li>
</ol>
<h4 id="4-元数据修改"><a href="#4-元数据修改" class="headerlink" title="4. 元数据修改"></a>4. 元数据修改</h4><p>经过前面几步，compaction过后的sstable已经持久化到设备上了，现在要做的是修改本次压缩过程中涉及到的sstable的元数据，删除用来compaction的数据，生成compaction后的sstable的元数据。这些都通过一次versionedit来表示，然后通过LogAndApply应用这个edit，生成新edit。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>&#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>), compact-&gt;compaction-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());	<span class="comment">// 删除</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);		<span class="comment">// 结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);		<span class="comment">// 应用edit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑比较简单，将本次操作过程中涉及的文件都加入一个edit中，然后通过LogAndApply应用即可。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>文章对你有帮助?打赏一下作者吧</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://pic.downk.cc/item/5d064208451253d178a15b27.png" alt="Raven 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="https://pic.downk.cc/item/5d0641c7451253d178a15376.png" alt="Raven 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Raven
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.ravenxrz.ink/archives/1ba074b9.html" title="leveldb源码阅读记录-Compaction">https://www.ravenxrz.ink/archives/1ba074b9.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/b2082466.html" rel="prev" title="leveldb源码阅读记录-SSTable">
      <i class="fa fa-chevron-left"></i> leveldb源码阅读记录-SSTable
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/ce22f5e9.html" rel="next" title="leveldb源码阅读记录-Cache">
      leveldb源码阅读记录-Cache <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MemTable-到-SStable"><span class="nav-text">MemTable 到 SStable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-minor-compaction如何进行？"><span class="nav-text">1. minor compaction如何进行？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-调用流程图"><span class="nav-text">1. 调用流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Minor-Compaction执行细节"><span class="nav-text">2. Minor Compaction执行细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-WriteLevel0Table-流程图"><span class="nav-text">1 WriteLevel0Table 流程图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3个函数的分析"><span class="nav-text">3个函数的分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-BuildTable-建立ssttable并持久化"><span class="nav-text">1. BuildTable (建立ssttable并持久化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Version-PickLevelForMemTableOutput"><span class="nav-text">2. Version::PickLevelForMemTableOutput</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-edit-gt-Addfile-（记录元sstable所在level等元数据）"><span class="nav-text">3. edit-&gt;Addfile （记录元sstable所在level等元数据）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-LogAndApply"><span class="nav-text">2. LogAndApply</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-何时Tigger-Compaction？"><span class="nav-text">2. 何时Tigger Compaction？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-compaction-score-amp-Finalize函数"><span class="nav-text">1. compaction_score_  &amp; Finalize函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#level-0"><span class="nav-text">level 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他level"><span class="nav-text">其他level</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择得分最高的来做compaction"><span class="nav-text">选择得分最高的来做compaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结："><span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-file-to-compact-amp-Seek-Compaction"><span class="nav-text">2. file_to_compact_ &amp; Seek Compaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-如何确定Compaction的输入源"><span class="nav-text">2. 如何确定Compaction的输入源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-PickCompaction"><span class="nav-text">1. PickCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流程图"><span class="nav-text">流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Size-Compaction"><span class="nav-text">1. Size Compaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-leve-n的sstable确定"><span class="nav-text">1. leve n的sstable确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetOverlappingInputs函数"><span class="nav-text">GetOverlappingInputs函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举个例子（level0-compaction的sstable选择）"><span class="nav-text">举个例子（level0 compaction的sstable选择）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-level-n-1的sstable确定"><span class="nav-text">2. level n+1的sstable确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核心代码"><span class="nav-text">核心代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#level-n新SStable的加入"><span class="nav-text">level n新SStable的加入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-记录下一轮的压缩起始文件"><span class="nav-text">3. 记录下一轮的压缩起始文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-AddBoundaryInputs"><span class="nav-text">4. AddBoundaryInputs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Seek-Compaction"><span class="nav-text">2. Seek Compaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么时候触发一次seek-compaction？"><span class="nav-text">1. 什么时候触发一次seek compaction？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-allowed-seeks–的时机-1-amp-DBImpl-Get的简单分析"><span class="nav-text">2. allowed_seeks–的时机 (1) &amp; DBImpl::Get的简单分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#seek-compaction的流程图（何时触发，如何触发）"><span class="nav-text">seek_compaction的流程图（何时触发，如何触发）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-allowed-seeks–的时机-2-amp-DBIter"><span class="nav-text">3.  allowed_seeks–的时机 (2) &amp; DBIter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Compaction的执行流程"><span class="nav-text">3. Compaction的执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshot"><span class="nav-text">Snapshot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DoCompactionWork"><span class="nav-text">DoCompactionWork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-排序"><span class="nav-text">1. 排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-丢弃不需要的kv-pairs"><span class="nav-text">2. 丢弃不需要的kv pairs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-写入不需要drop的kv"><span class="nav-text">3. 写入不需要drop的kv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-元数据修改"><span class="nav-text">4. 元数据修改</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Raven"
      src="https://pic.downk.cc/item/5e907515504f4bcb04b6f798.jpg">
  <p class="site-author-name" itemprop="name">Raven</p>
  <div class="site-description" itemprop="description">分享技术，记录生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhdmVueHJ6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ravenxrz"><i class="fa fa-fw fa-fab fa-github"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnpoYWduLnhpbmdydWlAZm94bWFpbC5jb20=" title="E-Mail → mailto:zhagn.xingrui@foxmail.com"><i class="fa fa-fw fa-fa fa-envelope"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-fa fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/resources" title="&#x2F;resources">我的资源</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Raven</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9taXN0LnRoZW1lLW5leHQub3Jn">NexT.Mist</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.ravenxrz.ink/archives/1ba074b9.html',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b2fd373d2ca2e03e591e',
      clientSecret: 'de4ab066908c1fbd32d3a45e091b3538761d685b',
      repo        : 'BlogComment',
      owner       : 'ravenxrz',
      admin       : ['ravenxrz'],
      id          : '9345431e02efd99ec5c6dff6c36544fb',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
